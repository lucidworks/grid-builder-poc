{"version":3,"file":"grid-item-wrapper.entry.esm.js","sources":["src/utils/drag-handler.ts","src/utils/version.ts","src/utils/resize-handler.ts","src/components/grid-item-wrapper/grid-item-wrapper.scss?tag=grid-item-wrapper","src/components/grid-item-wrapper/grid-item-wrapper.tsx"],"sourcesContent":["/**\n * Drag Handler\n * ============\n *\n * High-performance drag-and-drop system for grid items using interact.js and direct DOM\n * manipulation. This module handles smooth 60fps dragging while avoiding framework\n * re-render overhead.\n *\n * ## Problem\n *\n * Dragging UI elements at 60fps requires updating positions ~16ms per frame. Using\n * framework state updates would cause:\n * - Full component re-renders on every mousemove event\n * - Virtual DOM diffing overhead\n * - Layout thrashing from read/write cycles\n * - Janky, stuttering drag experience\n *\n * ## Solution\n *\n * Hybrid approach combining interact.js events with direct DOM manipulation:\n *\n * 1. **During drag** (60fps): Direct DOM updates via `element.style.transform`\n * - No state updates\n * - No re-renders\n * - Smooth visual feedback\n *\n * 2. **After drag** (single operation): Update StencilJS state once\n * - Trigger single re-render\n * - Persist final position\n * - Emit undo/redo commands\n *\n * ## Key Architecture Decisions\n *\n * ### Transform vs Top/Left Positioning\n *\n * **Using**: `transform: translate(x, y)`\n * **Not using**: `top: y; left: x;`\n *\n * **Why transforms**:\n * - GPU-accelerated (composited layer)\n * - Doesn't trigger layout/reflow\n * - Subpixel precision for smooth animations\n * - Better performance on low-end devices\n *\n * **Why not top/left**:\n * - Triggers layout recalculation\n * - CPU-bound rendering\n * - Causes reflows affecting other elements\n * - Stuttery on complex layouts\n *\n * ### Grid Snapping Strategy\n *\n * **When**: Only at drag end\n * **How**: `Math.round(position / gridSize) * gridSize`\n * **Why**: Allows free-form dragging during operation, snaps to grid on release\n *\n * ### Cross-Canvas Dragging\n *\n * Detects when item is dragged over different canvas by:\n * 1. Tracking drag start canvas ID\n * 2. Finding element center point at drag end\n * 3. Hit-testing against all canvas bounding boxes\n * 4. Delegating to dropzone handler if canvas changed\n *\n * ## Performance Characteristics\n *\n * **During drag** (per frame):\n * - 1 style update (transform)\n * - 2 data attribute updates\n * - No layout/reflow\n * - ~0.5ms per frame\n *\n * **At drag end**:\n * - Grid snapping calculations\n * - Edge snapping checks\n * - State update + single re-render\n * - ~5-10ms total\n *\n * **Performance gain over state-based approach**:\n * - State-based: ~16ms+ per frame (re-render overhead)\n * - This approach: ~0.5ms per frame\n * - **~30x faster during drag**\n *\n * ## Edge Cases Handled\n *\n * - Cross-canvas drag detection\n * - Boundary constraints (can't drag outside canvas)\n * - Edge snapping (auto-snap to canvas edges within 20px)\n * - Mobile vs desktop viewport layouts\n * - Dragging from non-drag handles prevented\n * - Clean state cleanup on component destruction\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n *\n * ```typescript\n * class MyDragHandler {\n * private basePos = { x: 0, y: 0 };\n *\n * handleDragStart(e) {\n * // Store starting position\n * this.basePos = getCurrentPosition(e.target);\n * }\n *\n * handleDragMove(e) {\n * // Direct DOM update (no framework state)\n * const newX = this.basePos.x + e.dx;\n * const newY = this.basePos.y + e.dy;\n * e.target.style.transform = `translate(${newX}px, ${newY}px)`;\n * }\n *\n * handleDragEnd(e) {\n * // Snap to grid/constraints\n * const snapped = snapToGrid(finalPosition);\n * e.target.style.transform = `translate(${snapped.x}px, ${snapped.y}px)`;\n *\n * // Single state update triggers framework re-render\n * this.updateState(snapped);\n * }\n * }\n * ```\n *\n * ## Integration with Other Systems\n *\n * - **grid-calculations**: Convert between pixels and grid units\n * - **dom-cache**: Fast canvas element lookup\n * - **state-manager**: Single state update at drag end\n * - **undo-redo**: Command pushed via onUpdate callback\n * - **interact.js**: Event source for drag lifecycle\n * @module drag-handler\n */\n\nimport type { InteractDragEvent, Interactable } from \"interactjs\";\nimport {\n  GridItem,\n  GridState,\n  selectItem,\n  setActiveCanvas,\n} from \"../services/state-manager\";\nimport { GridConfig } from \"../types/grid-config\";\nimport { domCache } from \"./dom-cache\";\nimport {\n  getGridSizeHorizontal,\n  getGridSizeVertical,\n  pixelsToGridX,\n  pixelsToGridY,\n} from \"./grid-calculations\";\nimport {\n  constrainPositionToCanvas,\n  CANVAS_WIDTH_UNITS,\n} from \"./boundary-constraints\";\n\n/**\n * Extract current transform position from element's inline style\n *\n * Parses the `transform: translate(Xpx, Ypx)` CSS property to get current position.\n * This is needed because drag deltas are cumulative - we need the base position\n * to add deltas to.\n *\n * **Why needed**:\n * - Drag uses cumulative deltas (dx, dy) from drag start\n * - Must add to initial position, not reset each frame\n * - Transform string is canonical source of truth during drag\n *\n * **Performance**:\n * - Regex parsing is fast (< 0.1ms)\n * - Only called once at drag start, not per frame\n *\n * **Regex explanation**:\n * - `([\\d.-]+)` matches numbers including decimals and negatives\n * - More specific than `[^,]+` to avoid ReDoS issues\n * - Matches: `translate(10.5px, -20.3px)`\n * @param element - Element with transform style\n * @returns Current x,y position in pixels, or {0,0} if no transform\n * @example\n * ```typescript\n * const el = document.getElementById('item-1');\n * el.style.transform = 'translate(150px, 200px)';\n * const pos = getTransformPosition(el); // → {x: 150, y: 200}\n * ```\n */\nfunction getTransformPosition(element: HTMLElement): { x: number; y: number } {\n  const transform = element.style.transform;\n  const match = transform.match(/translate\\(([\\d.-]+)px,\\s*([\\d.-]+)px\\)/);\n\n  if (match) {\n    return {\n      x: parseFloat(match[1]),\n      y: parseFloat(match[2]),\n    };\n  }\n\n  return { x: 0, y: 0 };\n}\n\n/**\n * Drag Handler Class\n * ===================\n *\n * Manages high-performance drag behavior for a single grid item. Each grid item\n * gets its own DragHandler instance that coordinates interact.js events with\n * DOM updates and state management.\n *\n * ## Instance Lifecycle\n *\n * 1. **Creation**: Instantiated by grid-item-wrapper when item mounts\n * 2. **Initialization**: Sets up interact.js draggable with event listeners\n * 3. **Active**: Handles drag events with direct DOM manipulation\n * 4. **Cleanup**: destroy() called when item unmounts to prevent memory leaks\n *\n * ## State Management\n *\n * **Private state** (not in framework):\n * - `basePosition`: Starting transform position at drag start\n * - `dragStartCanvasId`: Original canvas ID for cross-canvas detection\n * - `interactInstance`: interact.js draggable instance\n *\n * **Framework state**: Updated only once at drag end via `onUpdate` callback\n *\n * ## Performance Pattern\n *\n * This class implements the \"direct manipulation + deferred state\" pattern:\n * - High-frequency events (move): Direct DOM updates\n * - Low-frequency events (start/end): State updates + event tracking\n * @example\n * ```typescript\n * // In grid-item-wrapper.tsx\n * componentDidLoad() {\n *   this.dragHandler = new DragHandler(\n *     this.element,\n *     this.item,\n *     (updatedItem) => {\n *       // This callback runs ONCE at drag end\n *       gridState.updateItem(updatedItem);\n *       undoRedo.pushCommand(new MoveCommand(this.item, updatedItem));\n *     }\n *   );\n * }\n *\n * disconnectedCallback() {\n *   this.dragHandler?.destroy(); // Cleanup\n * }\n * ```\n */\nexport class DragHandler {\n  /** DOM element being dragged (grid-item-wrapper element) */\n  private element: HTMLElement;\n\n  /** Grid item data (position, size, layouts) */\n  private item: GridItem;\n\n  /** Grid state instance (for accessing canvases, viewport) */\n  private state: GridState;\n\n  /** Callback to update parent state after drag ends */\n  private onUpdate: (item: GridItem) => void;\n\n  /** Grid configuration options */\n  private config?: GridConfig;\n\n  /** interact.js draggable instance for cleanup */\n  private interactInstance: Interactable | null = null;\n\n  /** Position at drag start (from transform) - used to apply deltas */\n  private basePosition: { x: number; y: number } = { x: 0, y: 0 };\n\n  /** Canvas ID where drag started - for cross-canvas detection */\n  private dragStartCanvasId: string = \"\";\n\n  /** Optional separate drag handle element */\n  private dragHandleElement?: HTMLElement;\n\n  /** Optional callback when drag movement occurs */\n  private onDragMove?: () => void;\n\n  /** Track if any drag movement occurred */\n  private hasMoved: boolean = false;\n\n  /** RAF ID for batching drag move updates (limits to 60fps) */\n  private dragRafId: number | null = null;\n\n  /**\n   * Create drag handler and initialize interact.js\n   *\n   * **Lifecycle**: Called when grid-item-wrapper mounts\n   *\n   * **Why auto-initialize in constructor**:\n   * - Ensures drag is ready immediately after creation\n   * - Simplifies component code (no separate setup call)\n   * - Matches StencilJS lifecycle (componentDidLoad)\n   *\n   * **Performance**: Initialization is cheap (~1ms), deferred to constructor is fine\n   * @param element - DOM element to make draggable (grid-item-wrapper)\n   * @param item - Grid item data for position/layout management\n   * @param state - Grid state instance (for accessing canvases, viewport)\n   * @param onUpdate - Callback invoked with updated item after drag ends\n   * @param config - Grid configuration options (for auto-scroll, etc.)\n   * @param dragHandleElement - Optional element to use as drag handle\n   * @param onDragMove - Optional callback when drag movement occurs\n   * @example\n   * ```typescript\n   * // Typical usage in component\n   * private dragHandler: DragHandler;\n   *\n   * componentDidLoad() {\n   *   const header = this.element.querySelector('.grid-item-header');\n   *   this.dragHandler = new DragHandler(\n   *     this.element,\n   *     this.item,\n   *     this.state,\n   *     (item) => this.handleItemUpdate(item),\n   *     this.config,\n   *     header,\n   *     () => this.wasDragged = true\n   *   );\n   * }\n   * ```\n   */\n  constructor(\n    element: HTMLElement,\n    item: GridItem,\n    state: GridState,\n    onUpdate: (item: GridItem) => void,\n    config?: GridConfig,\n    dragHandleElement?: HTMLElement,\n    onDragMove?: () => void,\n  ) {\n    this.element = element;\n    this.item = item;\n    this.state = state;\n    this.onUpdate = onUpdate;\n    this.config = config;\n    this.dragHandleElement = dragHandleElement;\n    this.onDragMove = onDragMove;\n\n    this.initialize();\n  }\n\n  /**\n   * Cleanup interact.js instance to prevent memory leaks\n   *\n   * **When to call**: Component unmount (disconnectedCallback in StencilJS)\n   *\n   * **Why needed**:\n   * - interact.js attaches event listeners to elements\n   * - Without cleanup, listeners persist after element removal\n   * - Causes memory leaks and potential errors on removed elements\n   *\n   * **What it does**:\n   * - Calls `interactInstance.unset()` to remove all interact.js listeners\n   * - Safe to call multiple times (checks if instance exists)\n   *\n   * **Performance**: Very cheap operation (~0.1ms)\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper component\n   * disconnectedCallback() {\n   *   if (this.dragHandler) {\n   *     this.dragHandler.destroy();\n   *   }\n   * }\n   * ```\n   */\n  destroy(): void {\n    if (this.interactInstance) {\n      this.interactInstance.unset();\n    }\n  }\n\n  /**\n   * Initialize interact.js draggable on element\n   *\n   * **Configuration choices**:\n   *\n   * **allowFrom: '.drag-handle, .border-drag-zone'**\n   * - Allows drag from drag handle OR the invisible border drag zones\n   * - Border zones are 6px wide overlays on the selection border (when selected)\n   * - Users can drag by clicking the yellow border, not just the drag handle\n   * - More intuitive UX - larger drag area\n   *\n   * **Why border-drag-zone approach**:\n   * - Prevents accidental drags when clicking content\n   * - Invisible zones only active when item is selected\n   * - Shows subtle hover feedback (10% opacity yellow tint)\n   * - Doesn't interfere with resize handles or interactive content\n   *\n   * **inertia: false**\n   * - Disables momentum/physics after drag release\n   * - Grid snapping works better without inertia\n   * - Provides more predictable, precise positioning\n   *\n   * **autoScroll configuration**:\n   * - Enabled by default (can be disabled via config.enableAutoScroll)\n   * - Automatically scrolls nearest scrollable container when dragging near edge\n   * - Speed increases as item gets closer to edge (distance-based)\n   * - margin: 60px - triggers scroll when within 60px of edge\n   * - Works with both window scrolling and nested scrollable containers\n   *\n   * **Event binding**:\n   * - Uses `.bind(this)` to preserve class context in event handlers\n   * - Without bind, `this` would be interact.js context, not DragHandler\n   * - Allows handlers to access instance properties (element, item, etc.)\n   *\n   * **Error handling**:\n   * - Checks if interact.js loaded (from CDN script tag)\n   * - Fails gracefully with console warning if missing\n   * - Prevents app crash if CDN fails to load\n   * @example\n   * ```typescript\n   * // interact.js setup with event handlers\n   * interact(element).draggable({\n   *   allowFrom: '.drag-handle, .border-drag-zone',\n   *   inertia: false,\n   *   autoScroll: true,\n   *   listeners: {\n   *     start: handleDragStart,\n   *     move: handleDragMove,\n   *     end: handleDragEnd,\n   *   }\n   * });\n   * ```\n   */\n  private initialize(): void {\n    const interact = window.interact;\n    if (!interact) {\n      console.warn(\"interact.js not loaded\");\n      return;\n    }\n\n    // If a separate drag handle element is provided, make it draggable\n    // Otherwise, use allowFrom on the main element\n    const dragElement = this.dragHandleElement || this.element;\n\n    // Check if auto-scroll is enabled (default: true)\n    const enableAutoScroll = this.config?.enableAutoScroll ?? true;\n\n    const config: Record<string, any> = {\n      inertia: false,\n      // Auto-scroll configuration\n      autoScroll: enableAutoScroll\n        ? {\n            enabled: true,\n            // Scroll the window (works for most cases)\n            container: window,\n            // Trigger scroll when within 60px of edge\n            margin: 60,\n            // Scroll speed\n            speed: 600,\n          }\n        : false,\n      listeners: {\n        start: this.handleDragStart.bind(this),\n        move: this.handleDragMove.bind(this),\n        end: this.handleDragEnd.bind(this),\n      },\n    };\n\n    // Only use allowFrom/ignoreFrom if dragging from main element\n    if (!this.dragHandleElement) {\n      config.allowFrom = \".grid-item-header\";\n      config.ignoreFrom = \".resize-handle\";\n    }\n\n    this.interactInstance = interact(dragElement).draggable(config);\n  }\n\n  /**\n   * Handle drag start event\n   *\n   * **Responsibilities**:\n   * 1. Start performance monitoring (if perfMonitor available)\n   * 2. Add visual feedback (dragging class)\n   * 3. Capture initial state for cross-canvas detection\n   * 4. Extract base position from current transform\n   * 5. Reset delta accumulators\n   *\n   * **Why capture dragStartCanvasId**:\n   * - item.canvasId may be updated by dropzone during drag\n   * - Need original canvas to detect if item moved to different canvas\n   * - Enables cross-canvas drag detection at drag end\n   *\n   * **Why extract basePosition**:\n   * - interact.js provides cumulative deltas (dx, dy) from drag start\n   * - Must add deltas to starting position, not reset each frame\n   * - Transform string is canonical position source during drag\n   *\n   * **Data attributes usage**:\n   * - `data-x`, `data-y`: Store cumulative deltas from drag start\n   * - Reset to 0 at drag start\n   * - Updated on every move event\n   * - Used to calculate final position at drag end\n   *\n   * **Performance tracking**:\n   * - Optional perfMonitor integration for debugging\n   * - Measures total drag duration (start → end)\n   * - Helps identify performance regressions\n   * @param event - interact.js drag start event\n   * @example\n   * ```typescript\n   * // Event data structure\n   * {\n   *   target: HTMLElement,        // Element being dragged\n   *   dx: 0,                      // Delta X (always 0 at start)\n   *   dy: 0,                      // Delta Y (always 0 at start)\n   *   // ... other interact.js properties\n   * }\n   * ```\n   */\n  private handleDragStart(event: InteractDragEvent): void {\n    // Start performance tracking\n    if (window.perfMonitor) {\n      window.perfMonitor.startOperation(\"drag\");\n    }\n\n    // Reset movement flag\n    this.hasMoved = false;\n\n    // Add dragging class to main element (not the header)\n    const elementToMark = this.dragHandleElement ? this.element : event.target;\n    elementToMark.classList.add(\"dragging\");\n\n    // Store the original canvas ID at drag start\n    this.dragStartCanvasId = this.item.canvasId;\n\n    // Set this canvas as active and select this item\n    setActiveCanvas(this.item.canvasId);\n    selectItem(this.item.id, this.item.canvasId);\n\n    // Store the base position from transform of the main element\n    const elementToRead = this.dragHandleElement ? this.element : event.target;\n    this.basePosition = getTransformPosition(elementToRead);\n\n    // Store original position for snap-back animation (if dropped outside canvas)\n    (this.element as any)._originalTransform = this.element.style.transform;\n    (this.element as any)._originalPosition = {\n      x: this.basePosition.x,\n      y: this.basePosition.y,\n    };\n\n    // Reset accumulation\n    event.target.setAttribute(\"data-x\", \"0\");\n    event.target.setAttribute(\"data-y\", \"0\");\n  }\n\n  /**\n   * Handle drag move event (high-frequency, ~200/sec → batched to 60fps)\n   *\n   * **Critical Performance Path**: RAF batching limits updates to 60fps\n   *\n   * **Direct DOM Manipulation with RAF Batching**:\n   * - Updates `element.style.transform` via requestAnimationFrame\n   * - Cancels pending RAF before scheduling new one\n   * - No StencilJS state updates\n   * - No component re-renders\n   * - No virtual DOM diffing\n   * - Result: Smooth 60fps drag performance (consistent with resize)\n   *\n   * **Why this approach**:\n   * - State-based: Update state → trigger render → diff vdom → update DOM (~16ms+)\n   * - RAF-batched DOM: Batch updates to animation frame (~0.5ms at 60fps)\n   * - **30x faster** than state-based, **consistent with resize-handler**\n   *\n   * **RAF Batching Pattern**:\n   * 1. Cancel any pending RAF from previous move event\n   * 2. Schedule new RAF for DOM updates\n   * 3. Limits visual updates to 60fps (browser refresh rate)\n   * 4. Prevents unnecessary work when events fire > 60/sec\n   *\n   * **Delta accumulation**:\n   * - interact.js provides cumulative deltas since drag start\n   * - Read current delta from data attributes\n   * - Add new delta from event\n   * - Store back to data attributes\n   * - Apply to base position for final transform\n   *\n   * **Formula**:\n   * ```\n   * newX = basePosition.x + totalDeltaX\n   * newY = basePosition.y + totalDeltaY\n   * ```\n   *\n   * **Why data attributes**:\n   * - Persist state across events without class properties\n   * - Can be read/written during event without this context\n   * - Survive potential element re-renders (though we avoid those)\n   *\n   * **Performance per frame**:\n   * - 1 transform style update (RAF-batched)\n   * - 2 data attribute updates (immediate)\n   * - No layout/reflow (transform is composited)\n   * - Total: ~0.5ms at 60fps max\n   * @param event - interact.js drag move event\n   * @example\n   * ```typescript\n   * // Event provides cumulative deltas\n   * {\n   *   target: HTMLElement,\n   *   dx: 5,    // 5px moved horizontally since drag start\n   *   dy: 3,    // 3px moved vertically since drag start\n   * }\n   *\n   * // Applied as:\n   * // transform = translate(baseX + 5px, baseY + 3px)\n   * ```\n   */\n  private handleDragMove(event: InteractDragEvent): void {\n    const x = (parseFloat(event.target.getAttribute(\"data-x\")) || 0) + event.dx;\n    const y = (parseFloat(event.target.getAttribute(\"data-y\")) || 0) + event.dy;\n\n    // Update data attributes immediately for next move event\n    event.target.setAttribute(\"data-x\", x.toString());\n    event.target.setAttribute(\"data-y\", y.toString());\n\n    // Mark that movement has occurred and notify parent immediately\n    if (!this.hasMoved && this.onDragMove) {\n      this.hasMoved = true;\n      this.onDragMove();\n    }\n\n    // Cancel any pending RAF from previous move event\n    if (this.dragRafId) {\n      cancelAnimationFrame(this.dragRafId);\n    }\n\n    // Batch DOM updates with RAF (limits to ~60fps instead of ~200/sec)\n    this.dragRafId = requestAnimationFrame(() => {\n      // If dragging from a separate handle, apply transform to main element\n      // Otherwise, apply to the event target\n      const elementToMove = this.dragHandleElement\n        ? this.element\n        : event.target;\n\n      // Apply drag delta to base position\n      // Direct DOM manipulation - no StencilJS re-render during drag\n      elementToMove.style.transform = `translate(${this.basePosition.x + x}px, ${this.basePosition.y + y}px)`;\n\n      // Clear RAF ID after execution\n      this.dragRafId = null;\n    });\n  }\n\n  /**\n   * Handle drag end event - finalize position and update state\n   *\n   * **Most Complex Method**: Handles grid snapping, boundary constraints, cross-canvas\n   * detection, canvas boundary snap-back, mobile layout handling, and state persistence.\n   *\n   * ## Processing Steps\n   *\n   * ### 1. Cross-Canvas and Boundary Detection\n   * - Calculate item bounds in viewport coordinates\n   * - Hit-test against all canvas bounding boxes\n   * - Detect if dragged to different canvas OR overlapping canvas boundary\n   * - **Snap-back logic**: If item overlaps boundary, snap to canvas it's mostly within\n   * - **Early exit**: Let dropzone handler manage cross-canvas moves\n   *\n   * **Canvas Boundary Snap-Back**:\n   * - Calculate percentage of item area within each canvas\n   * - If item overlaps a boundary, determine which canvas contains majority\n   * - Snap to bottom/top edge of the canvas containing >50% of item area\n   * - Prevents components from spanning multiple canvases\n   *\n   * **Why check center point for cross-canvas**:\n   * - More intuitive than checking any corner\n   * - Prevents accidental canvas switches when edge crosses boundary\n   * - Matches user mental model (\"where did I drop it?\")\n   *\n   * **Why delegate to dropzone**:\n   * - Dropzone has specialized logic for cross-canvas moves\n   * - Handles state transfer between canvases\n   * - Emits proper undo/redo commands\n   * - This handler focuses on same-canvas repositioning\n   *\n   * ### 2. Grid Snapping\n   * Formula: `Math.round(position / gridSize) * gridSize`\n   * - Rounds to nearest grid unit\n   * - Separate X and Y snapping (different grid sizes)\n   * - Applied before boundary constraints\n   *\n   * **Why snap before constraints**:\n   * - Ensures snapped position respects grid\n   * - Constraints then clip to canvas bounds\n   * - Prevents off-grid positions at edges\n   *\n   * ### 3. Boundary Constraints\n   * - Prevents item from extending outside canvas\n   * - Uses `Math.max(0, Math.min(pos, maxPos))` clamp pattern\n   * - Considers item width/height (full item must be visible)\n   *\n   * ### 4. Edge Snapping\n   * - Auto-snap to canvas edges within 20px threshold\n   * - Provides \"magnetic\" edges for precise alignment\n   * - Applied after grid snapping (takes precedence)\n   *\n   * **UX benefit**:\n   * - Easy to align items to canvas edges\n   * - No need for pixel-perfect dragging\n   * - Common layout pattern (full-width headers, etc.)\n   *\n   * ### 5. Mobile Layout Handling\n   * - Detects current viewport (desktop vs mobile)\n   * - Updates appropriate layout object\n   * - Marks mobile layout as \"customized\" when modified\n   * - Initializes mobile width/height from desktop if not set\n   *\n   * **Why \"customized\" flag**:\n   * - Mobile layouts default to desktop layout\n   * - Flag indicates user explicitly modified mobile layout\n   * - Prevents future desktop changes from overwriting mobile\n   *\n   * ### 6. State Persistence\n   * - Converts final pixel position to grid units\n   * - Updates item.layouts with new position\n   * - Calls `onUpdate(item)` callback\n   * - Triggers single StencilJS re-render\n   * - Parent component pushes undo/redo command\n   *\n   * ## Performance Characteristics\n   *\n   * **Total execution time**: ~5-10ms\n   * - Cross-canvas detection: ~1-2ms (querySelectorAll + getBoundingClientRect)\n   * - Boundary overlap calculation: ~1ms\n   * - Grid calculations: ~1ms\n   * - Boundary checks: ~0.5ms\n   * - State update: ~3-5ms (single re-render)\n   *\n   * **Why this is acceptable**:\n   * - Only runs once at drag end (not 60fps)\n   * - User expects slight delay when releasing drag\n   * - Grid snapping provides visual feedback justifying delay\n   *\n   * ## Edge Cases Handled\n   *\n   * - Item dragged outside canvas bounds → clamped to canvas\n   * - Item dragged to different canvas → delegated to dropzone\n   * - Item overlapping canvas boundary → snapped back to majority canvas\n   * - Canvas container not found → early exit (safety)\n   * - Mobile view with no mobile layout → initialized from desktop\n   * - Item near edge → snapped to edge for alignment\n   * @param event - interact.js drag end event\n   * @example\n   * ```typescript\n   * // Example drag sequence:\n   * // 1. handleDragStart: Store basePosition (100, 200)\n   * // 2. handleDragMove (60 times): Update transform with deltas\n   * // 3. handleDragEnd: deltaX=150, deltaY=75\n   * //    - finalX = 100 + 150 = 250px\n   * //    - snappedX = Math.round(250 / 20) * 20 = 260px\n   * //    - gridX = 260 / 20 = 13 grid units\n   * //    - item.layouts.desktop.x = 13\n   * //    - onUpdate(item) → re-render + undo command\n   * ```\n   */\n  private handleDragEnd(event: InteractDragEvent): void {\n    // Cancel any pending RAF from drag move\n    if (this.dragRafId) {\n      cancelAnimationFrame(this.dragRafId);\n      this.dragRafId = null;\n    }\n\n    const deltaX = parseFloat(event.target.getAttribute(\"data-x\")) || 0;\n    const deltaY = parseFloat(event.target.getAttribute(\"data-y\")) || 0;\n\n    // Remove dragging class immediately to enable CSS transitions\n    const elementToMark = this.dragHandleElement ? this.element : event.target;\n    elementToMark.classList.remove(\"dragging\");\n\n    // If drag movement occurred, prevent click event from opening config panel\n    if (this.hasMoved) {\n      // Suppress click on the element that was dragged (event.target = drag handle)\n      // This prevents the click from bubbling up and opening the config panel\n      const draggedElement = event.target;\n      const suppressClick = (e: Event) => {\n        e.stopPropagation();\n        e.preventDefault();\n        // Remove this listener after handling one click\n        draggedElement.removeEventListener(\"click\", suppressClick, true);\n      };\n      draggedElement.addEventListener(\"click\", suppressClick, true);\n\n      // Fallback cleanup in case click never fires\n      setTimeout(() => {\n        draggedElement.removeEventListener(\"click\", suppressClick, true);\n      }, 100);\n    }\n\n    // Get the element's current position in viewport (use main element if dragging from handle)\n    const elementForRect = this.dragHandleElement ? this.element : event.target;\n    const rect = elementForRect.getBoundingClientRect();\n\n    // Find which canvas the item should belong to (hybrid approach)\n    let targetCanvasId = this.item.canvasId;\n    let isFullyContained = false;\n\n    const gridContainers = document.querySelectorAll(\".grid-container\");\n\n    // Priority 1: Check if item is fully contained in any canvas\n    gridContainers.forEach((container: HTMLElement) => {\n      const containerRect = container.getBoundingClientRect();\n      if (\n        rect.left >= containerRect.left &&\n        rect.right <= containerRect.right &&\n        rect.top >= containerRect.top &&\n        rect.bottom <= containerRect.bottom\n      ) {\n        targetCanvasId =\n          container.getAttribute(\"data-canvas-id\") || this.item.canvasId;\n        isFullyContained = true;\n      }\n    });\n\n    // Priority 2: Fallback to center point detection (for oversized items)\n    if (!isFullyContained) {\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n\n      gridContainers.forEach((container: HTMLElement) => {\n        const containerRect = container.getBoundingClientRect();\n        if (\n          centerX >= containerRect.left &&\n          centerX <= containerRect.right &&\n          centerY >= containerRect.top &&\n          centerY <= containerRect.bottom\n        ) {\n          targetCanvasId =\n            container.getAttribute(\"data-canvas-id\") || this.item.canvasId;\n        }\n      });\n    }\n\n    // If canvas changed from drag start, let the dropzone handle it\n    // (Use dragStartCanvasId since item.canvasId may have been updated by dropzone already)\n    if (targetCanvasId !== this.dragStartCanvasId) {\n      // Clean up drag state (dragging class already removed above)\n      event.target.setAttribute(\"data-x\", \"0\");\n      event.target.setAttribute(\"data-y\", \"0\");\n\n      // End performance tracking\n      if (window.perfMonitor) {\n        window.perfMonitor.endOperation(\"drag\");\n      }\n      return;\n    }\n\n    // Calculate new position relative to current canvas (same-canvas drag only)\n    const targetContainer = domCache.getCanvas(targetCanvasId);\n    if (!targetContainer) {\n      // Invalid drop - no canvas found, snap back to original position\n      this.snapBackToOriginalPosition(event);\n      return;\n    }\n\n    const gridSizeX = getGridSizeHorizontal(targetCanvasId, this.config);\n    const gridSizeY = getGridSizeVertical(this.config);\n\n    // Final position is base position + drag delta\n    let newX = this.basePosition.x + deltaX;\n    let newY = this.basePosition.y + deltaY;\n\n    // Snap to grid (separate X and Y)\n    newX = Math.round(newX / gridSizeX) * gridSizeX;\n    newY = Math.round(newY / gridSizeY) * gridSizeY;\n\n    // Get item dimensions (use main element if dragging from handle)\n    const elementForDimensions = this.dragHandleElement\n      ? this.element\n      : event.target;\n    const itemWidth = parseFloat(elementForDimensions.style.width) || 0;\n    const itemHeight = parseFloat(elementForDimensions.style.height) || 0;\n\n    // Convert to grid units for boundary checking\n    const gridX = pixelsToGridX(newX, targetCanvasId, this.config);\n    const gridY = pixelsToGridY(newY, this.config);\n    const gridWidth = pixelsToGridX(itemWidth, targetCanvasId, this.config);\n    const gridHeight = pixelsToGridY(itemHeight, this.config);\n\n    // Apply boundary constraints to keep component fully within canvas\n    // If item is dragged beyond edge, it will snap to the nearest valid position\n    const constrained = constrainPositionToCanvas(\n      gridX,\n      gridY,\n      gridWidth,\n      gridHeight,\n      CANVAS_WIDTH_UNITS,\n    );\n\n    // Convert back to pixels\n    const gridSizeXForConversion = getGridSizeHorizontal(targetCanvasId, this.config);\n    const gridSizeYForConversion = getGridSizeVertical(this.config);\n    newX = constrained.x * gridSizeXForConversion;\n    newY = constrained.y * gridSizeYForConversion;\n\n    // IMPORTANT: Get latest item from state to preserve any config changes\n    // that occurred during drag (e.g., backgroundColor changes)\n    const canvas = this.state.canvases[this.item.canvasId];\n    const latestItem = canvas?.items.find((i) => i.id === this.item.id);\n    const itemToUpdate = latestItem || this.item; // Fallback to stored item if not found\n\n    // Update item position in current viewport's layout (use constrained grid units)\n    const currentViewport = this.state.currentViewport || \"desktop\";\n    const layout =\n      itemToUpdate.layouts[currentViewport as \"desktop\" | \"mobile\"];\n\n    layout.x = constrained.x;\n    layout.y = constrained.y;\n\n    // If in mobile view, mark as customized\n    if (currentViewport === \"mobile\") {\n      itemToUpdate.layouts.mobile.customized = true;\n      // Set width/height if not already set (copy from desktop)\n      if (itemToUpdate.layouts.mobile.width === null) {\n        itemToUpdate.layouts.mobile.width = itemToUpdate.layouts.desktop.width;\n      }\n      if (itemToUpdate.layouts.mobile.height === null) {\n        itemToUpdate.layouts.mobile.height =\n          itemToUpdate.layouts.desktop.height;\n      }\n    }\n\n    // Wait for next animation frame before applying final position\n    // This allows CSS transitions to animate from current position to final snapped position\n    // (dragging class was removed above, enabling transitions)\n    requestAnimationFrame(() => {\n      // Apply final snapped position to DOM (to main element if dragging from handle)\n      const elementToMove = this.dragHandleElement\n        ? this.element\n        : event.target;\n      elementToMove.style.transform = `translate(${newX}px, ${newY}px)`;\n      event.target.setAttribute(\"data-x\", \"0\");\n      event.target.setAttribute(\"data-y\", \"0\");\n\n      // End performance tracking\n      if (window.perfMonitor) {\n        window.perfMonitor.endOperation(\"drag\");\n      }\n\n      // Trigger StencilJS update (single re-render at end)\n      this.onUpdate(itemToUpdate);\n    });\n  }\n\n  /**\n   * Snap item back to original position on invalid drop\n   *\n   * **Called when**: Item is dropped outside all canvases\n   *\n   * ## Behavior\n   *\n   * 1. **Retrieve stored position**: Get original transform and position from drag start\n   * 2. **Enable CSS transition**: Smooth 300ms cubic-bezier animation\n   * 3. **Restore original transform**: Snap back to starting position\n   * 4. **Clean up**: Remove transition and temp properties after animation\n   * 5. **No state update**: Item stays in original canvas position\n   *\n   * ## Visual Feedback\n   *\n   * **Transition**: 300ms cubic-bezier(0.4, 0.0, 0.2, 1) - Material Design standard\n   * **Effect**: Grid item smoothly animates back to palette/original position\n   * **User perception**: Clear indication that drop was invalid\n   * @param event - interact.js drag end event\n   */\n  private snapBackToOriginalPosition(event: InteractDragEvent): void {\n    const originalPos = (this.element as any)._originalPosition;\n    const originalTransform = (this.element as any)._originalTransform;\n\n    if (!originalPos) {\n      // Fallback: just remove dragging class if no original position stored\n      const elementToMark = this.dragHandleElement\n        ? this.element\n        : event.target;\n      elementToMark.classList.remove(\"dragging\");\n      return;\n    }\n\n    // Determine which element to animate\n    const elementToMove = this.dragHandleElement ? this.element : event.target;\n\n    // Enable CSS transitions for smooth snap-back\n    elementToMove.style.transition =\n      \"transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)\";\n\n    // Snap back to original position\n    elementToMove.style.transform =\n      originalTransform || `translate(${originalPos.x}px, ${originalPos.y}px)`;\n\n    // Remove transition after animation completes\n    setTimeout(() => {\n      elementToMove.style.transition = \"\";\n      elementToMove.classList.remove(\"dragging\");\n    }, 300);\n\n    // Reset data attributes\n    event.target.setAttribute(\"data-x\", \"0\");\n    event.target.setAttribute(\"data-y\", \"0\");\n\n    // Cleanup stored properties\n    delete (this.element as any)._originalPosition;\n    delete (this.element as any)._originalTransform;\n\n    // End performance tracking\n    if (window.perfMonitor) {\n      window.perfMonitor.endOperation(\"drag\");\n    }\n\n    // No state update - item stays in original position\n    // No undo/redo command pushed - invalid action\n  }\n}\n","export const BUILD_TIMESTAMP = '2025-12-01T03:32:27.692Z';\n","/**\n * Resize Handler\n * ===============\n *\n * High-performance resize system for grid items using interact.js with direct DOM\n * manipulation and requestAnimationFrame batching. Enables smooth 60fps resizing\n * with 8-point handles while avoiding framework re-render overhead.\n *\n * ## Problem\n *\n * Resizing UI elements at 60fps requires updating dimensions and position ~16ms per frame.\n * Using framework state updates would cause:\n * - Full component re-renders on every mousemove event during resize\n * - Virtual DOM diffing overhead\n * - Layout thrashing from repeated read/write cycles\n * - Janky, stuttering resize experience\n * - Position jumping on certain resize handles (bottom/right edges)\n *\n * ## Solution\n *\n * Hybrid approach combining interact.js resize events with RAF-batched DOM updates:\n *\n * 1. **During resize** (60fps): Direct DOM updates via RAF batching\n * - No state updates\n * - No re-renders\n * - Smooth visual feedback\n * - Batched with requestAnimationFrame\n *\n * 2. **After resize** (single operation): Update StencilJS state once\n * - Trigger single re-render\n * - Persist final dimensions\n * - Emit undo/redo commands\n *\n * ## Key Architecture Decisions\n *\n * ### 8-Point Resize Handles\n *\n * **Configuration**: `edges: { left: true, right: true, bottom: true, top: true }`\n *\n * Provides 8 resize handles:\n * - 4 corners: top-left, top-right, bottom-left, bottom-right\n * - 4 edges: top, right, bottom, left\n *\n * **Why all 8 handles**:\n * - Maximum flexibility for users\n * - Matches familiar UI patterns (Figma, Photoshop, etc.)\n * - Enables precise positioning and sizing\n *\n * ### RequestAnimationFrame Batching\n *\n * **Pattern**:\n * ```typescript\n * handleResizeMove(event) {\n * cancelAnimationFrame(this.rafId);\n * this.rafId = requestAnimationFrame(() => {\n * // Apply DOM updates once per frame\n * });\n * }\n * ```\n *\n * **Why RAF batching**:\n * - Mousemove events fire faster than display refresh (60fps)\n * - Without batching: multiple DOM updates per frame (wasted work)\n * - With batching: exactly 1 DOM update per frame (aligned with browser paint)\n * - Prevents layout thrashing\n * - Smoother visual updates\n *\n * **Performance impact**:\n * - Without RAF: ~200 updates/sec, many dropped frames\n * - With RAF: ~60 updates/sec, no dropped frames\n * - **3-4x fewer DOM operations**\n *\n * ### Grid Snapping Strategy\n *\n * **When**: Only at resize end (endOnly: true)\n * **Why**: Allows free-form resizing during operation, snaps to grid on release\n *\n * **interact.js modifier**:\n * ```typescript\n * interact.modifiers.snap({\n * targets: [interact.snappers.grid({ x: gridSizeX, y: gridSizeY })],\n * endOnly: true  // Critical: prevents mid-resize jumps\n * })\n * ```\n *\n * **Alternative approaches and why they fail**:\n * - Snap during resize: Causes visual jumping, poor UX\n * - Manual snapping in handleResizeEnd: Works, but duplicates logic\n * - endOnly modifier: Clean, performant, built into interact.js\n *\n * ### DeltaRect Position Preservation\n *\n * **Problem**: Resizing from left/top edges changes element position\n * **Solution**: Track accumulated deltas and update transform\n *\n * **Example**:\n * - Resize from left edge: width increases, x position decreases\n * - deltaRect.left = -50 (element moved left 50px)\n * - deltaRect.width = 50 (element grew 50px wider)\n * - Apply both: new x = startX + (-50), new width = startWidth + 50\n *\n * **Why this is tricky**:\n * - Bottom/right resizes only change dimensions\n * - Top/left resizes change BOTH position and dimensions\n * - Must update transform AND width/height simultaneously\n * - interact.js provides deltaRect to handle this automatically\n *\n * ### Minimum Size Constraints\n *\n * **Configuration**:\n * ```typescript\n * interact.modifiers.restrictSize({ min: { width: 100, height: 80 } })\n * ```\n *\n * **Why these minimums**:\n * - width: 100px → ~5 grid units (enough for readable text/UI)\n * - height: 80px → ~4 grid units (matches common component heights)\n * - Prevents accidentally collapsing items to unusable sizes\n * - No maximum (items can grow to fill canvas)\n *\n * ## Performance Characteristics\n *\n * **During resize** (per frame):\n * - 1 RAF batch (~60fps max)\n * - 3 style updates (transform, width, height)\n * - No layout/reflow (transform is composited)\n * - ~0.5-1ms per frame\n *\n * **At resize end**:\n * - Grid snapping calculations\n * - Boundary constraint checks\n * - State update + single re-render\n * - ~5-10ms total\n *\n * **Performance gain over state-based approach**:\n * - State-based: ~16ms+ per frame (re-render overhead)\n * - This approach: ~0.5-1ms per frame\n * - **~16-30x faster during resize**\n *\n * ## Edge Cases Handled\n *\n * - Resize from any of 8 handles\n * - Position preservation during top/left resize\n * - Boundary constraints (can't resize outside canvas)\n * - Minimum size enforcement (100×80px)\n * - Grid snapping without mid-resize jumps\n * - Mobile vs desktop viewport layouts\n * - Element styles not yet applied (RAF delay in constructor)\n * - Clean RAF cancellation on destroy\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n *\n * ```typescript\n * class MyResizeHandler {\n * private rafId: number | null = null;\n * private startRect = { x: 0, y: 0, width: 0, height: 0 };\n *\n * handleResizeMove(e) {\n * // Cancel previous frame\n * if (this.rafId) cancelAnimationFrame(this.rafId);\n *\n * // Batch with RAF\n * this.rafId = requestAnimationFrame(() => {\n * // Accumulate deltas\n * this.startRect.x += e.deltaRect.left;\n * this.startRect.y += e.deltaRect.top;\n * this.startRect.width += e.deltaRect.width;\n * this.startRect.height += e.deltaRect.height;\n *\n * // Direct DOM update\n * e.target.style.transform = `translate(${this.startRect.x}px, ${this.startRect.y}px)`;\n * e.target.style.width = this.startRect.width + 'px';\n * e.target.style.height = this.startRect.height + 'px';\n * });\n * }\n *\n * handleResizeEnd(e) {\n * cancelAnimationFrame(this.rafId);\n * // Single state update\n * this.updateState(this.startRect);\n * }\n * }\n * ```\n *\n * ## Integration with Other Systems\n *\n * - **grid-calculations**: Convert between pixels and grid units\n * - **dom-cache**: Fast canvas element lookup\n * - **state-manager**: Single state update at resize end\n * - **undo-redo**: Command pushed via onUpdate callback\n * - **interact.js**: Event source for resize lifecycle + modifiers\n * @module resize-handler\n */\n\nimport type { InteractResizeEvent, Interactable } from \"interactjs\";\nimport {\n  GridItem,\n  GridState,\n  setActiveCanvas,\n} from \"../services/state-manager\";\nimport { ComponentDefinition } from \"../types/component-definition\";\nimport { GridConfig } from \"../types/grid-config\";\nimport { domCache } from \"./dom-cache\";\nimport {\n  getGridSizeHorizontal,\n  getGridSizeVertical,\n  pixelsToGridX,\n  pixelsToGridY,\n  gridToPixelsX,\n  gridToPixelsY,\n} from \"./grid-calculations\";\nimport { BUILD_TIMESTAMP } from \"./version\";\nimport { createDebugLogger } from \"./debug\";\n\nconst debug = createDebugLogger(\"resize-handler\");\n\n/**\n * Extract current transform position from element's inline style\n *\n * **Purpose**: Get element's current position for resize start position tracking\n *\n * **Why needed**: Resize operations must preserve position when resizing from\n * top/left handles. The transform is the canonical position source during operations.\n *\n * **Pattern shared with drag-handler**: Both drag and resize need base position\n * extraction, so this function is duplicated (could be extracted to shared utility).\n * @param element - Element with transform style\n * @returns Current x,y position in pixels, or {0,0} if no transform\n * @example\n * ```typescript\n * const el = document.getElementById('item-1');\n * el.style.transform = 'translate(100px, 150px)';\n * const pos = getTransformPosition(el); // → {x: 100, y: 150}\n * ```\n */\nfunction getTransformPosition(element: HTMLElement): { x: number; y: number } {\n  const transform = element.style.transform;\n  const match = transform.match(/translate\\(([\\d.-]+)px,\\s*([\\d.-]+)px\\)/);\n\n  if (match) {\n    return {\n      x: parseFloat(match[1]),\n      y: parseFloat(match[2]),\n    };\n  }\n\n  return { x: 0, y: 0 };\n}\n\n/**\n * Resize Handler Class\n * =====================\n *\n * Manages high-performance resize behavior for a single grid item. Each grid item\n * gets its own ResizeHandler instance that coordinates interact.js resize events\n * with RAF-batched DOM updates and state management.\n *\n * ## Instance Lifecycle\n *\n * 1. **Creation**: Instantiated by grid-item-wrapper when item mounts\n * 2. **Initialization**: Sets up interact.js resizable with 8 handles + modifiers\n * 3. **Active**: Handles resize events with RAF-batched DOM manipulation\n * 4. **Cleanup**: destroy() called when item unmounts to prevent RAF/memory leaks\n *\n * ## State Management\n *\n * **Private state** (not in framework):\n * - `startRect`: Position and size at resize start\n * - `resizeRafId`: RAF handle for batching updates\n * - `interactInstance`: interact.js resizable instance\n *\n * **Framework state**: Updated only once at resize end via `onUpdate` callback\n *\n * ## Performance Pattern\n *\n * RAF batching + direct manipulation:\n * - High-frequency events (move): RAF-batched DOM updates\n * - Low-frequency events (start/end): State updates + event tracking\n * - Cancel pending RAF on each move (only last frame executes)\n * @example\n * ```typescript\n * // In grid-item-wrapper.tsx\n * componentDidLoad() {\n *   this.resizeHandler = new ResizeHandler(\n *     this.element,\n *     this.item,\n *     (updatedItem) => {\n *       // This callback runs ONCE at resize end\n *       gridState.updateItem(updatedItem);\n *       undoRedo.pushCommand(new ResizeCommand(this.item, updatedItem));\n *     }\n *   );\n * }\n *\n * disconnectedCallback() {\n *   this.resizeHandler?.destroy(); // Critical: prevents RAF leak\n * }\n * ```\n */\nexport class ResizeHandler {\n  /** DOM element being resized (grid-item-wrapper element) */\n  private element: HTMLElement;\n\n  /** Grid item data (position, size, layouts) */\n  private item: GridItem;\n\n  /** Grid state instance (for accessing canvases, viewport) */\n  private state: GridState;\n\n  /** Component definition (for min/max size constraints) */\n  private componentDefinition?: ComponentDefinition;\n\n  /** Grid configuration (for consistent grid size calculations) */\n  private config?: GridConfig;\n\n  /** Callback to update parent state after resize ends */\n  private onUpdate: (item: GridItem) => void;\n\n  /** interact.js resizable instance for cleanup */\n  private interactInstance: Interactable | null = null;\n\n  /** RAF ID for cancelling pending frame updates */\n  private resizeRafId: number | null = null;\n\n  /** Starting position and size at resize start (for deltaRect calculations) */\n  private startRect: { x: number; y: number; width: number; height: number } = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /** Last calculated position and size from handleResizeMove (for handleResizeEnd) */\n  private lastCalculated: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  } = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /** Min/max size constraints in pixels (cached from component definition) */\n  private minWidth: number = 100;\n  private minHeight: number = 80;\n  private maxWidth: number = Infinity;\n  private maxHeight: number = Infinity;\n\n  /**\n   * Create resize handler and initialize interact.js\n   *\n   * **Lifecycle**: Called when grid-item-wrapper mounts\n   *\n   * **RAF delay pattern**:\n   * If element doesn't have width/height styles yet, defers initialization to next frame.\n   * This handles race condition where StencilJS hasn't applied computed styles yet.\n   *\n   * **Why RAF delay is needed**:\n   * - interact.js reads element dimensions during setup\n   * - If dimensions are 0, resize handles won't work correctly\n   * - RAF ensures browser has completed style application\n   * - Only happens on initial mount, not on subsequent operations\n   *\n   * **Error handling**:\n   * Warns but continues if styles missing (won't break app, just logs issue)\n   * @param element - DOM element to make resizable (grid-item-wrapper)\n   * @param item - Grid item data for dimension/position management\n   * @param onUpdate - Callback invoked with updated item after resize ends\n   * @param componentDefinition - Optional component definition for min/max size constraints\n   * @example\n   * ```typescript\n   * // Typical usage in component\n   * private resizeHandler: ResizeHandler;\n   *\n   * componentDidLoad() {\n   *   const definition = this.componentRegistry.get(this.item.type);\n   *   this.resizeHandler = new ResizeHandler(\n   *     this.element,\n   *     this.item,\n   *     (item) => this.handleItemUpdate(item),\n   *     definition\n   *   );\n   * }\n   * ```\n   */\n  constructor(\n    element: HTMLElement,\n    item: GridItem,\n    state: GridState,\n    onUpdate: (item: GridItem) => void,\n    componentDefinition?: ComponentDefinition,\n    config?: GridConfig,\n  ) {\n    this.element = element;\n    this.item = item;\n    this.state = state;\n    this.onUpdate = onUpdate;\n    this.componentDefinition = componentDefinition;\n    this.config = config;\n\n    // Ensure element has width/height before initializing interact.js\n    // StencilJS might not have applied styles yet\n    if (!element.style.width || !element.style.height) {\n      console.warn(\n        \"Element missing width/height styles, waiting for next frame\",\n      );\n      requestAnimationFrame(() => this.initialize());\n    } else {\n      this.initialize();\n    }\n  }\n\n  /**\n   * Cleanup interact.js instance and cancel pending RAF\n   *\n   * **When to call**: Component unmount (disconnectedCallback in StencilJS)\n   *\n   * **Critical for RAF cleanup**:\n   * Unlike drag-handler, resize-handler uses RAF batching. Must cancel\n   * pending RAF to prevent:\n   * - Memory leaks from closures\n   * - Errors from updating removed elements\n   * - RAF callbacks firing after component destruction\n   *\n   * **What it does**:\n   * 1. Cancels any pending requestAnimationFrame\n   * 2. Calls `interactInstance.unset()` to remove event listeners\n   * 3. Safe to call multiple times (checks if instances exist)\n   *\n   * **Performance**: Very cheap operation (~0.1ms)\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper component\n   * disconnectedCallback() {\n   *   if (this.resizeHandler) {\n   *     this.resizeHandler.destroy(); // MUST call to prevent RAF leak\n   *   }\n   * }\n   * ```\n   */\n  destroy(): void {\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n      this.resizeRafId = null;\n    }\n\n    if (this.interactInstance) {\n      this.interactInstance.unset();\n    }\n  }\n\n  /**\n   * Initialize interact.js resizable on element\n   *\n   * **Configuration choices explained**:\n   *\n   * **edges: all true**\n   * - Enables 8 resize handles (4 corners + 4 edges)\n   * - Provides maximum flexibility for users\n   * - Matches familiar design tool patterns\n   *\n   * **modifiers array**:\n   * Order matters! Modifiers are applied in sequence:\n   *\n   * 1. **restrictSize modifier**: Enforces minimum dimensions\n   * - min width: 100px (~5 grid units)\n   * - min height: 80px (~4 grid units)\n   * - Prevents unusably small items\n   * - No maximum (items can grow to canvas bounds)\n   *\n   * 2. **snap modifier with endOnly: true**:\n   * - Snaps to grid ONLY at resize end\n   * - **Critical**: endOnly prevents mid-resize jumping\n   * - Uses function callbacks for dynamic grid sizes\n   * - range: Infinity means always snap (no distance limit)\n   *\n   * **Why function callbacks for grid sizes**:\n   * ```typescript\n   * x: () => getGridSizeHorizontal(this.item.canvasId)\n   * ```\n   * - Grid sizes can change (viewport switch, canvas resize)\n   * - Function ensures fresh value on each snap\n   * - Without callback, would cache stale grid size\n   *\n   * **Event binding**:\n   * - Uses `.bind(this)` to preserve class context\n   * - Without bind, `this` would be interact.js context\n   * - Allows handlers to access instance properties\n   *\n   * **Error handling**:\n   * - Checks if interact.js loaded (from CDN)\n   * - Fails gracefully with console warning\n   * - Prevents app crash if CDN fails\n   * @example\n   * ```typescript\n   * // interact.js resizable configuration\n   * interact(element).resizable({\n   *   edges: { left: true, right: true, bottom: true, top: true },\n   *   modifiers: [\n   *     interact.modifiers.restrictSize({ min: { width: 100, height: 80 } }),\n   *     interact.modifiers.snap({\n   *       targets: [interact.snappers.grid({ x: 20, y: 20 })],\n   *       endOnly: true  // Key: prevents visual jumping during resize\n   *     })\n   *   ]\n   * });\n   * ```\n   */\n  private initialize(): void {\n    // Log build timestamp and version info (only in development)\n    debug.log(\"📦 resize-handler.ts build:\", BUILD_TIMESTAMP);\n    debug.log(\n      \"🔧 Grid config fix applied - resize handler now uses same grid calculations as render\",\n    );\n\n    const interact = window.interact;\n    if (!interact) {\n      console.warn(\"interact.js not loaded\");\n      return;\n    }\n\n    // Get min/max size from component definition (in grid units), convert to pixels\n    const minSizeGridUnits = this.componentDefinition?.minSize;\n    const maxSizeGridUnits = this.componentDefinition?.maxSize;\n\n    this.minWidth = minSizeGridUnits\n      ? gridToPixelsX(minSizeGridUnits.width, this.item.canvasId, this.config)\n      : 100;\n    this.minHeight = minSizeGridUnits\n      ? gridToPixelsY(minSizeGridUnits.height, this.config)\n      : 80;\n\n    this.maxWidth = maxSizeGridUnits\n      ? gridToPixelsX(maxSizeGridUnits.width, this.item.canvasId, this.config)\n      : Infinity;\n    this.maxHeight = maxSizeGridUnits\n      ? gridToPixelsY(maxSizeGridUnits.height, this.config)\n      : Infinity;\n\n    // Determine which edges should be enabled based on min/max constraints\n    // If min == max for a dimension, disable resizing on that dimension\n    const canResizeWidth =\n      this.maxWidth === Infinity || this.maxWidth > this.minWidth;\n    const canResizeHeight =\n      this.maxHeight === Infinity || this.maxHeight > this.minHeight;\n\n    debug.log(\"🔧 ResizeHandler init for\", this.item.id, {\n      minWidth: this.minWidth,\n      maxWidth: this.maxWidth,\n      minHeight: this.minHeight,\n      maxHeight: this.maxHeight,\n      canResizeWidth,\n      canResizeHeight,\n      componentDefinition: this.componentDefinition,\n    });\n\n    // Apply disabled class to element to control handle visibility via CSS\n    if (!canResizeWidth) {\n      debug.log(\"  ❌ Disabling width resize\");\n      this.element.classList.add(\"resize-width-disabled\");\n    }\n    if (!canResizeHeight) {\n      debug.log(\"  ❌ Disabling height resize\");\n      this.element.classList.add(\"resize-height-disabled\");\n    }\n\n    this.interactInstance = interact(this.element).resizable({\n      edges: {\n        left: canResizeWidth,\n        right: canResizeWidth,\n        bottom: canResizeHeight,\n        top: canResizeHeight,\n      },\n\n      // Ignore resize from the drag handle header\n      ignoreFrom: \".grid-item-header\",\n\n      // No modifiers - we handle all constraints manually in handleResizeMove\n      // This prevents fighting between interact.js modifiers and our RAF-batched updates\n\n      listeners: {\n        start: this.handleResizeStart.bind(this),\n        move: this.handleResizeMove.bind(this),\n        end: this.handleResizeEnd.bind(this),\n      },\n    });\n  }\n\n  /**\n   * Handle resize start event\n   *\n   * **Responsibilities**:\n   * 1. Start performance monitoring (if perfMonitor available)\n   * 2. Add visual feedback (resizing class)\n   * 3. Capture starting position and dimensions\n   * 4. Initialize startRect for deltaRect accumulation\n   *\n   * **Why capture startRect**:\n   * - interact.js provides deltaRect (cumulative changes)\n   * - Must apply deltas to starting values\n   * - Position can change during resize (top/left handles)\n   * - Dimensions always change during resize\n   *\n   * **startRect structure**:\n   * ```typescript\n   * {\n   * x: 100,      // Starting transform X\n   * y: 150,      // Starting transform Y\n   * width: 300,  // Starting width in pixels\n   * height: 200  // Starting height in pixels\n   * }\n   * ```\n   *\n   * **Performance tracking**:\n   * - Optional perfMonitor integration\n   * - Measures total resize duration (start → end)\n   * - Helps identify performance regressions\n   * @param event - interact.js resize start event\n   * @example\n   * ```typescript\n   * // Event provides element reference\n   * {\n   *   target: HTMLElement,\n   *   rect: {width, height, left, top, ...},\n   *   // ... other interact.js properties\n   * }\n   * ```\n   */\n  private handleResizeStart(event: InteractResizeEvent): void {\n    // Start performance tracking\n    if (window.perfMonitor) {\n      window.perfMonitor.startOperation(\"resize\");\n    }\n\n    event.target.classList.add(\"resizing\");\n\n    // Set this canvas as active\n    setActiveCanvas(this.item.canvasId);\n\n    // Store the starting position and size\n    const position = getTransformPosition(event.target);\n    this.startRect.x = position.x;\n    this.startRect.y = position.y;\n    this.startRect.width = parseFloat(event.target.style.width) || 0;\n    this.startRect.height = parseFloat(event.target.style.height) || 0;\n\n    // Reset data attributes for tracking cumulative deltas (like drag-handler)\n    event.target.setAttribute(\"data-x\", \"0\");\n    event.target.setAttribute(\"data-y\", \"0\");\n    event.target.setAttribute(\"data-width\", \"0\");\n    event.target.setAttribute(\"data-height\", \"0\");\n\n    debug.log(\"🟢 RESIZE START:\", {\n      edges: event.edges,\n      startRect: { ...this.startRect },\n      itemId: this.item.id,\n    });\n  }\n\n  /**\n   * Handle resize move event with RAF batching (high-frequency, ~60fps)\n   *\n   * **Critical Performance Path**: This runs ~200 times/sec during resize (mousemove),\n   * but RAF batching limits actual DOM updates to ~60fps.\n   *\n   * **Data Attribute Pattern + RAF Batching**:\n   * The implementation combines two strategies for smooth, accurate resizing:\n   * 1. **Data attributes**: Track cumulative deltas separately from DOM styles\n   * 2. **RAF batching**: Throttle DOM updates to 60fps max\n   *\n   * **RAF Batching Pattern**:\n   * ```\n   * // Update data attributes immediately (for next event)\n   * element.setAttribute('data-width', deltaWidth);\n   *\n   * cancelAnimationFrame(oldId);  // Cancel previous pending frame\n   * newId = requestAnimationFrame(() => {\n   * // DOM updates execute once per browser paint (~60fps)\n   * element.style.width = newWidth + 'px';\n   * });\n   * ```\n   *\n   * **Why RAF batching is critical**:\n   * - Mousemove fires ~200x/sec (faster than 60fps display)\n   * - Without batching: 200 DOM updates/sec, many wasted (can't paint that fast)\n   * - With batching: ~60 DOM updates/sec, aligned with browser paint\n   * - **3-4x fewer DOM operations**\n   * - Prevents frame drops and stuttering\n   *\n   * **DeltaRect Accumulation**:\n   * interact.js provides cumulative changes since resize start:\n   * - `deltaRect.left`: X position change (negative = moved left)\n   * - `deltaRect.top`: Y position change (negative = moved up)\n   * - `deltaRect.width`: Width change\n   * - `deltaRect.height`: Height change\n   *\n   * **Why accumulate into startRect**:\n   * - Maintains single source of truth for current state\n   * - Allows direct application to DOM\n   * - Simplifies final position calculation\n   *\n   * **Example resize from top-left handle**:\n   * ```\n   * Start: x=100, y=150, width=300, height=200\n   * User drags top-left handle up-left by 50px\n   * deltaRect: {left: -50, top: -50, width: 50, height: 50}\n   * Result: x=50, y=100, width=350, height=250\n   * ```\n   *\n   * **Performance per frame**:\n   * - Cancel previous RAF: ~0.01ms\n   * - Schedule new RAF: ~0.01ms\n   * - Actual DOM update (in RAF callback):\n   * - 3 style updates (transform, width, height)\n   * - No layout/reflow (transform is composited)\n   * - ~0.5-1ms total\n   *\n   * **Without RAF batching**:\n   * - 200 updates/sec × 1ms = 200ms/sec wasted\n   * - Dropped frames, stuttering\n   *\n   * **With RAF batching**:\n   * - 60 updates/sec × 1ms = 60ms/sec\n   * - Smooth, no dropped frames\n   * @param event - interact.js resize move event\n   * @example\n   * ```typescript\n   * // Event provides deltaRect (cumulative changes)\n   * {\n   *   target: HTMLElement,\n   *   deltaRect: {\n   *     left: -10,   // Element moved left 10px\n   *     top: 0,      // No vertical movement\n   *     width: 10,   // Grew 10px wider\n   *     height: 0    // Height unchanged\n   *   }\n   * }\n   *\n   * // Applied as:\n   * // newX = startX + (-10)\n   * // newWidth = startWidth + 10\n   * ```\n   */\n  private handleResizeMove(event: InteractResizeEvent): void {\n    // Use data attributes to track cumulative deltas (same pattern as drag-handler)\n    // This prevents interact.js from getting confused about element position\n    const deltaX =\n      (parseFloat(event.target.getAttribute(\"data-x\")) || 0) +\n      event.deltaRect.left;\n    const deltaY =\n      (parseFloat(event.target.getAttribute(\"data-y\")) || 0) +\n      event.deltaRect.top;\n    const deltaWidth =\n      (parseFloat(event.target.getAttribute(\"data-width\")) || 0) +\n      event.deltaRect.width;\n    const deltaHeight =\n      (parseFloat(event.target.getAttribute(\"data-height\")) || 0) +\n      event.deltaRect.height;\n\n    // Update data attributes immediately for next move event\n    event.target.setAttribute(\"data-x\", deltaX.toString());\n    event.target.setAttribute(\"data-y\", deltaY.toString());\n    event.target.setAttribute(\"data-width\", deltaWidth.toString());\n    event.target.setAttribute(\"data-height\", deltaHeight.toString());\n\n    // Calculate new dimensions and position from base + deltas\n    let newWidth = this.startRect.width + deltaWidth;\n    let newHeight = this.startRect.height + deltaHeight;\n    let newX = this.startRect.x + deltaX;\n    let newY = this.startRect.y + deltaY;\n\n    // Get canvas dimensions for boundary constraints\n    const container = domCache.getCanvas(this.item.canvasId);\n    const containerWidth = container ? container.clientWidth : Infinity;\n    const containerHeight = container ? container.clientHeight : Infinity;\n\n    // Apply min/max size constraints first\n    newWidth = Math.max(this.minWidth, Math.min(this.maxWidth, newWidth));\n    newHeight = Math.max(this.minHeight, Math.min(this.maxHeight, newHeight));\n\n    // CRITICAL: Enforce canvas boundaries during resize\n    // Check all four edges independently to prevent overflow\n\n    // Left edge: position must be >= 0\n    if (newX < 0) {\n      if (event.edges.left) {\n        // Resizing from left edge: reduce width to compensate for negative position\n        newWidth = Math.max(this.minWidth, newWidth + newX);\n      }\n      newX = 0;\n    }\n\n    // Top edge: position must be >= 0\n    if (newY < 0) {\n      if (event.edges.top) {\n        // Resizing from top edge: reduce height to compensate for negative position\n        newHeight = Math.max(this.minHeight, newHeight + newY);\n      }\n      newY = 0;\n    }\n\n    // Right edge: x + width must be <= containerWidth\n    if (newX + newWidth > containerWidth) {\n      // Limit width so right edge stays at container boundary\n      // This works for both left and right edge resizing\n      newWidth = Math.max(this.minWidth, containerWidth - newX);\n    }\n\n    // Bottom edge: y + height must be <= containerHeight\n    if (newY + newHeight > containerHeight) {\n      // Limit height so bottom edge stays at container boundary\n      // This works for both top and bottom edge resizing\n      newHeight = Math.max(this.minHeight, containerHeight - newY);\n    }\n\n    // Cancel any pending RAF from previous move event\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n\n    // Batch DOM updates with RAF (limits to ~60fps instead of ~200/sec)\n    this.resizeRafId = requestAnimationFrame(() => {\n      debug.log(\"🔵 RESIZE MOVE (RAF):\", {\n        edges: event.edges,\n        deltas: { deltaX, deltaY, deltaWidth, deltaHeight },\n        startRect: { ...this.startRect },\n        calculated: { newX, newY, newWidth, newHeight },\n      });\n\n      // Apply styles - smooth free-form resizing at 60fps max\n      event.target.style.transform = `translate(${newX}px, ${newY}px)`;\n      event.target.style.width = newWidth + \"px\";\n      event.target.style.height = newHeight + \"px\";\n\n      // Clear RAF ID after execution\n      this.resizeRafId = null;\n    });\n  }\n\n  /**\n   * Handle resize end event - finalize dimensions and update state\n   *\n   * **Critical responsibilities**:\n   * - Cancel pending RAF (prevent stale updates)\n   * - Grid snap position AND dimensions\n   * - Enforce boundary constraints\n   * - Convert viewport coordinates to container-relative\n   * - Update state (triggers single re-render)\n   *\n   * ## Processing Steps\n   *\n   * ### 1. RAF Cleanup\n   * Cancel any pending requestAnimationFrame to prevent stale updates after\n   * resize completes. Critical to avoid errors and ensure clean state.\n   *\n   * ### 2. Coordinate Conversion\n   * interact.js provides viewport coordinates (event.rect.left/top).\n   * Must convert to container-relative coordinates:\n   * ```\n   * containerRelativeX = viewportX - containerRect.left\n   * ```\n   *\n   * **Why conversion needed**:\n   * - CSS transform uses container-relative coordinates\n   * - event.rect uses viewport coordinates\n   * - Scrolled pages have different viewport vs container positions\n   *\n   * ### 3. Grid Snapping (Position AND Dimensions)\n   * Unlike drag, resize snaps BOTH position and dimensions:\n   * ```\n   * newX = Math.round(newX / gridSizeX) * gridSizeX\n   * newWidth = Math.round(newWidth / gridSizeX) * gridSizeX\n   * ```\n   *\n   * **Why snap dimensions**:\n   * - Ensures items align to grid cells\n   * - Prevents items spanning fractional grid units\n   * - Makes layouts predictable and clean\n   *\n   * ### 4. Boundary Constraints\n   * **Manual implementation** (interact.js restrictEdges breaks with deltaRect):\n   * ```\n   * newX = Math.max(0, newX);  // Left edge\n   * newX = Math.min(newX, containerWidth - itemWidth);  // Right edge\n   * ```\n   *\n   * **Why manual constraints**:\n   * - interact.js restrictEdges modifier conflicts with deltaRect\n   * - Manual constraints applied after grid snapping\n   * - Ensures final position respects canvas bounds\n   *\n   * ### 5. Mobile Layout Handling\n   * - Detects current viewport (desktop vs mobile)\n   * - Updates appropriate layout object\n   * - Marks mobile as \"customized\" when modified\n   * - Ensures mobile layouts don't auto-sync from desktop\n   *\n   * ### 6. State Persistence\n   * - Converts pixels to grid units\n   * - Updates item.layouts with new position and dimensions\n   * - Calls `onUpdate(item)` callback\n   * - Triggers single StencilJS re-render\n   * - Parent pushes undo/redo command\n   *\n   * ## Performance Characteristics\n   *\n   * **Total execution time**: ~5-10ms\n   * - RAF cancellation: ~0.01ms\n   * - Coordinate conversion: ~0.5ms\n   * - Grid snapping: ~1ms\n   * - Boundary checks: ~0.5ms\n   * - State update: ~3-5ms (single re-render)\n   *\n   * **Why this is acceptable**:\n   * - Only runs once at resize end (not 60fps)\n   * - User expects slight delay when releasing resize\n   * - Grid snapping provides visual feedback justifying delay\n   *\n   * ## Edge Cases Handled\n   *\n   * - Resize extending outside canvas → clamped to bounds\n   * - Minimum size violations → prevented by modifier\n   * - Position changes during resize (top/left handles) → preserved via deltaRect\n   * - Container not found → early exit (safety)\n   * - Mobile view → mark as customized\n   * - Pending RAF → cancelled before state update\n   * @param event - interact.js resize end event\n   * @example\n   * ```typescript\n   * // Example resize sequence (top-left handle):\n   * // 1. handleResizeStart: Store startRect (x=100, y=150, w=300, h=200)\n   * // 2. handleResizeMove (RAF batched): Apply deltaRect changes\n   * // 3. handleResizeEnd:\n   * //    - event.rect: {left: 525, top: 375, width: 350, height: 250} (viewport coords)\n   * //    - containerRect: {left: 475, top: 275} (viewport offset)\n   * //    - relativeX = 525 - 475 = 50px\n   * //    - relativeY = 375 - 275 = 100px\n   * //    - snappedX = round(50/20)*20 = 60px\n   * //    - gridX = 60/20 = 3 grid units\n   * //    - item.layouts.desktop.x = 3\n   * //    - onUpdate(item) → re-render + undo command\n   * ```\n   */\n  private handleResizeEnd(event: InteractResizeEvent): void {\n    // Cancel any pending frame\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n      this.resizeRafId = null;\n    }\n\n    event.target.classList.remove(\"resizing\");\n\n    // Explicitly stop the interaction to prevent it from continuing on mouse move\n    if (event.interaction && typeof event.interaction.stop === 'function') {\n      event.interaction.stop();\n    }\n\n    // Get the container to calculate relative position\n    const container = domCache.getCanvas(this.item.canvasId);\n    if (!container) {\n      return;\n    }\n\n    const containerRect = container.getBoundingClientRect();\n    const gridSizeX = getGridSizeHorizontal(this.item.canvasId, this.config);\n    const gridSizeY = getGridSizeVertical(this.config);\n\n    // Get final deltas from data attributes BEFORE cleaning them up (like drag-handler)\n    const deltaX = parseFloat(event.target.getAttribute(\"data-x\")) || 0;\n    const deltaY = parseFloat(event.target.getAttribute(\"data-y\")) || 0;\n    const deltaWidth = parseFloat(event.target.getAttribute(\"data-width\")) || 0;\n    const deltaHeight =\n      parseFloat(event.target.getAttribute(\"data-height\")) || 0;\n\n    // Clean up data attributes AFTER reading them\n    event.target.removeAttribute(\"data-x\");\n    event.target.removeAttribute(\"data-y\");\n    event.target.removeAttribute(\"data-width\");\n    event.target.removeAttribute(\"data-height\");\n\n    // Calculate final position and size from base + deltas\n    let newX = this.startRect.x + deltaX;\n    let newY = this.startRect.y + deltaY;\n    let newWidth = this.startRect.width + deltaWidth;\n    let newHeight = this.startRect.height + deltaHeight;\n\n    debug.log(\"🔴 RESIZE END:\", {\n      edges: event.edges,\n      eventRect: {\n        left: event.rect.left,\n        top: event.rect.top,\n        width: event.rect.width,\n        height: event.rect.height,\n      },\n      containerRect: { left: containerRect.left, top: containerRect.top },\n      beforeSnap: { newX, newY, newWidth, newHeight },\n      gridSize: { gridSizeX, gridSizeY },\n      startRect: { ...this.startRect },\n      lastCalculated: { ...this.lastCalculated },\n    });\n\n    // Grid snap AFTER user releases mouse (not during resize)\n    // Use directional rounding based on resize direction to prevent snap-back\n    // If user made item bigger, round UP. If smaller, round DOWN.\n\n    // Width: directional rounding based on whether user grew or shrunk\n    if (newWidth > this.startRect.width) {\n      // User made it wider → round UP to next grid cell\n      newWidth = Math.ceil(newWidth / gridSizeX) * gridSizeX;\n    } else if (newWidth < this.startRect.width) {\n      // User made it narrower → round DOWN to previous grid cell\n      newWidth = Math.floor(newWidth / gridSizeX) * gridSizeX;\n    } else {\n      // No change → keep original (round normally)\n      newWidth = Math.round(newWidth / gridSizeX) * gridSizeX;\n    }\n    // Ensure grid snapping doesn't violate minimum size\n    newWidth = Math.max(this.minWidth, newWidth);\n\n    // Height: directional rounding based on whether user grew or shrunk\n    if (newHeight > this.startRect.height) {\n      // User made it taller → round UP to next grid cell\n      newHeight = Math.ceil(newHeight / gridSizeY) * gridSizeY;\n    } else if (newHeight < this.startRect.height) {\n      // User made it shorter → round DOWN to previous grid cell\n      newHeight = Math.floor(newHeight / gridSizeY) * gridSizeY;\n    } else {\n      // No change → keep original\n      newHeight = Math.round(newHeight / gridSizeY) * gridSizeY;\n    }\n    // Ensure grid snapping doesn't violate minimum size\n    newHeight = Math.max(this.minHeight, newHeight);\n\n    // Position: directional rounding for top/left edge resizes\n    if (newX < this.startRect.x) {\n      // User moved left edge left → round DOWN (move further left to grid)\n      newX = Math.floor(newX / gridSizeX) * gridSizeX;\n    } else if (newX > this.startRect.x) {\n      // User moved left edge right → round UP (move further right to grid)\n      newX = Math.ceil(newX / gridSizeX) * gridSizeX;\n    } else {\n      newX = Math.round(newX / gridSizeX) * gridSizeX;\n    }\n\n    if (newY < this.startRect.y) {\n      // User moved top edge up → round DOWN (move further up to grid)\n      newY = Math.floor(newY / gridSizeY) * gridSizeY;\n    } else if (newY > this.startRect.y) {\n      // User moved top edge down → round UP (move further down to grid)\n      newY = Math.ceil(newY / gridSizeY) * gridSizeY;\n    } else {\n      newY = Math.round(newY / gridSizeY) * gridSizeY;\n    }\n\n    debug.log(\"  afterDirectionalSnap:\", { newX, newY, newWidth, newHeight });\n\n    // Apply min/max size constraints AFTER grid snapping\n    // This ensures the final size respects component constraints\n    // IMPORTANT: When clamping, adjust position if resizing from top/left edges\n    const originalWidth = newWidth;\n    const originalHeight = newHeight;\n\n    newWidth = Math.max(this.minWidth, Math.min(this.maxWidth, newWidth));\n    newHeight = Math.max(this.minHeight, Math.min(this.maxHeight, newHeight));\n\n    // If width was clamped and we're resizing from the left edge, adjust x position\n    if (originalWidth !== newWidth && event.edges.left) {\n      const widthDiff = originalWidth - newWidth;\n      newX += widthDiff;\n    }\n\n    // If height was clamped and we're resizing from the top edge, adjust y position\n    if (originalHeight !== newHeight && event.edges.top) {\n      const heightDiff = originalHeight - newHeight;\n      newY += heightDiff;\n    }\n\n    debug.log(\"  afterMinMaxClamp:\", { newX, newY, newWidth, newHeight });\n\n    // COMPREHENSIVE BOUNDARY CONSTRAINT CHECK\n    // =========================================\n    // Ensure all 4 corners of the component stay within canvas bounds.\n    // Priority: shrink if too large, then move if position is outside.\n\n    const canvasWidth = container.clientWidth;\n    const canvasHeight = container.clientHeight;\n\n    debug.log(\"  canvasBounds:\", { canvasWidth, canvasHeight });\n\n    // 1. HORIZONTAL BOUNDS CHECK\n    // ---------------------------\n    // If component is wider than canvas, shrink it to fit\n    if (newWidth > canvasWidth) {\n      debug.log(\n        \"  ⚠️ Width exceeds canvas, shrinking from\",\n        newWidth,\n        \"to\",\n        canvasWidth,\n      );\n      newWidth = canvasWidth;\n    }\n\n    // Ensure left edge is within bounds (x >= 0)\n    if (newX < 0) {\n      debug.log(\n        \"  ⚠️ Left edge outside canvas, moving from x =\",\n        newX,\n        \"to x = 0\",\n      );\n      newX = 0;\n    }\n\n    // Ensure right edge is within bounds (x + width <= canvasWidth)\n    if (newX + newWidth > canvasWidth) {\n      if (event.edges && event.edges.right) {\n        // Resizing from RIGHT edge: clamp width to fit, keep position\n        const maxWidth = canvasWidth - newX;\n        debug.log(\n          \"  ⚠️ Right edge overflow (resizing from right), clamping width from\",\n          newWidth,\n          \"to\",\n          maxWidth,\n        );\n        newWidth = Math.max(this.minWidth, maxWidth);\n      } else {\n        // Not resizing from right (dragging or resizing from left): move left to fit\n        const requiredX = canvasWidth - newWidth;\n        debug.log(\n          \"  ⚠️ Right edge outside canvas, moving from x =\",\n          newX,\n          \"to x =\",\n          requiredX,\n        );\n        newX = requiredX;\n\n        // If still doesn't fit (requiredX < 0), shrink width\n        if (newX < 0) {\n          debug.log(\n            \"  ⚠️ Cannot fit by moving, shrinking width to\",\n            canvasWidth,\n          );\n          newWidth = canvasWidth;\n          newX = 0;\n        }\n      }\n    }\n\n    // 2. VERTICAL BOUNDS CHECK\n    // -------------------------\n    // If component is taller than canvas, shrink it to fit\n    if (newHeight > canvasHeight) {\n      debug.log(\n        \"  ⚠️ Height exceeds canvas, shrinking from\",\n        newHeight,\n        \"to\",\n        canvasHeight,\n      );\n      newHeight = canvasHeight;\n    }\n\n    // Ensure top edge is within bounds (y >= 0)\n    if (newY < 0) {\n      debug.log(\n        \"  ⚠️ Top edge outside canvas, moving from y =\",\n        newY,\n        \"to y = 0\",\n      );\n      newY = 0;\n    }\n\n    // Ensure bottom edge is within bounds (y + height <= canvasHeight)\n    if (newY + newHeight > canvasHeight) {\n      if (event.edges && event.edges.bottom) {\n        // Resizing from BOTTOM edge: clamp height to fit, keep Y position\n        const maxHeight = canvasHeight - newY;\n        debug.log(\n          \"  ⚠️ Bottom edge overflow (resizing from bottom), clamping height from\",\n          newHeight,\n          \"to\",\n          maxHeight,\n        );\n        newHeight = Math.max(this.minHeight, maxHeight);\n      } else {\n        // Not resizing from bottom (dragging or resizing from top): move up to fit\n        const requiredY = canvasHeight - newHeight;\n        debug.log(\n          \"  ⚠️ Bottom edge outside canvas, moving from y =\",\n          newY,\n          \"to y =\",\n          requiredY,\n        );\n        newY = requiredY;\n\n        // If still doesn't fit (requiredY < 0), shrink height\n        if (newY < 0) {\n          debug.log(\n            \"  ⚠️ Cannot fit by moving, shrinking height to\",\n            canvasHeight,\n          );\n          newHeight = canvasHeight;\n          newY = 0;\n        }\n      }\n    }\n\n    debug.log(\"  afterBoundaryCheck:\", { newX, newY, newWidth, newHeight });\n\n    // Apply final snapped position\n    event.target.style.transform = `translate(${newX}px, ${newY}px)`;\n    event.target.style.width = newWidth + \"px\";\n    event.target.style.height = newHeight + \"px\";\n\n    debug.log(\"  appliedToDOM:\", {\n      transform: `translate(${newX}px, ${newY}px)`,\n      width: `${newWidth}px`,\n      height: `${newHeight}px`,\n    });\n\n    // IMPORTANT: Get latest item from state to preserve any config changes\n    // that occurred during resize (e.g., backgroundColor changes)\n    const canvas = this.state.canvases[this.item.canvasId];\n    const latestItem = canvas?.items.find((i) => i.id === this.item.id);\n    const itemToUpdate = latestItem || this.item; // Fallback to stored item if not found\n\n    // Update item size and position in current viewport's layout (convert to grid units)\n    const currentViewport = this.state.currentViewport || \"desktop\";\n    const layout =\n      itemToUpdate.layouts[currentViewport as \"desktop\" | \"mobile\"];\n\n    layout.width = pixelsToGridX(newWidth, itemToUpdate.canvasId, this.config);\n    layout.height = pixelsToGridY(newHeight, this.config);\n    layout.x = pixelsToGridX(newX, itemToUpdate.canvasId, this.config);\n    layout.y = pixelsToGridY(newY, this.config);\n\n    debug.log(\"  finalGridUnits:\", {\n      x: layout.x,\n      y: layout.y,\n      width: layout.width,\n      height: layout.height,\n    });\n    debug.log(\"---\");\n\n    // If in mobile view, mark as customized\n    if (currentViewport === \"mobile\") {\n      itemToUpdate.layouts.mobile.customized = true;\n    }\n\n    // End performance tracking\n    if (window.perfMonitor) {\n      window.perfMonitor.endOperation(\"resize\");\n    }\n\n    // Trigger StencilJS update (single re-render at end)\n    this.onUpdate(itemToUpdate);\n  }\n}\n","/**\n * Grid Item Wrapper Styles\n * =========================\n *\n * Styles for grid-item-wrapper component with drag/resize handles.\n */\n\n/**\n * Screen Reader Only (sr-only)\n * =============================\n *\n * Standard accessibility pattern to hide content visually\n * while keeping it accessible to screen readers.\n *\n * **Use Cases**:\n * - ARIA description text for grid items\n * - Contextual hints for keyboard navigation\n * - Screen reader announcements\n *\n * **Technique**:\n * - Positioned off-screen instead of display:none\n * - display:none would hide from screen readers too\n * - clip prevents visual rendering\n *\n * **WCAG Compliance**: 1.3.1 Info and Relationships (Level A)\n */\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n/* Grid Item */\n.grid-item {\n  position: absolute;\n  box-sizing: border-box; /* Include padding and border in width/height */\n  /* Note: min-width/min-height removed - resize-handler.ts enforces minimums via JavaScript */\n  /* This allows component-specific minSize from componentDefinition to work correctly */\n  padding: 0; /* No padding - components fill edge-to-edge */\n  border: none; /* No border - use outline instead to avoid layout space */\n  border-radius: 0; /* No border radius - components control their own borders */\n  background: transparent; /* No background - components render flush with their own backgrounds */\n  box-shadow: none; /* No shadow - components control their own shadows */\n  outline: 2px solid transparent; /* Use outline for hover - doesn't affect layout */\n  outline-offset: -2px; /* Draw inside the element */\n  cursor: default;\n  transition: outline-color 0.2s, box-shadow 0.2s;\n  will-change: transform; /* GPU acceleration hint */\n  touch-action: none; /* Prevent default touch behaviors (scrolling, zooming) for drag/resize */\n  container-type: inline-size; /* Enable container queries for child components */\n\n  /* Default selection color (can be overridden per component type) */\n  --selection-color: #f59e0b;\n}\n\n/**\n * Smooth animations for drag/resize operations\n * ==============================================\n *\n * When enabled via config.enableAnimations, this class adds smooth CSS transitions\n * for transform (position) and width/height properties.\n *\n * **When applied**:\n * - Automatically added if config.enableAnimations is true\n * - Temporarily removed during drag/resize for instant feedback\n * - Reapplied at drag/resize end for smooth grid snapping\n *\n * **Performance**:\n * - Uses GPU-accelerated CSS transforms\n * - Negligible performance impact (~0.1ms per frame)\n * - Transition duration controlled by --animation-duration CSS variable\n *\n * **CSS Variable**:\n * - --animation-duration: Set via config.animationDuration (default: 100ms)\n */\n.grid-item.with-animations {\n  transition:\n    border-color 0.2s,\n    box-shadow 0.2s,\n    transform var(--animation-duration, 200ms) ease-out,\n    width var(--animation-duration, 200ms) ease-out,\n    height var(--animation-duration, 200ms) ease-out;\n}\n\n/**\n * Disable animations during active drag/resize\n * =============================================\n *\n * During drag/resize, we want instant feedback without animation delay.\n * This class is added during drag/resize and removes all transitions.\n */\n.grid-item.dragging,\n.grid-item.resizing {\n  transition: none !important;\n}\n\n.grid-item:hover {\n  outline-color: var(--selection-color);\n}\n\n/* Disable hover styles in viewer mode */\n.grid-item[data-viewer-mode=\"true\"]:hover {\n  outline-color: transparent;\n}\n\n.grid-item.selected {\n  /* Use outline instead of border to avoid layout shifts */\n  outline: 3px solid var(--selection-color);\n  outline-offset: -3px; /* Draw outline inside the element */\n  box-shadow:\n    0 0 0 3px color-mix(in srgb, var(--selection-color) 20%, transparent),\n    0 4px 12px color-mix(in srgb, var(--selection-color) 30%, transparent);\n  /* Add outer glow ring + shadow for clear visual distinction */\n}\n\n/* Disable selection styles in viewer mode */\n.grid-item[data-viewer-mode=\"true\"].selected {\n  /* No padding - components fill edge-to-edge in viewer mode too */\n  outline: 2px solid transparent;\n  outline-offset: -2px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 10%);\n}\n\n.grid-item.dragging {\n  cursor: move;\n  opacity: 0.7;\n}\n\n.grid-item.resizing {\n  user-select: none;\n}\n\n/* Item Header - tab on selection border that only shows when selected */\n.grid-item-header {\n  position: absolute;\n  z-index: 100; /* Above resize handles by default */\n  top: -26px; /* Position above the border (adjust based on content height) */\n  left: 12px; /* Offset from left edge */\n  display: flex;\n  align-items: center;\n  padding: 4px 10px;\n  border: 2px solid var(--selection-color);\n  border-radius: 4px 4px 0 0; /* Rounded top corners only */\n  border-bottom: none; /* No bottom border to connect with component border */\n  background: var(--selection-color);\n  color: white;\n  cursor: move !important; /* Indicate draggability - force override */\n  font-size: 11px;\n  font-weight: 600;\n  gap: 6px;\n  letter-spacing: 0.3px;\n  opacity: 0; /* Visual hiding only */\n  pointer-events: auto; /* Always interactive for interact.js */\n  transition: opacity 0.2s;\n  user-select: none; /* Prevent text selection while dragging */\n  touch-action: none; /* Enable touch dragging on mobile/tablet */\n}\n\n.grid-item.selected .grid-item-header,\n.grid-item:hover .grid-item-header {\n  opacity: 1;\n}\n\n/* Adjust for thicker border when selected */\n.grid-item.selected .grid-item-header {\n  top: -27px; /* Adjust for 3px border instead of 2px */\n  border: 3px solid var(--selection-color);\n  border-bottom: none;\n  z-index: 9999; /* Elevated z-index for selected component only */\n}\n\n/* Item Content */\n.grid-item-content {\n  width: 100%; /* Fill horizontal space */\n  height: 100%; /* Fill vertical space */\n  margin: 0; /* Remove any default margins */\n  padding: 0; /* Remove any default padding */\n  overflow: hidden;\n  color: #666;\n  font-size: 13px;\n  box-sizing: border-box; /* Include padding/border in dimensions */\n}\n\n/* Component Wrapper - Stencil wrapper for HTMLElement components */\n.component-wrapper {\n  width: 100%;\n  height: 100%;\n  margin: 0; /* Remove any default margins */\n  padding: 0; /* Remove any default padding */\n  box-sizing: border-box;\n}\n\n.component-placeholder,\n.component-error {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  align-items: center;\n  justify-content: center;\n  padding: 16px;\n  font-size: 12px;\n  text-align: center;\n  gap: 8px;\n}\n\n.component-placeholder {\n  color: #999;\n  font-style: italic;\n}\n\n.component-error {\n  color: #dc3545; // Bootstrap danger red\n  background: #fff3f3; // Subtle pink background\n  border: 1px dashed #dc3545;\n  border-radius: 4px;\n  font-weight: 500;\n\n  // Provide helpful context for developers\n  &::before {\n    content: \"⚠️\";\n    font-size: 24px;\n    display: block;\n  }\n}\n\n/* Item Controls */\n.grid-item-controls {\n  position: absolute;\n  z-index: 10; /* Above item content by default */\n  top: -16px; /* Float above the component */\n  right: 8px;\n  display: flex;\n  gap: 4px;\n  opacity: 0;\n  transition: opacity 0.2s;\n}\n\n.grid-item.selected .grid-item-controls,\n.grid-item:hover .grid-item-controls {\n  opacity: 1;\n}\n\n.grid-item.selected .grid-item-controls {\n  top: -16px; /* Keep floating above even with thicker border */\n  right: 8px;\n  z-index: 9999; /* Elevated z-index for selected component only */\n}\n\n.grid-item-control-btn {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  border-radius: 4px;\n  background: #4a90e2;\n  color: white;\n  cursor: pointer;\n  font-size: 12px;\n  line-height: 1;\n  transition: background 0.2s;\n}\n\n.grid-item-control-btn:hover {\n  background: #357abd;\n}\n\n.grid-item-delete {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  border-radius: 50%;\n  background: #f44;\n  color: white;\n  cursor: pointer;\n  font-size: 14px;\n  line-height: 1;\n  transition: background 0.2s;\n}\n\n.grid-item-delete:hover {\n  background: #c00;\n}\n\n/* Drag Handle - Hidden, drag functionality moved to header */\n.drag-handle {\n  display: none;\n}\n\n/* Resize Handles - Circular corners and pill-shaped sides */\n.resize-handle {\n  position: absolute;\n  z-index: 10; /* Above item content by default */\n  width: 14px;\n  height: 14px;\n  border: 2px solid white;\n  border-radius: 50%;\n  background: var(--selection-color);\n  box-shadow: 0 0 4px rgba(0, 0, 0, 40%);\n  opacity: 0;\n  transition: opacity 0.2s, transform 0.2s;\n  touch-action: none; /* Enable touch resizing on mobile/tablet */\n}\n\n.resize-handle:hover {\n  transform: scale(1.2);\n}\n\n.grid-item.selected .resize-handle,\n.grid-item:hover .resize-handle {\n  opacity: 1;\n}\n\n/* Elevate resize handles z-index for selected component only */\n.grid-item.selected .resize-handle {\n  z-index: 9999; /* Elevated z-index for selected component only */\n}\n\n.resize-handle.nw {\n  top: -7px;\n  left: -7px;\n  cursor: nw-resize;\n}\n\n.resize-handle.ne {\n  top: -7px;\n  right: -7px;\n  cursor: ne-resize;\n}\n\n.resize-handle.sw {\n  bottom: -7px;\n  left: -7px;\n  cursor: sw-resize;\n}\n\n.resize-handle.se {\n  right: -7px;\n  bottom: -7px;\n  cursor: se-resize;\n}\n\n.resize-handle.n {\n  top: -7px;\n  left: 50%;\n  width: 30px;\n  height: 6px;\n  border-radius: 3px; /* Fully rounded pill ends (half of height) */\n  cursor: n-resize;\n  transform: translateX(-50%);\n}\n\n.resize-handle.s {\n  bottom: -7px;\n  left: 50%;\n  width: 30px;\n  height: 6px;\n  border-radius: 3px; /* Fully rounded pill ends (half of height) */\n  cursor: s-resize;\n  transform: translateX(-50%);\n}\n\n.resize-handle.e {\n  top: 50%;\n  right: -7px;\n  width: 6px;\n  height: 30px;\n  border-radius: 3px; /* Fully rounded pill ends (half of width) */\n  cursor: e-resize;\n  transform: translateY(-50%);\n}\n\n.resize-handle.w {\n  top: 50%;\n  left: -7px;\n  width: 6px;\n  height: 30px;\n  border-radius: 3px; /* Fully rounded pill ends (half of width) */\n  cursor: w-resize;\n  transform: translateY(-50%);\n}\n\n/* Compensate resize handles for thicker border when selected */\n.grid-item.selected .resize-handle.nw,\n.grid-item.selected .resize-handle.n,\n.grid-item.selected .resize-handle.ne {\n  top: -8px; /* -7px - 1px for thicker border */\n}\n\n.grid-item.selected .resize-handle.sw,\n.grid-item.selected .resize-handle.s,\n.grid-item.selected .resize-handle.se {\n  bottom: -8px; /* -7px - 1px for thicker border */\n}\n\n.grid-item.selected .resize-handle.nw,\n.grid-item.selected .resize-handle.w,\n.grid-item.selected .resize-handle.sw {\n  left: -8px; /* -7px - 1px for thicker border */\n}\n\n.grid-item.selected .resize-handle.ne,\n.grid-item.selected .resize-handle.e,\n.grid-item.selected .resize-handle.se {\n  right: -8px; /* -7px - 1px for thicker border */\n}\n\n/* Hide resize handles when dimension is disabled (min == max) */\n/* Hide horizontal handles (left, right, and corners) when width resize is disabled */\n.grid-item.resize-width-disabled .resize-handle.w,\n.grid-item.resize-width-disabled .resize-handle.e,\n.grid-item.resize-width-disabled .resize-handle.nw,\n.grid-item.resize-width-disabled .resize-handle.ne,\n.grid-item.resize-width-disabled .resize-handle.sw,\n.grid-item.resize-width-disabled .resize-handle.se {\n  display: none;\n}\n\n/* Hide vertical handles (top, bottom) when height resize is disabled */\n.grid-item.resize-height-disabled .resize-handle.n,\n.grid-item.resize-height-disabled .resize-handle.s {\n  display: none;\n}\n\n/* ========================================\n * Click-to-Add Component Animation\n * ========================================\n * Pulse animation on selection outline when components are added via click-to-add.\n * Component appears instantly; selection outline stays visible but pulses from\n * 2px to 6px glow to draw attention. This prevents the confusing \"flash in/out/in\"\n * effect of fading the entire component.\n */\n\n/* Component Pulse Animation - Only pulses selection outline, not content */\n@keyframes component-animate-in {\n  0%, 100% {\n    outline-color: var(--selection-color);\n    box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.5);\n  }\n  50% {\n    outline-color: var(--selection-color);\n    box-shadow: 0 0 0 6px rgba(74, 144, 226, 0.7);\n  }\n}\n\n.component-animate-in {\n  animation: component-animate-in 600ms ease-out;\n  outline-color: var(--selection-color); /* Show selection during animation */\n}\n","/**\n * Grid Item Wrapper Component (Library Version)\n * ===============================================\n *\n * Individual grid item container with dynamic component rendering from registry.\n * This is the library version that uses ComponentDefinition.render() for flexibility.\n *\n * ## Key Differences from POC\n *\n * **Dynamic component rendering**:\n * - POC: Hardcoded switch statement with 8 component types\n * - Library: Uses ComponentDefinition.render() from component registry\n * - Consumer defines all component types\n * - Library just calls the render function\n *\n * **Removed POC-specific**:\n * - componentTemplates import (hardcoded component data)\n * - Fixed component type switch statement\n * - Hardcoded icon/title from templates\n *\n * **Added library features**:\n * - Component registry lookup\n * - Fallback for unknown component types\n * - Pass GridConfig to grid calculations\n * @module grid-item-wrapper\n */\n\nimport { Component, h, Listen, Prop, State, Watch } from \"@stencil/core\";\n\n// Internal imports\nimport {\n  GridItem,\n  gridState,\n  updateItem,\n  setActiveCanvas,\n} from \"../../services/state-manager\";\nimport { pushCommand } from \"../../services/undo-redo\";\nimport { MoveItemCommand } from \"../../services/undo-redo-commands\";\nimport {\n  VirtualRendererService,\n  virtualRenderer,\n} from \"../../services/virtual-renderer\";\nimport { EventManager, eventManager } from \"../../services/event-manager\";\nimport { DragHandler } from \"../../utils/drag-handler\";\nimport { ResizeHandler } from \"../../utils/resize-handler\";\nimport { gridToPixelsX, gridToPixelsY } from \"../../utils/grid-calculations\";\nimport { GridConfig } from \"../../types/grid-config\";\nimport { ComponentDefinition } from \"../../types/component-definition\";\nimport { createDebugLogger } from \"../../utils/debug\";\n\nconst debug = createDebugLogger(\"grid-item-wrapper\");\n\n/**\n * GridItemWrapper Component\n * ==========================\n *\n * Library component wrapping individual grid items with drag/resize/selection.\n *\n * **Tag**: `<grid-item-wrapper>`\n * **Shadow DOM**: Disabled (required for interact.js compatibility)\n * **Dynamic rendering**: Uses ComponentDefinition.render() from registry\n */\n@Component({\n  tag: \"grid-item-wrapper\",\n  styleUrl: \"grid-item-wrapper.scss\",\n  shadow: false,\n})\nexport class GridItemWrapper {\n  /**\n   * Grid item data (position, size, type, etc.)\n   *\n   * **Source**: Parent canvas-section component\n   * **Contains**: id, canvasId, type, name, layouts (desktop/mobile), zIndex, config\n   */\n  @Prop() item!: GridItem;\n\n  /**\n   * Render version (force re-render trigger)\n   *\n   * **Source**: Parent canvas-section (incremented on resize)\n   * **Purpose**: Force grid calculation refresh when container resizes\n   */\n  @Prop() renderVersion?: number;\n\n  /**\n   * Grid configuration options\n   *\n   * **Optional**: Customizes grid system behavior\n   * **Passed from**: grid-builder → canvas-section → grid-item-wrapper\n   * **Used for**: Grid size calculations with constraints\n   */\n  @Prop() config?: GridConfig;\n\n  /**\n   * Component registry (from parent grid-builder)\n   *\n   * **Source**: grid-builder component (built from components prop)\n   * **Structure**: Map<type, ComponentDefinition>\n   * **Purpose**: Look up component definitions for dynamic rendering\n   *\n   * **Note**: This is passed as a workaround since StencilJS doesn't have\n   * good support for context/provide-inject patterns. In a production app,\n   * consider using a global registry or context provider.\n   */\n  @Prop() componentRegistry?: Map<string, ComponentDefinition>;\n\n  /**\n   * Deletion hook (from parent grid-builder)\n   *\n   * **Source**: grid-builder component (from onBeforeDelete prop)\n   * **Purpose**: Allow host app to intercept deletion requests\n   *\n   * **Hook behavior**:\n   * - Called before deleting a component\n   * - Receives context with item data\n   * - Returns true/false or Promise<boolean>\n   * - If false, deletion is cancelled\n   * - If true, deletion proceeds\n   *\n   * **Default**: If not provided, components delete immediately\n   */\n  @Prop() onBeforeDelete?: (context: any) => boolean | Promise<boolean>;\n\n  /**\n   * Theme configuration (from parent grid-builder)\n   *\n   * **Source**: grid-builder → canvas-section → grid-item-wrapper\n   * **Purpose**: Access theme.selectionColor for component selection styling\n   *\n   * **Fallback chain for selection color**:\n   * 1. ComponentDefinition.selectionColor (per-component override)\n   * 2. theme.selectionColor (global theme default)\n   * 3. \"#f59e0b\" (hardcoded fallback - amber/gold)\n   *\n   * **Why passed**: grid-item-wrapper doesn't have access to global theme,\n   * so must be passed through component tree\n   */\n  @Prop() theme?: any;\n\n  /**\n   * Viewer mode flag\n   *\n   * **Purpose**: Disable editing features for rendering-only mode\n   * **Default**: false (editing enabled)\n   *\n   * **When true**:\n   * - ❌ No drag-and-drop handlers\n   * - ❌ No resize handles\n   * - ❌ No item header (drag handle)\n   * - ❌ No delete button\n   * - ❌ No selection state\n   * - ✅ Only renders component content\n   *\n   * **Use case**: grid-viewer component for display-only mode\n   */\n  @Prop() viewerMode?: boolean = false;\n\n  /**\n   * Current viewport (for viewer mode)\n   *\n   * **Purpose**: Determine which layout to render (desktop or mobile)\n   * **Source**: grid-viewer → canvas-section-viewer → grid-item-wrapper\n   * **Used by**: render() to select appropriate layout\n   *\n   * **Note**: When in builder mode (viewerMode=false), this is ignored\n   * and gridState.currentViewport is used instead. When in viewer mode\n   * (viewerMode=true), this prop is required.\n   */\n  @Prop() currentViewport?: \"desktop\" | \"mobile\";\n\n  /**\n   * Virtual renderer service instance (Phase 3: Instance-based architecture)\n   *\n   * **Optional prop**: Service instance for lazy loading\n   * **Default**: Falls back to singleton virtualRenderer if not provided\n   * **Source**: grid-builder → canvas-section → grid-item-wrapper\n   *\n   * **Purpose**: Support multiple grid-builder instances with isolated services\n   *\n   * **Migration strategy**:\n   * - Phase 3: Add as optional prop (this phase)\n   * - Phase 4: Remove singleton fallback and make required\n   */\n  @Prop() virtualRendererInstance?: VirtualRendererService;\n\n  /**\n   * Event manager service instance (Phase 3: Instance-based architecture)\n   *\n   * **Optional prop**: Service instance for event emission\n   * **Default**: Falls back to singleton eventManager if not provided\n   * **Source**: grid-builder → canvas-section → grid-item-wrapper\n   *\n   * **Purpose**: Support multiple grid-builder instances with isolated services\n   *\n   * **Migration strategy**:\n   * - Phase 3: Add as optional prop (this phase)\n   * - Phase 4: Remove singleton fallback and make required\n   */\n  @Prop() eventManagerInstance?: EventManager;\n\n  /**\n   * State manager instance (Phase 3: Instance-based architecture)\n   *\n   * **Optional prop**: Grid state instance for utilities\n   * **Default**: Falls back to singleton gridState if not provided\n   * **Source**: grid-builder → canvas-section → grid-item-wrapper\n   *\n   * **Purpose**: Support multiple grid-builder instances with isolated state\n   *\n   * **Migration strategy**:\n   * - Phase 3: Add as optional prop (this phase)\n   * - Phase 4: Remove singleton fallback and make required\n   *\n   * **Used by**: DragHandler, ResizeHandler for accessing canvases and viewport\n   */\n  @Prop() stateInstance?: any;\n\n  /**\n   * All items in the canvas (for viewer mode auto-layout)\n   *\n   * **Purpose**: Calculate mobile auto-layout positions\n   * **Source**: grid-viewer → canvas-section-viewer → grid-item-wrapper\n   * **Used by**: render() to calculate stacked positions in mobile viewport\n   *\n   * **Note**: When in builder mode (viewerMode=false), this is ignored\n   * and gridState.canvases is used instead. When in viewer mode\n   * (viewerMode=true), this prop is required for mobile auto-layout.\n   */\n  @Prop() canvasItems?: GridItem[];\n\n  /**\n   * Selection state (reactive)\n   *\n   * **Managed by**: updateComponentState()\n   * **Updated on**: componentWillLoad, componentWillUpdate\n   * **Triggers**: Visual selection styles (.selected class)\n   */\n  @State() isSelected: boolean = false;\n\n  /**\n   * Visibility state (virtual rendering)\n   *\n   * **Managed by**: IntersectionObserver callback\n   * **Initial value**: false (don't render content yet)\n   * **Triggered by**: Observer callback or manual check for initially-visible items\n   * **Controls**: Whether component content renders or placeholder shows\n   *\n   * **Note**: Virtual renderer checks if element is initially in viewport\n   * and triggers callback immediately to prevent \"Loading...\" on visible items.\n   * Off-screen items stay false until scrolled into view (virtual rendering).\n   */\n  @State() isVisible: boolean = false;\n\n  /**\n   * Item DOM element reference\n   */\n  private itemRef: HTMLElement;\n\n  /**\n   * Drag handler instance\n   */\n  private dragHandler: DragHandler;\n\n  /**\n   * Resize handler instance\n   */\n  private resizeHandler: ResizeHandler;\n\n  /**\n   * Item snapshot (for undo/redo)\n   */\n  private itemSnapshot: GridItem | null = null;\n\n  /**\n   * Track whether item was dragged (to prevent click event on drag end)\n   */\n  private wasDragged: boolean = false;\n\n  /**\n   * Component will load lifecycle hook\n   */\n  componentWillLoad() {\n    this.updateComponentState();\n\n    // Set initial visibility BEFORE first render\n    // When virtual rendering is disabled (e.g., Storybook), render immediately\n    if (this.config?.enableVirtualRendering === false) {\n      this.isVisible = true;\n    }\n    // When virtual rendering is enabled (default), isVisible starts as false\n    // and will be updated by IntersectionObserver callback in componentDidLoad\n  }\n\n  /**\n   * Component will update lifecycle hook\n   */\n  componentWillUpdate() {\n    this.updateComponentState();\n  }\n\n  /**\n   * Update component state (selection and snapshot)\n   */\n  private updateComponentState() {\n    // Update selection state (use instance state if available, fall back to global)\n    const selectedItemId = this.stateInstance?.selectedItemId || gridState.selectedItemId;\n    this.isSelected = selectedItemId === this.item.id;\n\n    // Capture item snapshot for undo/redo\n    this.captureItemSnapshot();\n  }\n\n  /**\n   * Component did load lifecycle hook\n   */\n  componentDidLoad() {\n    // Set up virtual rendering observer (both builder and viewer modes)\n    // Virtual rendering improves performance for long pages with many components\n    // Can be disabled via config for Storybook or testing scenarios\n    //\n    // IMPORTANT: Defer observer setup to avoid state change during componentDidLoad()\n    // The IntersectionObserver callback fires immediately if the element is in viewport,\n    // which would cause a state change and trigger Stencil warning about extra re-renders.\n    // Using requestAnimationFrame defers setup until after lifecycle completes.\n    requestAnimationFrame(() => {\n      if (this.config?.enableVirtualRendering !== false) {\n        // Virtual rendering enabled (default behavior)\n        (this.virtualRendererInstance || virtualRenderer).observe(this.itemRef, this.item.id, (isVisible) => {\n          this.isVisible = isVisible;\n        });\n      } else {\n        // Virtual rendering disabled - render immediately\n        this.isVisible = true;\n      }\n    });\n\n    // Inject component content into custom wrapper's content slot if needed\n    this.injectComponentContent();\n\n    // Skip drag/resize handlers in viewer mode\n    if (!this.viewerMode) {\n      // Get component definition for min/max size constraints\n      const componentDefinition = this.componentRegistry?.get(this.item.type);\n\n      // Get the header element for drag handler\n      const headerElement = this.itemRef.querySelector(\n        \".grid-item-header\",\n      ) as HTMLElement;\n\n      // Initialize drag and resize handlers\n      // Pass header element for drag (instead of whole item)\n      this.dragHandler = new DragHandler(\n        this.itemRef,\n        this.item,\n        this.stateInstance || gridState,\n        this.handleItemUpdate,\n        this.config,\n        headerElement,\n        () => {\n          this.wasDragged = true;\n        },\n      );\n      this.resizeHandler = new ResizeHandler(\n        this.itemRef,\n        this.item,\n        this.stateInstance || gridState,\n        this.handleItemUpdate,\n        componentDefinition,\n        this.config,\n      );\n    }\n  }\n\n  /**\n   * Component did update lifecycle hook\n   */\n  componentDidUpdate() {\n    // Re-inject component content if custom wrapper re-rendered\n    this.injectComponentContent();\n  }\n\n  /**\n   * Inject component content into custom wrapper's content slot\n   *\n   * **Purpose**: For custom wrappers, find the content slot div and inject component\n   * **Called from**: componentDidLoad, componentDidUpdate\n   * **Why needed**: Custom wrapper JSX renders, then we inject content into its slot\n   */\n  private injectComponentContent() {\n    // Only for custom wrappers\n    const definition = this.componentRegistry?.get(this.item.type);\n    if (!definition?.renderItemWrapper || !this.itemRef) return;\n\n    // Find the content slot\n    const contentSlotId = `${this.item.id}-content`;\n    const contentSlot = this.itemRef.querySelector(`#${contentSlotId}`);\n    if (!contentSlot) return;\n\n    // Check if already injected\n    if (contentSlot.hasAttribute(\"data-content-injected\")) return;\n\n    // Render and inject component content\n    const componentContent = this.renderComponent();\n\n    // Clear any existing content\n    contentSlot.innerHTML = \"\";\n\n    if (componentContent instanceof HTMLElement) {\n      contentSlot.appendChild(componentContent);\n    } else {\n      // For Stencil vNodes, we need to use a workaround\n      // Create a temporary container and let Stencil render into it\n      const tempContainer = document.createElement(\"div\");\n      contentSlot.appendChild(tempContainer);\n\n      // This is a limitation - vNodes can't be manually appended\n      // The custom wrapper should handle rendering the component directly\n      // For now, we'll just set a placeholder\n      tempContainer.textContent = \"[Component Content]\";\n    }\n\n    // Mark as injected\n    contentSlot.setAttribute(\"data-content-injected\", \"true\");\n  }\n\n  /**\n   * Disconnected callback (cleanup)\n   */\n  disconnectedCallback() {\n    // Cleanup handlers\n    if (this.dragHandler) {\n      this.dragHandler.destroy();\n    }\n    if (this.resizeHandler) {\n      this.resizeHandler.destroy();\n    }\n\n    // Cleanup virtual renderer\n    if (this.itemRef) {\n      (this.virtualRendererInstance || virtualRenderer).unobserve(this.itemRef, this.item.id);\n    }\n  }\n\n  /**\n   * Watch for item prop changes\n   *\n   * **When triggered**: Parent passes updated item data\n   * **Actions**:\n   * - Update component state (selection, snapshot)\n   * - Reinitialize drag/resize handlers with new item data\n   * - Preserve handlers if already initialized\n   */\n  @Watch(\"item\")\n  handleItemChange(newItem: GridItem, oldItem: GridItem) {\n    // Skip if item reference hasn't actually changed\n    if (newItem === oldItem) return;\n\n    debug.log(\"📦 Item prop changed:\", {\n      itemId: newItem.id,\n      oldId: oldItem?.id,\n    });\n\n    // Update component state\n    this.updateComponentState();\n\n    // Update drag/resize handlers with new item data\n    if (!this.viewerMode && this.dragHandler && this.resizeHandler) {\n      // Handlers are already initialized, they'll use the updated this.item reference\n      // No need to destroy and recreate - they reference this.item internally\n      debug.log(\"  ✅ Handlers updated with new item reference\");\n    }\n  }\n\n  /**\n   * Watch for renderVersion prop changes\n   *\n   * **When triggered**: Parent increments renderVersion (e.g., on container resize)\n   * **Purpose**: Force component re-render to recalculate grid positions\n   * **Note**: This is a force-update mechanism, actual recalculation happens in render()\n   */\n  @Watch(\"renderVersion\")\n  handleRenderVersionChange(newVersion: number, oldVersion: number) {\n    // Skip if version hasn't changed (undefined → undefined)\n    if (newVersion === oldVersion) return;\n\n    debug.log(\"🔄 RenderVersion changed:\", {\n      oldVersion,\n      newVersion,\n      itemId: this.item.id,\n    });\n\n    // No action needed - the prop change itself triggers re-render\n    // Grid calculations will be re-executed in render()\n  }\n\n  /**\n   * Watch for config prop changes\n   *\n   * **When triggered**: Parent passes updated GridConfig\n   * **Actions**: Reinitialize drag/resize handlers with new config\n   * **Note**: Config changes are rare (e.g., user changes grid settings)\n   */\n  @Watch(\"config\")\n  handleConfigChange(newConfig: GridConfig, oldConfig: GridConfig) {\n    // Skip if config reference hasn't changed\n    if (newConfig === oldConfig) return;\n\n    debug.log(\"⚙️ Config prop changed:\", {\n      itemId: this.item.id,\n      oldConfig,\n      newConfig,\n    });\n\n    // Reinitialize handlers with new config\n    if (!this.viewerMode && this.itemRef) {\n      // Cleanup old handlers\n      if (this.dragHandler) {\n        this.dragHandler.destroy();\n      }\n      if (this.resizeHandler) {\n        this.resizeHandler.destroy();\n      }\n\n      // Recreate handlers with new config\n      const componentDefinition = this.componentRegistry?.get(this.item.type);\n      const headerElement = this.itemRef.querySelector(\n        \".grid-item-header\",\n      ) as HTMLElement;\n\n      this.dragHandler = new DragHandler(\n        this.itemRef,\n        this.item,\n        this.stateInstance || gridState,\n        this.handleItemUpdate,\n        newConfig,\n        headerElement,\n        () => {\n          this.wasDragged = true;\n        },\n      );\n      this.resizeHandler = new ResizeHandler(\n        this.itemRef,\n        this.item,\n        this.stateInstance || gridState,\n        this.handleItemUpdate,\n        componentDefinition,\n        newConfig,\n      );\n\n      debug.log(\"  ✅ Handlers reinitialized with new config\");\n    }\n  }\n\n  /**\n   * Watch for currentViewport prop changes (viewer mode only)\n   *\n   * **When triggered**: Viewport switches between desktop/mobile in viewer mode\n   * **Purpose**: Force re-render to use appropriate layout\n   * **Note**: Only relevant in viewerMode=true\n   */\n  @Watch(\"currentViewport\")\n  handleViewportChange(\n    newViewport: \"desktop\" | \"mobile\",\n    oldViewport: \"desktop\" | \"mobile\",\n  ) {\n    // Skip if viewport hasn't changed\n    if (newViewport === oldViewport) return;\n\n    // Only relevant in viewer mode\n    if (!this.viewerMode) return;\n\n    debug.log(\"📱 Viewport prop changed (viewer mode):\", {\n      oldViewport,\n      newViewport,\n      itemId: this.item.id,\n    });\n\n    // No action needed - the prop change itself triggers re-render\n    // render() will use the new viewport to select layout\n  }\n\n  /**\n   * Listen for item-delete events from custom wrapper components\n   * This is the PUBLIC API for custom wrappers to request item deletion\n   * We intercept these and re-dispatch as internal 'grid-item:delete' events\n   */\n  @Listen(\"item-delete\")\n  handleItemDeleteEvent(event: CustomEvent) {\n    debug.log(\"🔴 @Listen(item-delete) - from custom wrapper\", {\n      eventTarget: event.target,\n      itemId: this.item.id,\n    });\n\n    // Stop the public event from bubbling\n    event.stopPropagation();\n\n    // Re-dispatch as internal event that grid-builder listens for\n    const deleteEvent = new CustomEvent(\"grid-item:delete\", {\n      detail: { itemId: this.item.id, canvasId: this.item.canvasId },\n      bubbles: true,\n      composed: true,\n    });\n    debug.log(\"  📤 Re-dispatching as grid-item:delete\");\n    this.itemRef.dispatchEvent(deleteEvent);\n  }\n\n  /**\n   * Listen for item-bring-to-front events from custom wrapper components\n   */\n  @Listen(\"item-bring-to-front\")\n  handleItemBringToFrontEvent(event: CustomEvent) {\n    event.stopPropagation();\n    const canvases = this.stateInstance?.canvases || gridState.canvases;\n    const canvas = canvases[this.item.canvasId];\n    if (!canvas) return;\n\n    const maxZ = Math.max(...canvas.items.map((i) => i.zIndex));\n    updateItem(this.item.canvasId, this.item.id, { zIndex: maxZ + 1 });\n  }\n\n  /**\n   * Listen for item-send-to-back events from custom wrapper components\n   */\n  @Listen(\"item-send-to-back\")\n  handleItemSendToBackEvent(event: CustomEvent) {\n    event.stopPropagation();\n    const canvases = this.stateInstance?.canvases || gridState.canvases;\n    const canvas = canvases[this.item.canvasId];\n    if (!canvas) return;\n\n    const minZ = Math.min(...canvas.items.map((i) => i.zIndex));\n    updateItem(this.item.canvasId, this.item.id, { zIndex: minZ - 1 });\n  }\n\n  /**\n   * Render component content (dynamic component from registry)\n   *\n   * **Dynamic rendering via ComponentDefinition.render()**:\n   * - Lookup component definition by type in registry\n   * - Call definition.render({ itemId, config })\n   * - Consumer controls what gets rendered\n   * - Library just provides the wrapper\n   *\n   * **Virtual rendering guard**:\n   * - Only render when isVisible = true\n   * - Show placeholder while loading\n   * - Performance optimization\n   *\n   * **Fallback for unknown types**:\n   * - If no registry provided: \"Component registry not available\"\n   * - If type not in registry:\n   *   1. Check config.hideUnknownComponents → hide completely (return null)\n   *   2. Check config.renderUnknownComponent → use custom renderer\n   *   3. Otherwise → show default error: \"Unknown component type: {type}\"\n   * - Prevents crashes, helps debugging\n   */\n  private renderComponent() {\n    // Virtual rendering: only render component content when visible\n    if (!this.isVisible) {\n      return <div class=\"component-placeholder\">Loading...</div>;\n    }\n\n    // Check if component registry is available\n    if (!this.componentRegistry) {\n      console.error(\n        `GridItemWrapper: componentRegistry not provided for item ${this.item.id}`,\n      );\n      return (\n        <div class=\"component-error\">Component registry not available</div>\n      );\n    }\n\n    // Look up component definition from registry\n    const definition = this.componentRegistry.get(this.item.type);\n\n    if (!definition) {\n      // Unknown component type - handle according to config options\n\n      // Option 1: Hide unknown components completely\n      if (this.config?.hideUnknownComponents) {\n        debug.log(\n          `GridItemWrapper: Hiding unknown component type \"${this.item.type}\" (hideUnknownComponents=true)`,\n        );\n        return null; // Don't render anything\n      }\n\n      // Option 2: Use custom unknown component renderer\n      if (this.config?.renderUnknownComponent) {\n        debug.log(\n          `GridItemWrapper: Rendering custom unknown component for type \"${this.item.type}\"`,\n        );\n        const customRenderer = this.config.renderUnknownComponent({\n          type: this.item.type,\n          itemId: this.item.id,\n        });\n\n        // Handle both HTMLElement and JSX returns\n        if (customRenderer instanceof HTMLElement) {\n          return (\n            <div\n              ref={(el) =>\n                el && !el.hasChildNodes() && el.appendChild(customRenderer)\n              }\n            />\n          );\n        }\n        return customRenderer;\n      }\n\n      // Option 3: Default error display\n      console.error(\n        `GridItemWrapper: Unknown component type \"${this.item.type}\" for item ${this.item.id}`,\n      );\n      return (\n        <div class=\"component-error\">\n          Unknown component type: {this.item.type}\n        </div>\n      );\n    }\n\n    // Call component definition's render function\n    // Pass itemId and config so component can look up state and use config\n    const rendered = definition.render({\n      itemId: this.item.id,\n      config: this.item.config,\n    });\n\n    // If render returns a DOM element (HTMLElement), wrap it in a div for Stencil\n    // This handles cases where consumer uses document.createElement()\n    if (rendered instanceof HTMLElement) {\n      return (\n        <div\n          class=\"component-wrapper\"\n          ref={(el) => el && !el.hasChildNodes() && el.appendChild(rendered)}\n        />\n      );\n    }\n\n    // Otherwise return the vNode directly (JSX)\n    return rendered;\n  }\n\n  /**\n   * Render component template\n   *\n   * **Layout selection and auto-layout**:\n   * - Desktop: Use desktop layout\n   * - Mobile (not customized): Auto-stack full-width\n   * - Mobile (customized): Use custom mobile layout\n   *\n   * **Grid to pixel conversion**:\n   * - Horizontal: gridToPixelsX(units, canvasId, config)\n   * - Vertical: gridToPixelsY(units)\n   * - Responsive width, fixed height\n   *\n   * **Transform-based positioning**:\n   * - GPU-accelerated translate()\n   * - Better performance than top/left\n   * - Sub-pixel accuracy\n   *\n   * **Dynamic component rendering**:\n   * - Look up definition from registry\n   * - Use definition.icon and definition.name for header\n   * - Call definition.render() for content\n   *\n   * **Accessibility (ARIA-describedby)**:\n   * - Provides contextual hints for screen reader users\n   * - Describes available keyboard interactions\n   * - Hidden visually with .sr-only class\n   * - Only rendered in builder mode (not viewer mode)\n   */\n  render() {\n    // Capture item ID and canvas ID at render time for delete handler\n    // This ensures the delete button always deletes the correct item,\n    // even if this.item prop changes during async operations (e.g., confirm dialog)\n    const itemIdForDelete = this.item.id;\n    const canvasIdForDelete = this.item.canvasId;\n\n    // Use prop-based viewport in viewer mode, instance or global state in builder mode\n    const currentViewport = this.viewerMode\n      ? this.currentViewport || \"desktop\"\n      : (this.stateInstance?.currentViewport || gridState.currentViewport);\n\n    const layout = this.item.layouts[currentViewport];\n\n    // For mobile viewport, calculate auto-layout if not customized\n    let actualLayout = layout;\n    if (currentViewport === \"mobile\" && !this.item.layouts.mobile.customized) {\n      // Auto-layout for mobile: stack components vertically at full width\n\n      // Use prop-based items in viewer mode, instance or global state in builder mode\n      const canvases = this.stateInstance?.canvases || gridState.canvases;\n      const canvasItems = this.viewerMode\n        ? this.canvasItems || []\n        : canvases[this.item.canvasId]?.items || [];\n\n      const itemIndex =\n        canvasItems.findIndex((i) => i.id === this.item.id) ?? 0;\n\n      // Calculate Y position by summing heights of all previous items\n      let yPosition = 0;\n      if (itemIndex > 0) {\n        for (let i = 0; i < itemIndex; i++) {\n          const prevItem = canvasItems[i];\n          yPosition += prevItem.layouts.desktop.height || 6;\n        }\n      }\n\n      actualLayout = {\n        x: 0, // Full left\n        y: yPosition,\n        width: 50, // Full width (50 units = 100%)\n        height: this.item.layouts.desktop.height || 6,\n      };\n    }\n\n    // Compute selection directly from state (only in editing mode)\n    // Use instance state if available, fall back to global state\n    const selectedItemId = this.stateInstance?.selectedItemId || gridState.selectedItemId;\n    const isSelected =\n      !this.viewerMode && selectedItemId === this.item.id;\n\n    const itemClasses = {\n      \"grid-item\": true,\n      selected: isSelected,\n      \"with-animations\": this.config?.enableAnimations ?? true,\n    };\n\n    // Convert grid units to pixels (with GridConfig support)\n    const xPixels = gridToPixelsX(\n      actualLayout.x,\n      this.item.canvasId,\n      this.config,\n    );\n    const yPixels = gridToPixelsY(actualLayout.y, this.config);\n    const widthPixels = gridToPixelsX(\n      actualLayout.width,\n      this.item.canvasId,\n      this.config,\n    );\n    const heightPixels = gridToPixelsY(actualLayout.height, this.config);\n\n    // Get component definition for icon, name, and selection color\n    const definition = this.componentRegistry?.get(this.item.type);\n    const icon = definition?.icon || \"�\";\n    const displayName = this.item.name || definition?.name || this.item.type;\n    // Selection color fallback chain:\n    // 1. Component-specific override (ComponentDefinition.selectionColor)\n    // 2. Theme default (theme.selectionColor)\n    // 3. Hardcoded fallback (amber/gold)\n    const selectionColor =\n      definition?.selectionColor ||\n      this.theme?.selectionColor ||\n      \"#f59e0b\";\n\n    // Get backgroundColor from config, or fall back to configSchema default\n    const backgroundColorField = definition?.configSchema?.find(\n      (f) => f.name === \"backgroundColor\",\n    );\n    const backgroundColor =\n      this.item.config?.backgroundColor ||\n      backgroundColorField?.defaultValue ||\n      \"transparent\";\n\n    const itemStyle = {\n      transform: `translate(${xPixels}px, ${yPixels}px)`,\n      width: `${widthPixels}px`,\n      height: `${heightPixels}px`,\n      zIndex: this.item.zIndex.toString(),\n      \"--selection-color\": selectionColor,\n      \"--animation-duration\": `${this.config?.animationDuration ?? 100}ms`,\n      // Apply backgroundColor from config to .grid-item so it fills to edges\n      background: backgroundColor,\n    };\n\n    // Generate unique IDs for custom wrapper and ARIA description\n    const contentSlotId = `${this.item.id}-content`;\n    const descriptionId = `${this.item.id}-description`;\n\n    // ARIA description text for screen readers (only in builder mode)\n    const ariaDescription = !this.viewerMode\n      ? \"Use arrow keys to nudge position, drag header to move, resize handles to change size, Delete to remove. Drag components from palette to add new items.\"\n      : null;\n\n    // Check if custom item wrapper is provided\n    if (definition?.renderItemWrapper) {\n      const customWrapper = definition.renderItemWrapper({\n        itemId: this.item.id,\n        componentType: this.item.type,\n        name: displayName,\n        icon,\n        isSelected,\n        contentSlotId,\n      });\n\n      return (\n        <div\n          class={itemClasses}\n          id={this.item.id}\n          tabindex={this.viewerMode ? undefined : 0}\n          aria-selected={isSelected ? \"true\" : \"false\"}\n          aria-describedby={ariaDescription ? descriptionId : undefined}\n          data-canvas-id={this.item.canvasId}\n          data-component-name={displayName}\n          data-viewer-mode={this.viewerMode ? \"true\" : \"false\"}\n          style={itemStyle}\n          onClick={(e) => this.handleClick(e)}\n          ref={(el) => (this.itemRef = el)}\n        >\n          {/* ARIA description (hidden, only for screen readers) */}\n          {ariaDescription && (\n            <div id={descriptionId} class=\"sr-only\">\n              {ariaDescription}\n            </div>\n          )}\n\n          {/* Custom wrapper JSX - renders securely */}\n          {customWrapper}\n\n          {/* Render component content into the content slot */}\n          {/* Note: The custom wrapper must include a div with id={contentSlotId} */}\n          {/* This is handled by a ref callback in renderComponent() */}\n\n          {/* Resize Handles (8 points) */}\n          <div class=\"resize-handle nw\" />\n          <div class=\"resize-handle ne\" />\n          <div class=\"resize-handle sw\" />\n          <div class=\"resize-handle se\" />\n          <div class=\"resize-handle n\" />\n          <div class=\"resize-handle s\" />\n          <div class=\"resize-handle e\" />\n          <div class=\"resize-handle w\" />\n        </div>\n      );\n    }\n\n    // Default item wrapper\n    return (\n      <div\n        class={itemClasses}\n        id={this.item.id}\n        role=\"group\"\n        aria-label={`${displayName} component`}\n        tabindex={this.viewerMode ? undefined : 0}\n        aria-selected={isSelected ? \"true\" : \"false\"}\n        aria-describedby={ariaDescription ? descriptionId : undefined}\n        data-canvas-id={this.item.canvasId}\n        data-component-name={displayName}\n        data-viewer-mode={this.viewerMode ? \"true\" : \"false\"}\n        style={itemStyle}\n        onClick={(e) => this.handleClick(e)}\n        ref={(el) => (this.itemRef = el)}\n      >\n        {/* ARIA description (hidden, only for screen readers) */}\n        {ariaDescription && (\n          <div id={descriptionId} class=\"sr-only\">\n            {ariaDescription}\n          </div>\n        )}\n\n        {/* Editing UI (hidden in viewer mode) */}\n        {!this.viewerMode && [\n          /* Drag Handle */\n          <div\n            class=\"drag-handle\"\n            key=\"drag-handle\"\n            aria-label={`Drag ${displayName}`}\n            role=\"button\"\n            aria-grabbed={false}\n          />,\n\n          /* Item Header */\n          <div\n            class=\"grid-item-header\"\n            key=\"header\"\n            aria-label={`${displayName} component header`}\n          >\n            {icon} {displayName}\n          </div>,\n\n          /* Item Controls */\n          <div class=\"grid-item-controls\" key=\"controls\">\n            <button\n              class=\"grid-item-delete\"\n              aria-label={`Delete ${displayName} component`}\n              onClick={() =>\n                this.handleDelete(itemIdForDelete, canvasIdForDelete)\n              }\n            >\n              ×\n            </button>\n          </div>,\n        ]}\n\n        {/* Item Content (always rendered) */}\n        <div\n          class=\"grid-item-content\"\n          id={contentSlotId}\n          data-component-type={this.item.type}\n        >\n          {this.renderComponent()}\n        </div>\n\n        {/* Resize Handles (hidden in viewer mode) */}\n        {!this.viewerMode && [\n          <div\n            class=\"resize-handle nw\"\n            key=\"resize-nw\"\n            role=\"slider\"\n            aria-label=\"Resize top-left corner\"\n            tabindex={-1}\n          />,\n          <div\n            class=\"resize-handle ne\"\n            key=\"resize-ne\"\n            role=\"slider\"\n            aria-label=\"Resize top-right corner\"\n            tabindex={-1}\n          />,\n          <div\n            class=\"resize-handle sw\"\n            key=\"resize-sw\"\n            role=\"slider\"\n            aria-label=\"Resize bottom-left corner\"\n            tabindex={-1}\n          />,\n          <div\n            class=\"resize-handle se\"\n            key=\"resize-se\"\n            role=\"slider\"\n            aria-label=\"Resize bottom-right corner\"\n            tabindex={-1}\n          />,\n          <div\n            class=\"resize-handle n\"\n            key=\"resize-n\"\n            role=\"slider\"\n            aria-label=\"Resize top edge\"\n            tabindex={-1}\n          />,\n          <div\n            class=\"resize-handle s\"\n            key=\"resize-s\"\n            role=\"slider\"\n            aria-label=\"Resize bottom edge\"\n            tabindex={-1}\n          />,\n          <div\n            class=\"resize-handle e\"\n            key=\"resize-e\"\n            role=\"slider\"\n            aria-label=\"Resize right edge\"\n            tabindex={-1}\n          />,\n          <div\n            class=\"resize-handle w\"\n            key=\"resize-w\"\n            role=\"slider\"\n            aria-label=\"Resize left edge\"\n            tabindex={-1}\n          />,\n        ]}\n      </div>\n    );\n  }\n\n  /**\n   * Capture item snapshot for undo/redo\n   */\n  private captureItemSnapshot = () => {\n    this.itemSnapshot = JSON.parse(JSON.stringify(this.item));\n  };\n\n  /**\n   * Handle item update (called by drag/resize handlers)\n   */\n  private handleItemUpdate = (updatedItem: GridItem) => {\n    // Check if position or canvas changed (for undo/redo)\n    let isDrag = false;\n    let isResize = false;\n\n    if (this.itemSnapshot) {\n      const snapshot = this.itemSnapshot;\n      const positionOnlyChanged =\n        (snapshot.layouts.desktop.x !== updatedItem.layouts.desktop.x ||\n          snapshot.layouts.desktop.y !== updatedItem.layouts.desktop.y) &&\n        snapshot.layouts.desktop.width === updatedItem.layouts.desktop.width &&\n        snapshot.layouts.desktop.height === updatedItem.layouts.desktop.height;\n      const sizeChanged =\n        snapshot.layouts.desktop.width !== updatedItem.layouts.desktop.width ||\n        snapshot.layouts.desktop.height !== updatedItem.layouts.desktop.height;\n      const canvasChanged = snapshot.canvasId !== updatedItem.canvasId;\n\n      isDrag = positionOnlyChanged || canvasChanged;\n      isResize = sizeChanged;\n\n      if (isDrag || isResize) {\n        // Find source canvas and index (use instance state if available)\n        const canvases = this.stateInstance?.canvases || gridState.canvases;\n        const sourceCanvas = canvases[snapshot.canvasId];\n        const sourceIndex =\n          sourceCanvas?.items.findIndex((i) => i.id === this.item.id) || 0;\n\n        // Handle cross-canvas z-index assignment\n        const sourceZIndex = snapshot.zIndex;\n        let targetZIndex = sourceZIndex; // Same canvas = same z-index\n\n        // If moving to different canvas, assign new z-index from target canvas\n        if (snapshot.canvasId !== updatedItem.canvasId) {\n          const targetCanvas = canvases[updatedItem.canvasId];\n          if (targetCanvas) {\n            targetZIndex = targetCanvas.zIndexCounter++;\n            updatedItem.zIndex = targetZIndex; // Update item's z-index\n          }\n        }\n\n        // Push undo command before updating state\n        // Include size tracking for resize operations (also handles resize with position change)\n        pushCommand(\n          new MoveItemCommand(\n            updatedItem.id,\n            snapshot.canvasId,\n            updatedItem.canvasId,\n            {\n              x: snapshot.layouts.desktop.x,\n              y: snapshot.layouts.desktop.y,\n            },\n            {\n              x: updatedItem.layouts.desktop.x,\n              y: updatedItem.layouts.desktop.y,\n            },\n            sourceIndex,\n            sourceZIndex,\n            targetZIndex,\n            // Include size for resize tracking (position and size can both change)\n            isResize\n              ? {\n                  width: snapshot.layouts.desktop.width,\n                  height: snapshot.layouts.desktop.height,\n                }\n              : undefined,\n            isResize\n              ? {\n                  width: updatedItem.layouts.desktop.width,\n                  height: updatedItem.layouts.desktop.height,\n                }\n              : undefined,\n          ),\n        );\n      }\n    }\n\n    // Update item in state (triggers re-render)\n    // Use instance state if available, fall back to global state\n    const canvases = this.stateInstance?.canvases || gridState.canvases;\n    const canvas = canvases[this.item.canvasId];\n    const itemIndex = canvas.items.findIndex((i) => i.id === this.item.id);\n    if (itemIndex !== -1) {\n      // Create new items array (immutable update)\n      const newItems = canvas.items.map((item, i) =>\n        i === itemIndex ? updatedItem : item\n      );\n\n      // Create new canvas with new items array\n      const newCanvas = { ...canvas, items: newItems };\n\n      // Create new canvases object\n      const newCanvases = { ...canvases, [this.item.canvasId]: newCanvas };\n\n      // Update the appropriate state object\n      if (this.stateInstance) {\n        this.stateInstance.canvases = newCanvases;\n      } else {\n        gridState.canvases = newCanvases;\n      }\n    }\n\n    // Emit events for plugins\n    if (isDrag) {\n      (this.eventManagerInstance || eventManager).emit(\"componentDragged\", {\n        itemId: updatedItem.id,\n        canvasId: updatedItem.canvasId,\n        position: {\n          x: updatedItem.layouts.desktop.x,\n          y: updatedItem.layouts.desktop.y,\n        },\n      });\n    }\n    if (isResize) {\n      (this.eventManagerInstance || eventManager).emit(\"componentResized\", {\n        itemId: updatedItem.id,\n        canvasId: updatedItem.canvasId,\n        size: {\n          width: updatedItem.layouts.desktop.width,\n          height: updatedItem.layouts.desktop.height,\n        },\n      });\n    }\n  };\n\n  /**\n   * Handle click event (selection and config panel)\n   */\n  private handleClick = (e: MouseEvent) => {\n    // Skip click handling in viewer mode\n    if (this.viewerMode) {\n      debug.log(\"  ⏭️ Skipping - viewer mode\");\n      return;\n    }\n\n    // Don't open config panel if item was just dragged\n    if (this.wasDragged) {\n      debug.log(\"  ⏭️ Skipping - was dragged\");\n      // Reset flag after a small delay to allow this click event to finish\n      setTimeout(() => {\n        this.wasDragged = false;\n      }, 10);\n      return;\n    }\n\n    // Don't open config panel if clicking on drag handle, resize handle, or control buttons\n    const target = e.target as HTMLElement;\n    if (\n      target.classList.contains(\"drag-handle\") ||\n      target.closest(\".drag-handle\") ||\n      target.classList.contains(\"resize-handle\") ||\n      target.closest(\".resize-handle\") ||\n      target.classList.contains(\"grid-item-delete\") ||\n      target.classList.contains(\"grid-item-control-btn\")\n    ) {\n      debug.log(\"  ⏭️ Skipping - clicked on control element\");\n      return;\n    }\n\n    debug.log(\"  ✅ Proceeding with click handling\");\n\n    // Set selection state immediately (use instance state if available)\n    if (this.stateInstance) {\n      this.stateInstance.selectedItemId = this.item.id;\n      this.stateInstance.selectedCanvasId = this.item.canvasId;\n    } else {\n      gridState.selectedItemId = this.item.id;\n      gridState.selectedCanvasId = this.item.canvasId;\n    }\n\n    // Set this canvas as active\n    setActiveCanvas(this.item.canvasId);\n\n    // Emit selection event for plugins\n    (this.eventManagerInstance || eventManager).emit(\"componentSelected\", {\n      itemId: this.item.id,\n      canvasId: this.item.canvasId,\n    });\n\n    // Dispatch event to open config panel\n    debug.log(\"  📤 Dispatching item-click event\", {\n      itemId: this.item.id,\n      canvasId: this.item.canvasId,\n      hasItemRef: !!this.itemRef,\n    });\n    const event = new CustomEvent(\"item-click\", {\n      detail: { itemId: this.item.id, canvasId: this.item.canvasId },\n      bubbles: true,\n      composed: true,\n    });\n    this.itemRef.dispatchEvent(event);\n    debug.log(\"  ✅ item-click event dispatched\");\n  };\n\n  /**\n   * Handle delete from default wrapper button\n   * Calls deletion hook if provided, then dispatches delete event if approved\n   * @param itemId - Item ID captured at render time\n   * @param canvasId - Canvas ID captured at render time\n   */\n  private handleDelete = async (itemId: string, canvasId: string) => {\n    debug.log(\"🗑️ handleDelete (default wrapper button)\", {\n      itemId,\n      canvasId,\n    });\n\n    // Dispatch deletion event directly\n    // The deletion hook (onBeforeDelete) is called by grid-builder's API deleteComponent method,\n    // not here - this prevents double-modal issue where user sees two confirmation dialogs\n    const event = new CustomEvent(\"grid-item:delete\", {\n      detail: { itemId, canvasId },\n      bubbles: true,\n      composed: true,\n    });\n    debug.log(\"  📤 Dispatching grid-item:delete (internal event)\");\n    this.itemRef.dispatchEvent(event);\n  };\n}\n"],"names":["getTransformPosition","debug"],"mappings":"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"}