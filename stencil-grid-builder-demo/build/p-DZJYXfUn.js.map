{"version":3,"file":"p-DZJYXfUn.js","sources":["src/utils/space-finder.ts"],"sourcesContent":["/**\n * Space Finding Utility\n * =====================\n *\n * Collision detection and smart positioning algorithms for finding\n * available space on canvas when adding components via click-to-add.\n *\n * ## Key Algorithms\n *\n * **Collision Detection (AABB)**:\n * - Axis-Aligned Bounding Box collision test\n * - Two rectangles DON'T collide if:\n * - One is completely to the left of the other\n * - One is completely to the right of the other\n * - One is completely above the other\n * - One is completely below the other\n * - If none of these are true, they collide\n *\n * **Smart Space Finding (Hybrid Strategy)**:\n * 1. Empty canvas → center horizontally (x = (50 - width) / 2, y = 2)\n * 2. Try top-left (2, 2) → return if no collision\n * 3. Scan grid top-to-bottom, left-to-right → return first free space\n * 4. No space found → place at bottom (below all items)\n *\n * ## Performance\n *\n * - Collision check: O(1) - constant time comparison\n * - Find free space: O(n × m) where n = items, m = grid scan area\n * - Typical canvas (10 items): ~50-100ms for full grid scan\n * - Early exit optimization: Returns immediately on first free space\n * @module space-finder\n */\n\nimport { gridState, GridState } from \"../services/state-manager\";\n\n/**\n * Canvas width in grid units\n * Canvas is 50 units wide (2% per unit = 100% total)\n */\nexport const CANVAS_WIDTH_UNITS = 50;\n\n/**\n * Maximum Y coordinate to scan for free space\n * Prevents infinite loops - canvas will auto-expand if needed\n */\nconst MAX_SCAN_Y = 200;\n\n/**\n * Default top margin when placing components\n */\nconst DEFAULT_TOP_MARGIN = 2;\n\n/**\n * Default left margin when placing components\n */\nconst DEFAULT_LEFT_MARGIN = 2;\n\n/**\n * Default spacing between components when placing at bottom\n */\nconst DEFAULT_BOTTOM_SPACING = 2;\n\n/**\n * Check if two grid items collide (overlap)\n *\n * Uses AABB (Axis-Aligned Bounding Box) collision detection.\n * Two rectangles collide if they overlap on both axes.\n *\n * **Algorithm**:\n * - Check if rectangles are completely separated on X axis\n * - Check if rectangles are completely separated on Y axis\n * - If separated on either axis → no collision\n * - Otherwise → collision\n *\n * **Edge cases**:\n * - Touching edges (no gap) is considered NOT colliding\n * - Actual overlap (one pixel or more) is colliding\n *\n * **Examples**:\n * ```typescript\n * // No collision (separated horizontally)\n * checkCollision(\n * { x: 0, y: 0, width: 10, height: 10 },\n * { x: 15, y: 0, width: 10, height: 10 }\n * ); // false\n *\n * // No collision (touching edges)\n * checkCollision(\n * { x: 0, y: 0, width: 10, height: 10 },\n * { x: 10, y: 0, width: 10, height: 10 }\n * ); // false (item1 ends at 10, item2 starts at 10 = touching, not overlapping)\n *\n * // Collision (overlapping)\n * checkCollision(\n * { x: 0, y: 0, width: 10, height: 10 },\n * { x: 5, y: 5, width: 10, height: 10 }\n * ); // true (actual overlap)\n * ```\n * @param item1 - First rectangle (x, y, width, height)\n * @param item2 - Second rectangle (x, y, width, height)\n * @returns true if rectangles overlap, false if separated or just touching\n */\nexport function checkCollision(\n  item1: { x: number; y: number; width: number; height: number },\n  item2: { x: number; y: number; width: number; height: number },\n): boolean {\n  // Check if completely separated horizontally (or just touching)\n  if (item1.x + item1.width <= item2.x || item2.x + item2.width <= item1.x) {\n    return false;\n  }\n\n  // Check if completely separated vertically (or just touching)\n  if (item1.y + item1.height <= item2.y || item2.y + item2.height <= item1.y) {\n    return false;\n  }\n\n  // Not separated on either axis → actual overlap/collision\n  return true;\n}\n\n/**\n * Get centered horizontal position for component\n *\n * Centers component horizontally on canvas, with top margin.\n * Used for first component on empty canvas.\n *\n * **Formula**: x = (CANVAS_WIDTH_UNITS - width) / 2\n *\n * **Examples**:\n * ```typescript\n * getCenteredPosition(10); // width=10 → x=20 (centered)\n * getCenteredPosition(20); // width=20 → x=15 (centered)\n * getCenteredPosition(50); // width=50 → x=0 (full width)\n * ```\n * @param width - Component width in grid units\n * @returns Position { x, y } centered horizontally\n */\nexport function getCenteredPosition(width: number): { x: number; y: number } {\n  const x = Math.floor((CANVAS_WIDTH_UNITS - width) / 2);\n  return { x, y: DEFAULT_TOP_MARGIN };\n}\n\n/**\n * Get position at bottom of canvas (below all items)\n *\n * Places component at canvas bottom with spacing margin.\n * Used as fallback when no free space found in grid scan.\n *\n * **Algorithm**:\n * 1. Find bottommost item (max y + height)\n * 2. Add spacing margin (2 grid units)\n * 3. Return position at left edge (x=0)\n *\n * **Examples**:\n * ```typescript\n * // Canvas with items at y=0-10, y=15-20\n * getBottomPosition('canvas1');\n * // Returns { x: 0, y: 22 } (20 + 2 spacing)\n *\n * // Empty canvas\n * getBottomPosition('canvas1');\n * // Returns { x: 0, y: 0 }\n * ```\n * @param canvasId - Canvas ID to check\n * @param state - Optional state instance (falls back to global gridState)\n * @returns Position { x, y } at canvas bottom\n */\nexport function getBottomPosition(canvasId: string, state?: GridState): { x: number; y: number } {\n  const stateToUse = state || gridState;\n  const canvas = stateToUse.canvases[canvasId];\n\n  // Empty canvas → start at top\n  if (!canvas || canvas.items.length === 0) {\n    return { x: 0, y: 0 };\n  }\n\n  // Find bottommost Y coordinate\n  const bottomY = Math.max(\n    ...canvas.items.map(\n      (item) => item.layouts.desktop.y + item.layouts.desktop.height,\n    ),\n  );\n\n  // Place below with spacing\n  return { x: 0, y: bottomY + DEFAULT_BOTTOM_SPACING };\n}\n\n/**\n * Find first available free space on canvas for component\n *\n * Uses hybrid strategy:\n * 1. **Empty canvas** → center horizontally\n * 2. **Try top-left** (2, 2) → return if no collision\n * 3. **Scan grid** → top-to-bottom, left-to-right for first free space\n * 4. **Fallback** → place at canvas bottom\n *\n * **Grid Scanning**:\n * - Starts at top-left (0, 0)\n * - Scans row by row (y=0 to MAX_SCAN_Y)\n * - Each row scans left to right (x=0 to CANVAS_WIDTH_UNITS - width)\n * - Returns immediately on first free space (early exit optimization)\n * - Limited to 200 vertical units (canvas auto-expands if needed)\n *\n * **Performance**:\n * - Empty canvas: O(1) - instant return\n * - Top-left free: O(n) - check all items once\n * - Grid scan: O(n × m) - worst case 200 × 50 = 10,000 checks\n * - Each check: O(n) collision tests against all items\n * - Typical (10 items): ~50-100ms for full scan\n * - Early exit: Usually finds space in first few rows\n *\n * **Examples**:\n * ```typescript\n * // Empty canvas → center\n * findFreeSpace('canvas1', 10, 6);\n * // Returns { x: 20, y: 2 } (centered)\n *\n * // Top-left free\n * findFreeSpace('canvas1', 10, 6);\n * // Returns { x: 2, y: 2 } (preferred position)\n *\n * // Top-left occupied, scan finds space at (15, 5)\n * findFreeSpace('canvas1', 10, 6);\n * // Returns { x: 15, y: 5 }\n *\n * // No space found (canvas full)\n * findFreeSpace('canvas1', 10, 6);\n * // Returns { x: 0, y: 25 } (bottom position)\n * ```\n * @param canvasId - Canvas ID to search\n * @param width - Component width in grid units\n * @param height - Component height in grid units\n * @param state - Optional state instance (falls back to global gridState)\n * @returns Position { x, y } or null if canvas doesn't exist\n */\nexport function findFreeSpace(\n  canvasId: string,\n  width: number,\n  height: number,\n  state?: GridState,\n): { x: number; y: number } | null {\n  const stateToUse = state || gridState;\n  const canvas = stateToUse.canvases[canvasId];\n\n  // Canvas doesn't exist\n  if (!canvas) {\n    return null;\n  }\n\n  // Empty canvas → center horizontally\n  if (canvas.items.length === 0) {\n    return getCenteredPosition(width);\n  }\n\n  // Try top-left position (preferred)\n  // But only if component fits within canvas bounds at this position\n  const fitsAtTopLeft = DEFAULT_LEFT_MARGIN + width <= CANVAS_WIDTH_UNITS;\n\n  if (fitsAtTopLeft) {\n    const topLeft = {\n      x: DEFAULT_LEFT_MARGIN,\n      y: DEFAULT_TOP_MARGIN,\n      width,\n      height,\n    };\n\n    const hasCollisionAtTopLeft = canvas.items.some((item) => {\n      return checkCollision(topLeft, item.layouts.desktop);\n    });\n\n    if (!hasCollisionAtTopLeft) {\n      return { x: DEFAULT_LEFT_MARGIN, y: DEFAULT_TOP_MARGIN };\n    }\n  }\n\n  // Scan grid for free space (top-to-bottom, left-to-right)\n  for (let y = 0; y < MAX_SCAN_Y; y += 1) {\n    for (let x = 0; x <= CANVAS_WIDTH_UNITS - width; x += 1) {\n      const testPos = { x, y, width, height };\n\n      // Check collision with all existing items\n      const collisions = canvas.items.map((item) => {\n        const collision = checkCollision(testPos, item.layouts.desktop);\n        return { itemId: item.id, itemType: item.type, collision };\n      });\n\n      const hasCollision = collisions.some((c) => c.collision);\n\n      // Found free space → return immediately (early exit)\n      if (!hasCollision) {\n        return { x, y };\n      }\n    }\n  }\n\n  // No free space found → place at bottom (canvas will auto-expand)\n  return getBottomPosition(canvasId, stateToUse);\n}\n"],"names":[],"mappings":"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"}