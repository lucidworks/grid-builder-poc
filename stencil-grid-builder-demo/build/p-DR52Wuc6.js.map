{"version":3,"file":"p-DR52Wuc6.js","sources":["src/services/virtual-renderer.ts","src/services/undo-redo-commands.ts","src/services/undo-redo.ts","src/utils/boundary-constraints.ts"],"sourcesContent":["/**\n * Virtual Renderer Service - Lazy Loading System\n * ===============================================\n *\n * Performance optimization using IntersectionObserver to lazy-load component content\n * only when visible in the viewport. Reduces initial render time, memory usage, and\n * improves page load performance for pages with 100+ grid items.\n *\n * ## Problem\n *\n * Grid builders with many items face performance challenges:\n * - **Initial render cost**: Rendering 100+ components at page load is expensive\n * - **Memory overhead**: All components in memory even if off-screen\n * - **Slow page load**: Long time to interactive (TTI)\n * - **Poor scrolling**: Heavy DOM operations during scroll\n * - **Wasted rendering**: Complex components rendered but never seen\n *\n * **Example scenario**:\n * - Page with 100 grid items\n * - 10 items visible initially\n * - 90 items rendered but off-screen (wasted work)\n * - Each complex component: ~5-50ms to render\n * - Total wasted: 450-4500ms (almost 5 seconds!)\n *\n * ## Solution\n *\n * IntersectionObserver pattern providing:\n * 1. **Lazy initialization**: Items start with placeholder content\n * 2. **Viewport detection**: Observe when items enter viewport\n * 3. **Callback notification**: Notify components when visible\n * 4. **Component rendering**: Replace placeholder with actual content\n * 5. **Pre-rendering**: Start loading 200px before entering viewport\n * 6. **Memory cleanup**: Unobserve removed components\n *\n * ## Architecture: IntersectionObserver Pattern\n *\n * **Observer setup**:\n * ```typescript\n * // In grid-builder-app.tsx componentDidLoad:\n * (window as any).virtualRenderer = new VirtualRendererService();\n *\n * // In grid-item-wrapper.tsx componentDidLoad:\n * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n * this.isVisible = isVisible;  // Triggers re-render\n * });\n * ```\n *\n * **Flow**:\n * ```\n * 1. Grid item mounts → observe(element, callback)\n * 2. Item scrolls into viewport (200px before visible)\n * 3. IntersectionObserver fires → callback(true)\n * 4. Component sets isVisible = true → re-renders\n * 5. Placeholder replaced with actual component\n * 6. User sees smooth transition\n * ```\n *\n * **Cleanup**:\n * ```\n * 1. Grid item unmounts → disconnectedCallback()\n * 2. unobserve(element, id) → stop watching\n * 3. Remove callback from map → allow GC\n * 4. Observer continues for other elements\n * ```\n *\n * ## IntersectionObserver Configuration\n *\n * **Root margin strategy** (`rootMargin: '200px'`):\n * - Pre-render items 200px before they enter viewport\n * - Ensures content ready when user scrolls\n * - Prevents \"pop-in\" effect (flash of placeholder)\n * - Balance between performance and UX\n *\n * **Why 200px**:\n * - Typical scroll speed: ~100-300px per second\n * - 200px gives ~1 second to render before visible\n * - Complex component: ~50-200ms to render\n * - Comfortable buffer for smooth loading\n *\n * **Threshold setting** (`threshold: 0.01`):\n * - Trigger when even 1% of element is visible\n * - Very early detection (as soon as edge appears)\n * - Maximizes pre-render time\n * - Prevents late loading\n *\n * **Why 0.01 not 0**:\n * - 0 = fully outside viewport\n * - 0.01 = edge just entering\n * - Better cross-browser behavior\n * - More reliable than 0\n *\n * ## Observer Callback Pattern\n *\n * **Callback signature**:\n * ```typescript\n * type VisibilityCallback = (isVisible: boolean) => void;\n * ```\n *\n * **Callback invocation**:\n * ```typescript\n * entries.forEach((entry) => {\n * const callback = this.observedElements.get(elementId);\n * if (callback) {\n * callback(entry.isIntersecting);  // true when entering, false when exiting\n * }\n * });\n * ```\n *\n * **Component handler**:\n * ```typescript\n * // In grid-item-wrapper.tsx:\n * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n * this.isVisible = isVisible;  // @State update triggers re-render\n * });\n * ```\n *\n * **Render method**:\n * ```typescript\n * renderComponent() {\n * if (!this.isVisible) {\n * return <div class=\"component-placeholder\">Loading...</div>;\n * }\n * // Render actual component (expensive)\n * return <component-image-gallery itemId={this.item.id} />;\n * }\n * ```\n *\n * ## Memory Management\n *\n * **Callback storage**:\n * ```typescript\n * private observedElements: Map<string, VisibilityCallback> = new Map();\n * ```\n *\n * **Why Map**:\n * - O(1) lookup by element ID\n * - Easy cleanup (delete)\n * - Prevents memory leaks\n * - Standard pattern\n *\n * **Cleanup strategy**:\n * 1. Component unmounts → unobserve(element, id)\n * 2. Delete callback from map → allow GC\n * 3. Observer stops watching element\n * 4. Element can be garbage collected\n *\n * **Memory impact**:\n * - Each callback: ~100 bytes\n * - 100 items: ~10KB total\n * - Negligible overhead\n *\n * ## Performance Characteristics\n *\n * **Initial page load** (100 items, 10 visible):\n * - Without virtual rendering: ~500-5000ms (render all)\n * - With virtual rendering: ~50-500ms (render 10)\n * - **10× faster initial load**\n *\n * **Scroll performance**:\n * - Observer overhead: ~1-2ms per event\n * - Component render: ~5-50ms (varies by type)\n * - Pre-render buffer: Items ready when visible\n * - Smooth 60fps scrolling maintained\n *\n * **Memory usage** (100 items):\n * - Without virtual rendering: ~50-500MB (all components)\n * - With virtual rendering: ~5-50MB (visible + buffered)\n * - **10× lower memory usage**\n *\n * ## Complex Component Targeting\n *\n * **Simple components** (always render):\n * - header, text, button (fast ~1-5ms)\n * - No lazy loading needed\n * - Always visible immediately\n *\n * **Complex components** (lazy load):\n * - image-gallery: Multiple images to load (~50-200ms)\n * - dashboard-widget: Chart rendering (~100-500ms)\n * - live-data: API calls + updates (~100ms+)\n *\n * **How wrapper decides**:\n * ```typescript\n * // In grid-item-wrapper.tsx:\n * componentDidLoad() {\n * // Always observe, component decides if needed\n * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n * this.isVisible = isVisible;\n * });\n * }\n *\n * renderComponent() {\n * // Simple components ignore isVisible flag\n * if (!this.isVisible && this.item.type === 'imageGallery') {\n * return <div class=\"component-placeholder\">Loading...</div>;\n * }\n * // Complex types use isVisible guard\n * }\n * ```\n *\n * ## Browser Compatibility\n *\n * **IntersectionObserver support**:\n * - Chrome 51+ (2016)\n * - Firefox 55+ (2017)\n * - Safari 12.1+ (2019)\n * - Edge 15+ (2017)\n * - ~97% global browser coverage (2024)\n *\n * **Polyfill option**:\n * ```typescript\n * // If needed for older browsers:\n * import 'intersection-observer'; // polyfill\n * ```\n *\n * **Graceful degradation**:\n * - If IntersectionObserver unavailable\n * - Could fallback to immediate rendering\n * - Or use scroll event listener (less efficient)\n *\n * ## Extracting This Pattern\n *\n * To adapt virtual rendering for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * // 1. Create observer service\n * class VirtualRenderer {\n * private observer: IntersectionObserver;\n * private callbacks = new Map<string, (visible: boolean) => void>();\n *\n * constructor() {\n * this.observer = new IntersectionObserver(\n * (entries) => entries.forEach(e =>\n * this.callbacks.get(e.target.id)?.(e.isIntersecting)\n * ),\n * { rootMargin: '200px', threshold: 0.01 }\n * );\n * }\n *\n * observe(el: Element, id: string, cb: (visible: boolean) => void) {\n * this.callbacks.set(id, cb);\n * this.observer.observe(el);\n * }\n *\n * unobserve(el: Element, id: string) {\n * this.callbacks.delete(id);\n * this.observer.unobserve(el);\n * }\n * }\n *\n * // 2. Create singleton\n * export const virtualRenderer = new VirtualRenderer();\n *\n * // 3. Use in component\n * useEffect(() => {\n * virtualRenderer.observe(ref.current, id, setIsVisible);\n * return () => virtualRenderer.unobserve(ref.current, id);\n * }, []);\n *\n * return isVisible ? <ComplexComponent /> : <Placeholder />;\n * ```\n *\n * **For different frameworks**:\n * - **React**: Use useEffect for lifecycle, useState for visibility\n * - **Vue**: Use onMounted/onUnmounted, ref() for visibility\n * - **Angular**: Use ngAfterViewInit/ngOnDestroy, signals for visibility\n * - **Svelte**: Use onMount/onDestroy, stores for visibility\n *\n * **Key patterns to preserve**:\n * 1. Singleton service (one observer for all components)\n * 2. Callback map for O(1) lookups\n * 3. 200px root margin for pre-rendering\n * 4. 0.01 threshold for early detection\n * 5. Cleanup on component unmount\n *\n * **Customization options**:\n * ```typescript\n * // Adjust root margin based on needs\n * rootMargin: '200px'  // Standard (1 second buffer)\n * rootMargin: '400px'  // Aggressive (2 second buffer, more memory)\n * rootMargin: '100px'  // Conservative (less memory, might see pop-in)\n *\n * // Adjust threshold based on needs\n * threshold: 0.01      // Trigger immediately\n * threshold: 0.1       // Trigger when 10% visible\n * threshold: 0.5       // Trigger when 50% visible (not recommended)\n * ```\n * @module virtual-renderer\n */\n\n/**\n * Visibility callback function type\n *\n * **Signature**: `(isVisible: boolean) => void`\n * **Called when**: Element enters or exits viewport\n * **Parameter**: `isVisible` - true when entering, false when exiting\n *\n * **Usage**:\n * ```typescript\n * virtualRenderer.observe(element, id, (isVisible) => {\n *   this.isVisible = isVisible;  // Update component state\n * });\n * ```\n */\nexport type VisibilityCallback = (isVisible: boolean) => void;\n\n/**\n * VirtualRendererService Class\n * ==============================\n *\n * Singleton service managing IntersectionObserver for all grid items.\n *\n * **Lifecycle**:\n * 1. Created once in grid-builder-app.tsx componentDidLoad\n * 2. Shared across all grid-item-wrapper components\n * 3. Lives for entire application lifetime\n * 4. Destroyed only on page unload\n *\n * **Properties**:\n * - `observer`: IntersectionObserver instance (null during initialization)\n * - `observedElements`: Map of element IDs to visibility callbacks\n *\n * **Methods**:\n * - `constructor()`: Initialize observer with configuration\n * - `initialize()`: Create IntersectionObserver with rootMargin and threshold\n * - `observe(element, id, callback)`: Start observing element\n * - `unobserve(element, id)`: Stop observing element\n * - `destroy()`: Cleanup all observations\n */\nexport class VirtualRendererService {\n  /**\n   * IntersectionObserver instance\n   *\n   * **Lifecycle**: Created in initialize(), destroyed in destroy()\n   * **Configuration**: rootMargin: '200px', threshold: 0.01\n   * **Purpose**: Watch all grid items for viewport intersection\n   *\n   * **Null during**:\n   * - Before initialize() completes\n   * - After destroy() called\n   * - Error during initialization\n   */\n  private observer: IntersectionObserver | null = null;\n\n  /**\n   * Map of element IDs to visibility callbacks\n   *\n   * **Structure**: `Map<elementId: string, callback: VisibilityCallback>`\n   * **Lookup**: O(1) by element ID\n   * **Cleanup**: Entries deleted in unobserve()\n   *\n   * **Memory**: ~100 bytes per entry, ~10KB for 100 items\n   *\n   * **Why Map**:\n   * - Fast lookups in observer callback\n   * - Easy cleanup (delete by key)\n   * - Prevents memory leaks\n   * - Standard pattern for observer registries\n   */\n  private observedElements: Map<string, VisibilityCallback> = new Map();\n\n  /**\n   * Constructor - Initialize virtual renderer\n   *\n   * **Called**: Once when VirtualRendererService instantiated\n   * **Purpose**: Create IntersectionObserver with configuration\n   *\n   * **Delegates to**: initialize()\n   * - Sets up observer with rootMargin and threshold\n   * - Registers callback handler for intersection events\n   *\n   * **Usage**:\n   * ```typescript\n   * // In grid-builder-app.tsx componentDidLoad:\n   * (window as any).virtualRenderer = new VirtualRendererService();\n   * ```\n   */\n  constructor() {\n    this.initialize();\n  }\n\n  /**\n   * Initialize IntersectionObserver\n   *\n   * **Called by**: constructor (once)\n   * **Purpose**: Create and configure IntersectionObserver instance\n   *\n   * ## Observer Configuration\n   *\n   * **Observer callback**:\n   * ```typescript\n   * (entries) => {\n   * entries.forEach((entry) => {\n   * const elementId = entry.target.id;\n   * const callback = this.observedElements.get(elementId);\n   * if (callback) {\n   * callback(entry.isIntersecting);  // true = entering, false = exiting\n   * }\n   * });\n   * }\n   * ```\n   *\n   * **Why forEach entries**:\n   * - IntersectionObserver can fire for multiple elements at once\n   * - Batch processing is more efficient\n   * - Each element gets independent callback\n   *\n   * **Element ID lookup**:\n   * ```typescript\n   * const elementId = entry.target.id;  // From element.id attribute\n   * const callback = this.observedElements.get(elementId);  // O(1) lookup\n   * ```\n   *\n   * **Why use element ID**:\n   * - Direct mapping to callback\n   * - No need to store element references\n   * - Simpler memory management\n   * - Works across DOM mutations\n   *\n   * ## Observer Options\n   *\n   * **Root margin** (`rootMargin: '200px'`):\n   * - Expand viewport bounds by 200px in all directions\n   * - Items render 200px before actually visible\n   * - 1 second buffer at typical scroll speed\n   * - Prevents \"pop-in\" effect\n   *\n   * **Threshold** (`threshold: 0.01`):\n   * - Fire when 1% of element visible\n   * - Very early detection\n   * - Maximizes pre-render time\n   * - More reliable than 0 across browsers\n   *\n   * **Why these specific values**:\n   * - 200px root margin: Balance between performance and UX\n   * - 0.01 threshold: As early as possible without false positives\n   * - Tested with 100+ items for optimal performance\n   *\n   * ## Callback Execution\n   *\n   * **entry.isIntersecting**:\n   * - `true`: Element entering viewport (or 200px buffer)\n   * - `false`: Element exiting viewport\n   * - Component can show/hide content accordingly\n   *\n   * **Callback guard** (`if (callback)`):\n   * - Handles race conditions\n   * - Element may have been unobserved but event still fires\n   * - Prevents errors from missing callbacks\n   * - Graceful degradation\n   *\n   * ## Performance Impact\n   *\n   * **Observer overhead**: ~1-2ms per intersection event\n   * **Callback execution**: ~0.1ms per callback\n   * **Total overhead**: Negligible compared to component rendering\n   *\n   * **Scalability**:\n   * - Single observer for all elements (efficient)\n   * - Map lookups O(1)\n   * - No DOM queries needed\n   * - Works well with 100+ elements\n   */\n  private initialize() {\n    // Create observer with 200px margin (pre-render before entering viewport)\n    this.observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          const elementId = entry.target.id;\n          const callback = this.observedElements.get(elementId);\n\n          if (callback) {\n            // Call callback with visibility state\n            callback(entry.isIntersecting);\n          }\n        });\n      },\n      {\n        rootMargin: \"200px\", // Start loading 200px before entering viewport\n        threshold: [0, 0.01], // Fire at 0% (just entered) AND 0.01% (already visible)\n      },\n    );\n  }\n\n  /**\n   * Observe element for visibility changes\n   *\n   * **Called from**: grid-item-wrapper.tsx componentDidLoad\n   * **Purpose**: Register element for lazy loading when it enters viewport\n   *\n   * ## Registration Process\n   *\n   * **Validation**:\n   * ```typescript\n   * if (!this.observer || !element) return;  // Guard against invalid state\n   * ```\n   *\n   * **Why validation needed**:\n   * - Observer may not be initialized (edge case)\n   * - Element may be null if ref not set\n   * - Fail gracefully without errors\n   * - Defensive programming\n   *\n   * **Store callback**:\n   * ```typescript\n   * this.observedElements.set(elementId, callback);  // Map: id → callback\n   * ```\n   *\n   * **Why store before observing**:\n   * - Callback ready when first intersection fires\n   * - No race condition between observe and callback\n   * - Guaranteed handler availability\n   *\n   * **Start observing**:\n   * ```typescript\n   * this.observer.observe(element);  // Add to observer's watch list\n   * ```\n   *\n   * ## Callback Invocation\n   *\n   * **When callback fires**:\n   * 1. Element enters viewport (or 200px buffer)\n   * 2. Observer callback runs\n   * 3. Looks up callback by elementId\n   * 4. Calls callback(true)\n   * 5. Component updates isVisible state\n   * 6. Component re-renders with actual content\n   *\n   * **Callback signature**:\n   * ```typescript\n   * (isVisible: boolean) => void\n   * ```\n   *\n   * **Typical usage**:\n   * ```typescript\n   * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n   * this.isVisible = isVisible;  // @State update → re-render\n   * });\n   * ```\n   *\n   * ## Multiple Observations\n   *\n   * **Same element, different callback**:\n   * - New callback replaces old one\n   * - Map key is elementId (unique)\n   * - No duplicate observations\n   * - Latest callback wins\n   *\n   * **Multiple elements**:\n   * - Each gets own callback\n   * - All share single observer\n   * - Efficient batch processing\n   * - Scalable to 100+ items\n   *\n   * ## Memory Impact\n   *\n   * **Per observation**:\n   * - Map entry: ~100 bytes\n   * - Observer tracking: ~50 bytes\n   * - Total: ~150 bytes per item\n   *\n   * **100 items**:\n   * - Map overhead: ~10KB\n   * - Observer overhead: ~5KB\n   * - Total: ~15KB (negligible)\n   *\n   * ## Edge Cases\n   *\n   * **Element already observed**:\n   * - IntersectionObserver handles gracefully\n   * - No duplicate tracking\n   * - Callback map updated\n   *\n   * **Element without ID**:\n   * - Callback stored with undefined key\n   * - Lookups will fail\n   * - Element won't lazy load\n   * - Should ensure ID set\n   *\n   * **Observer not initialized**:\n   * - Guard returns early\n   * - No error thrown\n   * - Element renders immediately\n   * - Graceful degradation\n   * @param element - DOM element to observe (must have id attribute)\n   * @param elementId - Unique ID for callback lookup (should match element.id)\n   * @param callback - Function called when visibility changes\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper.tsx componentDidLoad:\n   * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n   *   this.isVisible = isVisible;  // Trigger re-render\n   * });\n   * // → Element now monitored\n   * // → Callback fires when scrolled into view\n   * // → Component renders content instead of placeholder\n   * ```\n   */\n  observe(\n    element: HTMLElement,\n    elementId: string,\n    callback: VisibilityCallback,\n  ) {\n    if (!this.observer || !element) {\n      return;\n    }\n\n    // Store callback\n    this.observedElements.set(elementId, callback);\n\n    // Start observing\n    this.observer.observe(element);\n\n    // IMPORTANT: IntersectionObserver doesn't fire immediately for already-visible elements\n    // Check if element is already in viewport and call callback synchronously\n    // This prevents \"Loading...\" flash for items that are initially visible\n    const rect = element.getBoundingClientRect();\n    const windowHeight =\n      window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth =\n      window.innerWidth || document.documentElement.clientWidth;\n\n    // Check if element is in viewport (with 200px margin matching rootMargin)\n    const isInViewport =\n      rect.top < windowHeight + 200 &&\n      rect.bottom > -200 &&\n      rect.left < windowWidth + 200 &&\n      rect.right > -200;\n\n    // Call callback immediately if already visible\n    if (isInViewport) {\n      callback(true);\n    }\n  }\n\n  /**\n   * Stop observing element (cleanup)\n   *\n   * **Called from**: grid-item-wrapper.tsx disconnectedCallback\n   * **Purpose**: Remove element from observation and free callback memory\n   *\n   * ## Cleanup Process\n   *\n   * **Validation**:\n   * ```typescript\n   * if (!this.observer || !element) return;  // Guard against invalid state\n   * ```\n   *\n   * **Why validation needed**:\n   * - Observer may be destroyed\n   * - Element may be null during unmount\n   * - Fail gracefully without errors\n   * - Safe cleanup pattern\n   *\n   * **Remove callback**:\n   * ```typescript\n   * this.observedElements.delete(elementId);  // Free callback from map\n   * ```\n   *\n   * **Why delete first**:\n   * - Prevents callback from firing during unobserve\n   * - Immediate cleanup of memory\n   * - No race conditions\n   * - Clean separation\n   *\n   * **Stop observing**:\n   * ```typescript\n   * this.observer.unobserve(element);  // Remove from observer's watch list\n   * ```\n   *\n   * ## Memory Management\n   *\n   * **Callback deletion**:\n   * - Removes Map entry\n   * - Allows callback garbage collection\n   * - Frees ~100 bytes per element\n   * - Critical for long-running apps\n   *\n   * **Observer cleanup**:\n   * - Removes element from internal list\n   * - Stops firing intersection events\n   * - Frees ~50 bytes per element\n   * - Reduces observer overhead\n   *\n   * **What if not called**:\n   * - Callback remains in memory (leak)\n   * - Observer still tracks element (leak)\n   * - ~150 bytes leaked per unmounted item\n   * - Adds up with many mount/unmount cycles\n   *\n   * ## Cleanup Timing\n   *\n   * **Component lifecycle**:\n   * ```\n   * 1. Component mounts → componentDidLoad → observe()\n   * 2. Component unmounts → disconnectedCallback → unobserve()\n   * 3. Element removed from DOM\n   * 4. Callback deleted from map\n   * 5. Observer stops watching\n   * 6. Garbage collector can free memory\n   * ```\n   *\n   * **Why in disconnectedCallback**:\n   * - Called when component removed from DOM\n   * - Guaranteed cleanup point\n   * - Standard web component lifecycle\n   * - No memory leaks\n   *\n   * ## Edge Cases\n   *\n   * **Element not observed**:\n   * - IntersectionObserver handles gracefully\n   * - No error thrown\n   * - Map.delete() returns false but safe\n   * - Idempotent operation\n   *\n   * **Called multiple times**:\n   * - First call removes callback and stops observing\n   * - Subsequent calls are no-ops\n   * - Safe to call multiple times\n   * - Defensive cleanup\n   *\n   * **Observer already destroyed**:\n   * - Guard returns early\n   * - No error thrown\n   * - Map cleanup still happens\n   * - Graceful degradation\n   *\n   * ## Performance Impact\n   *\n   * **Per unobserve**:\n   * - Map.delete(): ~0.01ms\n   * - observer.unobserve(): ~0.1ms\n   * - Total: ~0.11ms (negligible)\n   *\n   * **Batch cleanup** (100 items):\n   * - Sequential unobserve: ~11ms\n   * - Observer.disconnect() + Map.clear(): ~1ms\n   * - destroy() method more efficient for bulk\n   * @param element - DOM element to stop observing\n   * @param elementId - Element's ID for callback removal\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper.tsx disconnectedCallback:\n   * disconnectedCallback() {\n   *   if (this.itemRef) {\n   *     virtualRenderer.unobserve(this.itemRef, this.item.id);\n   *   }\n   * }\n   * // → Callback removed from map\n   * // → Observer stops watching element\n   * // → Memory freed for garbage collection\n   * ```\n   */\n  unobserve(element: HTMLElement, elementId: string) {\n    if (!this.observer || !element) {\n      return;\n    }\n\n    // Remove callback\n    this.observedElements.delete(elementId);\n\n    // Stop observing\n    this.observer.unobserve(element);\n  }\n\n  /**\n   * Cleanup all observations (bulk cleanup)\n   *\n   * **Called**: Manually when destroying service (rare, typically page unload)\n   * **Purpose**: Completely tear down observer and free all memory\n   *\n   * ## Cleanup Operations\n   *\n   * **Disconnect observer**:\n   * ```typescript\n   * if (this.observer) {\n   * this.observer.disconnect();  // Stop watching all elements\n   * this.observer = null;         // Allow GC\n   * }\n   * ```\n   *\n   * **Why disconnect**:\n   * - Stops all intersection callbacks\n   * - Removes all elements from watch list\n   * - More efficient than unobserve for each element\n   * - Single operation vs N operations\n   *\n   * **Why set to null**:\n   * - Signals observer destroyed\n   * - Guards in other methods will return early\n   * - Allows IntersectionObserver GC\n   * - Clean state reset\n   *\n   * **Clear callbacks**:\n   * ```typescript\n   * this.observedElements.clear();  // Remove all Map entries\n   * ```\n   *\n   * **Why clear**:\n   * - Frees all callback references\n   * - Allows callback GC\n   * - Prevents memory leaks\n   * - Complete cleanup\n   *\n   * ## Performance Comparison\n   *\n   * **destroy() vs unobserve all** (100 items):\n   * - destroy(): disconnect + clear = ~1ms\n   * - unobserve × 100: ~11ms\n   * - **11× faster for bulk cleanup**\n   *\n   * **Memory freed** (100 items):\n   * - Callbacks: ~10KB\n   * - Observer tracking: ~5KB\n   * - Observer instance: ~1KB\n   * - Total: ~16KB\n   *\n   * ## When to Use\n   *\n   * **Appropriate scenarios**:\n   * - Page unload / navigation away\n   * - Application teardown\n   * - Test cleanup (afterEach)\n   * - Hot module reload (HMR)\n   *\n   * **Not appropriate**:\n   * - Individual component unmount (use unobserve)\n   * - Removing some items (use unobserve per item)\n   * - Temporary pause (no such feature needed)\n   *\n   * ## State After Destroy\n   *\n   * **Observer state**:\n   * - `this.observer = null`\n   * - All observe/unobserve calls become no-ops\n   * - Guards prevent errors\n   *\n   * **Callbacks state**:\n   * - `this.observedElements` empty\n   * - All callbacks freed\n   * - No memory leaks\n   *\n   * **Service unusable**:\n   * - Must create new instance to use again\n   * - Or call initialize() if made public\n   * - Current design: create new service\n   *\n   * ## Edge Cases\n   *\n   * **Observer not initialized**:\n   * - Guard skips disconnect\n   * - Only clears callbacks\n   * - Safe even if never initialized\n   *\n   * **Called multiple times**:\n   * - First call destroys everything\n   * - Subsequent calls are no-ops\n   * - Idempotent operation\n   * - Safe defensive cleanup\n   *\n   * **Active intersections**:\n   * - disconnect() cancels all pending callbacks\n   * - No callbacks fire after destroy\n   * - Clean shutdown\n   *\n   * ## Memory Leak Prevention\n   *\n   * **Without destroy**:\n   * - Observer remains in memory\n   * - All callbacks remain referenced\n   * - Elements can't be GC'd\n   * - ~16KB leak per 100 items\n   *\n   * **With destroy**:\n   * - Observer freed\n   * - Callbacks freed\n   * - Elements can be GC'd\n   * - No memory leaks\n   * @example\n   * ```typescript\n   * // On page unload:\n   * window.addEventListener('beforeunload', () => {\n   *   virtualRenderer.destroy();\n   * });\n   *\n   * // In tests:\n   * afterEach(() => {\n   *   virtualRenderer.destroy();\n   * });\n   *\n   * // Hot module reload:\n   * if (module.hot) {\n   *   module.hot.dispose(() => {\n   *     virtualRenderer.destroy();\n   *   });\n   * }\n   * ```\n   */\n  destroy() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n    this.observedElements.clear();\n  }\n}\n\n/**\n * Backward Compatibility Layer\n * ==============================\n *\n * Singleton instance export for backward compatibility.\n * Existing code can continue using this while we migrate to instance-based architecture.\n *\n * **Migration path**:\n * 1. Phase 1: VirtualRendererService class already exists (CURRENT PHASE - ✓ Complete)\n * 2. Phase 2: Update grid-builder to create instances\n * 3. Phase 3: Update child components to accept instances as props\n * 4. Phase 4: Remove singleton export and update all imports\n *\n * **Why singleton currently**:\n * - Single IntersectionObserver for all items (efficient)\n * - Shared callback registry (O(1) lookups)\n * - Can be replaced with per-instance observers in Phase 2\n *\n * **Usage note**: VirtualRendererService is already a class, so no conversion needed.\n * Just need to update grid-builder to create instances instead of importing singleton.\n *\n * **Current usage pattern**:\n * ```typescript\n * // In grid-item-wrapper.tsx:\n * import { virtualRenderer } from '../../services/virtual-renderer';\n *\n * componentDidLoad() {\n *   virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *     this.isVisible = isVisible;\n *   });\n * }\n *\n * disconnectedCallback() {\n *   virtualRenderer.unobserve(this.itemRef, this.item.id);\n * }\n * ```\n *\n * **Future usage pattern** (Phase 2+):\n * ```typescript\n * // In grid-item-wrapper.tsx:\n * @Prop() virtualRenderer: VirtualRendererService;  // Passed from grid-builder\n *\n * componentDidLoad() {\n *   this.virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *     this.isVisible = isVisible;\n *   });\n * }\n * ```\n */\nexport const virtualRenderer = new VirtualRendererService();\n","/**\n * Undo/Redo Commands\n * ===================\n *\n * Concrete Command implementations for grid operations. Each command class\n * encapsulates a specific user action with the ability to undo and redo.\n *\n * ## Problem\n *\n * The Command pattern requires concrete implementations for each undoable operation.\n * Each command must:\n * - Capture enough state to reverse the operation (undo)\n * - Capture enough state to reapply the operation (redo)\n * - Be self-contained (no external dependencies)\n * - Handle edge cases (canvas switching, index preservation)\n *\n * ## Solution\n *\n * Four concrete command classes covering all grid operations:\n *\n * 1. **AddItemCommand**: Adding new items to canvas\n * 2. **DeleteItemCommand**: Removing items with index preservation\n * 3. **MoveItemCommand**: Dragging items (same or different canvas)\n * 4. **ResizeCommand**: (Not yet implemented - resize operations not tracked)\n *\n * ## Key Design Patterns\n *\n * ### Deep Cloning Strategy\n *\n * **Why deep clone**: Prevent mutations from affecting command snapshots\n *\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **When to clone**:\n * - ✅ Constructor: Capture initial state\n * - ✅ redo(): Create fresh copy for state mutation\n * - ❌ undo(): Usually work with existing state references\n *\n * **Trade-offs**:\n * - ✅ Simple and reliable\n * - ✅ No reference bugs\n * - ❌ Higher memory usage (~1-5 KB per command)\n * - ❌ Slower than structural sharing\n *\n * ### Index Preservation Pattern\n *\n * **Why preserve index**: Undo delete should restore item at original position\n *\n * ```typescript\n * class DeleteItemCommand {\n * private itemIndex: number;  // Capture index before deletion\n *\n * undo() {\n * canvas.items.splice(this.itemIndex, 0, item);  // Restore at index\n * }\n * }\n * ```\n *\n * **Important for**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * ### Selection State Management\n *\n * **Pattern**: Clear selection when deleting selected item\n *\n * ```typescript\n * if (gridState.selectedItemId === itemId) {\n * gridState.selectedItemId = null;\n * gridState.selectedCanvasId = null;\n * }\n * ```\n *\n * **Why needed**:\n * - Prevents dangling references to deleted items\n * - Avoids errors when accessing selectedItemId\n * - Matches user expectations (deleted item can't be selected)\n *\n * ### Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between canvases\n *\n * **Solution**: Track source and target canvas IDs\n *\n * ```typescript\n * class MoveItemCommand {\n * sourceCanvasId: string;\n * targetCanvasId: string;\n *\n * undo() {\n * // Move from target back to source\n * removeFrom(targetCanvasId);\n * addTo(sourceCanvasId, sourceIndex);  // Restore position\n * }\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Typical flow**:\n * ```\n * 1. User performs action (drag, delete, etc.)\n * 2. Operation completes (state already updated)\n * 3. Create command with before/after snapshots\n * 4. pushCommand(command) → adds to history\n * 5. User presses Ctrl+Z\n * 6. command.undo() → reverses operation\n * 7. User presses Ctrl+Y\n * 8. command.redo() → reapplies operation\n * ```\n *\n * **Important**: Commands are created AFTER the operation completes,\n * not before. The constructor captures the final state.\n *\n * ## Extracting These Patterns\n *\n * To create new command types:\n *\n * ```typescript\n * export class MyCommand implements Command {\n * // Capture state needed for undo/redo\n * private beforeState: any;\n * private afterState: any;\n *\n * constructor(params) {\n * // Deep clone to prevent mutations\n * this.beforeState = JSON.parse(JSON.stringify(before));\n * this.afterState = JSON.parse(JSON.stringify(after));\n * }\n *\n * undo(): void {\n * // Restore before state\n * restoreState(this.beforeState);\n * gridState.canvases = { ...gridState.canvases };  // Trigger reactivity\n * }\n *\n * redo(): void {\n * // Apply after state\n * restoreState(this.afterState);\n * gridState.canvases = { ...gridState.canvases };\n * }\n * }\n * ```\n *\n * **Guidelines**:\n * - Always deep clone state in constructor\n * - Always trigger reactivity (`gridState.canvases = { ...gridState.canvases }`)\n * - Handle null cases (canvas/item not found)\n * - Clear selection if needed\n * - Preserve array indices for positional restore\n * @module undo-redo-commands\n */\n\nimport {\n  addItemToCanvas,\n  GridItem,\n  gridState,\n  setItemZIndex,\n  updateItem as updateItemInState,\n  deleteItemsBatch,\n  updateItemsBatch,\n} from \"./state-manager\";\nimport { Command } from \"./undo-redo\";\nimport { eventManager } from \"./event-manager\";\nimport { createDebugLogger } from \"../utils/debug\";\n\nconst debug = createDebugLogger(\"undo-redo-commands\");\n\n/**\n * Helper function to remove an item from a canvas and clear selection\n *\n * **Responsibilities**:\n * - Remove item from canvas items array\n * - Trigger state reactivity (spread pattern)\n * - Clear selection if deleted item was selected\n *\n * **Used by**:\n * - AddItemCommand.undo() - Remove just-added item\n * - DeleteItemCommand.redo() - Remove item again\n * - MoveItemCommand (implicitly via filter)\n *\n * **Why helper function**:\n * - DRY principle (used in multiple commands)\n * - Encapsulates selection clearing logic\n * - Consistent behavior across commands\n *\n * **Selection clearing**:\n * Prevents dangling references and UI errors when selected item deleted.\n * @param canvasId - Canvas containing the item\n * @param itemId - Item to remove\n * @example\n * ```typescript\n * // Used internally by commands\n * undo() {\n *   removeItemFromCanvas(this.canvasId, this.item.id);\n * }\n * ```\n */\nfunction removeItemFromCanvas(canvasId: string, itemId: string): void {\n  const canvas = gridState.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((i) => i.id !== itemId);\n  gridState.canvases = { ...gridState.canvases };\n\n  // Clear selection if this item was selected\n  if (gridState.selectedItemId === itemId) {\n    gridState.selectedItemId = null;\n    gridState.selectedCanvasId = null;\n  }\n}\n\n/**\n * AddItemCommand\n * ==============\n *\n * Captures the addition of a new grid item to a canvas, enabling undo/redo\n * for create operations.\n *\n * ## Use Cases\n *\n * - User drops component from palette onto canvas\n * - Programmatic item creation (stress tests, templates)\n * - Duplicating existing items\n *\n * ## Command Lifecycle\n *\n * **Creation**: After item already added to canvas\n * ```typescript\n * // 1. Add item to canvas (operation completes)\n * addItemToCanvas('canvas1', newItem);\n *\n * // 2. Create command for undo (captures final state)\n * const command = new AddItemCommand('canvas1', newItem);\n * pushCommand(command);\n * ```\n *\n * **Undo**: Remove the item from canvas\n * ```typescript\n * command.undo(); // Item disappears from canvas\n * ```\n *\n * **Redo**: Re-add the item to canvas\n * ```typescript\n * command.redo(); // Item reappears in canvas\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures item state with deep clone\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Prevents mutations from affecting command's snapshot\n * - Item might be modified after command creation\n * - Ensures redo restores exact original state\n *\n * **Redo cloning**: Creates fresh copy for state mutation\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.push(itemCopy);\n * ```\n *\n * **Why redo also clones**:\n * - Multiple redo calls shouldn't share references\n * - Prevents undo/redo from affecting each other\n * - Safe state isolation\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: redo() returns early if canvas not found\n * - **Item modified**: Command stores original state, not current\n * - **Selection**: undo() automatically clears selection via helper\n * @example\n * ```typescript\n * // After palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(),\n *   canvasId: 'canvas1',\n *   type: 'header',\n *   name: 'Header',\n *   layouts: { desktop: { x: 5, y: 5, width: 20, height: 8 }, ... },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n *\n * addItemToCanvas('canvas1', newItem);\n * pushCommand(new AddItemCommand('canvas1', newItem));\n * ```\n */\nexport class AddItemCommand implements Command {\n  /** Deep clone of item at creation time */\n  private item: GridItem;\n\n  /** Canvas ID where item was added */\n  private canvasId: string;\n\n  /**\n   * Capture item addition operation\n   *\n   * **Important**: Call AFTER item added to canvas (not before)\n   *\n   * **Deep clones item**: Prevents future mutations from affecting snapshot\n   * @param canvasId - Canvas where item was added\n   * @param item - Item that was added (will be deep cloned)\n   */\n  constructor(canvasId: string, item: GridItem) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state at time of creation\n    this.item = JSON.parse(JSON.stringify(item));\n  }\n\n  /**\n   * Undo: Remove the item from canvas\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  undo(): void {\n    // Remove the item from the canvas\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n\n  /**\n   * Redo: Re-add the item to canvas\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Appends to end**: Doesn't preserve original index (acceptable for add)\n   *\n   * **Side effects**:\n   * - Item added to end of canvas.items array\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found (e.g., canvas was deleted)\n   */\n  redo(): void {\n    // Re-add the item to the canvas\n    const canvas = gridState.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Use the cloned item state\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    canvas.items.push(itemCopy);\n    gridState.canvases = { ...gridState.canvases };\n  }\n}\n\n/**\n * DeleteItemCommand\n * ==================\n *\n * Captures the deletion of a grid item from a canvas, enabling undo/redo\n * for delete operations with index preservation.\n *\n * ## Use Cases\n *\n * - User deletes item with Delete key\n * - Delete button clicked\n * - Programmatic item removal\n * - Clearing canvas sections\n *\n * ## Index Preservation Pattern\n *\n * **Critical feature**: Restores deleted item at its ORIGINAL array position\n *\n * **Why important**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * **Implementation**:\n * ```typescript\n * constructor(canvasId, item, itemIndex) {\n * this.itemIndex = itemIndex;  // Capture before deletion!\n * }\n *\n * undo() {\n * canvas.items.splice(this.itemIndex, 0, itemCopy);  // Restore at index\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE deleting item (to capture index)\n * ```typescript\n * // 1. Get item and its index BEFORE deletion\n * const item = getItem('canvas1', 'item-5');\n * const index = gridState.canvases['canvas1'].items.indexOf(item);\n *\n * // 2. Create command (captures item and index)\n * const command = new DeleteItemCommand('canvas1', item, index);\n *\n * // 3. Perform deletion\n * removeItemFromCanvas('canvas1', 'item-5');\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Restore item at original position\n * ```typescript\n * command.undo(); // Item reappears at exact original position\n * ```\n *\n * **Redo**: Delete item again\n * ```typescript\n * command.redo(); // Item disappears (and selection cleared if selected)\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures complete item state before deletion\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Item will be deleted from state immediately after\n * - Reference would become invalid after deletion\n * - Must preserve complete state for restoration\n *\n * **Undo cloning**: Creates fresh copy for state insertion\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.splice(this.itemIndex, 0, itemCopy);\n * ```\n *\n * ## Selection State Handling\n *\n * **Redo behavior**: Delegates to removeItemFromCanvas helper\n *\n * **Helper automatically**:\n * - Clears selectedItemId if this item was selected\n * - Clears selectedCanvasId\n * - Prevents dangling references\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: undo() returns early if canvas not found\n * - **Invalid index**: Falls back to push() if index out of bounds\n * - **Item modified before delete**: Command stores pre-deletion state\n * - **Multiple deletes**: Each command independently tracks its item\n * @example\n * ```typescript\n * // Handle Delete key press\n * handleDeleteKey() {\n *   if (!gridState.selectedItemId || !gridState.selectedCanvasId) {\n *     return;\n *   }\n *\n *   const item = getItem(gridState.selectedCanvasId, gridState.selectedItemId);\n *   const canvas = gridState.canvases[gridState.selectedCanvasId];\n *   const index = canvas.items.indexOf(item);\n *\n *   // Create command before deleting\n *   const command = new DeleteItemCommand(\n *     gridState.selectedCanvasId,\n *     item,\n *     index\n *   );\n *\n *   // Perform deletion\n *   removeItemFromCanvas(gridState.selectedCanvasId, gridState.selectedItemId);\n *\n *   // Enable undo\n *   pushCommand(command);\n * }\n * ```\n */\nexport class DeleteItemCommand implements Command {\n  /** Deep clone of item before deletion */\n  private item: GridItem;\n\n  /** Canvas ID where item was deleted from */\n  private canvasId: string;\n\n  /** Original array index for position restoration */\n  private itemIndex: number;\n\n  /**\n   * Capture item deletion operation\n   *\n   * **Important**: Call BEFORE deleting item (to capture index)\n   *\n   * **Deep clones item**: Preserves state before deletion\n   *\n   * **Captures index**: Critical for restoring at original position\n   * @param canvasId - Canvas containing the item\n   * @param item - Item being deleted (will be deep cloned)\n   * @param itemIndex - Original array index (call indexOf before deletion!)\n   */\n  constructor(canvasId: string, item: GridItem, itemIndex: number) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state before deletion\n    this.item = JSON.parse(JSON.stringify(item));\n    this.itemIndex = itemIndex;\n  }\n\n  /**\n   * Undo: Restore item at original position\n   *\n   * **Index preservation**: Uses splice to insert at exact original position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive coding)\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Side effects**:\n   * - Item restored to canvas.items array at original index\n   * - Other items shift to make room\n   * - Z-index order maintained (items render in array order)\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found\n   */\n  undo(): void {\n    // Re-add the item to its original position\n    const canvas = gridState.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    // Insert at original index if possible, otherwise push to end\n    if (this.itemIndex >= 0 && this.itemIndex <= canvas.items.length) {\n      canvas.items.splice(this.itemIndex, 0, itemCopy);\n    } else {\n      canvas.items.push(itemCopy);\n    }\n    gridState.canvases = { ...gridState.canvases };\n  }\n\n  /**\n   * Redo: Delete item again\n   *\n   * **Delegates to helper**: Uses removeItemFromCanvas for consistency\n   *\n   * **Automatic selection clearing**: Helper clears selection if this item selected\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  redo(): void {\n    // Remove the item again\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n}\n\n/**\n * MoveItemCommand\n * ===============\n *\n * Captures the movement of a grid item within the same canvas or across canvases,\n * enabling undo/redo for drag operations with position and index preservation.\n *\n * ## Use Cases\n *\n * - User drags item to new position in same canvas\n * - User drags item across canvas boundaries (cross-canvas move)\n * - Programmatic item repositioning\n * - Layout reorganization\n *\n * ## Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between different canvases\n *\n * **Solution**: Track both source and target canvas IDs\n *\n * **Same-canvas move**:\n * ```typescript\n * sourceCanvasId === targetCanvasId\n * // Only position changes, no canvas transfer\n * ```\n *\n * **Cross-canvas move**:\n * ```typescript\n * sourceCanvasId !== targetCanvasId\n * // Item removed from source, added to target\n * // Position updated to target coordinates\n * ```\n *\n * ## Position Tracking\n *\n * **Dual position capture**:\n * - `sourcePosition`: { x, y } before drag\n * - `targetPosition`: { x, y } after drag\n *\n * **Why both needed**:\n * - Undo must restore original position\n * - Redo must restore final position\n * - Positions are in grid coordinates (not pixels)\n *\n * ## Index Preservation Pattern\n *\n * **Critical for undo**: Restore item at original array position in source canvas\n *\n * **Why important**:\n * - Maintains visual z-order consistency\n * - Restores exact pre-drag state\n * - Items render in array order\n *\n * **Implementation**:\n * ```typescript\n * // Capture source index before move\n * const sourceIndex = sourceCanvas.items.indexOf(item);\n *\n * // Restore at index on undo\n * sourceCanvas.items.splice(sourceIndex, 0, item);\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE drag operation (capture source state)\n * ```typescript\n * // 1. Capture state before drag starts\n * const sourceIndex = canvas.items.indexOf(item);\n * const sourcePos = { x: item.layouts.desktop.x, y: item.layouts.desktop.y };\n *\n * // 2. Drag completes (position updated in DOM)\n * // ...\n *\n * // 3. Create command with before/after state\n * const command = new MoveItemCommand(\n * item.id,\n * sourceCanvasId,\n * targetCanvasId,  // May be same as source\n * sourcePos,\n * targetPos,       // New position after drag\n * sourceIndex\n * );\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Move back to source at original position\n * ```typescript\n * command.undo();\n * // Item returns to source canvas at original index\n * // Position restored to sourcePosition\n * ```\n *\n * **Redo**: Move to target at new position\n * ```typescript\n * command.redo();\n * // Item moves to target canvas (appended to end)\n * // Position updated to targetPosition\n * ```\n *\n * ## State Mutation Pattern\n *\n * **Unlike Add/Delete**: Does NOT deep clone item\n *\n * **Why reference-based**:\n * - Same item object moves between canvases\n * - Only position properties mutated\n * - Efficient (no serialization overhead)\n * - Item identity preserved (same ID, zIndex, etc.)\n *\n * **What gets cloned**:\n * ```typescript\n * // Only position objects cloned (shallow)\n * this.sourcePosition = { ...sourcePosition };\n * this.targetPosition = { ...targetPosition };\n * ```\n *\n * ## Position Coordinates\n *\n * **Uses desktop layout**: `item.layouts.desktop.x/y`\n *\n * **Why desktop**:\n * - Drag handler operates on desktop coordinates\n * - Mobile layout auto-generated or separately customized\n * - Single source of truth for command\n *\n * **Grid units**: Positions stored in grid units (not pixels)\n *\n * ## Canvas Mutation Flow\n *\n * **Undo sequence** (target → source):\n * 1. Find item in target canvas\n * 2. Remove from target.items array\n * 3. Update item.canvasId to source\n * 4. Update item position to sourcePosition\n * 5. Insert at sourceIndex in source.items\n * 6. Trigger reactivity\n *\n * **Redo sequence** (source → target):\n * 1. Find item in source canvas\n * 2. Remove from source.items array\n * 3. Update item.canvasId to target\n * 4. Update item position to targetPosition\n * 5. Append to target.items (no index preservation for redo)\n * 6. Trigger reactivity\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: Both undo/redo return early if canvas not found\n * - **Item not found**: Returns early (defensive coding)\n * - **Same position move**: Creates valid command (user expectation)\n * - **Invalid source index**: Fallback to append (defensive)\n * @example\n * ```typescript\n * // After drag end event\n * handleDragEnd(event) {\n *   const item = getItem(sourceCanvasId, itemId);\n *   const sourceIndex = gridState.canvases[sourceCanvasId].items.indexOf(item);\n *\n *   const command = new MoveItemCommand(\n *     itemId,\n *     sourceCanvasId,\n *     targetCanvasId,  // Detected from drop target\n *     { x: oldX, y: oldY },  // Captured on drag start\n *     { x: newX, y: newY },  // Calculated from drop position\n *     sourceIndex\n *   );\n *\n *   pushCommand(command);\n * }\n * ```\n */\nexport class MoveItemCommand implements Command {\n  /** Item ID (reference to item, not deep clone) */\n  private itemId: string;\n\n  /** Canvas ID where item started */\n  private sourceCanvasId: string;\n\n  /** Canvas ID where item ended (may equal source for same-canvas move) */\n  private targetCanvasId: string;\n\n  /** Position before drag (grid coordinates) */\n  private sourcePosition: { x: number; y: number };\n\n  /** Position after drag (grid coordinates) */\n  private targetPosition: { x: number; y: number };\n\n  /** Size before operation (grid units) - optional for resize tracking */\n  private sourceSize?: { width: number; height: number };\n\n  /** Size after operation (grid units) - optional for resize tracking */\n  private targetSize?: { width: number; height: number };\n\n  /** Z-index in source canvas (for undo restoration) */\n  private sourceZIndex: number;\n\n  /**\n   * Z-index in target canvas (assigned during cross-canvas move)\n   *\n   * **Cross-canvas behavior**:\n   * - Same canvas move: sourceZIndex === targetZIndex (no change)\n   * - Cross-canvas move: targetZIndex = targetCanvas.zIndexCounter++ (new z-index)\n   *\n   * **Why needed**:\n   * - Prevents z-index conflicts between canvases\n   * - Each canvas has independent z-index space\n   * - Undo must restore original z-index in source canvas\n   */\n  private targetZIndex: number;\n\n  /** Original array index in source canvas (for undo restoration) */\n  private sourceIndex: number;\n\n  /**\n   * Capture item move operation\n   *\n   * **Important**: Item should already be at target position\n   *\n   * **Shallow position clone**: Prevents mutation of passed objects\n   *\n   * **No item clone**: Uses reference-based approach (item ID tracking)\n   *\n   * **Resize support**: Optional size parameters track width/height changes\n   *\n   * **Z-index handling**:\n   * - Same canvas: sourceZIndex === targetZIndex (no change)\n   * - Cross-canvas: targetZIndex assigned from targetCanvas.zIndexCounter++\n   * @param itemId - ID of moved item\n   * @param sourceCanvasId - Canvas where item started\n   * @param targetCanvasId - Canvas where item ended\n   * @param sourcePosition - Position before drag (will be shallow cloned)\n   * @param targetPosition - Position after drag (will be shallow cloned)\n   * @param sourceIndex - Original array index in source canvas\n   * @param sourceZIndex - Z-index in source canvas (for undo restoration)\n   * @param targetZIndex - Z-index in target canvas (assigned during move)\n   * @param sourceSize - Optional: Size before operation (for resize tracking)\n   * @param targetSize - Optional: Size after operation (for resize tracking)\n   */\n  constructor(\n    itemId: string,\n    sourceCanvasId: string,\n    targetCanvasId: string,\n    sourcePosition: { x: number; y: number },\n    targetPosition: { x: number; y: number },\n    sourceIndex: number,\n    sourceZIndex: number,\n    targetZIndex: number,\n    sourceSize?: { width: number; height: number },\n    targetSize?: { width: number; height: number },\n  ) {\n    this.itemId = itemId;\n    this.sourceCanvasId = sourceCanvasId;\n    this.targetCanvasId = targetCanvasId;\n    this.sourcePosition = { ...sourcePosition };\n    this.targetPosition = { ...targetPosition };\n    this.sourceIndex = sourceIndex;\n    this.sourceZIndex = sourceZIndex;\n    this.targetZIndex = targetZIndex;\n    this.sourceSize = sourceSize ? { ...sourceSize } : undefined;\n    this.targetSize = targetSize ? { ...targetSize } : undefined;\n  }\n\n  /**\n   * Undo: Move item back to source canvas at original position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from target canvas\n   * - Updates canvasId back to source\n   * - Restores source position\n   * - Inserts at original index in source\n   *\n   * **Index preservation**: Uses splice to restore exact array position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive)\n   *\n   * **Side effects**:\n   * - Item removed from target canvas\n   * - Item added to source canvas at original index\n   * - Item position updated to sourcePosition\n   * - Item canvasId updated to sourceCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  undo(): void {\n    debug.log(\"🔙 MoveItemCommand.undo()\", {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in target canvas first\n    let targetCanvas = gridState.canvases[this.targetCanvasId];\n    let item = targetCanvas?.items.find((i) => i.id === this.itemId);\n\n    // If target canvas doesn't exist or item not found there, search all canvases\n    // This handles the case where the target canvas was deleted\n    if (!item) {\n      for (const canvasId in gridState.canvases) {\n        const canvas = gridState.canvases[canvasId];\n        item = canvas.items.find((i) => i.id === this.itemId);\n        if (item) {\n          targetCanvas = canvas;\n          break;\n        }\n      }\n    }\n\n    if (!item || !targetCanvas) {\n      console.warn(\"  ❌ Item or canvas not found, aborting undo\");\n      return;\n    }\n\n    debug.log(\"  📍 Found item, current position:\", {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Remove from current canvas (wherever it is)\n    targetCanvas.items = targetCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's position, z-index, and canvasId back to source\n    item.canvasId = this.sourceCanvasId;\n    item.layouts.desktop.x = this.sourcePosition.x;\n    item.layouts.desktop.y = this.sourcePosition.y;\n    item.zIndex = this.sourceZIndex;\n\n    debug.log(\"  ✅ Updated item position and z-index to:\", {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n      zIndex: item.zIndex,\n    });\n\n    // Restore size if it was tracked (for resize operations)\n    if (this.sourceSize) {\n      item.layouts.desktop.width = this.sourceSize.width;\n      item.layouts.desktop.height = this.sourceSize.height;\n    }\n\n    // Add back to source canvas at original index\n    const sourceCanvas = gridState.canvases[this.sourceCanvasId];\n    if (!sourceCanvas) {\n      console.warn(\"  ❌ Source canvas not found, aborting undo\");\n      return;\n    }\n\n    if (\n      this.sourceIndex >= 0 &&\n      this.sourceIndex <= sourceCanvas.items.length\n    ) {\n      sourceCanvas.items.splice(this.sourceIndex, 0, item);\n    } else {\n      sourceCanvas.items.push(item);\n    }\n\n    // Trigger state update\n    gridState.canvases = { ...gridState.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log(\"  🎨 Clearing inline transform style\");\n      element.style.transform = \"\";\n    }\n\n    debug.log(\"  ✅ Undo complete\");\n  }\n\n  /**\n   * Redo: Move item to target canvas at final position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from source canvas\n   * - Updates canvasId to target\n   * - Restores target position\n   * - Appends to target canvas (no index preservation for redo)\n   *\n   * **No index preservation for redo**: Appends to end of target array\n   * (undo needs original index, redo doesn't)\n   *\n   * **Side effects**:\n   * - Item removed from source canvas\n   * - Item added to end of target canvas\n   * - Item position updated to targetPosition\n   * - Item canvasId updated to targetCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  redo(): void {\n    debug.log(\"🔜 MoveItemCommand.redo()\", {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in source canvas\n    const sourceCanvas = gridState.canvases[this.sourceCanvasId];\n    const item = sourceCanvas?.items.find((i) => i.id === this.itemId);\n    if (!item) {\n      console.warn(\"  ❌ Item not found, aborting redo\");\n      return;\n    }\n\n    debug.log(\"  📍 Found item, current position:\", {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Remove from source canvas\n    sourceCanvas.items = sourceCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's position, z-index, and canvasId to target\n    item.canvasId = this.targetCanvasId;\n    item.layouts.desktop.x = this.targetPosition.x;\n    item.layouts.desktop.y = this.targetPosition.y;\n    item.zIndex = this.targetZIndex;\n\n    debug.log(\"  ✅ Updated item position and z-index to:\", {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n      zIndex: item.zIndex,\n    });\n\n    // Restore size if it was tracked (for resize operations)\n    if (this.targetSize) {\n      item.layouts.desktop.width = this.targetSize.width;\n      item.layouts.desktop.height = this.targetSize.height;\n    }\n\n    // Add to target canvas\n    const targetCanvas = gridState.canvases[this.targetCanvasId];\n    if (!targetCanvas) {\n      console.warn(\"  ❌ Target canvas not found, aborting redo\");\n      return;\n    }\n\n    targetCanvas.items.push(item);\n\n    // Trigger state update\n    gridState.canvases = { ...gridState.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log(\"  🎨 Clearing inline transform style\");\n      element.style.transform = \"\";\n    }\n\n    debug.log(\"  ✅ Redo complete\");\n  }\n}\n\n/**\n * UpdateItemCommand - Update item properties\n *\n * Records old item state and applies updates\n */\nexport class UpdateItemCommand implements Command {\n  constructor(\n    private canvasId: string,\n    private itemId: string,\n    private oldItem: GridItem,\n    private updates: Partial<GridItem>,\n  ) {}\n\n  undo(): void {\n    updateItemInState(this.canvasId, this.itemId, this.oldItem);\n  }\n\n  redo(): void {\n    updateItemInState(this.canvasId, this.itemId, this.updates);\n  }\n}\n\n/**\n * RemoveItemCommand - Remove item from canvas\n *\n * Stores removed item for restoration\n */\nexport class RemoveItemCommand implements Command {\n  constructor(\n    private canvasId: string,\n    private item: GridItem,\n  ) {}\n\n  undo(): void {\n    addItemToCanvas(this.canvasId, this.item);\n  }\n\n  redo(): void {\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n}\n\n/**\n * SetViewportCommand - Change current viewport\n *\n * Stores old and new viewport states\n */\nexport class SetViewportCommand implements Command {\n  constructor(\n    private oldViewport: \"desktop\" | \"mobile\",\n    private newViewport: \"desktop\" | \"mobile\",\n  ) {}\n\n  undo(): void {\n    gridState.currentViewport = this.oldViewport;\n  }\n\n  redo(): void {\n    gridState.currentViewport = this.newViewport;\n  }\n}\n\n/**\n * ToggleGridCommand - Toggle grid visibility\n *\n * Stores old and new visibility states\n */\nexport class ToggleGridCommand implements Command {\n  constructor(\n    private oldValue: boolean,\n    private newValue: boolean,\n  ) {}\n\n  undo(): void {\n    gridState.showGrid = this.oldValue;\n  }\n\n  redo(): void {\n    gridState.showGrid = this.newValue;\n  }\n}\n\n/**\n * BatchAddCommand - Add multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n * Reduces undo stack size and provides atomic undo/redo for batch operations.\n *\n * **Use cases**:\n * - Stress test (add 100+ items at once)\n * - Template application (add multiple pre-configured items)\n * - Undo batch delete operation\n * - Import from file (restore multiple items)\n *\n * **Undo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Re-adds all items with original IDs and properties\n * - Maintains z-index and positioning\n * - Single state update, single re-render\n */\nexport class BatchAddCommand implements Command {\n  private itemsData: GridItem[];\n\n  constructor(itemIds: string[]) {\n    // Store full item data for redo (deep clone to prevent mutations)\n    this.itemsData = itemIds\n      .map((id) => {\n        const item = Object.values(gridState.canvases)\n          .flatMap((canvas) => canvas.items)\n          .find((i) => i.id === id);\n        return item ? JSON.parse(JSON.stringify(item)) : null;\n      })\n      .filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n    deleteItemsBatch(itemIds);\n  }\n\n  redo(): void {\n    // Re-add all items (addItemsBatch will generate new IDs, so we need custom logic)\n    const updatedCanvases = { ...gridState.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    gridState.canvases = updatedCanvases;\n  }\n}\n\n/**\n * BatchDeleteCommand - Delete multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n *\n * **Use cases**:\n * - Clear canvas (delete all items)\n * - Delete selection group\n * - Undo batch add operation\n * - Bulk cleanup operations\n *\n * **Undo behavior**:\n * - Re-adds all items with original properties and positions\n * - Maintains z-index and canvas placement\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchDeleteCommand implements Command {\n  private itemsData: GridItem[];\n\n  constructor(itemIds: string[]) {\n    // Store full item data for undo (deep clone to prevent mutations)\n    this.itemsData = itemIds\n      .map((id) => {\n        const item = Object.values(gridState.canvases)\n          .flatMap((canvas) => canvas.items)\n          .find((i) => i.id === id);\n        return item ? JSON.parse(JSON.stringify(item)) : null;\n      })\n      .filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Re-add all items (same logic as BatchAddCommand.redo)\n    const updatedCanvases = { ...gridState.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    gridState.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n    deleteItemsBatch(itemIds);\n  }\n}\n\n/**\n * BatchUpdateConfigCommand - Update multiple item configs in a single batch\n *\n * **Performance benefit**: 1 undo/redo command for N config updates instead of N commands.\n *\n * **Use cases**:\n * - Theme changes (update colors for all headers)\n * - Bulk property changes (set all text sizes to 16px)\n * - Template application (apply preset configs)\n * - Undo/redo bulk config changes\n *\n * **Undo behavior**:\n * - Restores all old configs in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Applies all new configs in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchUpdateConfigCommand implements Command {\n  private updates: {\n    itemId: string;\n    canvasId: string;\n    oldItem: GridItem;\n    newItem: GridItem;\n  }[];\n\n  constructor(\n    updates: {\n      itemId: string;\n      canvasId: string;\n      updates: Partial<GridItem>;\n    }[],\n  ) {\n    // Store old and new state for each item (deep clone to prevent mutations)\n    this.updates = updates\n      .map(({ itemId, canvasId, updates: itemUpdates }) => {\n        const canvas = gridState.canvases[canvasId];\n        const item = canvas?.items.find((i) => i.id === itemId);\n\n        if (!item) {\n          return null;\n        }\n\n        return {\n          itemId,\n          canvasId,\n          oldItem: JSON.parse(JSON.stringify(item)),\n          newItem: JSON.parse(JSON.stringify({ ...item, ...itemUpdates })),\n        };\n      })\n      .filter(Boolean) as {\n      itemId: string;\n      canvasId: string;\n      oldItem: GridItem;\n      newItem: GridItem;\n    }[];\n  }\n\n  undo(): void {\n    // Restore old configs\n    const batchUpdates = this.updates.map(({ itemId, canvasId, oldItem }) => ({\n      itemId,\n      canvasId,\n      updates: oldItem,\n    }));\n    updateItemsBatch(batchUpdates);\n  }\n\n  redo(): void {\n    // Apply new configs\n    const batchUpdates = this.updates.map(({ itemId, canvasId, newItem }) => ({\n      itemId,\n      canvasId,\n      updates: newItem,\n    }));\n    updateItemsBatch(batchUpdates);\n  }\n}\n\n/**\n * AddCanvasCommand\n * =================\n *\n * Undoable command for adding a canvas to the grid.\n *\n * **Pattern**: Host app owns canvas metadata, library manages item placement\n *\n * **Library responsibility** (what this command does):\n * - Create canvas in gridState.canvases with empty items array\n * - Initialize zIndexCounter for item stacking\n * - Track operation in undo/redo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or other metadata\n * - Host app maintains its own canvas metadata separately\n * - Host app listens to canvasAdded event to sync its state\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app maintains canvas metadata\n * const canvasMetadata = {\n * 'section-1': { title: 'Hero Section', backgroundColor: '#f0f4f8' }\n * };\n *\n * // Create canvas in library (just placement state)\n * const cmd = new AddCanvasCommand('section-1');\n * pushCommand(cmd); // Add to undo/redo stack\n * cmd.redo(); // Creates canvas with items: [], zIndexCounter: 1\n *\n * // Host app listens to event and syncs its own state\n * api.on('canvasAdded', (event) => {\n * // Host app can now add its own metadata\n * });\n * ```\n *\n * **Why this separation**:\n * - Library focuses on layout (items, positions, z-index)\n * - Host app owns presentation (styling, titles, metadata)\n * - Different apps can use library with different data models\n */\nexport class AddCanvasCommand implements Command {\n  description = \"Add Canvas\";\n  private canvasId: string;\n  private stateInstance: any; // GridState instance\n  private eventManagerInstance: any; // EventManager instance\n\n  constructor(canvasId: string, stateInstance: any, eventManagerInstance: any) {\n    this.canvasId = canvasId;\n    this.stateInstance = stateInstance;\n    this.eventManagerInstance = eventManagerInstance;\n  }\n\n  undo(): void {\n    debug.log(\"🔙 AddCanvasCommand.undo() - removing canvas:\", this.canvasId);\n\n    // Remove canvas from instance state\n    delete this.stateInstance.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    debug.log(\"  📢 Emitting canvasRemoved event for:\", this.canvasId);\n    this.eventManagerInstance.emit(\"canvasRemoved\", { canvasId: this.canvasId });\n  }\n\n  redo(): void {\n    // Add canvas to instance state (minimal - just item placement management)\n    this.stateInstance.canvases[this.canvasId] = {\n      zIndexCounter: 1,\n      items: [],\n    };\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    this.eventManagerInstance.emit(\"canvasAdded\", { canvasId: this.canvasId });\n  }\n}\n\n/**\n * RemoveCanvasCommand\n * ====================\n *\n * Undoable command for removing a canvas from the grid.\n *\n * **Critical**: Snapshots canvas items and zIndexCounter before removal\n *\n * **Library responsibility** (what this command does):\n * - Snapshot canvas items array and zIndexCounter\n * - Remove canvas from gridState.canvases\n * - Restore canvas with all items on undo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or metadata\n * - Host app must listen to canvasRemoved event\n * - Host app must manage its own metadata undo/redo separately\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app listens to events and manages its own metadata\n * api.on('canvasRemoved', (event) => {\n * // Host app removes its own metadata\n * delete canvasMetadata[event.canvasId];\n * });\n *\n * api.on('canvasAdded', (event) => {\n * // On undo of remove, host app restores metadata\n * if (wasUndoOperation) {\n * canvasMetadata[event.canvasId] = savedMetadata;\n * }\n * });\n *\n * // Remove canvas\n * const cmd = new RemoveCanvasCommand('section-1');\n * pushCommand(cmd);\n * cmd.redo(); // Removes canvas from library\n * ```\n *\n * **Edge case handling**:\n * - Canvas doesn't exist: command becomes no-op\n * - Canvas has items: all items removed with canvas\n * - Undo restores items with original layouts and zIndex\n */\nexport class RemoveCanvasCommand implements Command {\n  description = \"Remove Canvas\";\n  private canvasId: string;\n  private stateInstance: any; // GridState instance\n  private eventManagerInstance: any; // EventManager instance\n  private canvasSnapshot: {\n    zIndexCounter: number;\n    items: GridItem[];\n  } | null = null;\n\n  constructor(canvasId: string, stateInstance: any, eventManagerInstance: any) {\n    this.canvasId = canvasId;\n    this.stateInstance = stateInstance;\n    this.eventManagerInstance = eventManagerInstance;\n\n    // Snapshot canvas state (deep clone to prevent mutations)\n    const canvas = this.stateInstance.canvases[canvasId];\n    if (canvas) {\n      this.canvasSnapshot = JSON.parse(JSON.stringify(canvas));\n    }\n  }\n\n  undo(): void {\n    // Restore canvas from snapshot (just layout state, no metadata)\n    if (this.canvasSnapshot) {\n      this.stateInstance.canvases[this.canvasId] = JSON.parse(\n        JSON.stringify(this.canvasSnapshot),\n      );\n\n      // Trigger state change for reactivity\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n      // Emit event so host app can sync its metadata\n      this.eventManagerInstance.emit(\"canvasAdded\", { canvasId: this.canvasId });\n    }\n  }\n\n  redo(): void {\n    // Remove canvas from instance state\n    delete this.stateInstance.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    this.eventManagerInstance.emit(\"canvasRemoved\", { canvasId: this.canvasId });\n  }\n}\n\n/**\n * Change Z-Index Command\n * ======================\n *\n * Handles undo/redo for z-index changes (layer reordering).\n * Supports both single-item changes and multi-item swaps.\n *\n * **Use cases**:\n * - Layer panel drag-to-reorder (swap with other item)\n * - Bring to front / send to back (single item)\n * - Move forward / move backward (swap with adjacent item)\n * - Direct z-index assignment (single item)\n *\n * **What it captures**:\n * - Array of z-index changes (supports cascading/swap operations)\n * - Each change: { itemId, canvasId, oldZIndex, newZIndex }\n *\n * **Why array-based**:\n * - Move forward/backward swaps z-index with adjacent item (2 items affected)\n * - Drag-to-reorder can shuffle multiple items\n * - Undo must atomically restore all affected items\n *\n * **Operation**:\n * - Uses `setItemZIndex` from state-manager for each item\n * - Updates all items' zIndex properties in single undo/redo operation\n * - Maintains canvas zIndexCounter\n * - Triggers reactivity once for UI updates\n * - Emits events for layer panel to update\n *\n * **Example usage**:\n * ```typescript\n * // Single item: Bring to front\n * const result = bringItemToFront('canvas1', 'item-3');\n * if (result) {\n * const cmd = new ChangeZIndexCommand([{\n * itemId: 'item-3',\n * canvasId: 'canvas1',\n * oldZIndex: result.oldZIndex,\n * newZIndex: result.newZIndex\n * }]);\n * undoRedoManager.push(cmd);\n * }\n *\n * // Swap operation: Move forward (affects 2 items)\n * // moveItemForward swaps z-index with next item\n * const changes = [\n * { itemId: 'item-3', canvasId: 'canvas1', oldZIndex: 5, newZIndex: 7 },\n * { itemId: 'item-7', canvasId: 'canvas1', oldZIndex: 7, newZIndex: 5 }\n * ];\n * const cmd = new ChangeZIndexCommand(changes);\n * undoRedoManager.push(cmd);\n * ```\n *\n * **Edge case handling**:\n * - Item doesn't exist: skips that item (doesn't fail entire command)\n * - Canvas doesn't exist: skips that item\n * - Undo restores exact z-index values for all items\n * - Maintains visual layer order across all affected items\n */\nexport class ChangeZIndexCommand implements Command {\n  description: string;\n  private changes: {\n    itemId: string;\n    canvasId: string;\n    oldZIndex: number;\n    newZIndex: number;\n  }[];\n\n  constructor(\n    changes: {\n      itemId: string;\n      canvasId: string;\n      oldZIndex: number;\n      newZIndex: number;\n    }[],\n  ) {\n    this.changes = changes;\n\n    // Descriptive message for command history\n    if (changes.length === 1) {\n      const change = changes[0];\n      this.description = `Change Z-Index (${change.oldZIndex} → ${change.newZIndex})`;\n    } else {\n      this.description = `Reorder ${changes.length} Layers`;\n    }\n  }\n\n  undo(): void {\n    // Restore old z-index for all affected items\n    this.changes.forEach((change) => {\n      const result = setItemZIndex(\n        change.canvasId,\n        change.itemId,\n        change.oldZIndex,\n      );\n\n      if (result) {\n        debug.log(\n          `Undo z-index change: ${change.itemId} from ${result.newZIndex} to ${result.oldZIndex}`,\n        );\n      }\n    });\n\n    // Emit single event (batch or individual based on change count)\n    if (this.changes.length === 1) {\n      const change = this.changes[0];\n      eventManager.emit(\"zIndexChanged\", {\n        itemId: change.itemId,\n        canvasId: change.canvasId,\n        oldZIndex: change.newZIndex, // Swapped for undo\n        newZIndex: change.oldZIndex,\n      });\n    } else {\n      // Emit batch event for atomic update\n      eventManager.emit(\"zIndexBatchChanged\", {\n        changes: this.changes.map((change) => ({\n          itemId: change.itemId,\n          canvasId: change.canvasId,\n          oldZIndex: change.newZIndex, // Swapped for undo\n          newZIndex: change.oldZIndex,\n        })),\n      });\n    }\n  }\n\n  redo(): void {\n    // Reapply new z-index for all affected items\n    this.changes.forEach((change) => {\n      const result = setItemZIndex(\n        change.canvasId,\n        change.itemId,\n        change.newZIndex,\n      );\n\n      if (result) {\n        debug.log(\n          `Redo z-index change: ${change.itemId} from ${result.oldZIndex} to ${result.newZIndex}`,\n        );\n      }\n    });\n\n    // Emit single event (batch or individual based on change count)\n    if (this.changes.length === 1) {\n      const change = this.changes[0];\n      eventManager.emit(\"zIndexChanged\", {\n        itemId: change.itemId,\n        canvasId: change.canvasId,\n        oldZIndex: change.oldZIndex,\n        newZIndex: change.newZIndex,\n      });\n    } else {\n      // Emit batch event for atomic update\n      eventManager.emit(\"zIndexBatchChanged\", {\n        changes: this.changes.map((change) => ({\n          itemId: change.itemId,\n          canvasId: change.canvasId,\n          oldZIndex: change.oldZIndex,\n          newZIndex: change.newZIndex,\n        })),\n      });\n    }\n  }\n}\n","/**\n * Undo/Redo Service\n * ==================\n *\n * Command pattern implementation for undo/redo functionality in the grid builder.\n * Provides stack-based history management with keyboard shortcuts and UI state tracking.\n *\n * ## Problem\n *\n * Interactive applications need undo/redo capabilities for:\n * - Recovering from mistakes (accidental delete)\n * - Experimenting with layouts (try different arrangements)\n * - Learning the interface (undo to see what changed)\n * - Building confidence (knowing you can undo)\n *\n * **Without undo/redo**:\n * - Users hesitant to experiment\n * - Mistakes are permanent\n * - No way to review history\n * - Poor user experience\n *\n * ## Solution\n *\n * Implement **Command Pattern** with stack-based history:\n *\n * 1. **Command Interface**: Each undoable action implements undo() and redo()\n * 2. **History Stack**: Array of command objects\n * 3. **Position Pointer**: Tracks current position in history\n * 4. **Bounded History**: Limited to 50 commands to prevent memory bloat\n * 5. **Branching**: New actions after undo discard \"future\" history\n *\n * ## Architecture: Command Pattern\n *\n * **Classic Gang of Four pattern** for undo/redo:\n *\n * **Key Components**:\n * - **Command Interface**: Defines undo() and redo() methods\n * - **Concrete Commands**: AddItemCommand, DeleteItemCommand, MoveItemCommand, ResizeCommand\n * - **Invoker**: undo-redo.ts (this file) manages command execution\n * - **Receiver**: state-manager.ts (receives state mutations)\n *\n * **Flow**:\n * ```\n * User Action → Create Command → pushCommand() → Execute & Store\n * Undo (Ctrl+Z) → Get command at position → command.undo() → Update position\n * Redo (Ctrl+Y) → Advance position → command.redo() → Execute\n * ```\n *\n * **Why Command Pattern**:\n * - ✅ Encapsulates actions as objects\n * - ✅ Enables undo/redo without coupling to specific operations\n * - ✅ Supports macro commands (batch operations)\n * - ✅ Easy to extend with new command types\n * - ✅ History can be serialized/persisted\n *\n * ## History Management\n *\n * **Stack-based with position pointer**:\n * ```\n * commandHistory = [cmd1, cmd2, cmd3, cmd4, cmd5]\n * ↑\n * historyPosition = 2\n * ```\n *\n * **Operations**:\n * - **Push new command**: Discard commands after position, append new command\n * - **Undo**: Execute command.undo() at position, decrement position\n * - **Redo**: Increment position, execute command.redo() at new position\n *\n * **Branching behavior** (discarding future on new action):\n * ```\n * Initial:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n * ↑ position = 2\n *\n * Undo 2x:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n * ↑ position = 0\n *\n * New cmd:  [cmd1, cmd6]  ← cmd2-cmd5 discarded!\n * ↑ position = 1\n * ```\n *\n * **Why branching (not tree)**:\n * - Simpler mental model for users\n * - No UI complexity for branch navigation\n * - Standard undo/redo UX pattern\n *\n * ## Memory Management\n *\n * **Bounded history** (MAX_HISTORY = 50):\n * - Prevents unbounded memory growth\n * - Removes oldest command when limit reached\n * - 50 commands ≈ typical user session\n *\n * **Memory per command**:\n * - Command object: ~200-500 bytes\n * - State snapshots: ~1-5 KB (JSON serialized GridItem)\n * - Total for 50 commands: ~50-250 KB (acceptable)\n *\n * **Sliding window approach**:\n * ```\n * When history full:\n * [cmd1, cmd2, ..., cmd50]  ← At capacity\n * Push cmd51:\n * [cmd2, cmd3, ..., cmd51]  ← cmd1 removed\n * ```\n *\n * ## State Snapshot Strategy\n *\n * Each command stores **before/after snapshots**:\n * ```typescript\n * class MoveItemCommand implements Command {\n * beforeState = JSON.parse(JSON.stringify(item));  // Deep clone\n * afterState = JSON.parse(JSON.stringify(updatedItem));\n *\n * undo() { restoreState(beforeState); }\n * redo() { restoreState(afterState); }\n * }\n * ```\n *\n * **Deep cloning required because**:\n * - Prevents mutations from affecting snapshots\n * - Ensures independent state copies\n * - Simple and reliable (no reference tracking needed)\n *\n * **Trade-off**:\n * - ✅ Simple implementation\n * - ✅ No reference bugs\n * - ❌ Higher memory usage than delta-based\n * - ❌ Slower than structural sharing (acceptable for this use case)\n *\n * ## Keyboard Shortcuts\n *\n * Implemented in grid-builder-app.tsx:\n * - **Ctrl+Z** (Cmd+Z on Mac): Undo last command\n * - **Ctrl+Y** (Cmd+Y on Mac): Redo next command\n * - **Ctrl+Shift+Z**: Alternative redo (common in design tools)\n *\n * ## UI Integration\n *\n * **Reactive state for buttons**:\n * ```typescript\n * undoRedoState = {\n * canUndo: boolean,  // Enable/disable undo button\n * canRedo: boolean   // Enable/disable redo button\n * }\n * ```\n *\n * **Updates on**:\n * - New command pushed\n * - Undo executed\n * - Redo executed\n * - History cleared\n *\n * **Button rendering**:\n * ```tsx\n * <button disabled={!undoRedoState.canUndo} onClick={undo}>\n * Undo\n * </button>\n * ```\n *\n * ## Extracting This Pattern\n *\n * To adapt Command pattern for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * interface Command {\n * undo(): void;\n * redo(): void;\n * }\n *\n * class UndoRedoManager {\n * private history: Command[] = [];\n * private position = -1;\n *\n * push(command: Command) {\n * this.history.splice(this.position + 1);  // Discard future\n * this.history.push(command);\n * this.position++;\n * }\n *\n * undo() {\n * if (this.position >= 0) {\n * this.history[this.position].undo();\n * this.position--;\n * }\n * }\n *\n * redo() {\n * if (this.position < this.history.length - 1) {\n * this.position++;\n * this.history[this.position].redo();\n * }\n * }\n * }\n * ```\n *\n * **Example commands**:\n * ```typescript\n * class AddItemCommand implements Command {\n * constructor(\n * private canvasId: string,\n * private item: GridItem\n * ) {}\n *\n * undo() { removeItemFromCanvas(this.canvasId, this.item.id); }\n * redo() { addItemToCanvas(this.canvasId, this.item); }\n * }\n * ```\n *\n * **For different frameworks**:\n * - React: Use useReducer or Zustand middleware\n * - Vue: Use Pinia plugin or custom composable\n * - Angular: Use NgRx effects or service\n * @module undo-redo\n */\n\nimport { createStore } from \"@stencil/store\";\nimport { createDebugLogger } from \"../utils/debug\";\n\nconst debug = createDebugLogger(\"undo-redo\");\n\n/**\n * Command Interface\n * =================\n *\n * Core abstraction for undoable operations. All commands must implement\n * both undo() and redo() methods to reverse and reapply their effects.\n *\n * **Design principle**: Commands are **self-contained** - they store all\n * data needed to both undo and redo without external dependencies.\n *\n * **Typical implementation**:\n * ```typescript\n * class MyCommand implements Command {\n * private beforeState: any;\n * private afterState: any;\n *\n * constructor(initialState) {\n * this.beforeState = JSON.parse(JSON.stringify(initialState));\n * // ... perform operation ...\n * this.afterState = JSON.parse(JSON.stringify(finalState));\n * }\n *\n * undo() { restoreState(this.beforeState); }\n * redo() { restoreState(this.afterState); }\n * }\n * ```\n *\n * **Why separate undo/redo methods**:\n * - ❌ Not: Single execute(reverse: boolean) method\n * - ✅ Yes: Separate undo() and redo() methods\n * - Reason: Clearer intent, easier to implement, matches user mental model\n *\n * **Concrete implementations**:\n * - AddItemCommand: Add/remove grid item\n * - DeleteItemCommand: Remove/restore grid item with index preservation\n * - MoveItemCommand: Update item position (cross-canvas support)\n * - ResizeCommand: Update item dimensions\n * @example\n * ```typescript\n * class DeleteItemCommand implements Command {\n *   constructor(\n *     private canvasId: string,\n *     private item: GridItem,\n *     private itemIndex: number\n *   ) {}\n *\n *   undo() {\n *     // Restore item at original index\n *     const canvas = gridState.canvases[this.canvasId];\n *     canvas.items.splice(this.itemIndex, 0, this.item);\n *     gridState.canvases = { ...gridState.canvases };\n *   }\n *\n *   redo() {\n *     // Remove item again\n *     removeItemFromCanvas(this.canvasId, this.item.id);\n *   }\n * }\n * ```\n */\nexport interface Command {\n  /**\n   * Reverse the effect of this command\n   *\n   * **Idempotent**: Calling undo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  undo(): void;\n\n  /**\n   * Reapply the effect of this command\n   *\n   * **Idempotent**: Calling redo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  redo(): void;\n}\n\n/**\n * Undo/Redo State\n * ================\n *\n * Reactive state for UI button enable/disable logic.\n * Components subscribe to this state to update undo/redo button states.\n *\n * **Why reactive**:\n * - Automatic button state updates (no manual DOM manipulation)\n * - Components re-render when canUndo/canRedo changes\n * - Declarative UI logic\n *\n * **Usage in components**:\n * ```tsx\n * import { undoRedoState } from './undo-redo';\n *\n * render() {\n *   return (\n *     <div>\n *       <button\n *         disabled={!undoRedoState.canUndo}\n *         onClick={() => undo()}>\n *         Undo\n *       </button>\n *       <button\n *         disabled={!undoRedoState.canRedo}\n *         onClick={() => redo()}>\n *         Redo\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n */\nexport interface UndoRedoState {\n  /** Whether undo operation is available (historyPosition >= 0) */\n  canUndo: boolean;\n\n  /** Whether redo operation is available (historyPosition < commandHistory.length - 1) */\n  canRedo: boolean;\n}\n\n/**\n * Maximum number of commands in history\n *\n * **Why 50**: Balance between:\n * - ✅ Enough for typical user session\n * - ✅ Reasonable memory usage (~50-250 KB)\n * - ❌ Not unlimited (prevents memory bloat)\n *\n * **Behavior when exceeded**: Oldest command removed (sliding window)\n */\nconst MAX_HISTORY = 50;\n\n/**\n * UndoRedoManager Class\n * =====================\n *\n * Instance-based undo/redo management for grid builder.\n * Each grid-builder component can create its own UndoRedoManager instance.\n *\n * ## Architecture\n *\n * **Before (Singleton)**:\n * - Single global history shared by all grid-builder instances\n * - Multiple instances pollute each other's history\n * - Storybook stories contaminate each other\n *\n * **After (Instance-based)**:\n * - Each grid-builder creates its own UndoRedoManager\n * - Isolated history per instance\n * - Multiple grid-builders on same page work independently\n *\n * ## Usage\n *\n * **New code (instance-based)**:\n * ```typescript\n * // In grid-builder component\n * componentWillLoad() {\n *   this.undoRedoManager = new UndoRedoManager();\n *   this.undoRedoState = this.undoRedoManager.state;\n * }\n * ```\n *\n * **Legacy code (backward compatible)**:\n * ```typescript\n * // Still works via singleton export\n * import { undoRedo } from './services/undo-redo';\n * undoRedo.push(new AddItemCommand(...));\n * ```\n *\n * ## Instance State\n *\n * Each instance has:\n * - Independent reactive state (StencilJS store)\n * - Own command history stack\n * - Own history position pointer\n * - Own lifecycle (dispose() cleanup)\n */\nexport class UndoRedoManager {\n  /**\n   * Reactive state for button enable/disable\n   *\n   * **Access pattern**:\n   * ```typescript\n   * const canUndoNow = undoRedoManager.state.canUndo;\n   * ```\n   *\n   * **Updates**: Automatically triggered after each operation\n   */\n  public state: UndoRedoState;\n\n  /**\n   * Cleanup subscriptions (called on component unmount)\n   *\n   * **Usage**:\n   * ```typescript\n   * disconnectedCallback() {\n   *   this.undoRedoManager.dispose();\n   * }\n   * ```\n   */\n  public dispose: () => void;\n\n  /**\n   * Command history stack\n   *\n   * **Structure**: Array of Command objects in chronological order\n   * **Growth**: Appends new commands to end\n   * **Bounded**: Limited to MAX_HISTORY commands (50)\n   * **Branching**: Discards commands after current position on new push\n   */\n  private commandHistory: Command[] = [];\n\n  /**\n   * Current position in command history\n   *\n   * **Range**: -1 (empty history) to commandHistory.length - 1\n   * **Meaning**:\n   * - -1: No commands or all undone\n   * - 0: First command is current state\n   * - N: Command at index N is current state\n   */\n  private historyPosition: number = -1;\n\n  /**\n   * Create new UndoRedoManager instance\n   *\n   * @example\n   * ```typescript\n   * // Empty history (default)\n   * const manager = new UndoRedoManager();\n   * ```\n   */\n  constructor() {\n    // Create StencilJS reactive store\n    const { state, dispose } = createStore<UndoRedoState>({\n      canUndo: false,\n      canRedo: false,\n    });\n\n    this.state = state;\n    this.dispose = dispose;\n  }\n\n  /**\n   * Update reactive state for undo/redo button enablement\n   *\n   * **Called after**:\n   * - push() - New command added\n   * - undo() - Position moved backward\n   * - redo() - Position moved forward\n   * - clearHistory() - History reset\n   *\n   * **Updates**:\n   * - `canUndo`: true if historyPosition >= 0 (commands available to undo)\n   * - `canRedo`: true if historyPosition < commandHistory.length - 1 (commands available to redo)\n   */\n  private updateButtonStates(): void {\n    this.state.canUndo = this.historyPosition >= 0;\n    this.state.canRedo = this.historyPosition < this.commandHistory.length - 1;\n  }\n\n  /**\n   * Push a new command to the history stack\n *\n * **Use cases**:\n * - After drag operation completes\n * - After resize operation completes\n * - After adding new item\n * - After deleting item\n *\n * **Branching behavior** (discards future):\n * ```\n * Before: [cmd1, cmd2, cmd3, cmd4]\n * ↑ position = 1 (undid twice)\n *\n * Push cmd5: [cmd1, cmd2, cmd5]\n * ↑ position = 2\n *\n * Note: cmd3 and cmd4 discarded!\n * ```\n *\n * **Why discard future**:\n * - Matches user mental model (new action erases \"undone\" history)\n * - Simpler implementation than tree-based history\n * - Standard undo/redo UX pattern\n *\n * **Memory management**:\n * - If history exceeds MAX_HISTORY (50), oldest command removed\n * - Position adjusted to maintain integrity\n *\n * **Operation sequence**:\n * 1. Discard commands after current position (splice)\n * 2. Append new command to history\n * 3. If over limit, remove oldest (shift)\n * 4. Update position pointer\n * 5. Update button states (triggers UI)\n *\n * **Typical usage**:\n * ```typescript\n * // After drag end\n * const command = new MoveItemCommand(item, oldPos, newPos);\n * pushCommand(command);\n * ```\n *\n * **Important**: Command should be fully constructed (with snapshots taken)\n * before being pushed. This function does NOT execute the command - it's\n * assumed the operation already happened.\n * @param command - Fully constructed command with before/after snapshots\n * @example\n * ```typescript\n * // Delete item example\n * handleDelete(itemId: string, canvasId: string) {\n *   const item = getItem(canvasId, itemId);\n *   const index = gridState.canvases[canvasId].items.indexOf(item);\n *\n *   // Perform the delete\n *   removeItemFromCanvas(canvasId, itemId);\n *\n *   // Push command for undo (AFTER operation)\n *   const command = new DeleteItemCommand(canvasId, item, index);\n *   pushCommand(command);\n * }\n * ```\n   * @param command - Fully constructed command with before/after snapshots\n   */\n  push(command: Command): void {\n    debug.log(\n      \"➕ PUSH: Adding command to history:\",\n      (command as any).description || command,\n    );\n\n    // Remove any commands after current position\n    this.commandHistory.splice(this.historyPosition + 1);\n\n    // Add new command\n    this.commandHistory.push(command);\n\n    // Limit history size\n    if (this.commandHistory.length > MAX_HISTORY) {\n      this.commandHistory.shift();\n    } else {\n      this.historyPosition++;\n    }\n\n    debug.log(\n      \"  History position now:\",\n      this.historyPosition,\n      \", Total commands:\",\n      this.commandHistory.length,\n    );\n\n    // Update button states\n    this.updateButtonStates();\n  }\n\n  /**\n   * Undo the last command in history\n   *\n   * **Triggered by**:\n   * - Ctrl+Z / Cmd+Z keyboard shortcut\n   * - Undo button click\n   * - Programmatic undo (rare)\n   *\n   * **Operation sequence**:\n   * 1. Check if undo available (historyPosition >= 0)\n   * 2. Get command at current position\n   * 3. Execute command.undo() (reverses operation)\n   * 4. Decrement position pointer\n   * 5. Update button states (triggers UI)\n   *\n   * **Side effects**:\n   * - Mutates global state (via command.undo())\n   * - Triggers component re-renders\n   * - Updates undo/redo button states\n   * - May deselect items (depending on command)\n   *\n   * **Position before/after**:\n   * ```\n   * Before: [cmd1, cmd2, cmd3]\n   * ↑ position = 2\n   *\n   * After:  [cmd1, cmd2, cmd3]\n   * ↑ position = 1\n   * ```\n   *\n   * **Safety**: No-op if historyPosition < 0 (nothing to undo)\n   *\n   * **Multiple undo**: Can be called repeatedly to undo multiple commands\n   * @example\n   * ```typescript\n   * // Keyboard shortcut handler\n   * window.addEventListener('keydown', (e) => {\n   *   if ((e.ctrlKey || e.metaKey) && e.key === 'z') {\n   *     undo();\n   *     e.preventDefault();\n   *   }\n   * });\n   * ```\n   */\n  undo(): void {\n    if (this.historyPosition < 0) {\n      return;\n    }\n\n    const command = this.commandHistory[this.historyPosition];\n    debug.log(\n      \"🔙 UNDO: Executing command at position\",\n      this.historyPosition,\n      \":\",\n      command,\n    );\n    debug.log(\"  Command description:\", (command as any).description);\n    command.undo();\n    this.historyPosition--;\n    debug.log(\"  New position after undo:\", this.historyPosition);\n\n    this.updateButtonStates();\n  }\n\n  /**\n   * Redo the next command in history\n   *\n   * **Triggered by**:\n   * - Ctrl+Y / Cmd+Y keyboard shortcut\n   * - Ctrl+Shift+Z / Cmd+Shift+Z (alternative)\n   * - Redo button click\n   * - Programmatic redo (rare)\n   *\n   * **Operation sequence**:\n   * 1. Check if redo available (historyPosition < commandHistory.length - 1)\n   * 2. Increment position pointer\n   * 3. Get command at new position\n   * 4. Execute command.redo() (reapplies operation)\n   * 5. Update button states (triggers UI)\n   *\n   * **Side effects**:\n   * - Mutates global state (via command.redo())\n   * - Triggers component re-renders\n   * - Updates undo/redo button states\n   * - May select items (depending on command)\n   *\n   * **Position before/after**:\n   * ```\n   * Before: [cmd1, cmd2, cmd3]\n   * ↑ position = 1\n   *\n   * After:  [cmd1, cmd2, cmd3]\n   * ↑ position = 2\n   * ```\n   *\n   * **Safety**: No-op if no commands to redo (position at end)\n   *\n   * **Multiple redo**: Can be called repeatedly to redo multiple commands\n   *\n   * **Redo after new action**: Redo becomes unavailable after new command\n   * pushed (future history discarded)\n   * @example\n   * ```typescript\n   * // Keyboard shortcut handler\n   * window.addEventListener('keydown', (e) => {\n   *   if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\n   *     redo();\n   *     e.preventDefault();\n   *   }\n   * });\n   * ```\n   */\n  redo(): void {\n    if (this.historyPosition >= this.commandHistory.length - 1) {\n      return;\n    }\n\n    this.historyPosition++;\n    const command = this.commandHistory[this.historyPosition];\n    command.redo();\n\n    this.updateButtonStates();\n  }\n\n  /**\n   * Check if undo operation is available\n   *\n   * **Use cases**:\n   * - Enabling/disabling undo button\n   * - Showing undo keyboard hint\n   * - Programmatic checks before undo\n   *\n   * **Returns true when**: historyPosition >= 0 (commands in history)\n   * **Returns false when**: historyPosition = -1 (no history or all undone)\n   *\n   * **Note**: Prefer using `undoRedoState.canUndo` in UI components\n   * for automatic reactivity. This function is for imperative checks.\n   * @returns true if undo() can be called, false otherwise\n   * @example\n   * ```typescript\n   * // Imperative check\n   * if (canUndo()) {\n   *   debug.log('Undo available');\n   *   undo();\n   * }\n   *\n   * // Prefer reactive state in UI\n   * <button disabled={!undoRedoState.canUndo}>Undo</button>\n   * ```\n   */\n  canUndo(): boolean {\n    return this.historyPosition >= 0;\n  }\n\n  /**\n   * Check if redo operation is available\n   *\n   * **Use cases**:\n   * - Enabling/disabling redo button\n   * - Showing redo keyboard hint\n   * - Programmatic checks before redo\n   *\n   * **Returns true when**: historyPosition < commandHistory.length - 1\n   * **Returns false when**: At end of history or history empty\n   *\n   * **Becomes false after**: New command pushed (future discarded)\n   *\n   * **Note**: Prefer using `undoRedoState.canRedo` in UI components\n   * for automatic reactivity. This function is for imperative checks.\n   * @returns true if redo() can be called, false otherwise\n   * @example\n   * ```typescript\n   * // Imperative check\n   * if (canRedo()) {\n   *   debug.log('Redo available');\n   *   redo();\n   * }\n   *\n   * // Prefer reactive state in UI\n   * <button disabled={!undoRedoState.canRedo}>Redo</button>\n   * ```\n   */\n  canRedo(): boolean {\n    return this.historyPosition < this.commandHistory.length - 1;\n  }\n\n  /**\n   * Clear all command history\n   *\n   * **Use cases**:\n   * - Application reset\n   * - Loading new project\n   * - Test cleanup\n   * - Memory management (rare)\n   *\n   * **Effects**:\n   * - Empties command history array\n   * - Resets position to -1\n   * - Disables both undo and redo buttons\n   * - Does NOT affect current state (only history)\n   *\n   * **Memory**: Allows garbage collection of command objects and snapshots\n   *\n   * **Cannot be undone**: This operation itself is not undoable\n   *\n   * **Safety**: Safe to call even if history already empty\n   * @example\n   * ```typescript\n   * // Reset application\n   * function resetApp() {\n   *   clearHistory();\n   *   reset(); // Reset state\n   *   debug.log('Application reset');\n   * }\n   *\n   * // Test cleanup\n   * afterEach(() => {\n   *   clearHistory();\n   * });\n   * ```\n   */\n  clearHistory(): void {\n    this.commandHistory.length = 0;\n    this.historyPosition = -1;\n    this.updateButtonStates();\n  }\n}\n\n/**\n * Backward Compatibility Layer\n * ==============================\n *\n * Singleton instance and helper function exports for backward compatibility.\n * Existing code can continue using these while we migrate to instance-based architecture.\n *\n * **Migration path**:\n * 1. Phase 1: Create instance-based classes (CURRENT PHASE)\n * 2. Phase 2: Update grid-builder to create instances\n * 3. Phase 3: Update child components to accept instances as props\n * 4. Phase 4: Remove these exports and update all imports\n *\n * **Why needed**:\n * - Allows incremental migration without breaking the codebase\n * - Can test instance-based approach without immediate breaking changes\n */\n\n// Create singleton instance (for backward compatibility only)\nconst defaultManager = new UndoRedoManager();\n\n// Export singleton state (backward compatible)\nexport const undoRedoState = defaultManager.state;\n\n// Export singleton instance methods as standalone functions (backward compatible)\nexport const pushCommand = (command: Command) => defaultManager.push(command);\nexport const undo = () => defaultManager.undo();\nexport const redo = () => defaultManager.redo();\nexport const canUndo = () => defaultManager.canUndo();\nexport const canRedo = () => defaultManager.canRedo();\nexport const clearHistory = () => defaultManager.clearHistory();\n\n// Export object wrapper for backward compatibility (deprecated, use standalone functions)\nexport const undoRedo = {\n  push: pushCommand,\n  undo,\n  redo,\n  canUndo,\n  canRedo,\n  clearHistory,\n};\n","/**\n * Boundary Constraints Utility\n * =============================\n *\n * Utilities for constraining component placement and sizing within canvas boundaries.\n * Ensures components stay fully within canvas and handles size fitting when needed.\n *\n * ## Problem\n *\n * Components can be placed or dragged such that they extend beyond canvas boundaries:\n * - Dropped from palette outside canvas bounds\n * - Dragged beyond edges\n * - Default size larger than canvas\n *\n * ## Solution\n *\n * Provides constraint functions that:\n * 1. Validate component can fit within canvas (respecting minSize)\n * 2. Adjust size to fit canvas if needed (respecting minSize/maxSize)\n * 3. Constrain position to keep component fully within bounds\n * @module boundary-constraints\n */\n\nimport { ComponentDefinition } from \"../types/component-definition\";\n\n/**\n * Canvas dimensions in grid units\n *\n * **Standard canvas size**:\n * - Width: 50 units (100% width, 2% per unit)\n * - Height: Unlimited (grows with content)\n */\nexport const CANVAS_WIDTH_UNITS = 50;\n\n/**\n * Component size after constraint validation\n */\nexport interface ConstrainedSize {\n  /** Width in grid units (may be adjusted from default) */\n  width: number;\n  /** Height in grid units (may be adjusted from default) */\n  height: number;\n  /** Whether size was adjusted to fit */\n  wasAdjusted: boolean;\n}\n\n/**\n * Component position and size after boundary constraints\n */\nexport interface ConstrainedPlacement {\n  /** X position in grid units */\n  x: number;\n  /** Y position in grid units */\n  y: number;\n  /** Width in grid units */\n  width: number;\n  /** Height in grid units */\n  height: number;\n  /** Whether position was adjusted */\n  positionAdjusted: boolean;\n  /** Whether size was adjusted */\n  sizeAdjusted: boolean;\n}\n\n/**\n * Validate if component can fit within canvas\n *\n * Checks if component's minimum size is smaller than or equal to canvas size.\n * If component's minSize > canvas size, placement should be rejected.\n * @param definition - Component definition with min/max size constraints\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns true if component can fit, false if too large\n * @example\n * ```typescript\n * const hugeComponent = {\n *   type: 'huge-widget',\n *   minSize: { width: 60, height: 10 } // 60 > 50 canvas width\n * };\n *\n * if (!canComponentFitCanvas(hugeComponent)) {\n *   console.warn('Component too large for canvas');\n *   return; // Don't allow placement\n * }\n * ```\n */\nexport function canComponentFitCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): boolean {\n  // Get minimum size (or use default minimums if not specified)\n  const minWidth = definition.minSize?.width || 0;\n\n  // Check if minimum size fits within canvas\n  // Height is unlimited, so only check width\n  return minWidth <= canvasWidth;\n}\n\n/**\n * Constrain component size to fit within canvas\n *\n * Adjusts component size if default size exceeds canvas bounds,\n * while respecting min/max size constraints.\n *\n * **Size adjustment rules**:\n * 1. If defaultSize fits, use it\n * 2. If defaultSize > canvas, shrink to canvas size\n * 3. Never shrink below minSize\n * 4. Never grow beyond maxSize\n *\n * **Width constraint**: Canvas width (50 units)\n * **Height constraint**: None (canvas height grows with content)\n * @param definition - Component definition\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained size and adjustment flag\n * @example\n * ```typescript\n * const wideComponent = {\n *   type: 'banner',\n *   defaultSize: { width: 60, height: 10 }, // Too wide\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const size = constrainSizeToCanvas(wideComponent);\n * // { width: 50, height: 10, wasAdjusted: true }\n * ```\n */\nexport function constrainSizeToCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedSize {\n  const defaultWidth = definition.defaultSize.width;\n  const defaultHeight = definition.defaultSize.height;\n\n  const minWidth = definition.minSize?.width || 0;\n  const maxWidth = definition.maxSize?.width || Infinity;\n\n  let width = defaultWidth;\n  let height = defaultHeight;\n  let wasAdjusted = false;\n\n  // Constrain width to canvas\n  if (width > canvasWidth) {\n    width = canvasWidth;\n    wasAdjusted = true;\n  }\n\n  // Respect minSize\n  if (width < minWidth) {\n    width = minWidth;\n  }\n\n  // Respect maxSize\n  if (width > maxWidth) {\n    width = maxWidth;\n  }\n\n  // Height is not constrained by canvas (canvas grows vertically)\n  // but still respect min/max if specified\n  const minHeight = definition.minSize?.height || 0;\n  const maxHeight = definition.maxSize?.height || Infinity;\n\n  if (height < minHeight) {\n    height = minHeight;\n  }\n  if (height > maxHeight) {\n    height = maxHeight;\n  }\n\n  return { width, height, wasAdjusted };\n}\n\n/**\n * Constrain component position to keep it fully within canvas bounds\n *\n * Adjusts position so component stays completely inside canvas.\n * Snaps to edges if component would extend beyond boundaries.\n *\n * **Boundary rules**:\n * - Left edge: x >= 0\n * - Right edge: x + width <= canvasWidth\n * - Top edge: y >= 0\n * - Bottom edge: No constraint (canvas height grows)\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param width - Component width in grid units\n * @param height - Component height in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement\n * @example\n * ```typescript\n * // Component would extend beyond right edge\n * const placement = constrainPositionToCanvas(45, 10, 20, 10);\n * // { x: 30, y: 10, width: 20, height: 10, positionAdjusted: true, sizeAdjusted: false }\n * // Adjusted from 45 to 30 so (30 + 20 = 50) stays within canvas\n * ```\n */\nexport function constrainPositionToCanvas(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedPlacement {\n  let newX = x;\n  let newY = y;\n  let positionAdjusted = false;\n\n  // Constrain left edge\n  if (newX < 0) {\n    newX = 0;\n    positionAdjusted = true;\n  }\n\n  // Constrain right edge\n  if (newX + width > canvasWidth) {\n    newX = canvasWidth - width;\n    positionAdjusted = true;\n  }\n\n  // Constrain top edge\n  if (newY < 0) {\n    newY = 0;\n    positionAdjusted = true;\n  }\n\n  // No bottom edge constraint - canvas grows vertically\n\n  // Ensure position doesn't go negative after adjustment\n  newX = Math.max(0, newX);\n  newY = Math.max(0, newY);\n\n  return {\n    x: newX,\n    y: newY,\n    width,\n    height,\n    positionAdjusted,\n    sizeAdjusted: false,\n  };\n}\n\n/**\n * Apply full boundary constraints to component placement\n *\n * Complete constraint pipeline:\n * 1. Check if component can fit (validate minSize <= canvas)\n * 2. Adjust size to fit canvas (if needed)\n * 3. Constrain position to keep within bounds\n *\n * **Returns null if component cannot fit** (minSize > canvas)\n * @param definition - Component definition\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement, or null if component too large\n * @example\n * ```typescript\n * const definition = {\n *   type: 'widget',\n *   defaultSize: { width: 60, height: 10 },\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const placement = applyBoundaryConstraints(definition, 45, 10);\n * // {\n * //   x: 0,              // Adjusted from 45 to fit\n * //   y: 10,             // No Y adjustment needed\n * //   width: 50,         // Shrunk from 60 to fit canvas\n * //   height: 10,        // No height adjustment\n * //   positionAdjusted: true,\n * //   sizeAdjusted: true\n * // }\n * ```\n */\nexport function applyBoundaryConstraints(\n  definition: ComponentDefinition,\n  x: number,\n  y: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedPlacement | null {\n  // 1. Validate component can fit\n  if (!canComponentFitCanvas(definition, canvasWidth)) {\n    console.warn(\n      `Component \"${definition.name}\" minSize (${definition.minSize?.width}) ` +\n        `exceeds canvas width (${canvasWidth}). Placement rejected.`,\n    );\n    return null;\n  }\n\n  // 2. Adjust size to fit canvas\n  const constrainedSize = constrainSizeToCanvas(definition, canvasWidth);\n\n  // 3. Constrain position to keep within bounds\n  const constrainedPlacement = constrainPositionToCanvas(\n    x,\n    y,\n    constrainedSize.width,\n    constrainedSize.height,\n    canvasWidth,\n  );\n\n  // Combine size and position adjustments\n  return {\n    ...constrainedPlacement,\n    sizeAdjusted: constrainedSize.wasAdjusted,\n  };\n}\n"],"names":["debug"],"mappings":"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"}