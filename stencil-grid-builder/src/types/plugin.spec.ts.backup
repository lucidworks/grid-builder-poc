/**
 * Plugin System Tests
 * ====================
 *
 * Tests for plugin registration, lifecycle, and hook invocation.
 * Includes sample plugin implementations to verify the plugin contract works.
 */

import { newSpecPage } from '@stencil/core/testing';
import { GridBuilder } from '../components/grid-builder/grid-builder';
import { GridBuilderPlugin } from './plugin';
import { GridBuilderAPI } from '../services/grid-builder-api';
import { reset as resetState } from '../services/state-manager';
import { clearHistory } from '../services/undo-redo';

/**
 * Mock Logger Plugin
 * ===================
 *
 * Simple plugin that logs all events for testing event subscription
 */
class MockLoggerPlugin implements GridBuilderPlugin {
  name = 'mock-logger';
  version = '1.0.0';

  private api: GridBuilderAPI | null = null;
  public initCalled = false;
  public destroyCalled = false;
  public events: Array<{ type: string; data: any }> = [];

  init(api: GridBuilderAPI): void {
    this.api = api;
    this.initCalled = true;

    // Subscribe to all item events
    api.on('itemAdded', (event) => {
      this.events.push({ type: 'itemAdded', data: event });
    });

    api.on('itemRemoved', (event) => {
      this.events.push({ type: 'itemRemoved', data: event });
    });

    api.on('itemUpdated', (event) => {
      this.events.push({ type: 'itemUpdated', data: event });
    });

    api.on('selectionChanged', (event) => {
      this.events.push({ type: 'selectionChanged', data: event });
    });
  }

  destroy(): void {
    this.destroyCalled = true;
    this.api?.destroy();
  }

  getEventCount(type: string): number {
    return this.events.filter((e) => e.type === type).length;
  }
}

/**
 * Mock Auto-Save Plugin
 * =======================
 *
 * Plugin that saves state on intervals for testing cleanup
 */
class MockAutoSavePlugin implements GridBuilderPlugin {
  name = 'mock-auto-save';
  version = '1.0.0';

  private api: GridBuilderAPI | null = null;
  public initCalled = false;
  public destroyCalled = false;
  public saveCount = 0;
  private intervalId: number | null = null;

  constructor(private interval: number = 100) {}

  init(api: GridBuilderAPI): void {
    this.api = api;
    this.initCalled = true;

    // Start auto-save interval
    this.intervalId = window.setInterval(() => {
      this.saveState();
    }, this.interval);
  }

  destroy(): void {
    this.destroyCalled = true;

    // Stop auto-save interval
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }

  private saveState(): void {
    if (this.api) {
      const state = this.api.exportState();
      this.saveCount++;
    }
  }
}

/**
 * Mock Analytics Plugin
 * ======================
 *
 * Plugin that tracks user interactions for testing event handling
 */
class MockAnalyticsPlugin implements GridBuilderPlugin {
  name = 'mock-analytics';
  version = '1.0.0';

  private api: GridBuilderAPI | null = null;
  public initCalled = false;
  public destroyCalled = false;
  public metrics = {
    itemsAdded: 0,
    itemsRemoved: 0,
    itemsUpdated: 0,
    viewportChanges: 0,
    undoCount: 0,
    redoCount: 0,
  };

  private handlers = {
    itemAdded: () => {
      this.metrics.itemsAdded++;
    },
    itemRemoved: () => {
      this.metrics.itemsRemoved++;
    },
    itemUpdated: () => {
      this.metrics.itemsUpdated++;
    },
    viewportChanged: () => {
      this.metrics.viewportChanges++;
    },
  };

  init(api: GridBuilderAPI): void {
    this.api = api;
    this.initCalled = true;

    // Subscribe to events
    api.on('itemAdded', this.handlers.itemAdded);
    api.on('itemRemoved', this.handlers.itemRemoved);
    api.on('itemUpdated', this.handlers.itemUpdated);
    api.on('viewportChanged', this.handlers.viewportChanged);
  }

  destroy(): void {
    this.destroyCalled = true;

    // Unsubscribe from events
    if (this.api) {
      this.api.off('itemAdded', this.handlers.itemAdded);
      this.api.off('itemRemoved', this.handlers.itemRemoved);
      this.api.off('itemUpdated', this.handlers.itemUpdated);
      this.api.off('viewportChanged', this.handlers.viewportChanged);
    }
  }
}

/**
 * Failing Plugin
 * ===============
 *
 * Plugin that throws errors for testing error handling
 */
class FailingPlugin implements GridBuilderPlugin {
  name = 'failing-plugin';
  version = '1.0.0';

  init(api: GridBuilderAPI): void {
    throw new Error('Init failed');
  }

  destroy(): void {
    throw new Error('Destroy failed');
  }
}

// Mock component definitions for tests
const mockComponentDefinitions = [
  {
    type: 'header',
    name: 'Header',
    icon: 'ðŸ“„',
    defaultSize: { width: 50, height: 6 },
    minSize: { width: 10, height: 3 },
  },
  {
    type: 'text',
    name: 'Text Block',
    icon: 'ðŸ“',
    defaultSize: { width: 25, height: 10 },
    minSize: { width: 10, height: 5 },
  },
];

describe('Plugin System', () => {
  beforeEach(() => {
    resetState();
    clearHistory();
  });

  describe('Plugin Registration', () => {
    it('should accept plugins prop', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        template: () => (
          <grid-builder components={mockComponentDefinitions} plugins={[plugin]}></grid-builder>
        ),
      });

      const gridBuilder = page.rootInstance as GridBuilder;

      expect(gridBuilder.plugins).toBeDefined();
      expect(gridBuilder.plugins?.length).toBe(1);
      expect(gridBuilder.plugins?.[0]).toBe(plugin);
    });

    it('should accept multiple plugins', async () => {
      const plugin1 = new MockLoggerPlugin();
      const plugin2 = new MockAutoSavePlugin();
      const plugin3 = new MockAnalyticsPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin1, plugin2, plugin3];

      await page.waitForChanges();

      expect(gridBuilder.plugins?.length).toBe(3);
    });

    it('should work without plugins', async () => {
      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;

      expect(gridBuilder.plugins).toBeUndefined();
    });
  });

  describe('Plugin Lifecycle', () => {
    it('should call init() on plugin when component loads', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      // Trigger componentDidLoad
      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      expect(plugin.initCalled).toBe(true);
    });

    it('should pass GridBuilderAPI to plugin init()', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      expect(plugin.initCalled).toBe(true);
      expect(plugin['api']).toBeDefined();
      expect(plugin['api']).toBeInstanceOf(GridBuilderAPI);
    });

    it('should initialize all plugins', async () => {
      const plugin1 = new MockLoggerPlugin();
      const plugin2 = new MockAutoSavePlugin();
      const plugin3 = new MockAnalyticsPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin1, plugin2, plugin3];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      expect(plugin1.initCalled).toBe(true);
      expect(plugin2.initCalled).toBe(true);
      expect(plugin3.initCalled).toBe(true);
    });

    it('should call destroy() on plugin when component unmounts', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      // Trigger disconnectedCallback
      gridBuilder.disconnectedCallback();

      expect(plugin.destroyCalled).toBe(true);
    });

    it('should destroy all plugins on unmount', async () => {
      const plugin1 = new MockLoggerPlugin();
      const plugin2 = new MockAutoSavePlugin();
      const plugin3 = new MockAnalyticsPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin1, plugin2, plugin3];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      gridBuilder.disconnectedCallback();

      expect(plugin1.destroyCalled).toBe(true);
      expect(plugin2.destroyCalled).toBe(true);
      expect(plugin3.destroyCalled).toBe(true);
    });

    it('should handle plugin init failures gracefully', async () => {
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
      const goodPlugin = new MockLoggerPlugin();
      const badPlugin = new FailingPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [goodPlugin, badPlugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      // Good plugin should still initialize
      expect(goodPlugin.initCalled).toBe(true);

      // Error should be logged
      expect(consoleErrorSpy).toHaveBeenCalled();

      consoleErrorSpy.mockRestore();
    });

    it('should handle plugin destroy failures gracefully', async () => {
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();

      // Create a plugin that fails on destroy
      const badPlugin: GridBuilderPlugin = {
        name: 'bad-destroy',
        init: jest.fn(),
        destroy: jest.fn(() => {
          throw new Error('Destroy failed');
        }),
      };

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [badPlugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      gridBuilder.disconnectedCallback();

      // Error should be logged
      expect(consoleErrorSpy).toHaveBeenCalled();

      consoleErrorSpy.mockRestore();
    });
  });

  describe('Plugin Event Subscription', () => {
    it('should receive itemAdded events', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      const api = await gridBuilder.getAPI();

      // Add an item
      api.addItem('canvas1', 'header', 0, 0, 10, 10);

      expect(plugin.getEventCount('itemAdded')).toBe(1);
      expect(plugin.events[0].type).toBe('itemAdded');
      expect(plugin.events[0].data.item.type).toBe('header');
    });

    it('should receive itemRemoved events', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      const api = await gridBuilder.getAPI();

      // Add then remove an item
      const item = api.addItem('canvas1', 'header', 0, 0, 10, 10);
      plugin.events = []; // Clear add event

      api.removeItem('canvas1', item.id);

      expect(plugin.getEventCount('itemRemoved')).toBe(1);
      expect(plugin.events[0].type).toBe('itemRemoved');
      expect(plugin.events[0].data.itemId).toBe(item.id);
    });

    it('should receive itemUpdated events', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      const api = await gridBuilder.getAPI();

      // Add then update an item
      const item = api.addItem('canvas1', 'header', 0, 0, 10, 10);
      plugin.events = []; // Clear add event

      api.updateItem('canvas1', item.id, { name: 'Updated Header' });

      expect(plugin.getEventCount('itemUpdated')).toBe(1);
      expect(plugin.events[0].type).toBe('itemUpdated');
      expect(plugin.events[0].data.updates.name).toBe('Updated Header');
    });

    it('should receive selectionChanged events', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      const api = await gridBuilder.getAPI();

      // Add then select an item
      const item = api.addItem('canvas1', 'header', 0, 0, 10, 10);
      plugin.events = []; // Clear add event

      api.selectItem(item.id, 'canvas1');

      expect(plugin.getEventCount('selectionChanged')).toBe(1);
      expect(plugin.events[0].type).toBe('selectionChanged');
      expect(plugin.events[0].data.itemId).toBe(item.id);
    });
  });

  describe('Sample Plugin Implementations', () => {
    describe('MockAnalyticsPlugin', () => {
      it('should track item additions', async () => {
        const plugin = new MockAnalyticsPlugin();

        const page = await newSpecPage({
          components: [GridBuilder],
          html: '<grid-builder></grid-builder>',
        });

        const gridBuilder = page.rootInstance as GridBuilder;
        gridBuilder.plugins = [plugin];

        await page.waitForChanges();
        await gridBuilder.componentDidLoad();

        const api = await gridBuilder.getAPI();

        api.addItem('canvas1', 'header', 0, 0, 10, 10);
        api.addItem('canvas1', 'text', 10, 10, 10, 10);
        api.addItem('canvas1', 'image', 20, 20, 10, 10);

        expect(plugin.metrics.itemsAdded).toBe(3);
      });

      it('should track item removals', async () => {
        const plugin = new MockAnalyticsPlugin();

        const page = await newSpecPage({
          components: [GridBuilder],
          html: '<grid-builder></grid-builder>',
        });

        const gridBuilder = page.rootInstance as GridBuilder;
        gridBuilder.plugins = [plugin];

        await page.waitForChanges();
        await gridBuilder.componentDidLoad();

        const api = await gridBuilder.getAPI();

        const item1 = api.addItem('canvas1', 'header', 0, 0, 10, 10);
        const item2 = api.addItem('canvas1', 'text', 10, 10, 10, 10);

        api.removeItem('canvas1', item1.id);
        api.removeItem('canvas1', item2.id);

        expect(plugin.metrics.itemsRemoved).toBe(2);
      });

      it('should track viewport changes', async () => {
        const plugin = new MockAnalyticsPlugin();

        const page = await newSpecPage({
          components: [GridBuilder],
          html: '<grid-builder></grid-builder>',
        });

        const gridBuilder = page.rootInstance as GridBuilder;
        gridBuilder.plugins = [plugin];

        await page.waitForChanges();
        await gridBuilder.componentDidLoad();

        const api = await gridBuilder.getAPI();

        api.setViewport('mobile');
        api.setViewport('desktop');
        api.setViewport('mobile');

        expect(plugin.metrics.viewportChanges).toBe(3);
      });

      it('should properly unsubscribe on destroy', async () => {
        const plugin = new MockAnalyticsPlugin();

        const page = await newSpecPage({
          components: [GridBuilder],
          html: '<grid-builder></grid-builder>',
        });

        const gridBuilder = page.rootInstance as GridBuilder;
        gridBuilder.plugins = [plugin];

        await page.waitForChanges();
        await gridBuilder.componentDidLoad();

        const api = await gridBuilder.getAPI();

        // Add an item before destroy
        api.addItem('canvas1', 'header', 0, 0, 10, 10);
        expect(plugin.metrics.itemsAdded).toBe(1);

        // Destroy plugin
        gridBuilder.disconnectedCallback();

        // Add another item after destroy
        api.addItem('canvas1', 'text', 10, 10, 10, 10);

        // Metric should not increase (unsubscribed)
        expect(plugin.metrics.itemsAdded).toBe(1);
      });
    });

    describe('MockAutoSavePlugin', () => {
      it('should save state on interval', async () => {
        jest.useFakeTimers();

        const plugin = new MockAutoSavePlugin(100); // 100ms interval

        const page = await newSpecPage({
          components: [GridBuilder],
          html: '<grid-builder></grid-builder>',
        });

        const gridBuilder = page.rootInstance as GridBuilder;
        gridBuilder.plugins = [plugin];

        await page.waitForChanges();
        await gridBuilder.componentDidLoad();

        expect(plugin.saveCount).toBe(0);

        // Fast-forward 100ms
        jest.advanceTimersByTime(100);
        expect(plugin.saveCount).toBe(1);

        // Fast-forward another 100ms
        jest.advanceTimersByTime(100);
        expect(plugin.saveCount).toBe(2);

        // Fast-forward 500ms (5 more saves)
        jest.advanceTimersByTime(500);
        expect(plugin.saveCount).toBe(7);

        jest.useRealTimers();
      });

      it('should stop saving after destroy', async () => {
        jest.useFakeTimers();

        const plugin = new MockAutoSavePlugin(100);

        const page = await newSpecPage({
          components: [GridBuilder],
          html: '<grid-builder></grid-builder>',
        });

        const gridBuilder = page.rootInstance as GridBuilder;
        gridBuilder.plugins = [plugin];

        await page.waitForChanges();
        await gridBuilder.componentDidLoad();

        // Fast-forward to get some saves
        jest.advanceTimersByTime(300);
        expect(plugin.saveCount).toBe(3);

        // Destroy plugin
        gridBuilder.disconnectedCallback();

        // Fast-forward more time
        jest.advanceTimersByTime(500);

        // Save count should not increase (timer cleared)
        expect(plugin.saveCount).toBe(3);

        jest.useRealTimers();
      });
    });
  });

  describe('Plugin API Access', () => {
    it('should allow plugins to access grid state', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      const api = plugin['api'];
      expect(api).toBeDefined();

      const state = api?.getState();
      expect(state).toBeDefined();
      expect(state?.canvases).toBeDefined();
    });

    it('should allow plugins to modify grid state', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      const api = plugin['api'];
      expect(api).toBeDefined();

      // Plugin adds an item
      const item = api?.addItem('canvas1', 'header', 0, 0, 10, 10);

      expect(item).toBeDefined();
      expect(item?.type).toBe('header');

      // Verify it's in state
      const canvas = api?.getCanvas('canvas1');
      expect(canvas?.items.length).toBe(1);
    });

    it('should allow plugins to use undo/redo', async () => {
      const plugin = new MockLoggerPlugin();

      const page = await newSpecPage({
        components: [GridBuilder],
        html: '<grid-builder></grid-builder>',
      });

      const gridBuilder = page.rootInstance as GridBuilder;
      gridBuilder.plugins = [plugin];

      await page.waitForChanges();
      await gridBuilder.componentDidLoad();

      const api = plugin['api'];

      // Add item
      api?.addItem('canvas1', 'header', 0, 0, 10, 10);
      expect(api?.canUndo()).toBe(true);

      // Undo
      api?.undo();
      const canvas = api?.getCanvas('canvas1');
      expect(canvas?.items.length).toBe(0);

      // Redo
      expect(api?.canRedo()).toBe(true);
      api?.redo();
      expect(canvas?.items.length).toBe(1);
    });
  });
});
