// Mock IntersectionObserver BEFORE importing virtualRenderer
const mockObserve = jest.fn();
const mockUnobserve = jest.fn();
const mockDisconnect = jest.fn();
let mockCallback: any;
let mockOptions: any;

(global as any).IntersectionObserver = jest.fn((callback, options) => {
  mockCallback = callback;
  mockOptions = options;
  return {
    observe: mockObserve,
    unobserve: mockUnobserve,
    disconnect: mockDisconnect,
    root: null,
    rootMargin: '200px',
    thresholds: [0.01],
    takeRecords: jest.fn(),
  };
});

import { VirtualRendererService, VisibilityCallback } from './virtual-renderer';

describe('virtual-renderer', () => {
  let service: VirtualRendererService;
  let mockElement: HTMLElement;
  let callback: jest.Mock<VisibilityCallback>;

  beforeEach(() => {
    // Clear mocks
    jest.clearAllMocks();

    // Create service
    service = new VirtualRendererService();

    // Create mock element
    mockElement = document.createElement('div');
    mockElement.id = 'test-element';

    // Create mock callback
    callback = jest.fn();
  });

  afterEach(() => {
    // Clean up
    service.destroy();
  });

  describe('constructor', () => {
    it('should initialize IntersectionObserver with correct options', () => {
      expect(mockOptions).toEqual({
        rootMargin: '200px',
        threshold: 0.01,
      });
    });
  });

  describe('observe', () => {
    it('should observe element and store callback', () => {
      service.observe(mockElement, 'test-element', callback);

      expect(mockObserve).toHaveBeenCalledWith(mockElement);
    });

    it('should handle null element gracefully', () => {
      expect(() => {
        service.observe(null as any, 'test-element', callback);
      }).not.toThrow();

      expect(mockObserve).not.toHaveBeenCalled();
    });

    it('should store callback for element ID', () => {
      service.observe(mockElement, 'test-element', mockCallback);

      // Simulate intersection observer callback
      const entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: mockElement,
          isIntersecting: true,
        },
      ];

      (mockObserver as any).callback(entries);

      expect(mockCallback).toHaveBeenCalledWith(true);
    });

    it('should handle multiple elements', () => {
      const element2 = document.createElement('div');
      element2.id = 'test-element-2';
      const callback2 = jest.fn();

      service.observe(mockElement, 'test-element', mockCallback);
      service.observe(element2, 'test-element-2', callback2);

      expect(mockObserver.observe).toHaveBeenCalledTimes(2);
      expect(mockObserver.observe).toHaveBeenCalledWith(mockElement);
      expect(mockObserver.observe).toHaveBeenCalledWith(element2);
    });
  });

  describe('unobserve', () => {
    beforeEach(() => {
      service.observe(mockElement, 'test-element', mockCallback);
    });

    it('should unobserve element and remove callback', () => {
      service.unobserve(mockElement, 'test-element');

      expect(mockObserver.unobserve).toHaveBeenCalledWith(mockElement);

      // Callback should not be called after unobserve
      const entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: mockElement,
          isIntersecting: true,
        },
      ];

      (mockObserver as any).callback(entries);

      expect(mockCallback).not.toHaveBeenCalled();
    });

    it('should handle null element gracefully', () => {
      expect(() => {
        service.unobserve(null as any, 'test-element');
      }).not.toThrow();
    });

    it('should handle unobserving non-observed element', () => {
      const element2 = document.createElement('div');
      element2.id = 'test-element-2';

      expect(() => {
        service.unobserve(element2, 'test-element-2');
      }).not.toThrow();
    });
  });

  describe('destroy', () => {
    beforeEach(() => {
      service.observe(mockElement, 'test-element', mockCallback);
    });

    it('should disconnect observer', () => {
      service.destroy();

      expect(mockObserver.disconnect).toHaveBeenCalled();
    });

    it('should clear all observed elements', () => {
      service.destroy();

      // Callback should not be called after destroy
      const entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: mockElement,
          isIntersecting: true,
        },
      ];

      (mockObserver as any).callback(entries);

      expect(mockCallback).not.toHaveBeenCalled();
    });

    it('should handle multiple destroy calls', () => {
      service.destroy();

      expect(() => {
        service.destroy();
      }).not.toThrow();
    });
  });

  describe('Intersection Callbacks', () => {
    beforeEach(() => {
      service.observe(mockElement, 'test-element', mockCallback);
    });

    it('should call callback with true when element becomes visible', () => {
      const entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: mockElement,
          isIntersecting: true,
        },
      ];

      (mockObserver as any).callback(entries);

      expect(mockCallback).toHaveBeenCalledWith(true);
    });

    it('should call callback with false when element becomes invisible', () => {
      const entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: mockElement,
          isIntersecting: false,
        },
      ];

      (mockObserver as any).callback(entries);

      expect(mockCallback).toHaveBeenCalledWith(false);
    });

    it('should handle multiple intersection changes', () => {
      // Becomes visible
      let entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: mockElement,
          isIntersecting: true,
        },
      ];

      (mockObserver as any).callback(entries);
      expect(mockCallback).toHaveBeenCalledWith(true);

      // Becomes invisible
      entries = [
        {
          target: mockElement,
          isIntersecting: false,
        },
      ];

      (mockObserver as any).callback(entries);
      expect(mockCallback).toHaveBeenCalledWith(false);

      expect(mockCallback).toHaveBeenCalledTimes(2);
    });

    it('should handle multiple elements in single callback', () => {
      const element2 = document.createElement('div');
      element2.id = 'test-element-2';
      const callback2 = jest.fn();

      service.observe(element2, 'test-element-2', callback2);

      const entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: mockElement,
          isIntersecting: true,
        },
        {
          target: element2,
          isIntersecting: false,
        },
      ];

      (mockObserver as any).callback(entries);

      expect(mockCallback).toHaveBeenCalledWith(true);
      expect(callback2).toHaveBeenCalledWith(false);
    });

    it('should not call callback for unknown element', () => {
      const unknownElement = document.createElement('div');
      unknownElement.id = 'unknown-element';

      const entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: unknownElement,
          isIntersecting: true,
        },
      ];

      expect(() => {
        (mockObserver as any).callback(entries);
      }).not.toThrow();

      expect(mockCallback).not.toHaveBeenCalled();
    });
  });

  describe('Performance Benefits', () => {
    it('should use 200px rootMargin for pre-rendering', () => {
      const options = (mockObserver as any).options;
      expect(options.rootMargin).toBe('200px');
    });

    it('should trigger at 1% visibility threshold', () => {
      const options = (mockObserver as any).options;
      expect(options.threshold).toBe(0.01);
    });

    it('should support lazy loading pattern', () => {
      let isVisible = false;

      service.observe(mockElement, 'test-element', (visible) => {
        isVisible = visible;
      });

      // Initially not visible
      expect(isVisible).toBe(false);

      // Becomes visible
      const entries: Partial<IntersectionObserverEntry>[] = [
        {
          target: mockElement,
          isIntersecting: true,
        },
      ];

      (mockObserver as any).callback(entries);

      expect(isVisible).toBe(true);
    });
  });
});
