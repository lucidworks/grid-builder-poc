{"version":3,"file":"boundary-constraints.js","sourceRoot":"","sources":["../../src/utils/boundary-constraints.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Boundary Constraints Utility\n * =============================\n *\n * Utilities for constraining component placement and sizing within canvas boundaries.\n * Ensures components stay fully within canvas and handles size fitting when needed.\n *\n * ## Problem\n *\n * Components can be placed or dragged such that they extend beyond canvas boundaries:\n * - Dropped from palette outside canvas bounds\n * - Dragged beyond edges\n * - Default size larger than canvas\n *\n * ## Solution\n *\n * Provides constraint functions that:\n * 1. Validate component can fit within canvas (respecting minSize)\n * 2. Adjust size to fit canvas if needed (respecting minSize/maxSize)\n * 3. Constrain position to keep component fully within bounds\n *\n * @module boundary-constraints\n */\n\nimport { ComponentDefinition } from '../types/component-definition';\n\n/**\n * Canvas dimensions in grid units\n *\n * **Standard canvas size**:\n * - Width: 50 units (100% width, 2% per unit)\n * - Height: Unlimited (grows with content)\n */\nexport const CANVAS_WIDTH_UNITS = 50;\n\n/**\n * Component size after constraint validation\n */\nexport interface ConstrainedSize {\n  /** Width in grid units (may be adjusted from default) */\n  width: number;\n  /** Height in grid units (may be adjusted from default) */\n  height: number;\n  /** Whether size was adjusted to fit */\n  wasAdjusted: boolean;\n}\n\n/**\n * Component position and size after boundary constraints\n */\nexport interface ConstrainedPlacement {\n  /** X position in grid units */\n  x: number;\n  /** Y position in grid units */\n  y: number;\n  /** Width in grid units */\n  width: number;\n  /** Height in grid units */\n  height: number;\n  /** Whether position was adjusted */\n  positionAdjusted: boolean;\n  /** Whether size was adjusted */\n  sizeAdjusted: boolean;\n}\n\n/**\n * Validate if component can fit within canvas\n *\n * Checks if component's minimum size is smaller than or equal to canvas size.\n * If component's minSize > canvas size, placement should be rejected.\n *\n * @param definition - Component definition with min/max size constraints\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns true if component can fit, false if too large\n *\n * @example\n * ```typescript\n * const hugeComponent = {\n *   type: 'huge-widget',\n *   minSize: { width: 60, height: 10 } // 60 > 50 canvas width\n * };\n *\n * if (!canComponentFitCanvas(hugeComponent)) {\n *   console.warn('Component too large for canvas');\n *   return; // Don't allow placement\n * }\n * ```\n */\nexport function canComponentFitCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS\n): boolean {\n  // Get minimum size (or use default minimums if not specified)\n  const minWidth = definition.minSize?.width || 0;\n\n  // Check if minimum size fits within canvas\n  // Height is unlimited, so only check width\n  return minWidth <= canvasWidth;\n}\n\n/**\n * Constrain component size to fit within canvas\n *\n * Adjusts component size if default size exceeds canvas bounds,\n * while respecting min/max size constraints.\n *\n * **Size adjustment rules**:\n * 1. If defaultSize fits, use it\n * 2. If defaultSize > canvas, shrink to canvas size\n * 3. Never shrink below minSize\n * 4. Never grow beyond maxSize\n *\n * **Width constraint**: Canvas width (50 units)\n * **Height constraint**: None (canvas height grows with content)\n *\n * @param definition - Component definition\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained size and adjustment flag\n *\n * @example\n * ```typescript\n * const wideComponent = {\n *   type: 'banner',\n *   defaultSize: { width: 60, height: 10 }, // Too wide\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const size = constrainSizeToCanvas(wideComponent);\n * // { width: 50, height: 10, wasAdjusted: true }\n * ```\n */\nexport function constrainSizeToCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS\n): ConstrainedSize {\n  const defaultWidth = definition.defaultSize.width;\n  const defaultHeight = definition.defaultSize.height;\n\n  const minWidth = definition.minSize?.width || 0;\n  const maxWidth = definition.maxSize?.width || Infinity;\n\n  let width = defaultWidth;\n  let height = defaultHeight;\n  let wasAdjusted = false;\n\n  // Constrain width to canvas\n  if (width > canvasWidth) {\n    width = canvasWidth;\n    wasAdjusted = true;\n  }\n\n  // Respect minSize\n  if (width < minWidth) {\n    width = minWidth;\n  }\n\n  // Respect maxSize\n  if (width > maxWidth) {\n    width = maxWidth;\n  }\n\n  // Height is not constrained by canvas (canvas grows vertically)\n  // but still respect min/max if specified\n  const minHeight = definition.minSize?.height || 0;\n  const maxHeight = definition.maxSize?.height || Infinity;\n\n  if (height < minHeight) {\n    height = minHeight;\n  }\n  if (height > maxHeight) {\n    height = maxHeight;\n  }\n\n  return { width, height, wasAdjusted };\n}\n\n/**\n * Constrain component position to keep it fully within canvas bounds\n *\n * Adjusts position so component stays completely inside canvas.\n * Snaps to edges if component would extend beyond boundaries.\n *\n * **Boundary rules**:\n * - Left edge: x >= 0\n * - Right edge: x + width <= canvasWidth\n * - Top edge: y >= 0\n * - Bottom edge: No constraint (canvas height grows)\n *\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param width - Component width in grid units\n * @param height - Component height in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement\n *\n * @example\n * ```typescript\n * // Component would extend beyond right edge\n * const placement = constrainPositionToCanvas(45, 10, 20, 10);\n * // { x: 30, y: 10, width: 20, height: 10, positionAdjusted: true, sizeAdjusted: false }\n * // Adjusted from 45 to 30 so (30 + 20 = 50) stays within canvas\n * ```\n */\nexport function constrainPositionToCanvas(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS\n): ConstrainedPlacement {\n  let newX = x;\n  let newY = y;\n  let positionAdjusted = false;\n\n  // Constrain left edge\n  if (newX < 0) {\n    newX = 0;\n    positionAdjusted = true;\n  }\n\n  // Constrain right edge\n  if (newX + width > canvasWidth) {\n    newX = canvasWidth - width;\n    positionAdjusted = true;\n  }\n\n  // Constrain top edge\n  if (newY < 0) {\n    newY = 0;\n    positionAdjusted = true;\n  }\n\n  // No bottom edge constraint - canvas grows vertically\n\n  // Ensure position doesn't go negative after adjustment\n  newX = Math.max(0, newX);\n  newY = Math.max(0, newY);\n\n  return {\n    x: newX,\n    y: newY,\n    width,\n    height,\n    positionAdjusted,\n    sizeAdjusted: false,\n  };\n}\n\n/**\n * Apply full boundary constraints to component placement\n *\n * Complete constraint pipeline:\n * 1. Check if component can fit (validate minSize <= canvas)\n * 2. Adjust size to fit canvas (if needed)\n * 3. Constrain position to keep within bounds\n *\n * **Returns null if component cannot fit** (minSize > canvas)\n *\n * @param definition - Component definition\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement, or null if component too large\n *\n * @example\n * ```typescript\n * const definition = {\n *   type: 'widget',\n *   defaultSize: { width: 60, height: 10 },\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const placement = applyBoundaryConstraints(definition, 45, 10);\n * // {\n * //   x: 0,              // Adjusted from 45 to fit\n * //   y: 10,             // No Y adjustment needed\n * //   width: 50,         // Shrunk from 60 to fit canvas\n * //   height: 10,        // No height adjustment\n * //   positionAdjusted: true,\n * //   sizeAdjusted: true\n * // }\n * ```\n */\nexport function applyBoundaryConstraints(\n  definition: ComponentDefinition,\n  x: number,\n  y: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS\n): ConstrainedPlacement | null {\n  // 1. Validate component can fit\n  if (!canComponentFitCanvas(definition, canvasWidth)) {\n    console.warn(\n      `Component \"${definition.name}\" minSize (${definition.minSize?.width}) ` +\n      `exceeds canvas width (${canvasWidth}). Placement rejected.`\n    );\n    return null;\n  }\n\n  // 2. Adjust size to fit canvas\n  const constrainedSize = constrainSizeToCanvas(definition, canvasWidth);\n\n  // 3. Constrain position to keep within bounds\n  const constrainedPlacement = constrainPositionToCanvas(\n    x,\n    y,\n    constrainedSize.width,\n    constrainedSize.height,\n    canvasWidth\n  );\n\n  // Combine size and position adjustments\n  return {\n    ...constrainedPlacement,\n    sizeAdjusted: constrainedSize.wasAdjusted,\n  };\n}\n"]}