{"version":3,"file":"resize-handler.js","sourceRoot":"","sources":["../../src/utils/resize-handler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Resize Handler\n * ===============\n *\n * High-performance resize system for grid items using interact.js with direct DOM\n * manipulation and requestAnimationFrame batching. Enables smooth 60fps resizing\n * with 8-point handles while avoiding framework re-render overhead.\n *\n * ## Problem\n *\n * Resizing UI elements at 60fps requires updating dimensions and position ~16ms per frame.\n * Using framework state updates would cause:\n * - Full component re-renders on every mousemove event during resize\n * - Virtual DOM diffing overhead\n * - Layout thrashing from repeated read/write cycles\n * - Janky, stuttering resize experience\n * - Position jumping on certain resize handles (bottom/right edges)\n *\n * ## Solution\n *\n * Hybrid approach combining interact.js resize events with RAF-batched DOM updates:\n *\n * 1. **During resize** (60fps): Direct DOM updates via RAF batching\n *    - No state updates\n *    - No re-renders\n *    - Smooth visual feedback\n *    - Batched with requestAnimationFrame\n *\n * 2. **After resize** (single operation): Update StencilJS state once\n *    - Trigger single re-render\n *    - Persist final dimensions\n *    - Emit undo/redo commands\n *\n * ## Key Architecture Decisions\n *\n * ### 8-Point Resize Handles\n *\n * **Configuration**: `edges: { left: true, right: true, bottom: true, top: true }`\n *\n * Provides 8 resize handles:\n * - 4 corners: top-left, top-right, bottom-left, bottom-right\n * - 4 edges: top, right, bottom, left\n *\n * **Why all 8 handles**:\n * - Maximum flexibility for users\n * - Matches familiar UI patterns (Figma, Photoshop, etc.)\n * - Enables precise positioning and sizing\n *\n * ### RequestAnimationFrame Batching\n *\n * **Pattern**:\n * ```typescript\n * handleResizeMove(event) {\n *   cancelAnimationFrame(this.rafId);\n *   this.rafId = requestAnimationFrame(() => {\n *     // Apply DOM updates once per frame\n *   });\n * }\n * ```\n *\n * **Why RAF batching**:\n * - Mousemove events fire faster than display refresh (60fps)\n * - Without batching: multiple DOM updates per frame (wasted work)\n * - With batching: exactly 1 DOM update per frame (aligned with browser paint)\n * - Prevents layout thrashing\n * - Smoother visual updates\n *\n * **Performance impact**:\n * - Without RAF: ~200 updates/sec, many dropped frames\n * - With RAF: ~60 updates/sec, no dropped frames\n * - **3-4x fewer DOM operations**\n *\n * ### Grid Snapping Strategy\n *\n * **When**: Only at resize end (endOnly: true)\n * **Why**: Allows free-form resizing during operation, snaps to grid on release\n *\n * **interact.js modifier**:\n * ```typescript\n * interact.modifiers.snap({\n *   targets: [interact.snappers.grid({ x: gridSizeX, y: gridSizeY })],\n *   endOnly: true  // Critical: prevents mid-resize jumps\n * })\n * ```\n *\n * **Alternative approaches and why they fail**:\n * - Snap during resize: Causes visual jumping, poor UX\n * - Manual snapping in handleResizeEnd: Works, but duplicates logic\n * - endOnly modifier: Clean, performant, built into interact.js\n *\n * ### DeltaRect Position Preservation\n *\n * **Problem**: Resizing from left/top edges changes element position\n * **Solution**: Track accumulated deltas and update transform\n *\n * **Example**:\n * - Resize from left edge: width increases, x position decreases\n * - deltaRect.left = -50 (element moved left 50px)\n * - deltaRect.width = 50 (element grew 50px wider)\n * - Apply both: new x = startX + (-50), new width = startWidth + 50\n *\n * **Why this is tricky**:\n * - Bottom/right resizes only change dimensions\n * - Top/left resizes change BOTH position and dimensions\n * - Must update transform AND width/height simultaneously\n * - interact.js provides deltaRect to handle this automatically\n *\n * ### Minimum Size Constraints\n *\n * **Configuration**:\n * ```typescript\n * interact.modifiers.restrictSize({ min: { width: 100, height: 80 } })\n * ```\n *\n * **Why these minimums**:\n * - width: 100px â†’ ~5 grid units (enough for readable text/UI)\n * - height: 80px â†’ ~4 grid units (matches common component heights)\n * - Prevents accidentally collapsing items to unusable sizes\n * - No maximum (items can grow to fill canvas)\n *\n * ## Performance Characteristics\n *\n * **During resize** (per frame):\n * - 1 RAF batch (~60fps max)\n * - 3 style updates (transform, width, height)\n * - No layout/reflow (transform is composited)\n * - ~0.5-1ms per frame\n *\n * **At resize end**:\n * - Grid snapping calculations\n * - Boundary constraint checks\n * - State update + single re-render\n * - ~5-10ms total\n *\n * **Performance gain over state-based approach**:\n * - State-based: ~16ms+ per frame (re-render overhead)\n * - This approach: ~0.5-1ms per frame\n * - **~16-30x faster during resize**\n *\n * ## Edge Cases Handled\n *\n * - Resize from any of 8 handles\n * - Position preservation during top/left resize\n * - Boundary constraints (can't resize outside canvas)\n * - Minimum size enforcement (100Ã—80px)\n * - Grid snapping without mid-resize jumps\n * - Mobile vs desktop viewport layouts\n * - Element styles not yet applied (RAF delay in constructor)\n * - Clean RAF cancellation on destroy\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n *\n * ```typescript\n * class MyResizeHandler {\n *   private rafId: number | null = null;\n *   private startRect = { x: 0, y: 0, width: 0, height: 0 };\n *\n *   handleResizeMove(e) {\n *     // Cancel previous frame\n *     if (this.rafId) cancelAnimationFrame(this.rafId);\n *\n *     // Batch with RAF\n *     this.rafId = requestAnimationFrame(() => {\n *       // Accumulate deltas\n *       this.startRect.x += e.deltaRect.left;\n *       this.startRect.y += e.deltaRect.top;\n *       this.startRect.width += e.deltaRect.width;\n *       this.startRect.height += e.deltaRect.height;\n *\n *       // Direct DOM update\n *       e.target.style.transform = `translate(${this.startRect.x}px, ${this.startRect.y}px)`;\n *       e.target.style.width = this.startRect.width + 'px';\n *       e.target.style.height = this.startRect.height + 'px';\n *     });\n *   }\n *\n *   handleResizeEnd(e) {\n *     cancelAnimationFrame(this.rafId);\n *     // Single state update\n *     this.updateState(this.startRect);\n *   }\n * }\n * ```\n *\n * ## Integration with Other Systems\n *\n * - **grid-calculations**: Convert between pixels and grid units\n * - **dom-cache**: Fast canvas element lookup\n * - **state-manager**: Single state update at resize end\n * - **undo-redo**: Command pushed via onUpdate callback\n * - **interact.js**: Event source for resize lifecycle + modifiers\n *\n * @module resize-handler\n */\n\nimport type { InteractResizeEvent, Interactable } from 'interactjs';\nimport { GridItem, setActiveCanvas } from '../services/state-manager';\nimport { ComponentDefinition } from '../types/component-definition';\nimport { GridConfig } from '../types/grid-config';\nimport { domCache } from './dom-cache';\nimport { getGridSizeHorizontal, getGridSizeVertical, pixelsToGridX, pixelsToGridY, gridToPixelsX, gridToPixelsY } from './grid-calculations';\nimport { BUILD_TIMESTAMP } from './version';\nimport { createDebugLogger } from './debug';\n\nconst debug = createDebugLogger('resize-handler');\n\n/**\n * Extract current transform position from element's inline style\n *\n * **Purpose**: Get element's current position for resize start position tracking\n *\n * **Why needed**: Resize operations must preserve position when resizing from\n * top/left handles. The transform is the canonical position source during operations.\n *\n * **Pattern shared with drag-handler**: Both drag and resize need base position\n * extraction, so this function is duplicated (could be extracted to shared utility).\n *\n * @param element - Element with transform style\n * @returns Current x,y position in pixels, or {0,0} if no transform\n *\n * @example\n * ```typescript\n * const el = document.getElementById('item-1');\n * el.style.transform = 'translate(100px, 150px)';\n * const pos = getTransformPosition(el); // â†’ {x: 100, y: 150}\n * ```\n */\nfunction getTransformPosition(element: HTMLElement): { x: number; y: number } {\n  const transform = element.style.transform;\n  const match = transform.match(/translate\\(([\\d.-]+)px,\\s*([\\d.-]+)px\\)/);\n\n  if (match) {\n    return {\n      x: parseFloat(match[1]),\n      y: parseFloat(match[2]),\n    };\n  }\n\n  return { x: 0, y: 0 };\n}\n\n/**\n * Resize Handler Class\n * =====================\n *\n * Manages high-performance resize behavior for a single grid item. Each grid item\n * gets its own ResizeHandler instance that coordinates interact.js resize events\n * with RAF-batched DOM updates and state management.\n *\n * ## Instance Lifecycle\n *\n * 1. **Creation**: Instantiated by grid-item-wrapper when item mounts\n * 2. **Initialization**: Sets up interact.js resizable with 8 handles + modifiers\n * 3. **Active**: Handles resize events with RAF-batched DOM manipulation\n * 4. **Cleanup**: destroy() called when item unmounts to prevent RAF/memory leaks\n *\n * ## State Management\n *\n * **Private state** (not in framework):\n * - `startRect`: Position and size at resize start\n * - `resizeRafId`: RAF handle for batching updates\n * - `interactInstance`: interact.js resizable instance\n *\n * **Framework state**: Updated only once at resize end via `onUpdate` callback\n *\n * ## Performance Pattern\n *\n * RAF batching + direct manipulation:\n * - High-frequency events (move): RAF-batched DOM updates\n * - Low-frequency events (start/end): State updates + event tracking\n * - Cancel pending RAF on each move (only last frame executes)\n *\n * @example\n * ```typescript\n * // In grid-item-wrapper.tsx\n * componentDidLoad() {\n *   this.resizeHandler = new ResizeHandler(\n *     this.element,\n *     this.item,\n *     (updatedItem) => {\n *       // This callback runs ONCE at resize end\n *       gridState.updateItem(updatedItem);\n *       undoRedo.pushCommand(new ResizeCommand(this.item, updatedItem));\n *     }\n *   );\n * }\n *\n * disconnectedCallback() {\n *   this.resizeHandler?.destroy(); // Critical: prevents RAF leak\n * }\n * ```\n */\nexport class ResizeHandler {\n  /** DOM element being resized (grid-item-wrapper element) */\n  private element: HTMLElement;\n\n  /** Grid item data (position, size, layouts) */\n  private item: GridItem;\n\n  /** Component definition (for min/max size constraints) */\n  private componentDefinition?: ComponentDefinition;\n\n  /** Grid configuration (for consistent grid size calculations) */\n  private config?: GridConfig;\n\n  /** Callback to update parent state after resize ends */\n  private onUpdate: (item: GridItem) => void;\n\n  /** interact.js resizable instance for cleanup */\n  private interactInstance: Interactable | null = null;\n\n  /** RAF ID for cancelling pending frame updates */\n  private resizeRafId: number | null = null;\n\n  /** Starting position and size at resize start (for deltaRect calculations) */\n  private startRect: { x: number; y: number; width: number; height: number } = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /** Last calculated position and size from handleResizeMove (for handleResizeEnd) */\n  private lastCalculated: { x: number; y: number; width: number; height: number } = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /** Min/max size constraints in pixels (cached from component definition) */\n  private minWidth: number = 100;\n  private minHeight: number = 80;\n  private maxWidth: number = Infinity;\n  private maxHeight: number = Infinity;\n\n  /**\n   * Create resize handler and initialize interact.js\n   *\n   * **Lifecycle**: Called when grid-item-wrapper mounts\n   *\n   * **RAF delay pattern**:\n   * If element doesn't have width/height styles yet, defers initialization to next frame.\n   * This handles race condition where StencilJS hasn't applied computed styles yet.\n   *\n   * **Why RAF delay is needed**:\n   * - interact.js reads element dimensions during setup\n   * - If dimensions are 0, resize handles won't work correctly\n   * - RAF ensures browser has completed style application\n   * - Only happens on initial mount, not on subsequent operations\n   *\n   * **Error handling**:\n   * Warns but continues if styles missing (won't break app, just logs issue)\n   *\n   * @param element - DOM element to make resizable (grid-item-wrapper)\n   * @param item - Grid item data for dimension/position management\n   * @param onUpdate - Callback invoked with updated item after resize ends\n   * @param componentDefinition - Optional component definition for min/max size constraints\n   *\n   * @example\n   * ```typescript\n   * // Typical usage in component\n   * private resizeHandler: ResizeHandler;\n   *\n   * componentDidLoad() {\n   *   const definition = this.componentRegistry.get(this.item.type);\n   *   this.resizeHandler = new ResizeHandler(\n   *     this.element,\n   *     this.item,\n   *     (item) => this.handleItemUpdate(item),\n   *     definition\n   *   );\n   * }\n   * ```\n   */\n  constructor(element: HTMLElement, item: GridItem, onUpdate: (item: GridItem) => void, componentDefinition?: ComponentDefinition, config?: GridConfig) {\n    this.element = element;\n    this.item = item;\n    this.onUpdate = onUpdate;\n    this.componentDefinition = componentDefinition;\n    this.config = config;\n\n    // Ensure element has width/height before initializing interact.js\n    // StencilJS might not have applied styles yet\n    if (!element.style.width || !element.style.height) {\n      console.warn('Element missing width/height styles, waiting for next frame');\n      requestAnimationFrame(() => this.initialize());\n    } else {\n      this.initialize();\n    }\n  }\n\n  /**\n   * Cleanup interact.js instance and cancel pending RAF\n   *\n   * **When to call**: Component unmount (disconnectedCallback in StencilJS)\n   *\n   * **Critical for RAF cleanup**:\n   * Unlike drag-handler, resize-handler uses RAF batching. Must cancel\n   * pending RAF to prevent:\n   * - Memory leaks from closures\n   * - Errors from updating removed elements\n   * - RAF callbacks firing after component destruction\n   *\n   * **What it does**:\n   * 1. Cancels any pending requestAnimationFrame\n   * 2. Calls `interactInstance.unset()` to remove event listeners\n   * 3. Safe to call multiple times (checks if instances exist)\n   *\n   * **Performance**: Very cheap operation (~0.1ms)\n   *\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper component\n   * disconnectedCallback() {\n   *   if (this.resizeHandler) {\n   *     this.resizeHandler.destroy(); // MUST call to prevent RAF leak\n   *   }\n   * }\n   * ```\n   */\n  destroy(): void {\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n      this.resizeRafId = null;\n    }\n\n    if (this.interactInstance) {\n      this.interactInstance.unset();\n    }\n  }\n\n  /**\n   * Initialize interact.js resizable on element\n   *\n   * **Configuration choices explained**:\n   *\n   * **edges: all true**\n   * - Enables 8 resize handles (4 corners + 4 edges)\n   * - Provides maximum flexibility for users\n   * - Matches familiar design tool patterns\n   *\n   * **modifiers array**:\n   * Order matters! Modifiers are applied in sequence:\n   *\n   * 1. **restrictSize modifier**: Enforces minimum dimensions\n   *    - min width: 100px (~5 grid units)\n   *    - min height: 80px (~4 grid units)\n   *    - Prevents unusably small items\n   *    - No maximum (items can grow to canvas bounds)\n   *\n   * 2. **snap modifier with endOnly: true**:\n   *    - Snaps to grid ONLY at resize end\n   *    - **Critical**: endOnly prevents mid-resize jumping\n   *    - Uses function callbacks for dynamic grid sizes\n   *    - range: Infinity means always snap (no distance limit)\n   *\n   * **Why function callbacks for grid sizes**:\n   * ```typescript\n   * x: () => getGridSizeHorizontal(this.item.canvasId)\n   * ```\n   * - Grid sizes can change (viewport switch, canvas resize)\n   * - Function ensures fresh value on each snap\n   * - Without callback, would cache stale grid size\n   *\n   * **Event binding**:\n   * - Uses `.bind(this)` to preserve class context\n   * - Without bind, `this` would be interact.js context\n   * - Allows handlers to access instance properties\n   *\n   * **Error handling**:\n   * - Checks if interact.js loaded (from CDN)\n   * - Fails gracefully with console warning\n   * - Prevents app crash if CDN fails\n   *\n   * @private\n   *\n   * @example\n   * ```typescript\n   * // interact.js resizable configuration\n   * interact(element).resizable({\n   *   edges: { left: true, right: true, bottom: true, top: true },\n   *   modifiers: [\n   *     interact.modifiers.restrictSize({ min: { width: 100, height: 80 } }),\n   *     interact.modifiers.snap({\n   *       targets: [interact.snappers.grid({ x: 20, y: 20 })],\n   *       endOnly: true  // Key: prevents visual jumping during resize\n   *     })\n   *   ]\n   * });\n   * ```\n   */\n  private initialize(): void {\n    // Log build timestamp and version info (only in development)\n    debug.log('ðŸ“¦ resize-handler.ts build:', BUILD_TIMESTAMP);\n    debug.log('ðŸ”§ Grid config fix applied - resize handler now uses same grid calculations as render');\n\n    const interact = window.interact;\n    if (!interact) {\n      console.warn('interact.js not loaded');\n      return;\n    }\n\n    // Get min/max size from component definition (in grid units), convert to pixels\n    const minSizeGridUnits = this.componentDefinition?.minSize;\n    const maxSizeGridUnits = this.componentDefinition?.maxSize;\n\n    this.minWidth = minSizeGridUnits\n      ? gridToPixelsX(minSizeGridUnits.width, this.item.canvasId, this.config)\n      : 100;\n    this.minHeight = minSizeGridUnits\n      ? gridToPixelsY(minSizeGridUnits.height, this.config)\n      : 80;\n\n    this.maxWidth = maxSizeGridUnits\n      ? gridToPixelsX(maxSizeGridUnits.width, this.item.canvasId, this.config)\n      : Infinity;\n    this.maxHeight = maxSizeGridUnits\n      ? gridToPixelsY(maxSizeGridUnits.height, this.config)\n      : Infinity;\n\n    // Determine which edges should be enabled based on min/max constraints\n    // If min == max for a dimension, disable resizing on that dimension\n    const canResizeWidth = this.maxWidth === Infinity || this.maxWidth > this.minWidth;\n    const canResizeHeight = this.maxHeight === Infinity || this.maxHeight > this.minHeight;\n\n    debug.log('ðŸ”§ ResizeHandler init for', this.item.id, {\n      minWidth: this.minWidth,\n      maxWidth: this.maxWidth,\n      minHeight: this.minHeight,\n      maxHeight: this.maxHeight,\n      canResizeWidth,\n      canResizeHeight,\n      componentDefinition: this.componentDefinition,\n    });\n\n    // Apply disabled class to element to control handle visibility via CSS\n    if (!canResizeWidth) {\n      debug.log('  âŒ Disabling width resize');\n      this.element.classList.add('resize-width-disabled');\n    }\n    if (!canResizeHeight) {\n      debug.log('  âŒ Disabling height resize');\n      this.element.classList.add('resize-height-disabled');\n    }\n\n    this.interactInstance = interact(this.element).resizable({\n      edges: {\n        left: canResizeWidth,\n        right: canResizeWidth,\n        bottom: canResizeHeight,\n        top: canResizeHeight\n      },\n\n      // Ignore resize from the drag handle header\n      ignoreFrom: '.grid-item-header',\n\n      // No modifiers - we handle all constraints manually in handleResizeMove\n      // This prevents fighting between interact.js modifiers and our RAF-batched updates\n\n      listeners: {\n        start: this.handleResizeStart.bind(this),\n        move: this.handleResizeMove.bind(this),\n        end: this.handleResizeEnd.bind(this),\n      },\n    });\n  }\n\n  /**\n   * Handle resize start event\n   *\n   * **Responsibilities**:\n   * 1. Start performance monitoring (if perfMonitor available)\n   * 2. Add visual feedback (resizing class)\n   * 3. Capture starting position and dimensions\n   * 4. Initialize startRect for deltaRect accumulation\n   *\n   * **Why capture startRect**:\n   * - interact.js provides deltaRect (cumulative changes)\n   * - Must apply deltas to starting values\n   * - Position can change during resize (top/left handles)\n   * - Dimensions always change during resize\n   *\n   * **startRect structure**:\n   * ```typescript\n   * {\n   *   x: 100,      // Starting transform X\n   *   y: 150,      // Starting transform Y\n   *   width: 300,  // Starting width in pixels\n   *   height: 200  // Starting height in pixels\n   * }\n   * ```\n   *\n   * **Performance tracking**:\n   * - Optional perfMonitor integration\n   * - Measures total resize duration (start â†’ end)\n   * - Helps identify performance regressions\n   *\n   * @private\n   * @param event - interact.js resize start event\n   *\n   * @example\n   * ```typescript\n   * // Event provides element reference\n   * {\n   *   target: HTMLElement,\n   *   rect: {width, height, left, top, ...},\n   *   // ... other interact.js properties\n   * }\n   * ```\n   */\n  private handleResizeStart(event: InteractResizeEvent): void {\n    // Start performance tracking\n    if (window.perfMonitor) {\n      window.perfMonitor.startOperation('resize');\n    }\n\n    event.target.classList.add('resizing');\n\n    // Set this canvas as active\n    setActiveCanvas(this.item.canvasId);\n\n    // Store the starting position and size\n    const position = getTransformPosition(event.target);\n    this.startRect.x = position.x;\n    this.startRect.y = position.y;\n    this.startRect.width = parseFloat(event.target.style.width) || 0;\n    this.startRect.height = parseFloat(event.target.style.height) || 0;\n\n    // Reset data attributes for tracking cumulative deltas (like drag-handler)\n    event.target.setAttribute('data-x', '0');\n    event.target.setAttribute('data-y', '0');\n    event.target.setAttribute('data-width', '0');\n    event.target.setAttribute('data-height', '0');\n\n    debug.log('ðŸŸ¢ RESIZE START:', {\n      edges: event.edges,\n      startRect: { ...this.startRect },\n      itemId: this.item.id,\n    });\n  }\n\n  /**\n   * Handle resize move event with RAF batching (high-frequency, ~60fps)\n   *\n   * **Critical Performance Path**: This runs ~200 times/sec during resize (mousemove),\n   * but RAF batching limits actual DOM updates to ~60fps.\n   *\n   * **Data Attribute Pattern + RAF Batching**:\n   * The implementation combines two strategies for smooth, accurate resizing:\n   * 1. **Data attributes**: Track cumulative deltas separately from DOM styles\n   * 2. **RAF batching**: Throttle DOM updates to 60fps max\n   *\n   * **RAF Batching Pattern**:\n   * ```\n   * // Update data attributes immediately (for next event)\n   * element.setAttribute('data-width', deltaWidth);\n   *\n   * cancelAnimationFrame(oldId);  // Cancel previous pending frame\n   * newId = requestAnimationFrame(() => {\n   *   // DOM updates execute once per browser paint (~60fps)\n   *   element.style.width = newWidth + 'px';\n   * });\n   * ```\n   *\n   * **Why RAF batching is critical**:\n   * - Mousemove fires ~200x/sec (faster than 60fps display)\n   * - Without batching: 200 DOM updates/sec, many wasted (can't paint that fast)\n   * - With batching: ~60 DOM updates/sec, aligned with browser paint\n   * - **3-4x fewer DOM operations**\n   * - Prevents frame drops and stuttering\n   *\n   * **DeltaRect Accumulation**:\n   * interact.js provides cumulative changes since resize start:\n   * - `deltaRect.left`: X position change (negative = moved left)\n   * - `deltaRect.top`: Y position change (negative = moved up)\n   * - `deltaRect.width`: Width change\n   * - `deltaRect.height`: Height change\n   *\n   * **Why accumulate into startRect**:\n   * - Maintains single source of truth for current state\n   * - Allows direct application to DOM\n   * - Simplifies final position calculation\n   *\n   * **Example resize from top-left handle**:\n   * ```\n   * Start: x=100, y=150, width=300, height=200\n   * User drags top-left handle up-left by 50px\n   * deltaRect: {left: -50, top: -50, width: 50, height: 50}\n   * Result: x=50, y=100, width=350, height=250\n   * ```\n   *\n   * **Performance per frame**:\n   * - Cancel previous RAF: ~0.01ms\n   * - Schedule new RAF: ~0.01ms\n   * - Actual DOM update (in RAF callback):\n   *   - 3 style updates (transform, width, height)\n   *   - No layout/reflow (transform is composited)\n   *   - ~0.5-1ms total\n   *\n   * **Without RAF batching**:\n   * - 200 updates/sec Ã— 1ms = 200ms/sec wasted\n   * - Dropped frames, stuttering\n   *\n   * **With RAF batching**:\n   * - 60 updates/sec Ã— 1ms = 60ms/sec\n   * - Smooth, no dropped frames\n   *\n   * @private\n   * @param event - interact.js resize move event\n   *\n   * @example\n   * ```typescript\n   * // Event provides deltaRect (cumulative changes)\n   * {\n   *   target: HTMLElement,\n   *   deltaRect: {\n   *     left: -10,   // Element moved left 10px\n   *     top: 0,      // No vertical movement\n   *     width: 10,   // Grew 10px wider\n   *     height: 0    // Height unchanged\n   *   }\n   * }\n   *\n   * // Applied as:\n   * // newX = startX + (-10)\n   * // newWidth = startWidth + 10\n   * ```\n   */\n  private handleResizeMove(event: InteractResizeEvent): void {\n    // Use data attributes to track cumulative deltas (same pattern as drag-handler)\n    // This prevents interact.js from getting confused about element position\n    const deltaX = (parseFloat(event.target.getAttribute('data-x')) || 0) + event.deltaRect.left;\n    const deltaY = (parseFloat(event.target.getAttribute('data-y')) || 0) + event.deltaRect.top;\n    const deltaWidth = (parseFloat(event.target.getAttribute('data-width')) || 0) + event.deltaRect.width;\n    const deltaHeight = (parseFloat(event.target.getAttribute('data-height')) || 0) + event.deltaRect.height;\n\n    // Update data attributes immediately for next move event\n    event.target.setAttribute('data-x', deltaX.toString());\n    event.target.setAttribute('data-y', deltaY.toString());\n    event.target.setAttribute('data-width', deltaWidth.toString());\n    event.target.setAttribute('data-height', deltaHeight.toString());\n\n    // Calculate new dimensions and position from base + deltas\n    let newWidth = this.startRect.width + deltaWidth;\n    let newHeight = this.startRect.height + deltaHeight;\n    let newX = this.startRect.x + deltaX;\n    let newY = this.startRect.y + deltaY;\n\n    // Get canvas dimensions for boundary constraints\n    const container = domCache.getCanvas(this.item.canvasId);\n    const containerWidth = container ? container.clientWidth : Infinity;\n    const containerHeight = container ? container.clientHeight : Infinity;\n\n    // Apply min/max size constraints first\n    newWidth = Math.max(this.minWidth, Math.min(this.maxWidth, newWidth));\n    newHeight = Math.max(this.minHeight, Math.min(this.maxHeight, newHeight));\n\n    // CRITICAL: Enforce canvas boundaries during resize\n    // Check all four edges independently to prevent overflow\n\n    // Left edge: position must be >= 0\n    if (newX < 0) {\n      if (event.edges.left) {\n        // Resizing from left edge: reduce width to compensate for negative position\n        newWidth = Math.max(this.minWidth, newWidth + newX);\n      }\n      newX = 0;\n    }\n\n    // Top edge: position must be >= 0\n    if (newY < 0) {\n      if (event.edges.top) {\n        // Resizing from top edge: reduce height to compensate for negative position\n        newHeight = Math.max(this.minHeight, newHeight + newY);\n      }\n      newY = 0;\n    }\n\n    // Right edge: x + width must be <= containerWidth\n    if (newX + newWidth > containerWidth) {\n      // Limit width so right edge stays at container boundary\n      // This works for both left and right edge resizing\n      newWidth = Math.max(this.minWidth, containerWidth - newX);\n    }\n\n    // Bottom edge: y + height must be <= containerHeight\n    if (newY + newHeight > containerHeight) {\n      // Limit height so bottom edge stays at container boundary\n      // This works for both top and bottom edge resizing\n      newHeight = Math.max(this.minHeight, containerHeight - newY);\n    }\n\n    // Cancel any pending RAF from previous move event\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n\n    // Batch DOM updates with RAF (limits to ~60fps instead of ~200/sec)\n    this.resizeRafId = requestAnimationFrame(() => {\n      debug.log('ðŸ”µ RESIZE MOVE (RAF):', {\n        edges: event.edges,\n        deltas: { deltaX, deltaY, deltaWidth, deltaHeight },\n        startRect: { ...this.startRect },\n        calculated: { newX, newY, newWidth, newHeight },\n      });\n\n      // Apply styles - smooth free-form resizing at 60fps max\n      event.target.style.transform = `translate(${newX}px, ${newY}px)`;\n      event.target.style.width = newWidth + 'px';\n      event.target.style.height = newHeight + 'px';\n\n      // Clear RAF ID after execution\n      this.resizeRafId = null;\n    });\n  }\n\n  /**\n   * Handle resize end event - finalize dimensions and update state\n   *\n   * **Critical responsibilities**:\n   * - Cancel pending RAF (prevent stale updates)\n   * - Grid snap position AND dimensions\n   * - Enforce boundary constraints\n   * - Convert viewport coordinates to container-relative\n   * - Update state (triggers single re-render)\n   *\n   * ## Processing Steps\n   *\n   * ### 1. RAF Cleanup\n   * Cancel any pending requestAnimationFrame to prevent stale updates after\n   * resize completes. Critical to avoid errors and ensure clean state.\n   *\n   * ### 2. Coordinate Conversion\n   * interact.js provides viewport coordinates (event.rect.left/top).\n   * Must convert to container-relative coordinates:\n   * ```\n   * containerRelativeX = viewportX - containerRect.left\n   * ```\n   *\n   * **Why conversion needed**:\n   * - CSS transform uses container-relative coordinates\n   * - event.rect uses viewport coordinates\n   * - Scrolled pages have different viewport vs container positions\n   *\n   * ### 3. Grid Snapping (Position AND Dimensions)\n   * Unlike drag, resize snaps BOTH position and dimensions:\n   * ```\n   * newX = Math.round(newX / gridSizeX) * gridSizeX\n   * newWidth = Math.round(newWidth / gridSizeX) * gridSizeX\n   * ```\n   *\n   * **Why snap dimensions**:\n   * - Ensures items align to grid cells\n   * - Prevents items spanning fractional grid units\n   * - Makes layouts predictable and clean\n   *\n   * ### 4. Boundary Constraints\n   * **Manual implementation** (interact.js restrictEdges breaks with deltaRect):\n   * ```\n   * newX = Math.max(0, newX);  // Left edge\n   * newX = Math.min(newX, containerWidth - itemWidth);  // Right edge\n   * ```\n   *\n   * **Why manual constraints**:\n   * - interact.js restrictEdges modifier conflicts with deltaRect\n   * - Manual constraints applied after grid snapping\n   * - Ensures final position respects canvas bounds\n   *\n   * ### 5. Mobile Layout Handling\n   * - Detects current viewport (desktop vs mobile)\n   * - Updates appropriate layout object\n   * - Marks mobile as \"customized\" when modified\n   * - Ensures mobile layouts don't auto-sync from desktop\n   *\n   * ### 6. State Persistence\n   * - Converts pixels to grid units\n   * - Updates item.layouts with new position and dimensions\n   * - Calls `onUpdate(item)` callback\n   * - Triggers single StencilJS re-render\n   * - Parent pushes undo/redo command\n   *\n   * ## Performance Characteristics\n   *\n   * **Total execution time**: ~5-10ms\n   * - RAF cancellation: ~0.01ms\n   * - Coordinate conversion: ~0.5ms\n   * - Grid snapping: ~1ms\n   * - Boundary checks: ~0.5ms\n   * - State update: ~3-5ms (single re-render)\n   *\n   * **Why this is acceptable**:\n   * - Only runs once at resize end (not 60fps)\n   * - User expects slight delay when releasing resize\n   * - Grid snapping provides visual feedback justifying delay\n   *\n   * ## Edge Cases Handled\n   *\n   * - Resize extending outside canvas â†’ clamped to bounds\n   * - Minimum size violations â†’ prevented by modifier\n   * - Position changes during resize (top/left handles) â†’ preserved via deltaRect\n   * - Container not found â†’ early exit (safety)\n   * - Mobile view â†’ mark as customized\n   * - Pending RAF â†’ cancelled before state update\n   *\n   * @private\n   * @param event - interact.js resize end event\n   *\n   * @example\n   * ```typescript\n   * // Example resize sequence (top-left handle):\n   * // 1. handleResizeStart: Store startRect (x=100, y=150, w=300, h=200)\n   * // 2. handleResizeMove (RAF batched): Apply deltaRect changes\n   * // 3. handleResizeEnd:\n   * //    - event.rect: {left: 525, top: 375, width: 350, height: 250} (viewport coords)\n   * //    - containerRect: {left: 475, top: 275} (viewport offset)\n   * //    - relativeX = 525 - 475 = 50px\n   * //    - relativeY = 375 - 275 = 100px\n   * //    - snappedX = round(50/20)*20 = 60px\n   * //    - gridX = 60/20 = 3 grid units\n   * //    - item.layouts.desktop.x = 3\n   * //    - onUpdate(item) â†’ re-render + undo command\n   * ```\n   */\n  private handleResizeEnd(event: InteractResizeEvent): void {\n    // Cancel any pending frame\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n      this.resizeRafId = null;\n    }\n\n    event.target.classList.remove('resizing');\n\n    // Get the container to calculate relative position\n    const container = domCache.getCanvas(this.item.canvasId);\n    if (!container) {\n      return;\n    }\n\n    const containerRect = container.getBoundingClientRect();\n    const gridSizeX = getGridSizeHorizontal(this.item.canvasId);\n    const gridSizeY = getGridSizeVertical();\n\n    // Get final deltas from data attributes BEFORE cleaning them up (like drag-handler)\n    const deltaX = parseFloat(event.target.getAttribute('data-x')) || 0;\n    const deltaY = parseFloat(event.target.getAttribute('data-y')) || 0;\n    const deltaWidth = parseFloat(event.target.getAttribute('data-width')) || 0;\n    const deltaHeight = parseFloat(event.target.getAttribute('data-height')) || 0;\n\n    // Clean up data attributes AFTER reading them\n    event.target.removeAttribute('data-x');\n    event.target.removeAttribute('data-y');\n    event.target.removeAttribute('data-width');\n    event.target.removeAttribute('data-height');\n\n    // Calculate final position and size from base + deltas\n    let newX = this.startRect.x + deltaX;\n    let newY = this.startRect.y + deltaY;\n    let newWidth = this.startRect.width + deltaWidth;\n    let newHeight = this.startRect.height + deltaHeight;\n\n    debug.log('ðŸ”´ RESIZE END:', {\n      edges: event.edges,\n      eventRect: { left: event.rect.left, top: event.rect.top, width: event.rect.width, height: event.rect.height },\n      containerRect: { left: containerRect.left, top: containerRect.top },\n      beforeSnap: { newX, newY, newWidth, newHeight },\n      gridSize: { gridSizeX, gridSizeY },\n      startRect: { ...this.startRect },\n      lastCalculated: { ...this.lastCalculated },\n    });\n\n    // Grid snap AFTER user releases mouse (not during resize)\n    // Use directional rounding based on resize direction to prevent snap-back\n    // If user made item bigger, round UP. If smaller, round DOWN.\n\n    // Width: directional rounding based on whether user grew or shrunk\n    if (newWidth > this.startRect.width) {\n      // User made it wider â†’ round UP to next grid cell\n      newWidth = Math.ceil(newWidth / gridSizeX) * gridSizeX;\n    } else if (newWidth < this.startRect.width) {\n      // User made it narrower â†’ round DOWN to previous grid cell\n      newWidth = Math.floor(newWidth / gridSizeX) * gridSizeX;\n    } else {\n      // No change â†’ keep original (round normally)\n      newWidth = Math.round(newWidth / gridSizeX) * gridSizeX;\n    }\n    // Ensure grid snapping doesn't violate minimum size\n    newWidth = Math.max(this.minWidth, newWidth);\n\n    // Height: directional rounding based on whether user grew or shrunk\n    if (newHeight > this.startRect.height) {\n      // User made it taller â†’ round UP to next grid cell\n      newHeight = Math.ceil(newHeight / gridSizeY) * gridSizeY;\n    } else if (newHeight < this.startRect.height) {\n      // User made it shorter â†’ round DOWN to previous grid cell\n      newHeight = Math.floor(newHeight / gridSizeY) * gridSizeY;\n    } else {\n      // No change â†’ keep original\n      newHeight = Math.round(newHeight / gridSizeY) * gridSizeY;\n    }\n    // Ensure grid snapping doesn't violate minimum size\n    newHeight = Math.max(this.minHeight, newHeight);\n\n    // Position: directional rounding for top/left edge resizes\n    if (newX < this.startRect.x) {\n      // User moved left edge left â†’ round DOWN (move further left to grid)\n      newX = Math.floor(newX / gridSizeX) * gridSizeX;\n    } else if (newX > this.startRect.x) {\n      // User moved left edge right â†’ round UP (move further right to grid)\n      newX = Math.ceil(newX / gridSizeX) * gridSizeX;\n    } else {\n      newX = Math.round(newX / gridSizeX) * gridSizeX;\n    }\n\n    if (newY < this.startRect.y) {\n      // User moved top edge up â†’ round DOWN (move further up to grid)\n      newY = Math.floor(newY / gridSizeY) * gridSizeY;\n    } else if (newY > this.startRect.y) {\n      // User moved top edge down â†’ round UP (move further down to grid)\n      newY = Math.ceil(newY / gridSizeY) * gridSizeY;\n    } else {\n      newY = Math.round(newY / gridSizeY) * gridSizeY;\n    }\n\n    debug.log('  afterDirectionalSnap:', { newX, newY, newWidth, newHeight });\n\n    // Apply min/max size constraints AFTER grid snapping\n    // This ensures the final size respects component constraints\n    // IMPORTANT: When clamping, adjust position if resizing from top/left edges\n    const originalWidth = newWidth;\n    const originalHeight = newHeight;\n\n    newWidth = Math.max(this.minWidth, Math.min(this.maxWidth, newWidth));\n    newHeight = Math.max(this.minHeight, Math.min(this.maxHeight, newHeight));\n\n    // If width was clamped and we're resizing from the left edge, adjust x position\n    if (originalWidth !== newWidth && event.edges.left) {\n      const widthDiff = originalWidth - newWidth;\n      newX += widthDiff;\n    }\n\n    // If height was clamped and we're resizing from the top edge, adjust y position\n    if (originalHeight !== newHeight && event.edges.top) {\n      const heightDiff = originalHeight - newHeight;\n      newY += heightDiff;\n    }\n\n    debug.log('  afterMinMaxClamp:', { newX, newY, newWidth, newHeight });\n\n    // COMPREHENSIVE BOUNDARY CONSTRAINT CHECK\n    // =========================================\n    // Ensure all 4 corners of the component stay within canvas bounds.\n    // Priority: shrink if too large, then move if position is outside.\n\n    const canvasWidth = container.clientWidth;\n    const canvasHeight = container.clientHeight;\n\n    debug.log('  canvasBounds:', { canvasWidth, canvasHeight });\n\n    // 1. HORIZONTAL BOUNDS CHECK\n    // ---------------------------\n    // If component is wider than canvas, shrink it to fit\n    if (newWidth > canvasWidth) {\n      debug.log('  âš ï¸ Width exceeds canvas, shrinking from', newWidth, 'to', canvasWidth);\n      newWidth = canvasWidth;\n    }\n\n    // Ensure left edge is within bounds (x >= 0)\n    if (newX < 0) {\n      debug.log('  âš ï¸ Left edge outside canvas, moving from x =', newX, 'to x = 0');\n      newX = 0;\n    }\n\n    // Ensure right edge is within bounds (x + width <= canvasWidth)\n    if (newX + newWidth > canvasWidth) {\n      if (event.edges && event.edges.right) {\n        // Resizing from RIGHT edge: clamp width to fit, keep position\n        const maxWidth = canvasWidth - newX;\n        debug.log('  âš ï¸ Right edge overflow (resizing from right), clamping width from', newWidth, 'to', maxWidth);\n        newWidth = Math.max(this.minWidth, maxWidth);\n      } else {\n        // Not resizing from right (dragging or resizing from left): move left to fit\n        const requiredX = canvasWidth - newWidth;\n        debug.log('  âš ï¸ Right edge outside canvas, moving from x =', newX, 'to x =', requiredX);\n        newX = requiredX;\n\n        // If still doesn't fit (requiredX < 0), shrink width\n        if (newX < 0) {\n          debug.log('  âš ï¸ Cannot fit by moving, shrinking width to', canvasWidth);\n          newWidth = canvasWidth;\n          newX = 0;\n        }\n      }\n    }\n\n    // 2. VERTICAL BOUNDS CHECK\n    // -------------------------\n    // If component is taller than canvas, shrink it to fit\n    if (newHeight > canvasHeight) {\n      debug.log('  âš ï¸ Height exceeds canvas, shrinking from', newHeight, 'to', canvasHeight);\n      newHeight = canvasHeight;\n    }\n\n    // Ensure top edge is within bounds (y >= 0)\n    if (newY < 0) {\n      debug.log('  âš ï¸ Top edge outside canvas, moving from y =', newY, 'to y = 0');\n      newY = 0;\n    }\n\n    // Ensure bottom edge is within bounds (y + height <= canvasHeight)\n    if (newY + newHeight > canvasHeight) {\n      if (event.edges && event.edges.bottom) {\n        // Resizing from BOTTOM edge: clamp height to fit, keep Y position\n        const maxHeight = canvasHeight - newY;\n        debug.log('  âš ï¸ Bottom edge overflow (resizing from bottom), clamping height from', newHeight, 'to', maxHeight);\n        newHeight = Math.max(this.minHeight, maxHeight);\n      } else {\n        // Not resizing from bottom (dragging or resizing from top): move up to fit\n        const requiredY = canvasHeight - newHeight;\n        debug.log('  âš ï¸ Bottom edge outside canvas, moving from y =', newY, 'to y =', requiredY);\n        newY = requiredY;\n\n        // If still doesn't fit (requiredY < 0), shrink height\n        if (newY < 0) {\n          debug.log('  âš ï¸ Cannot fit by moving, shrinking height to', canvasHeight);\n          newHeight = canvasHeight;\n          newY = 0;\n        }\n      }\n    }\n\n    debug.log('  afterBoundaryCheck:', { newX, newY, newWidth, newHeight });\n\n    // Apply final snapped position\n    event.target.style.transform = `translate(${newX}px, ${newY}px)`;\n    event.target.style.width = newWidth + 'px';\n    event.target.style.height = newHeight + 'px';\n\n    debug.log('  appliedToDOM:', {\n      transform: `translate(${newX}px, ${newY}px)`,\n      width: `${newWidth}px`,\n      height: `${newHeight}px`,\n    });\n\n    // Update item size and position in current viewport's layout (convert to grid units)\n    const currentViewport = window.gridState?.currentViewport || 'desktop';\n    const layout = this.item.layouts[currentViewport as 'desktop' | 'mobile'];\n\n    layout.width = pixelsToGridX(newWidth, this.item.canvasId, this.config);\n    layout.height = pixelsToGridY(newHeight, this.config);\n    layout.x = pixelsToGridX(newX, this.item.canvasId, this.config);\n    layout.y = pixelsToGridY(newY, this.config);\n\n    debug.log('  finalGridUnits:', {\n      x: layout.x,\n      y: layout.y,\n      width: layout.width,\n      height: layout.height,\n    });\n    debug.log('---');\n\n    // If in mobile view, mark as customized\n    if (currentViewport === 'mobile') {\n      this.item.layouts.mobile.customized = true;\n    }\n\n    // End performance tracking\n    if (window.perfMonitor) {\n      window.perfMonitor.endOperation('resize');\n    }\n\n    // Trigger StencilJS update (single re-render at end)\n    this.onUpdate(this.item);\n  }\n}\n"]}