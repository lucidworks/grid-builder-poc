{"version":3,"file":"grid-builder-api.js","sourceRoot":"","sources":["../../src/services/grid-builder-api.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * GridBuilderAPI - Public API for the Grid Builder Library\n * ========================================================\n *\n * This class provides a clean, well-documented API for consumers to interact\n * with the grid builder system. It wraps the internal state management and\n * provides methods for:\n *\n * - Item management (add, remove, update, move)\n * - Selection handling\n * - Viewport switching\n * - Undo/redo operations\n * - State import/export\n * - Event subscription\n *\n * ## Usage Example\n *\n * ```typescript\n * // Get API instance from grid-builder component\n * const api = await gridBuilder.getAPI();\n *\n * // Listen for events\n * api.on('itemAdded', (event) => {\n *   console.log('Item added:', event.item);\n * });\n *\n * // Add an item\n * const item = api.addItem('canvas1', 'header', 10, 10, 20, 15);\n *\n * // Update item\n * api.updateItem('canvas1', item.id, {\n *   layouts: {\n *     desktop: { x: 15, y: 15, width: 25, height: 20 },\n *     mobile: { x: null, y: null, width: null, height: null, customized: false },\n *   },\n * });\n *\n * // Export state\n * const json = api.exportState();\n * localStorage.setItem('gridState', json);\n *\n * // Import state\n * const json = localStorage.getItem('gridState');\n * if (json) {\n *   api.importState(json);\n * }\n * ```\n *\n * @module grid-builder-api\n */\n\nimport {\n  addItemsBatch,\n  deleteItemsBatch,\n  deselectItem,\n  generateItemId,\n  getItem as getItemFromState,\n  GridItem,\n  gridState,\n  GridState,\n  reset as resetState,\n  selectItem as selectItemInState,\n  updateItemsBatch,\n} from './state-manager';\nimport {\n  AddCanvasCommand,\n  AddItemCommand,\n  BatchAddCommand,\n  BatchDeleteCommand,\n  BatchUpdateConfigCommand,\n  MoveItemCommand,\n  RemoveCanvasCommand,\n  RemoveItemCommand,\n  SetViewportCommand,\n  ToggleGridCommand,\n  UpdateItemCommand,\n} from './undo-redo-commands';\nimport {\n  canRedo as canRedoInternal,\n  canUndo as canUndoInternal,\n  clearHistory as clearHistoryInternal,\n  pushCommand,\n  redo as redoInternal,\n  undo as undoInternal,\n} from './undo-redo';\nimport {\n  CanvasAddedEvent,\n  CanvasRemovedEvent,\n  GridBuilderEventMap,\n  GridVisibilityChangedEvent,\n  ItemAddedEvent,\n  ItemMovedEvent,\n  ItemRemovedEvent,\n  ItemUpdatedEvent,\n  SelectionChangedEvent,\n  StateChangedEvent,\n  ViewportChangedEvent,\n} from '../types/events';\n\n/**\n * Event listener function type\n */\ntype EventListener<K extends keyof GridBuilderEventMap> = (event: GridBuilderEventMap[K]) => void;\n\n/**\n * Event emitter for grid builder events\n *\n * Uses a Map of event name → Set of listeners for efficient\n * listener management and notification\n */\nclass EventEmitter {\n  private listeners: Map<keyof GridBuilderEventMap, Set<EventListener<any>>> = new Map();\n\n  /**\n   * Register an event listener\n   */\n  on<K extends keyof GridBuilderEventMap>(event: K, listener: EventListener<K>): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(listener);\n  }\n\n  /**\n   * Unregister an event listener\n   */\n  off<K extends keyof GridBuilderEventMap>(event: K, listener: EventListener<K>): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n    }\n  }\n\n  /**\n   * Register a one-time event listener\n   */\n  once<K extends keyof GridBuilderEventMap>(event: K, listener: EventListener<K>): void {\n    const onceListener = ((eventData: GridBuilderEventMap[K]) => {\n      this.off(event, onceListener);\n      listener(eventData);\n    }) as EventListener<K>;\n\n    this.on(event, onceListener);\n  }\n\n  /**\n   * Emit an event to all registered listeners\n   */\n  emit<K extends keyof GridBuilderEventMap>(event: K, data: GridBuilderEventMap[K]): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach((listener) => listener(data));\n    }\n  }\n\n  /**\n   * Remove all event listeners\n   */\n  clear(): void {\n    this.listeners.clear();\n  }\n}\n\n/**\n * GridBuilderAPI - Main API class for grid builder library\n *\n * Provides high-level methods for interacting with the grid builder,\n * event subscription, and state management.\n */\nexport class GridBuilderAPI {\n  private eventEmitter: EventEmitter = new EventEmitter();\n\n  // ============================================================================\n  // State Access Methods\n  // ============================================================================\n\n  /**\n   * Get the current grid state\n   *\n   * **Note**: Returns reference to state object. Mutations will affect the grid.\n   * For read-only access, use `exportState()` and parse the JSON.\n   *\n   * @returns Current grid state object\n   */\n  getState(): GridState {\n    return gridState;\n  }\n\n  /**\n   * Get all canvases\n   *\n   * @returns Object mapping canvas IDs to canvas data\n   */\n  getCanvases() {\n    return gridState.canvases;\n  }\n\n  /**\n   * Get a specific canvas\n   *\n   * @param canvasId - Canvas ID\n   * @returns Canvas data or null if not found\n   */\n  getCanvas(canvasId: string) {\n    return gridState.canvases[canvasId] || null;\n  }\n\n  /**\n   * Add a canvas with undo/redo support\n   *\n   * **Pattern**: Library manages item placement, host app manages presentation\n   *\n   * **Library responsibility** (what this method does):\n   * - Create canvas in gridState.canvases with empty items array\n   * - Initialize zIndexCounter for item stacking\n   * - Track operation in undo/redo stack\n   * - Emit canvasAdded event\n   *\n   * **Host app responsibility** (what this method does NOT do):\n   * - Store canvas title, backgroundColor, or other metadata\n   * - Host app must maintain its own canvas metadata separately\n   * - Host app listens to canvasAdded event to sync its state\n   *\n   * **Integration pattern**:\n   * ```typescript\n   * // Host app maintains canvas metadata\n   * const canvasMetadata = {\n   *   'hero-section': { title: 'Hero Section', backgroundColor: '#f0f4f8' }\n   * };\n   *\n   * // Listen to library events\n   * api.on('canvasAdded', (event) => {\n   *   // Host app knows a canvas was created, can update UI\n   *   console.log('Canvas added:', event.canvasId);\n   * });\n   *\n   * // Create canvas in library (just placement state)\n   * api.addCanvas('hero-section');\n   *\n   * // Later: undo/redo works for library state\n   * api.undo(); // Removes canvas from library\n   * api.redo(); // Restores canvas in library\n   *\n   * // Host app manages its own metadata undo/redo separately\n   * ```\n   *\n   * @param canvasId - Unique canvas identifier\n   *\n   * @emits canvasAdded - After canvas is created in library state\n   * @emits stateChanged - After state is updated\n   *\n   * @example\n   * ```typescript\n   * // Host app adds a new section\n   * api.addCanvas('hero-section');\n   *\n   * // Later: user can undo\n   * api.undo(); // Removes the canvas\n   *\n   * // And redo\n   * api.redo(); // Brings it back\n   * ```\n   */\n  addCanvas(canvasId: string): void {\n    const cmd = new AddCanvasCommand(canvasId);\n    pushCommand(cmd);\n    cmd.redo(); // Execute the command\n\n    // Emit event\n    this.eventEmitter.emit('canvasAdded', { canvasId } as CanvasAddedEvent);\n  }\n\n  /**\n   * Remove a canvas with undo/redo support\n   *\n   * **Critical**: Removes canvas AND all its items\n   *\n   * **Undo behavior**: Restores canvas with all items in original state\n   *\n   * **Host app responsibilities**:\n   * - Listen to canvasRemoved event\n   * - Update its own UI/state\n   * - Handle cleanup of canvas-specific resources\n   *\n   * @param canvasId - Canvas to remove\n   *\n   * @emits canvasRemoved - After canvas is removed\n   * @emits stateChanged - After state is updated\n   *\n   * @example\n   * ```typescript\n   * // Host app removes a section\n   * api.removeCanvas('custom-section-1');\n   *\n   * // Later: user can undo\n   * api.undo(); // Restores canvas with all its items\n   * ```\n   */\n  removeCanvas(canvasId: string): void {\n    const cmd = new RemoveCanvasCommand(canvasId);\n    pushCommand(cmd);\n    cmd.redo(); // Execute the command\n\n    // Emit event\n    this.eventEmitter.emit('canvasRemoved', { canvasId } as CanvasRemovedEvent);\n  }\n\n  /**\n   * Get a specific item from a canvas\n   *\n   * @param canvasId - Canvas ID\n   * @param itemId - Item ID\n   * @returns Grid item or null if not found\n   */\n  getItem(canvasId: string, itemId: string): GridItem | null {\n    return getItemFromState(canvasId, itemId);\n  }\n\n  /**\n   * Get current viewport\n   *\n   * @returns Current viewport ('desktop' or 'mobile')\n   */\n  getCurrentViewport() {\n    return gridState.currentViewport;\n  }\n\n  /**\n   * Get grid visibility state\n   *\n   * @returns True if grid is visible, false otherwise\n   */\n  getGridVisibility(): boolean {\n    return gridState.showGrid;\n  }\n\n  /**\n   * Get currently selected item\n   *\n   * @returns Object with itemId and canvasId, or null if nothing selected\n   */\n  getSelectedItem(): { itemId: string; canvasId: string } | null {\n    if (gridState.selectedItemId && gridState.selectedCanvasId) {\n      return {\n        itemId: gridState.selectedItemId,\n        canvasId: gridState.selectedCanvasId,\n      };\n    }\n    return null;\n  }\n\n  // ============================================================================\n  // Item Management Methods\n  // ============================================================================\n\n  /**\n   * Add an item to a canvas\n   *\n   * Creates a new grid item with generated ID and adds it to the specified canvas.\n   * This operation is undoable.\n   *\n   * @param canvasId - Target canvas ID\n   * @param componentType - Type of component to add\n   * @param x - X position in grid units\n   * @param y - Y position in grid units\n   * @param width - Width in grid units\n   * @param height - Height in grid units\n   * @param config - Optional component configuration data\n   * @returns Created grid item\n   *\n   * @emits itemAdded\n   */\n  addItem(\n    canvasId: string,\n    componentType: string,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    config?: Record<string, any>\n  ): GridItem {\n    const item: GridItem = {\n      id: generateItemId(),\n      canvasId,\n      type: componentType,\n      name: componentType,\n      layouts: {\n        desktop: { x, y, width, height },\n        mobile: { x: null, y: null, width: null, height: null, customized: false },\n      },\n      zIndex: gridState.canvases[canvasId]?.zIndexCounter || 1,\n      config: config || {},\n    };\n\n    const command = new AddItemCommand(canvasId, item);\n    command.redo(); // Execute command first\n    pushCommand(command); // Then add to history\n\n    this.eventEmitter.emit('itemAdded', { item, canvasId } as ItemAddedEvent);\n\n    return item;\n  }\n\n  /**\n   * Remove an item from a canvas\n   *\n   * This operation is undoable.\n   *\n   * @param canvasId - Canvas ID\n   * @param itemId - Item ID to remove\n   *\n   * @emits itemRemoved\n   */\n  removeItem(canvasId: string, itemId: string): void {\n    const item = getItemFromState(canvasId, itemId);\n    if (!item) {\n      return;\n    }\n\n    const command = new RemoveItemCommand(canvasId, item);\n    command.redo(); // Execute command first\n    pushCommand(command); // Then add to history\n\n    this.eventEmitter.emit('itemRemoved', { itemId, canvasId } as ItemRemovedEvent);\n  }\n\n  /**\n   * Update an item's properties\n   *\n   * This operation is undoable.\n   *\n   * @param canvasId - Canvas ID\n   * @param itemId - Item ID to update\n   * @param updates - Partial item data to merge\n   *\n   * @emits itemUpdated\n   */\n  updateItem(canvasId: string, itemId: string, updates: Partial<GridItem>): void {\n    const oldItem = getItemFromState(canvasId, itemId);\n    if (!oldItem) {\n      return;\n    }\n\n    const command = new UpdateItemCommand(canvasId, itemId, oldItem, updates);\n    command.redo(); // Execute command first\n    pushCommand(command); // Then add to history\n\n    this.eventEmitter.emit('itemUpdated', { itemId, canvasId, updates } as ItemUpdatedEvent);\n  }\n\n  /**\n   * Move an item from one canvas to another\n   *\n   * This operation is undoable.\n   *\n   * @param fromCanvasId - Source canvas ID\n   * @param toCanvasId - Target canvas ID\n   * @param itemId - Item ID to move\n   *\n   * @emits itemMoved\n   */\n  moveItem(fromCanvasId: string, toCanvasId: string, itemId: string): void {\n    const item = getItemFromState(fromCanvasId, itemId);\n    if (!item) {\n      return;\n    }\n\n    // Get source canvas to find item index\n    const sourceCanvas = gridState.canvases[fromCanvasId];\n    if (!sourceCanvas) {\n      return;\n    }\n\n    const sourceIndex = sourceCanvas.items.findIndex((i) => i.id === itemId);\n    const sourcePosition = { x: item.layouts.desktop.x, y: item.layouts.desktop.y };\n    const targetPosition = { x: item.layouts.desktop.x, y: item.layouts.desktop.y };\n\n    const command = new MoveItemCommand(\n      itemId,\n      fromCanvasId,\n      toCanvasId,\n      sourcePosition,\n      targetPosition,\n      sourceIndex\n    );\n    command.redo(); // Execute command first\n    pushCommand(command); // Then add to history\n\n    this.eventEmitter.emit('itemMoved', { itemId, fromCanvasId, toCanvasId } as ItemMovedEvent);\n  }\n\n  // ============================================================================\n  // Batch Operations\n  // ============================================================================\n\n  /**\n   * Add multiple items in a single batch operation\n   *\n   * **Performance Optimization** (Extraction Guide Phase 7.2):\n   * Batch operations trigger a single state update and re-render, compared to\n   * N individual updates causing N re-renders. For 100 items:\n   * - Individual: 100 re-renders (~1600ms)\n   * - Batch: 1 re-render (~16ms)\n   * - **100× performance improvement**\n   *\n   * **Undo/Redo Integration**:\n   * The entire batch operation is treated as a single undoable command.\n   * Calling undo() will remove all items added in the batch, and redo()\n   * will restore all of them in a single operation.\n   *\n   * **Best Practices**:\n   * - Use for 3+ items (overhead is negligible, benefits scale with size)\n   * - Group related operations for logical undo/redo units\n   * - Keep batches under 1000 items for optimal performance\n   * - Batch operations emit single `itemsBatchAdded` event (not individual `itemAdded`)\n   *\n   * @param items - Array of item specifications with the following properties:\n   *   - `canvasId` (string): Target canvas ID where item will be added\n   *   - `type` (string): Component type identifier (must match a component definition)\n   *   - `x` (number): X position in grid units (0-based)\n   *   - `y` (number): Y position in grid units (0-based)\n   *   - `width` (number): Width in grid units\n   *   - `height` (number): Height in grid units\n   *   - `config` (object, optional): Component-specific configuration data\n   *\n   * @returns Array of created item IDs (in same order as input array)\n   *\n   * @emits itemsBatchAdded - Fired once after all items are added\n   * @emits stateChanged - Fired once after batch completes (inherited from state update)\n   *\n   * @example\n   * ```typescript\n   * // Add a hero section and 3 article cards in one operation\n   * const itemIds = api.addItemsBatch([\n   *   {\n   *     canvasId: 'canvas1',\n   *     type: 'hero',\n   *     x: 0, y: 0,\n   *     width: 50, height: 15,\n   *     config: { headline: 'Welcome', background: '#007bff' }\n   *   },\n   *   {\n   *     canvasId: 'canvas1',\n   *     type: 'article',\n   *     x: 0, y: 20,\n   *     width: 15, height: 12,\n   *     config: { title: 'Article 1' }\n   *   },\n   *   {\n   *     canvasId: 'canvas1',\n   *     type: 'article',\n   *     x: 17, y: 20,\n   *     width: 15, height: 12,\n   *     config: { title: 'Article 2' }\n   *   },\n   *   {\n   *     canvasId: 'canvas1',\n   *     type: 'article',\n   *     x: 34, y: 20,\n   *     width: 15, height: 12,\n   *     config: { title: 'Article 3' }\n   *   }\n   * ]);\n   *\n   * console.log(`Added ${itemIds.length} items`); // \"Added 4 items\"\n   *\n   * // Undo removes all 4 items in one operation\n   * api.undo();\n   *\n   * // Redo restores all 4 items in one operation\n   * api.redo();\n   * ```\n   *\n   * @see https://github.com/yourusername/extraction-guide#phase-72-batch-operations\n   */\n  addItemsBatch(\n    items: Array<{\n      canvasId: string;\n      type: string;\n      x: number;\n      y: number;\n      width: number;\n      height: number;\n      config?: Record<string, any>;\n    }>\n  ): string[] {\n    // Convert API format to state-manager format\n    const partialItems = items.map(({ canvasId, type, x, y, width, height, config }) => ({\n      canvasId,\n      type,\n      name: type,\n      layouts: {\n        desktop: { x, y, width, height },\n        mobile: { x: null, y: null, width: null, height: null, customized: false },\n      },\n      config: config || {},\n    }));\n\n    // Use state-manager batch operation (single state update)\n    const itemIds = addItemsBatch(partialItems);\n\n    // Add to undo/redo history\n    const command = new BatchAddCommand(itemIds);\n    pushCommand(command); // Note: Batch operations store full item data, so no need to redo()\n\n    // Collect all created items for event\n    const createdItems = itemIds.map((id) => this.findItemById(id)).filter(Boolean) as GridItem[];\n\n    // Emit single batch event\n    this.eventEmitter.emit('itemsBatchAdded', { items: createdItems });\n\n    return itemIds;\n  }\n\n  /**\n   * Delete multiple items in a single batch operation\n   *\n   * **Performance Optimization** (Extraction Guide Phase 7.2):\n   * Batch deletion triggers a single state update and re-render, compared to\n   * N individual deletes causing N re-renders. For 50 items:\n   * - Individual: 50 re-renders (~800ms)\n   * - Batch: 1 re-render (~16ms)\n   * - **50× performance improvement**\n   *\n   * **Undo/Redo Integration**:\n   * The entire batch deletion is treated as a single undoable command.\n   * Calling undo() will restore all deleted items with their original\n   * positions, configs, and z-indices. Calling redo() will delete them\n   * all again in a single operation.\n   *\n   * **Selection Handling**:\n   * If any deleted item is currently selected, the selection is automatically\n   * cleared. This prevents orphaned selection state.\n   *\n   * **Best Practices**:\n   * - Use for bulk cleanup operations (e.g., \"Clear Canvas\", \"Delete Selected\")\n   * - Combine with batch add for \"Replace All\" operations\n   * - Items are deleted across all canvases (itemIds can span multiple canvases)\n   * - Batch operations emit single `itemsBatchDeleted` event (not individual `itemRemoved`)\n   *\n   * @param itemIds - Array of item IDs to delete. Item IDs can belong to different\n   *   canvases. Invalid or non-existent item IDs are silently ignored (no error thrown).\n   *\n   * @emits itemsBatchDeleted - Fired once after all items are deleted\n   * @emits selectionChanged - Fired if a selected item was deleted\n   * @emits stateChanged - Fired once after batch completes (inherited from state update)\n   *\n   * @example\n   * ```typescript\n   * // Delete all selected items in one operation\n   * const selectedIds = ['item-1', 'item-2', 'item-3'];\n   * api.deleteItemsBatch(selectedIds);\n   *\n   * // Undo restores all 3 items\n   * api.undo();\n   *\n   * // Clear entire canvas\n   * const canvas = api.getCanvas('canvas1');\n   * const allItemIds = canvas.items.map(item => item.id);\n   * api.deleteItemsBatch(allItemIds);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Delete items across multiple canvases\n   * api.deleteItemsBatch([\n   *   'canvas1-item-1',\n   *   'canvas1-item-2',\n   *   'canvas2-item-5',\n   *   'canvas2-item-6'\n   * ]); // All 4 items deleted in one operation\n   * ```\n   *\n   * @see https://github.com/yourusername/extraction-guide#phase-72-batch-operations\n   */\n  deleteItemsBatch(itemIds: string[]): void {\n    // Add to undo/redo history BEFORE deletion (need state for undo)\n    const command = new BatchDeleteCommand(itemIds);\n    pushCommand(command);\n\n    // Use state-manager batch operation (single state update)\n    deleteItemsBatch(itemIds);\n\n    // Clear selection if any deleted item was selected\n    if (gridState.selectedItemId && itemIds.includes(gridState.selectedItemId)) {\n      gridState.selectedItemId = null;\n      gridState.selectedCanvasId = null;\n    }\n\n    // Emit single batch event\n    this.eventEmitter.emit('itemsBatchDeleted', { itemIds });\n  }\n\n  /**\n   * Update config for multiple items in a single batch operation\n   *\n   * **Performance Optimization** (Extraction Guide Phase 7.2):\n   * Batch config updates trigger a single state update and re-render, compared to\n   * N individual updates causing N re-renders. For 200 items:\n   * - Individual: 200 re-renders (~3200ms)\n   * - Batch: 1 re-render (~16ms)\n   * - **200× performance improvement**\n   *\n   * **Undo/Redo Integration**:\n   * The entire batch update is treated as a single undoable command.\n   * Calling undo() will revert all config changes to their original values,\n   * and redo() will reapply all changes in a single operation.\n   *\n   * **Config Merging Behavior**:\n   * Config updates are **shallow merged** with existing config. This means:\n   * - New properties are added\n   * - Existing properties are overwritten\n   * - Unspecified properties remain unchanged\n   * - To delete a property, explicitly set it to `undefined`\n   *\n   * **Best Practices**:\n   * - Use for theme changes across multiple components\n   * - Ideal for bulk property updates (e.g., \"Set all headers to blue\")\n   * - Items can belong to different canvases\n   * - Invalid item IDs log warnings but don't throw errors\n   * - Batch operations emit single `itemsBatchUpdated` event (not individual `itemUpdated`)\n   *\n   * @param updates - Array of config update specifications with the following properties:\n   *   - `itemId` (string): ID of item to update\n   *   - `config` (object): Partial config object to merge with existing config\n   *\n   * @emits itemsBatchUpdated - Fired once after all configs are updated\n   * @emits stateChanged - Fired once after batch completes (inherited from state update)\n   *\n   * @example\n   * ```typescript\n   * // Update theme colors across all header components\n   * api.updateConfigsBatch([\n   *   { itemId: 'header-1', config: { backgroundColor: '#007bff', textColor: '#fff' } },\n   *   { itemId: 'header-2', config: { backgroundColor: '#007bff', textColor: '#fff' } },\n   *   { itemId: 'header-3', config: { backgroundColor: '#007bff', textColor: '#fff' } }\n   * ]);\n   *\n   * // Undo reverts all 3 headers to original colors\n   * api.undo();\n   *\n   * // Redo applies blue theme again\n   * api.redo();\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Bulk update text content\n   * const items = api.getCanvas('canvas1').items.filter(i => i.type === 'text');\n   * api.updateConfigsBatch(\n   *   items.map((item, idx) => ({\n   *     itemId: item.id,\n   *     config: { content: `Updated text ${idx + 1}` }\n   *   }))\n   * );\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Config merging demonstration\n   * // Original config: { title: 'Old', fontSize: 16, color: 'red' }\n   * api.updateConfigsBatch([\n   *   {\n   *     itemId: 'item-1',\n   *     config: { title: 'New', color: 'blue' }\n   *   }\n   * ]);\n   * // Result: { title: 'New', fontSize: 16, color: 'blue' }\n   * //          ^^^^^ updated    ^^^^^^^^ unchanged   ^^^^ updated\n   * ```\n   *\n   * @see https://github.com/yourusername/extraction-guide#phase-72-batch-operations\n   */\n  updateConfigsBatch(updates: Array<{ itemId: string; config: Record<string, any> }>): void {\n    // Convert to state-manager format (need canvasId)\n    const batchUpdates = updates.map(({ itemId, config }) => {\n      const item = this.findItemById(itemId);\n      if (!item) {\n        console.warn(`Item ${itemId} not found for config update`);\n        return null;\n      }\n      return {\n        itemId,\n        canvasId: item.canvasId,\n        updates: { config: { ...item.config, ...config } },\n      };\n    }).filter(Boolean) as Array<{ itemId: string; canvasId: string; updates: Partial<GridItem> }>;\n\n    // Add to undo/redo history\n    const command = new BatchUpdateConfigCommand(batchUpdates);\n    pushCommand(command);\n\n    // Use state-manager batch operation (single state update)\n    updateItemsBatch(batchUpdates);\n\n    // Emit single batch event with simpler format\n    const eventUpdates = batchUpdates.map(({ itemId, canvasId, updates }) => ({\n      itemId,\n      canvasId,\n      config: updates.config!,\n    }));\n    this.eventEmitter.emit('itemsBatchUpdated', { updates: eventUpdates });\n  }\n\n  /**\n   * Helper method to find an item by ID across all canvases\n   *\n   * @param itemId - Item ID to find\n   * @returns Grid item or null if not found\n   */\n  private findItemById(itemId: string): GridItem | null {\n    for (const canvasId in gridState.canvases) {\n      const canvas = gridState.canvases[canvasId];\n      const item = canvas.items.find((i) => i.id === itemId);\n      if (item) {\n        return item;\n      }\n    }\n    return null;\n  }\n\n  // ============================================================================\n  // Selection Methods\n  // ============================================================================\n\n  /**\n   * Select an item\n   *\n   * @param itemId - Item ID to select\n   * @param canvasId - Canvas ID containing the item\n   *\n   * @emits selectionChanged\n   */\n  selectItem(itemId: string, canvasId: string): void {\n    selectItemInState(itemId, canvasId);\n    this.eventEmitter.emit('selectionChanged', { itemId, canvasId } as SelectionChangedEvent);\n  }\n\n  /**\n   * Deselect the currently selected item\n   *\n   * @emits selectionChanged\n   */\n  deselectItem(): void {\n    deselectItem();\n    this.eventEmitter.emit('selectionChanged', { itemId: null, canvasId: null } as SelectionChangedEvent);\n  }\n\n  // ============================================================================\n  // Viewport and Display Methods\n  // ============================================================================\n\n  /**\n   * Change the current viewport\n   *\n   * This operation is undoable.\n   *\n   * @param viewport - Target viewport ('desktop' or 'mobile')\n   *\n   * @emits viewportChanged\n   */\n  setViewport(viewport: 'desktop' | 'mobile'): void {\n    const oldViewport = gridState.currentViewport;\n    const command = new SetViewportCommand(oldViewport, viewport);\n    command.redo(); // Execute command first\n    pushCommand(command); // Then add to history\n\n    this.eventEmitter.emit('viewportChanged', { oldViewport, newViewport: viewport } as ViewportChangedEvent);\n  }\n\n  /**\n   * Toggle grid visibility\n   *\n   * This operation is undoable.\n   *\n   * @param visible - True to show grid, false to hide\n   *\n   * @emits gridVisibilityChanged\n   */\n  toggleGrid(visible: boolean): void {\n    const oldValue = gridState.showGrid;\n    const command = new ToggleGridCommand(oldValue, visible);\n    command.redo(); // Execute command first\n    pushCommand(command); // Then add to history\n\n    this.eventEmitter.emit('gridVisibilityChanged', { visible } as GridVisibilityChangedEvent);\n  }\n\n\n  // ============================================================================\n  // Undo/Redo Methods\n  // ============================================================================\n\n  /**\n   * Undo the last action\n   *\n   * @emits stateChanged\n   */\n  undo(): void {\n    undoInternal();\n    this.eventEmitter.emit('stateChanged', {} as StateChangedEvent);\n  }\n\n  /**\n   * Redo the last undone action\n   *\n   * @emits stateChanged\n   */\n  redo(): void {\n    redoInternal();\n    this.eventEmitter.emit('stateChanged', {} as StateChangedEvent);\n  }\n\n  /**\n   * Check if undo is available\n   *\n   * @returns True if undo is available\n   */\n  canUndo(): boolean {\n    return canUndoInternal();\n  }\n\n  /**\n   * Check if redo is available\n   *\n   * @returns True if redo is available\n   */\n  canRedo(): boolean {\n    return canRedoInternal();\n  }\n\n  /**\n   * Clear undo/redo history\n   */\n  clearHistory(): void {\n    clearHistoryInternal();\n  }\n\n  // ============================================================================\n  // State Management Methods\n  // ============================================================================\n\n  /**\n   * Export current grid state as JSON\n   *\n   * Useful for saving/loading grid configurations, persistence, etc.\n   *\n   * @returns JSON string representation of grid state\n   *\n   * @example\n   * ```typescript\n   * const json = api.exportState();\n   * localStorage.setItem('gridState', json);\n   * ```\n   */\n  exportState(): string {\n    return JSON.stringify(gridState);\n  }\n\n  /**\n   * Import grid state from JSON\n   *\n   * Replaces current state with imported state. This operation\n   * clears undo/redo history.\n   *\n   * @param json - JSON string from exportState()\n   *\n   * @throws Error if JSON is invalid\n   *\n   * @emits stateChanged\n   *\n   * @example\n   * ```typescript\n   * const json = localStorage.getItem('gridState');\n   * if (json) {\n   *   api.importState(json);\n   * }\n   * ```\n   */\n  importState(json: string): void {\n    const newState = JSON.parse(json);\n\n    // Replace state properties\n    Object.assign(gridState, newState);\n\n    // Clear undo/redo history (imported state is new baseline)\n    clearHistoryInternal();\n\n    this.eventEmitter.emit('stateChanged', {} as StateChangedEvent);\n  }\n\n  /**\n   * Reset grid to initial state\n   *\n   * Clears all canvases, resets viewport to desktop, shows grid.\n   * This operation clears undo/redo history.\n   *\n   * @emits stateChanged\n   */\n  reset(): void {\n    resetState();\n    clearHistoryInternal();\n    this.eventEmitter.emit('stateChanged', {} as StateChangedEvent);\n  }\n\n  // ============================================================================\n  // Event System Methods\n  // ============================================================================\n\n  /**\n   * Register an event listener\n   *\n   * @param event - Event name\n   * @param listener - Event handler function\n   *\n   * @example\n   * ```typescript\n   * api.on('itemAdded', (event) => {\n   *   console.log('Item added:', event.item);\n   * });\n   * ```\n   */\n  on<K extends keyof GridBuilderEventMap>(event: K, listener: EventListener<K>): void {\n    this.eventEmitter.on(event, listener);\n  }\n\n  /**\n   * Unregister an event listener\n   *\n   * @param event - Event name\n   * @param listener - Event handler function to remove\n   */\n  off<K extends keyof GridBuilderEventMap>(event: K, listener: EventListener<K>): void {\n    this.eventEmitter.off(event, listener);\n  }\n\n  /**\n   * Register a one-time event listener\n   *\n   * Listener is automatically removed after first invocation.\n   *\n   * @param event - Event name\n   * @param listener - Event handler function\n   *\n   * @example\n   * ```typescript\n   * api.once('itemAdded', (event) => {\n   *   console.log('First item added:', event.item);\n   * });\n   * ```\n   */\n  once<K extends keyof GridBuilderEventMap>(event: K, listener: EventListener<K>): void {\n    this.eventEmitter.once(event, listener);\n  }\n\n  /**\n   * Remove all event listeners and clean up\n   *\n   * Call this when destroying the API instance to prevent memory leaks.\n   */\n  destroy(): void {\n    this.eventEmitter.clear();\n  }\n}\n"]}