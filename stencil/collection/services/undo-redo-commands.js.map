{"version":3,"file":"undo-redo-commands.js","sourceRoot":"","sources":["../../src/services/undo-redo-commands.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Undo/Redo Commands\n * ===================\n *\n * Concrete Command implementations for grid operations. Each command class\n * encapsulates a specific user action with the ability to undo and redo.\n *\n * ## Problem\n *\n * The Command pattern requires concrete implementations for each undoable operation.\n * Each command must:\n * - Capture enough state to reverse the operation (undo)\n * - Capture enough state to reapply the operation (redo)\n * - Be self-contained (no external dependencies)\n * - Handle edge cases (canvas switching, index preservation)\n *\n * ## Solution\n *\n * Four concrete command classes covering all grid operations:\n *\n * 1. **AddItemCommand**: Adding new items to canvas\n * 2. **DeleteItemCommand**: Removing items with index preservation\n * 3. **MoveItemCommand**: Dragging items (same or different canvas)\n * 4. **ResizeCommand**: (Not yet implemented - resize operations not tracked)\n *\n * ## Key Design Patterns\n *\n * ### Deep Cloning Strategy\n *\n * **Why deep clone**: Prevent mutations from affecting command snapshots\n *\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **When to clone**:\n * - ‚úÖ Constructor: Capture initial state\n * - ‚úÖ redo(): Create fresh copy for state mutation\n * - ‚ùå undo(): Usually work with existing state references\n *\n * **Trade-offs**:\n * - ‚úÖ Simple and reliable\n * - ‚úÖ No reference bugs\n * - ‚ùå Higher memory usage (~1-5 KB per command)\n * - ‚ùå Slower than structural sharing\n *\n * ### Index Preservation Pattern\n *\n * **Why preserve index**: Undo delete should restore item at original position\n *\n * ```typescript\n * class DeleteItemCommand {\n *   private itemIndex: number;  // Capture index before deletion\n *\n *   undo() {\n *     canvas.items.splice(this.itemIndex, 0, item);  // Restore at index\n *   }\n * }\n * ```\n *\n * **Important for**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * ### Selection State Management\n *\n * **Pattern**: Clear selection when deleting selected item\n *\n * ```typescript\n * if (gridState.selectedItemId === itemId) {\n *   gridState.selectedItemId = null;\n *   gridState.selectedCanvasId = null;\n * }\n * ```\n *\n * **Why needed**:\n * - Prevents dangling references to deleted items\n * - Avoids errors when accessing selectedItemId\n * - Matches user expectations (deleted item can't be selected)\n *\n * ### Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between canvases\n *\n * **Solution**: Track source and target canvas IDs\n *\n * ```typescript\n * class MoveItemCommand {\n *   sourceCanvasId: string;\n *   targetCanvasId: string;\n *\n *   undo() {\n *     // Move from target back to source\n *     removeFrom(targetCanvasId);\n *     addTo(sourceCanvasId, sourceIndex);  // Restore position\n *   }\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Typical flow**:\n * ```\n * 1. User performs action (drag, delete, etc.)\n * 2. Operation completes (state already updated)\n * 3. Create command with before/after snapshots\n * 4. pushCommand(command) ‚Üí adds to history\n * 5. User presses Ctrl+Z\n * 6. command.undo() ‚Üí reverses operation\n * 7. User presses Ctrl+Y\n * 8. command.redo() ‚Üí reapplies operation\n * ```\n *\n * **Important**: Commands are created AFTER the operation completes,\n * not before. The constructor captures the final state.\n *\n * ## Extracting These Patterns\n *\n * To create new command types:\n *\n * ```typescript\n * export class MyCommand implements Command {\n *   // Capture state needed for undo/redo\n *   private beforeState: any;\n *   private afterState: any;\n *\n *   constructor(params) {\n *     // Deep clone to prevent mutations\n *     this.beforeState = JSON.parse(JSON.stringify(before));\n *     this.afterState = JSON.parse(JSON.stringify(after));\n *   }\n *\n *   undo(): void {\n *     // Restore before state\n *     restoreState(this.beforeState);\n *     gridState.canvases = { ...gridState.canvases };  // Trigger reactivity\n *   }\n *\n *   redo(): void {\n *     // Apply after state\n *     restoreState(this.afterState);\n *     gridState.canvases = { ...gridState.canvases };\n *   }\n * }\n * ```\n *\n * **Guidelines**:\n * - Always deep clone state in constructor\n * - Always trigger reactivity (`gridState.canvases = { ...gridState.canvases }`)\n * - Handle null cases (canvas/item not found)\n * - Clear selection if needed\n * - Preserve array indices for positional restore\n *\n * @module undo-redo-commands\n */\n\nimport {\n  addItemToCanvas,\n  GridItem,\n  gridState,\n  updateItem as updateItemInState,\n  deleteItemsBatch,\n  updateItemsBatch,\n} from './state-manager';\nimport { Command } from './undo-redo';\nimport { eventManager } from './event-manager';\nimport { createDebugLogger } from '../utils/debug';\n\nconst debug = createDebugLogger('undo-redo-commands');\n\n/**\n * Helper function to remove an item from a canvas and clear selection\n *\n * **Responsibilities**:\n * - Remove item from canvas items array\n * - Trigger state reactivity (spread pattern)\n * - Clear selection if deleted item was selected\n *\n * **Used by**:\n * - AddItemCommand.undo() - Remove just-added item\n * - DeleteItemCommand.redo() - Remove item again\n * - MoveItemCommand (implicitly via filter)\n *\n * **Why helper function**:\n * - DRY principle (used in multiple commands)\n * - Encapsulates selection clearing logic\n * - Consistent behavior across commands\n *\n * **Selection clearing**:\n * Prevents dangling references and UI errors when selected item deleted.\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item to remove\n *\n * @example\n * ```typescript\n * // Used internally by commands\n * undo() {\n *   removeItemFromCanvas(this.canvasId, this.item.id);\n * }\n * ```\n *\n * @private\n */\nfunction removeItemFromCanvas(canvasId: string, itemId: string): void {\n  const canvas = gridState.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((i) => i.id !== itemId);\n  gridState.canvases = { ...gridState.canvases };\n\n  // Clear selection if this item was selected\n  if (gridState.selectedItemId === itemId) {\n    gridState.selectedItemId = null;\n    gridState.selectedCanvasId = null;\n  }\n}\n\n/**\n * AddItemCommand\n * ==============\n *\n * Captures the addition of a new grid item to a canvas, enabling undo/redo\n * for create operations.\n *\n * ## Use Cases\n *\n * - User drops component from palette onto canvas\n * - Programmatic item creation (stress tests, templates)\n * - Duplicating existing items\n *\n * ## Command Lifecycle\n *\n * **Creation**: After item already added to canvas\n * ```typescript\n * // 1. Add item to canvas (operation completes)\n * addItemToCanvas('canvas1', newItem);\n *\n * // 2. Create command for undo (captures final state)\n * const command = new AddItemCommand('canvas1', newItem);\n * pushCommand(command);\n * ```\n *\n * **Undo**: Remove the item from canvas\n * ```typescript\n * command.undo(); // Item disappears from canvas\n * ```\n *\n * **Redo**: Re-add the item to canvas\n * ```typescript\n * command.redo(); // Item reappears in canvas\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures item state with deep clone\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Prevents mutations from affecting command's snapshot\n * - Item might be modified after command creation\n * - Ensures redo restores exact original state\n *\n * **Redo cloning**: Creates fresh copy for state mutation\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.push(itemCopy);\n * ```\n *\n * **Why redo also clones**:\n * - Multiple redo calls shouldn't share references\n * - Prevents undo/redo from affecting each other\n * - Safe state isolation\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: redo() returns early if canvas not found\n * - **Item modified**: Command stores original state, not current\n * - **Selection**: undo() automatically clears selection via helper\n *\n * @example\n * ```typescript\n * // After palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(),\n *   canvasId: 'canvas1',\n *   type: 'header',\n *   name: 'Header',\n *   layouts: { desktop: { x: 5, y: 5, width: 20, height: 8 }, ... },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n *\n * addItemToCanvas('canvas1', newItem);\n * pushCommand(new AddItemCommand('canvas1', newItem));\n * ```\n */\nexport class AddItemCommand implements Command {\n  /** Deep clone of item at creation time */\n  private item: GridItem;\n\n  /** Canvas ID where item was added */\n  private canvasId: string;\n\n  /**\n   * Capture item addition operation\n   *\n   * **Important**: Call AFTER item added to canvas (not before)\n   *\n   * **Deep clones item**: Prevents future mutations from affecting snapshot\n   *\n   * @param canvasId - Canvas where item was added\n   * @param item - Item that was added (will be deep cloned)\n   */\n  constructor(canvasId: string, item: GridItem) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state at time of creation\n    this.item = JSON.parse(JSON.stringify(item));\n  }\n\n  /**\n   * Undo: Remove the item from canvas\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  undo(): void {\n    // Remove the item from the canvas\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n\n  /**\n   * Redo: Re-add the item to canvas\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Appends to end**: Doesn't preserve original index (acceptable for add)\n   *\n   * **Side effects**:\n   * - Item added to end of canvas.items array\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found (e.g., canvas was deleted)\n   */\n  redo(): void {\n    // Re-add the item to the canvas\n    const canvas = gridState.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Use the cloned item state\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    canvas.items.push(itemCopy);\n    gridState.canvases = { ...gridState.canvases };\n  }\n}\n\n/**\n * DeleteItemCommand\n * ==================\n *\n * Captures the deletion of a grid item from a canvas, enabling undo/redo\n * for delete operations with index preservation.\n *\n * ## Use Cases\n *\n * - User deletes item with Delete key\n * - Delete button clicked\n * - Programmatic item removal\n * - Clearing canvas sections\n *\n * ## Index Preservation Pattern\n *\n * **Critical feature**: Restores deleted item at its ORIGINAL array position\n *\n * **Why important**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * **Implementation**:\n * ```typescript\n * constructor(canvasId, item, itemIndex) {\n *   this.itemIndex = itemIndex;  // Capture before deletion!\n * }\n *\n * undo() {\n *   canvas.items.splice(this.itemIndex, 0, itemCopy);  // Restore at index\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE deleting item (to capture index)\n * ```typescript\n * // 1. Get item and its index BEFORE deletion\n * const item = getItem('canvas1', 'item-5');\n * const index = gridState.canvases['canvas1'].items.indexOf(item);\n *\n * // 2. Create command (captures item and index)\n * const command = new DeleteItemCommand('canvas1', item, index);\n *\n * // 3. Perform deletion\n * removeItemFromCanvas('canvas1', 'item-5');\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Restore item at original position\n * ```typescript\n * command.undo(); // Item reappears at exact original position\n * ```\n *\n * **Redo**: Delete item again\n * ```typescript\n * command.redo(); // Item disappears (and selection cleared if selected)\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures complete item state before deletion\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Item will be deleted from state immediately after\n * - Reference would become invalid after deletion\n * - Must preserve complete state for restoration\n *\n * **Undo cloning**: Creates fresh copy for state insertion\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.splice(this.itemIndex, 0, itemCopy);\n * ```\n *\n * ## Selection State Handling\n *\n * **Redo behavior**: Delegates to removeItemFromCanvas helper\n *\n * **Helper automatically**:\n * - Clears selectedItemId if this item was selected\n * - Clears selectedCanvasId\n * - Prevents dangling references\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: undo() returns early if canvas not found\n * - **Invalid index**: Falls back to push() if index out of bounds\n * - **Item modified before delete**: Command stores pre-deletion state\n * - **Multiple deletes**: Each command independently tracks its item\n *\n * @example\n * ```typescript\n * // Handle Delete key press\n * handleDeleteKey() {\n *   if (!gridState.selectedItemId || !gridState.selectedCanvasId) {\n *     return;\n *   }\n *\n *   const item = getItem(gridState.selectedCanvasId, gridState.selectedItemId);\n *   const canvas = gridState.canvases[gridState.selectedCanvasId];\n *   const index = canvas.items.indexOf(item);\n *\n *   // Create command before deleting\n *   const command = new DeleteItemCommand(\n *     gridState.selectedCanvasId,\n *     item,\n *     index\n *   );\n *\n *   // Perform deletion\n *   removeItemFromCanvas(gridState.selectedCanvasId, gridState.selectedItemId);\n *\n *   // Enable undo\n *   pushCommand(command);\n * }\n * ```\n */\nexport class DeleteItemCommand implements Command {\n  /** Deep clone of item before deletion */\n  private item: GridItem;\n\n  /** Canvas ID where item was deleted from */\n  private canvasId: string;\n\n  /** Original array index for position restoration */\n  private itemIndex: number;\n\n  /**\n   * Capture item deletion operation\n   *\n   * **Important**: Call BEFORE deleting item (to capture index)\n   *\n   * **Deep clones item**: Preserves state before deletion\n   *\n   * **Captures index**: Critical for restoring at original position\n   *\n   * @param canvasId - Canvas containing the item\n   * @param item - Item being deleted (will be deep cloned)\n   * @param itemIndex - Original array index (call indexOf before deletion!)\n   */\n  constructor(canvasId: string, item: GridItem, itemIndex: number) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state before deletion\n    this.item = JSON.parse(JSON.stringify(item));\n    this.itemIndex = itemIndex;\n  }\n\n  /**\n   * Undo: Restore item at original position\n   *\n   * **Index preservation**: Uses splice to insert at exact original position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive coding)\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Side effects**:\n   * - Item restored to canvas.items array at original index\n   * - Other items shift to make room\n   * - Z-index order maintained (items render in array order)\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found\n   */\n  undo(): void {\n    // Re-add the item to its original position\n    const canvas = gridState.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    // Insert at original index if possible, otherwise push to end\n    if (this.itemIndex >= 0 && this.itemIndex <= canvas.items.length) {\n      canvas.items.splice(this.itemIndex, 0, itemCopy);\n    } else {\n      canvas.items.push(itemCopy);\n    }\n    gridState.canvases = { ...gridState.canvases };\n  }\n\n  /**\n   * Redo: Delete item again\n   *\n   * **Delegates to helper**: Uses removeItemFromCanvas for consistency\n   *\n   * **Automatic selection clearing**: Helper clears selection if this item selected\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  redo(): void {\n    // Remove the item again\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n}\n\n/**\n * MoveItemCommand\n * ===============\n *\n * Captures the movement of a grid item within the same canvas or across canvases,\n * enabling undo/redo for drag operations with position and index preservation.\n *\n * ## Use Cases\n *\n * - User drags item to new position in same canvas\n * - User drags item across canvas boundaries (cross-canvas move)\n * - Programmatic item repositioning\n * - Layout reorganization\n *\n * ## Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between different canvases\n *\n * **Solution**: Track both source and target canvas IDs\n *\n * **Same-canvas move**:\n * ```typescript\n * sourceCanvasId === targetCanvasId\n * // Only position changes, no canvas transfer\n * ```\n *\n * **Cross-canvas move**:\n * ```typescript\n * sourceCanvasId !== targetCanvasId\n * // Item removed from source, added to target\n * // Position updated to target coordinates\n * ```\n *\n * ## Position Tracking\n *\n * **Dual position capture**:\n * - `sourcePosition`: { x, y } before drag\n * - `targetPosition`: { x, y } after drag\n *\n * **Why both needed**:\n * - Undo must restore original position\n * - Redo must restore final position\n * - Positions are in grid coordinates (not pixels)\n *\n * ## Index Preservation Pattern\n *\n * **Critical for undo**: Restore item at original array position in source canvas\n *\n * **Why important**:\n * - Maintains visual z-order consistency\n * - Restores exact pre-drag state\n * - Items render in array order\n *\n * **Implementation**:\n * ```typescript\n * // Capture source index before move\n * const sourceIndex = sourceCanvas.items.indexOf(item);\n *\n * // Restore at index on undo\n * sourceCanvas.items.splice(sourceIndex, 0, item);\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE drag operation (capture source state)\n * ```typescript\n * // 1. Capture state before drag starts\n * const sourceIndex = canvas.items.indexOf(item);\n * const sourcePos = { x: item.layouts.desktop.x, y: item.layouts.desktop.y };\n *\n * // 2. Drag completes (position updated in DOM)\n * // ...\n *\n * // 3. Create command with before/after state\n * const command = new MoveItemCommand(\n *   item.id,\n *   sourceCanvasId,\n *   targetCanvasId,  // May be same as source\n *   sourcePos,\n *   targetPos,       // New position after drag\n *   sourceIndex\n * );\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Move back to source at original position\n * ```typescript\n * command.undo();\n * // Item returns to source canvas at original index\n * // Position restored to sourcePosition\n * ```\n *\n * **Redo**: Move to target at new position\n * ```typescript\n * command.redo();\n * // Item moves to target canvas (appended to end)\n * // Position updated to targetPosition\n * ```\n *\n * ## State Mutation Pattern\n *\n * **Unlike Add/Delete**: Does NOT deep clone item\n *\n * **Why reference-based**:\n * - Same item object moves between canvases\n * - Only position properties mutated\n * - Efficient (no serialization overhead)\n * - Item identity preserved (same ID, zIndex, etc.)\n *\n * **What gets cloned**:\n * ```typescript\n * // Only position objects cloned (shallow)\n * this.sourcePosition = { ...sourcePosition };\n * this.targetPosition = { ...targetPosition };\n * ```\n *\n * ## Position Coordinates\n *\n * **Uses desktop layout**: `item.layouts.desktop.x/y`\n *\n * **Why desktop**:\n * - Drag handler operates on desktop coordinates\n * - Mobile layout auto-generated or separately customized\n * - Single source of truth for command\n *\n * **Grid units**: Positions stored in grid units (not pixels)\n *\n * ## Canvas Mutation Flow\n *\n * **Undo sequence** (target ‚Üí source):\n * 1. Find item in target canvas\n * 2. Remove from target.items array\n * 3. Update item.canvasId to source\n * 4. Update item position to sourcePosition\n * 5. Insert at sourceIndex in source.items\n * 6. Trigger reactivity\n *\n * **Redo sequence** (source ‚Üí target):\n * 1. Find item in source canvas\n * 2. Remove from source.items array\n * 3. Update item.canvasId to target\n * 4. Update item position to targetPosition\n * 5. Append to target.items (no index preservation for redo)\n * 6. Trigger reactivity\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: Both undo/redo return early if canvas not found\n * - **Item not found**: Returns early (defensive coding)\n * - **Same position move**: Creates valid command (user expectation)\n * - **Invalid source index**: Fallback to append (defensive)\n *\n * @example\n * ```typescript\n * // After drag end event\n * handleDragEnd(event) {\n *   const item = getItem(sourceCanvasId, itemId);\n *   const sourceIndex = gridState.canvases[sourceCanvasId].items.indexOf(item);\n *\n *   const command = new MoveItemCommand(\n *     itemId,\n *     sourceCanvasId,\n *     targetCanvasId,  // Detected from drop target\n *     { x: oldX, y: oldY },  // Captured on drag start\n *     { x: newX, y: newY },  // Calculated from drop position\n *     sourceIndex\n *   );\n *\n *   pushCommand(command);\n * }\n * ```\n */\nexport class MoveItemCommand implements Command {\n  /** Item ID (reference to item, not deep clone) */\n  private itemId: string;\n\n  /** Canvas ID where item started */\n  private sourceCanvasId: string;\n\n  /** Canvas ID where item ended (may equal source for same-canvas move) */\n  private targetCanvasId: string;\n\n  /** Position before drag (grid coordinates) */\n  private sourcePosition: { x: number; y: number };\n\n  /** Position after drag (grid coordinates) */\n  private targetPosition: { x: number; y: number };\n\n  /** Size before operation (grid units) - optional for resize tracking */\n  private sourceSize?: { width: number; height: number };\n\n  /** Size after operation (grid units) - optional for resize tracking */\n  private targetSize?: { width: number; height: number };\n\n  /** Original array index in source canvas (for undo restoration) */\n  private sourceIndex: number;\n\n  /**\n   * Capture item move operation\n   *\n   * **Important**: Item should already be at target position\n   *\n   * **Shallow position clone**: Prevents mutation of passed objects\n   *\n   * **No item clone**: Uses reference-based approach (item ID tracking)\n   *\n   * **Resize support**: Optional size parameters track width/height changes\n   *\n   * @param itemId - ID of moved item\n   * @param sourceCanvasId - Canvas where item started\n   * @param targetCanvasId - Canvas where item ended\n   * @param sourcePosition - Position before drag (will be shallow cloned)\n   * @param targetPosition - Position after drag (will be shallow cloned)\n   * @param sourceIndex - Original array index in source canvas\n   * @param sourceSize - Optional: Size before operation (for resize tracking)\n   * @param targetSize - Optional: Size after operation (for resize tracking)\n   */\n  constructor(\n    itemId: string,\n    sourceCanvasId: string,\n    targetCanvasId: string,\n    sourcePosition: { x: number; y: number },\n    targetPosition: { x: number; y: number },\n    sourceIndex: number,\n    sourceSize?: { width: number; height: number },\n    targetSize?: { width: number; height: number }\n  ) {\n    this.itemId = itemId;\n    this.sourceCanvasId = sourceCanvasId;\n    this.targetCanvasId = targetCanvasId;\n    this.sourcePosition = { ...sourcePosition };\n    this.targetPosition = { ...targetPosition };\n    this.sourceSize = sourceSize ? { ...sourceSize } : undefined;\n    this.targetSize = targetSize ? { ...targetSize } : undefined;\n    this.sourceIndex = sourceIndex;\n  }\n\n  /**\n   * Undo: Move item back to source canvas at original position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from target canvas\n   * - Updates canvasId back to source\n   * - Restores source position\n   * - Inserts at original index in source\n   *\n   * **Index preservation**: Uses splice to restore exact array position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive)\n   *\n   * **Side effects**:\n   * - Item removed from target canvas\n   * - Item added to source canvas at original index\n   * - Item position updated to sourcePosition\n   * - Item canvasId updated to sourceCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  undo(): void {\n    debug.log('üîô MoveItemCommand.undo()', {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in target canvas first\n    let targetCanvas = gridState.canvases[this.targetCanvasId];\n    let item = targetCanvas?.items.find((i) => i.id === this.itemId);\n\n    // If target canvas doesn't exist or item not found there, search all canvases\n    // This handles the case where the target canvas was deleted\n    if (!item) {\n      for (const canvasId in gridState.canvases) {\n        const canvas = gridState.canvases[canvasId];\n        item = canvas.items.find((i) => i.id === this.itemId);\n        if (item) {\n          targetCanvas = canvas;\n          break;\n        }\n      }\n    }\n\n    if (!item || !targetCanvas) {\n      console.warn('  ‚ùå Item or canvas not found, aborting undo');\n      return;\n    }\n\n    debug.log('  üìç Found item, current position:', {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Remove from current canvas (wherever it is)\n    targetCanvas.items = targetCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's position and canvasId back to source\n    item.canvasId = this.sourceCanvasId;\n    item.layouts.desktop.x = this.sourcePosition.x;\n    item.layouts.desktop.y = this.sourcePosition.y;\n\n    debug.log('  ‚úÖ Updated item position to:', {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Restore size if it was tracked (for resize operations)\n    if (this.sourceSize) {\n      item.layouts.desktop.width = this.sourceSize.width;\n      item.layouts.desktop.height = this.sourceSize.height;\n    }\n\n    // Add back to source canvas at original index\n    const sourceCanvas = gridState.canvases[this.sourceCanvasId];\n    if (!sourceCanvas) {\n      console.warn('  ‚ùå Source canvas not found, aborting undo');\n      return;\n    }\n\n    if (this.sourceIndex >= 0 && this.sourceIndex <= sourceCanvas.items.length) {\n      sourceCanvas.items.splice(this.sourceIndex, 0, item);\n    } else {\n      sourceCanvas.items.push(item);\n    }\n\n    // Trigger state update\n    gridState.canvases = { ...gridState.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log('  üé® Clearing inline transform style');\n      element.style.transform = '';\n    }\n\n    debug.log('  ‚úÖ Undo complete');\n  }\n\n  /**\n   * Redo: Move item to target canvas at final position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from source canvas\n   * - Updates canvasId to target\n   * - Restores target position\n   * - Appends to target canvas (no index preservation for redo)\n   *\n   * **No index preservation for redo**: Appends to end of target array\n   * (undo needs original index, redo doesn't)\n   *\n   * **Side effects**:\n   * - Item removed from source canvas\n   * - Item added to end of target canvas\n   * - Item position updated to targetPosition\n   * - Item canvasId updated to targetCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  redo(): void {\n    debug.log('üîú MoveItemCommand.redo()', {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in source canvas\n    const sourceCanvas = gridState.canvases[this.sourceCanvasId];\n    const item = sourceCanvas?.items.find((i) => i.id === this.itemId);\n    if (!item) {\n      console.warn('  ‚ùå Item not found, aborting redo');\n      return;\n    }\n\n    debug.log('  üìç Found item, current position:', {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Remove from source canvas\n    sourceCanvas.items = sourceCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's position and canvasId to target\n    item.canvasId = this.targetCanvasId;\n    item.layouts.desktop.x = this.targetPosition.x;\n    item.layouts.desktop.y = this.targetPosition.y;\n\n    debug.log('  ‚úÖ Updated item position to:', {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Restore size if it was tracked (for resize operations)\n    if (this.targetSize) {\n      item.layouts.desktop.width = this.targetSize.width;\n      item.layouts.desktop.height = this.targetSize.height;\n    }\n\n    // Add to target canvas\n    const targetCanvas = gridState.canvases[this.targetCanvasId];\n    if (!targetCanvas) {\n      console.warn('  ‚ùå Target canvas not found, aborting redo');\n      return;\n    }\n\n    targetCanvas.items.push(item);\n\n    // Trigger state update\n    gridState.canvases = { ...gridState.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log('  üé® Clearing inline transform style');\n      element.style.transform = '';\n    }\n\n    debug.log('  ‚úÖ Redo complete');\n  }\n}\n\n/**\n * UpdateItemCommand - Update item properties\n *\n * Records old item state and applies updates\n */\nexport class UpdateItemCommand implements Command {\n  constructor(\n    private canvasId: string,\n    private itemId: string,\n    private oldItem: GridItem,\n    private updates: Partial<GridItem>\n  ) {}\n\n  undo(): void {\n    updateItemInState(this.canvasId, this.itemId, this.oldItem);\n  }\n\n  redo(): void {\n    updateItemInState(this.canvasId, this.itemId, this.updates);\n  }\n}\n\n/**\n * RemoveItemCommand - Remove item from canvas\n *\n * Stores removed item for restoration\n */\nexport class RemoveItemCommand implements Command {\n  constructor(\n    private canvasId: string,\n    private item: GridItem\n  ) {}\n\n  undo(): void {\n    addItemToCanvas(this.canvasId, this.item);\n  }\n\n  redo(): void {\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n}\n\n/**\n * SetViewportCommand - Change current viewport\n *\n * Stores old and new viewport states\n */\nexport class SetViewportCommand implements Command {\n  constructor(\n    private oldViewport: 'desktop' | 'mobile',\n    private newViewport: 'desktop' | 'mobile'\n  ) {}\n\n  undo(): void {\n    gridState.currentViewport = this.oldViewport;\n  }\n\n  redo(): void {\n    gridState.currentViewport = this.newViewport;\n  }\n}\n\n/**\n * ToggleGridCommand - Toggle grid visibility\n *\n * Stores old and new visibility states\n */\nexport class ToggleGridCommand implements Command {\n  constructor(\n    private oldValue: boolean,\n    private newValue: boolean\n  ) {}\n\n  undo(): void {\n    gridState.showGrid = this.oldValue;\n  }\n\n  redo(): void {\n    gridState.showGrid = this.newValue;\n  }\n}\n\n\n/**\n * BatchAddCommand - Add multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n * Reduces undo stack size and provides atomic undo/redo for batch operations.\n *\n * **Use cases**:\n * - Stress test (add 100+ items at once)\n * - Template application (add multiple pre-configured items)\n * - Undo batch delete operation\n * - Import from file (restore multiple items)\n *\n * **Undo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Re-adds all items with original IDs and properties\n * - Maintains z-index and positioning\n * - Single state update, single re-render\n */\nexport class BatchAddCommand implements Command {\n  private itemsData: GridItem[];\n\n  constructor(itemIds: string[]) {\n    // Store full item data for redo (deep clone to prevent mutations)\n    this.itemsData = itemIds.map((id) => {\n      const item = Object.values(gridState.canvases)\n        .flatMap((canvas) => canvas.items)\n        .find((i) => i.id === id);\n      return item ? JSON.parse(JSON.stringify(item)) : null;\n    }).filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n    deleteItemsBatch(itemIds);\n  }\n\n  redo(): void {\n    // Re-add all items (addItemsBatch will generate new IDs, so we need custom logic)\n    const updatedCanvases = { ...gridState.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    gridState.canvases = updatedCanvases;\n  }\n}\n\n/**\n * BatchDeleteCommand - Delete multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n *\n * **Use cases**:\n * - Clear canvas (delete all items)\n * - Delete selection group\n * - Undo batch add operation\n * - Bulk cleanup operations\n *\n * **Undo behavior**:\n * - Re-adds all items with original properties and positions\n * - Maintains z-index and canvas placement\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchDeleteCommand implements Command {\n  private itemsData: GridItem[];\n\n  constructor(itemIds: string[]) {\n    // Store full item data for undo (deep clone to prevent mutations)\n    this.itemsData = itemIds.map((id) => {\n      const item = Object.values(gridState.canvases)\n        .flatMap((canvas) => canvas.items)\n        .find((i) => i.id === id);\n      return item ? JSON.parse(JSON.stringify(item)) : null;\n    }).filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Re-add all items (same logic as BatchAddCommand.redo)\n    const updatedCanvases = { ...gridState.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    gridState.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n    deleteItemsBatch(itemIds);\n  }\n}\n\n/**\n * BatchUpdateConfigCommand - Update multiple item configs in a single batch\n *\n * **Performance benefit**: 1 undo/redo command for N config updates instead of N commands.\n *\n * **Use cases**:\n * - Theme changes (update colors for all headers)\n * - Bulk property changes (set all text sizes to 16px)\n * - Template application (apply preset configs)\n * - Undo/redo bulk config changes\n *\n * **Undo behavior**:\n * - Restores all old configs in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Applies all new configs in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchUpdateConfigCommand implements Command {\n  private updates: Array<{\n    itemId: string;\n    canvasId: string;\n    oldItem: GridItem;\n    newItem: GridItem;\n  }>;\n\n  constructor(\n    updates: Array<{\n      itemId: string;\n      canvasId: string;\n      updates: Partial<GridItem>;\n    }>\n  ) {\n    // Store old and new state for each item (deep clone to prevent mutations)\n    this.updates = updates.map(({ itemId, canvasId, updates: itemUpdates }) => {\n      const canvas = gridState.canvases[canvasId];\n      const item = canvas?.items.find((i) => i.id === itemId);\n\n      if (!item) {\n        return null;\n      }\n\n      return {\n        itemId,\n        canvasId,\n        oldItem: JSON.parse(JSON.stringify(item)),\n        newItem: JSON.parse(JSON.stringify({ ...item, ...itemUpdates })),\n      };\n    }).filter(Boolean) as Array<{\n      itemId: string;\n      canvasId: string;\n      oldItem: GridItem;\n      newItem: GridItem;\n    }>;\n  }\n\n  undo(): void {\n    // Restore old configs\n    const batchUpdates = this.updates.map(({ itemId, canvasId, oldItem }) => ({\n      itemId,\n      canvasId,\n      updates: oldItem,\n    }));\n    updateItemsBatch(batchUpdates);\n  }\n\n  redo(): void {\n    // Apply new configs\n    const batchUpdates = this.updates.map(({ itemId, canvasId, newItem }) => ({\n      itemId,\n      canvasId,\n      updates: newItem,\n    }));\n    updateItemsBatch(batchUpdates);\n  }\n}\n\n/**\n * AddCanvasCommand\n * =================\n *\n * Undoable command for adding a canvas to the grid.\n *\n * **Pattern**: Host app owns canvas metadata, library manages item placement\n *\n * **Library responsibility** (what this command does):\n * - Create canvas in gridState.canvases with empty items array\n * - Initialize zIndexCounter for item stacking\n * - Track operation in undo/redo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or other metadata\n * - Host app maintains its own canvas metadata separately\n * - Host app listens to canvasAdded event to sync its state\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app maintains canvas metadata\n * const canvasMetadata = {\n *   'section-1': { title: 'Hero Section', backgroundColor: '#f0f4f8' }\n * };\n *\n * // Create canvas in library (just placement state)\n * const cmd = new AddCanvasCommand('section-1');\n * pushCommand(cmd); // Add to undo/redo stack\n * cmd.redo(); // Creates canvas with items: [], zIndexCounter: 1\n *\n * // Host app listens to event and syncs its own state\n * api.on('canvasAdded', (event) => {\n *   // Host app can now add its own metadata\n * });\n * ```\n *\n * **Why this separation**:\n * - Library focuses on layout (items, positions, z-index)\n * - Host app owns presentation (styling, titles, metadata)\n * - Different apps can use library with different data models\n *\n * @module undo-redo-commands\n */\nexport class AddCanvasCommand implements Command {\n  description = 'Add Canvas';\n  private canvasId: string;\n\n  constructor(canvasId: string) {\n    this.canvasId = canvasId;\n  }\n\n  undo(): void {\n    debug.log('üîô AddCanvasCommand.undo() - removing canvas:', this.canvasId);\n\n    // Remove canvas from library state\n    delete gridState.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    gridState.canvases = { ...gridState.canvases };\n\n    // Emit event so host app can sync its metadata\n    debug.log('  üì¢ Emitting canvasRemoved event for:', this.canvasId);\n    eventManager.emit('canvasRemoved', { canvasId: this.canvasId });\n  }\n\n  redo(): void {\n    // Add canvas to library state (minimal - just item placement management)\n    gridState.canvases[this.canvasId] = {\n      zIndexCounter: 1,\n      items: [],\n    };\n\n    // Trigger state change for reactivity\n    gridState.canvases = { ...gridState.canvases };\n\n    // Emit event so host app can sync its metadata\n    eventManager.emit('canvasAdded', { canvasId: this.canvasId });\n  }\n}\n\n/**\n * RemoveCanvasCommand\n * ====================\n *\n * Undoable command for removing a canvas from the grid.\n *\n * **Critical**: Snapshots canvas items and zIndexCounter before removal\n *\n * **Library responsibility** (what this command does):\n * - Snapshot canvas items array and zIndexCounter\n * - Remove canvas from gridState.canvases\n * - Restore canvas with all items on undo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or metadata\n * - Host app must listen to canvasRemoved event\n * - Host app must manage its own metadata undo/redo separately\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app listens to events and manages its own metadata\n * api.on('canvasRemoved', (event) => {\n *   // Host app removes its own metadata\n *   delete canvasMetadata[event.canvasId];\n * });\n *\n * api.on('canvasAdded', (event) => {\n *   // On undo of remove, host app restores metadata\n *   if (wasUndoOperation) {\n *     canvasMetadata[event.canvasId] = savedMetadata;\n *   }\n * });\n *\n * // Remove canvas\n * const cmd = new RemoveCanvasCommand('section-1');\n * pushCommand(cmd);\n * cmd.redo(); // Removes canvas from library\n * ```\n *\n * **Edge case handling**:\n * - Canvas doesn't exist: command becomes no-op\n * - Canvas has items: all items removed with canvas\n * - Undo restores items with original layouts and zIndex\n *\n * @module undo-redo-commands\n */\nexport class RemoveCanvasCommand implements Command {\n  description = 'Remove Canvas';\n  private canvasId: string;\n  private canvasSnapshot: {\n    zIndexCounter: number;\n    items: GridItem[];\n  } | null = null;\n\n  constructor(canvasId: string) {\n    this.canvasId = canvasId;\n\n    // Snapshot canvas state (deep clone to prevent mutations)\n    const canvas = gridState.canvases[canvasId];\n    if (canvas) {\n      this.canvasSnapshot = JSON.parse(JSON.stringify(canvas));\n    }\n  }\n\n  undo(): void {\n    // Restore canvas from snapshot (just layout state, no metadata)\n    if (this.canvasSnapshot) {\n      gridState.canvases[this.canvasId] = JSON.parse(JSON.stringify(this.canvasSnapshot));\n\n      // Trigger state change for reactivity\n      gridState.canvases = { ...gridState.canvases };\n\n      // Emit event so host app can sync its metadata\n      eventManager.emit('canvasAdded', { canvasId: this.canvasId });\n    }\n  }\n\n  redo(): void {\n    // Remove canvas from library state\n    delete gridState.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    gridState.canvases = { ...gridState.canvases };\n\n    // Emit event so host app can sync its metadata\n    eventManager.emit('canvasRemoved', { canvasId: this.canvasId });\n  }\n}\n"]}