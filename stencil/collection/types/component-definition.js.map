{"version":3,"file":"component-definition.js","sourceRoot":"","sources":["../../src/types/component-definition.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/**\n * Component Definition Types\n * ===========================\n *\n * Type definitions for defining custom component types in the grid builder library.\n * Consumers use these interfaces to register their own component types with the library.\n */\n\n/**\n * Configuration field definition for auto-generated config forms\n */\nexport interface ConfigField {\n  /** Field name (used as key in config object) */\n  name: string;\n\n  /** Display label shown in UI */\n  label: string;\n\n  /** Input type */\n  type: 'text' | 'number' | 'color' | 'select' | 'checkbox' | 'textarea';\n\n  /** Default value when component is created */\n  defaultValue?: any;\n\n  /** Options for select fields (array of {label, value} or strings) */\n  options?: Array<{ label: string; value: string } | string>;\n\n  /** Optional validation function */\n  validation?: (value: any) => boolean;\n\n  /** Placeholder text for input fields */\n  placeholder?: string;\n\n  /** Help text shown below field */\n  helpText?: string;\n\n  /** Minimum value for number inputs */\n  min?: number;\n\n  /** Maximum value for number inputs */\n  max?: number;\n\n  /** Step size for number inputs */\n  step?: number;\n\n  /** Number of rows for textarea */\n  rows?: number;\n}\n\n/**\n * Component Definition Interface\n * ================================\n *\n * Defines a custom component type that can be added to the grid builder.\n * Each definition specifies how to render the component, configure it, and validate it.\n *\n * **Example: Simple Header Component**\n * ```typescript\n * const headerComponent: ComponentDefinition = {\n *   type: 'header',\n *   name: 'Header',\n *   icon: 'üìÑ',\n *   defaultSize: { width: 20, height: 6 },\n *   render: ({ itemId, config }) => (\n *     <div class=\"my-header\">\n *       <h1>{config?.text || 'New Header'}</h1>\n *     </div>\n *   ),\n *   configSchema: [\n *     {\n *       name: 'text',\n *       label: 'Header Text',\n *       type: 'text',\n *       defaultValue: 'New Header'\n *     }\n *   ]\n * };\n * ```\n *\n * **Example: Complex Dashboard with Custom Config Panel**\n * ```typescript\n * const dashboardComponent: ComponentDefinition = {\n *   type: 'dashboard',\n *   name: 'Dashboard Widget',\n *   icon: 'üìä',\n *   defaultSize: { width: 20, height: 15 },\n *   render: ({ itemId, config }) => (\n *     <component-dashboard itemId={itemId} config={config} />\n *   ),\n *   // Custom config panel instead of auto-generated form\n *   renderConfigPanel: ({ config, onChange, onSave, onCancel }) => (\n *     <div class=\"dashboard-config-wizard\">\n *       <h3>Configure Dashboard</h3>\n *       <div class=\"config-step\">\n *         <label>Data Source</label>\n *         <select\n *           value={config.dataSource}\n *           onChange={(e) => onChange('dataSource', e.target.value)}\n *         >\n *           <option value=\"sales\">Sales Data</option>\n *           <option value=\"analytics\">Analytics</option>\n *         </select>\n *       </div>\n *       <div class=\"actions\">\n *         <button onClick={onCancel}>Cancel</button>\n *         <button class=\"primary\" onClick={onSave}>Apply</button>\n *       </div>\n *     </div>\n *   ),\n *   // Optional lifecycle hooks for resource management\n *   onVisible: (itemId, config) => {\n *     console.log(`Dashboard ${itemId} visible, starting data polling...`);\n *   },\n *   onHidden: (itemId) => {\n *     console.log(`Dashboard ${itemId} hidden, pausing data polling...`);\n *   }\n * };\n * ```\n */\nexport interface ComponentDefinition {\n  /**\n   * Unique component type identifier\n   *\n   * **Requirements**:\n   * - Must be unique across all component definitions\n   * - Lowercase recommended (e.g., 'header', 'text-block')\n   * - Used in state to identify component type\n   *\n   * @example 'header', 'text-block', 'image-gallery'\n   */\n  type: string;\n\n  /**\n   * Display name in component palette\n   *\n   * **Usage**: Shown in UI when user selects component from palette\n   *\n   * @example 'Header', 'Text Block', 'Image Gallery'\n   */\n  name: string;\n\n  /**\n   * Icon/emoji for component palette\n   *\n   * **Usage**: Visual identifier in palette\n   * **Recommendation**: Use emoji for consistency\n   *\n   * @example 'üìÑ', 'üìù', 'üñºÔ∏è'\n   */\n  icon: string;\n\n  /**\n   * Default size when added to canvas (grid units)\n   *\n   * **Grid units**: Percentage-based (2% grid = 50 units = 100% width)\n   * **Typical sizes**:\n   * - Header: { width: 20, height: 6 } (40% width, ~120px height)\n   * - Text: { width: 20, height: 10 } (40% width, ~200px height)\n   * - Image: { width: 15, height: 12 } (30% width, ~240px height)\n   */\n  defaultSize: {\n    width: number;\n    height: number;\n  };\n\n  /**\n   * Minimum allowed size (grid units)\n   *\n   * **Optional**: If not specified, no minimum enforced\n   * **Usage**: Prevents user from making component too small\n   *\n   * @example { width: 10, height: 4 }\n   */\n  minSize?: {\n    width: number;\n    height: number;\n  };\n\n  /**\n   * Maximum allowed size (grid units)\n   *\n   * **Optional**: If not specified, no maximum enforced\n   * **Usage**: Prevents user from making component too large\n   *\n   * @example { width: 50, height: 30 }\n   */\n  maxSize?: {\n    width: number;\n    height: number;\n  };\n\n  /**\n   * Custom selection color for this component type\n   *\n   * **Optional**: If not specified, uses default yellow/gold (#f59e0b)\n   * **Usage**: Visual differentiation of component types\n   * **Applied to**:\n   * - Selection border\n   * - Drag handle header background\n   * - Resize handles\n   *\n   * **Recommended colors**:\n   * - Headers: '#3b82f6' (blue)\n   * - Text: '#10b981' (green)\n   * - Images: '#8b5cf6' (purple)\n   * - Buttons: '#ef4444' (red)\n   *\n   * @example '#3b82f6'\n   */\n  selectionColor?: string;\n\n  /**\n   * Render function - returns StencilJS component or HTMLElement\n   *\n   * **Called by**: grid-item-wrapper component\n   * **Return value**: StencilJS component reference (e.g., `<my-component />`)\n   * **Important**: Returns component reference, NOT rendered output\n   *               StencilJS manages internal component state independently\n   *\n   * **Props provided**:\n   * - `itemId`: Unique item identifier (use for event handlers, data fetching)\n   * - `config`: Current configuration values (from configSchema or custom panel)\n   *\n   * **Component state management**:\n   * Components with internal `@State` decorators (like live data feeds)\n   * will continue to update correctly. The wrapper's render memoization\n   * only caches the component reference, not the rendered output.\n   *\n   * @param props - Contains itemId and config\n   * @returns StencilJS component reference\n   *\n   * @example\n   * ```typescript\n   * render: ({ itemId, config }) => (\n   *   <component-header itemId={itemId} config={config} />\n   * )\n   * ```\n   */\n  render: (props: { itemId: string; config?: Record<string, any> }) => any;\n\n  /**\n   * Configuration schema for auto-generated config panel\n   *\n   * **Optional**: If not provided and renderConfigPanel not provided,\n   * component will have no configurable properties.\n   *\n   * **Usage**: Library generates form UI from this schema\n   * **Alternative**: Use `renderConfigPanel` for custom config UI\n   *\n   * **When to use**:\n   * - Simple text/color/select fields\n   * - Standard form inputs\n   * - Quick component configuration\n   *\n   * **When NOT to use** (use renderConfigPanel instead):\n   * - Complex UIs (image uploaders, multi-step wizards)\n   * - Visual pickers (color palettes, icon selectors)\n   * - Conditional field visibility\n   *\n   * @example\n   * ```typescript\n   * configSchema: [\n   *   {\n   *     name: 'text',\n   *     label: 'Header Text',\n   *     type: 'text',\n   *     defaultValue: 'New Header',\n   *     placeholder: 'Enter header text...'\n   *   },\n   *   {\n   *     name: 'level',\n   *     label: 'Heading Level',\n   *     type: 'select',\n   *     options: ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'],\n   *     defaultValue: 'H1'\n   *   },\n   *   {\n   *     name: 'color',\n   *     label: 'Text Color',\n   *     type: 'color',\n   *     defaultValue: '#000000'\n   *   }\n   * ]\n   * ```\n   */\n  configSchema?: ConfigField[];\n\n  /**\n   * Optional: Custom config panel renderer\n   *\n   * **When provided**: Completely overrides auto-generated form\n   * **Use cases**:\n   * - Complex configuration UIs (wizards, image uploaders, visual pickers)\n   * - Multi-step configuration flows\n   * - Conditional field visibility\n   * - Advanced validation logic\n   *\n   * **Props provided**:\n   * - `config`: Current configuration values (live preview state)\n   * - `onChange`: Callback to update a config field (for live preview)\n   * - `onSave`: Callback to save changes (commits to item)\n   * - `onCancel`: Callback to cancel and discard changes\n   *\n   * **State management**:\n   * - `config` is temporary state (not yet committed)\n   * - Call `onChange(fieldName, value)` for each field change\n   * - Call `onSave()` to commit all changes\n   * - Call `onCancel()` to discard all changes\n   *\n   * **Live preview**: Component renders using `config` while editing,\n   * so user sees changes in real-time before saving.\n   *\n   * **Auto-close on deletion**: Built-in config panels automatically close\n   * when the associated component is deleted. Custom panels should listen\n   * to the `componentDeleted` event via the EventManager to implement the\n   * same behavior:\n   * ```typescript\n   * // In your custom config panel component\n   * componentDidLoad() {\n   *   eventManager.on('componentDeleted', this.handleComponentDeleted);\n   * }\n   *\n   * private handleComponentDeleted = (event: { itemId: string }) => {\n   *   if (this.selectedItemId === event.itemId) {\n   *     this.closePanel();\n   *   }\n   * };\n   *\n   * disconnectedCallback() {\n   *   eventManager.off('componentDeleted', this.handleComponentDeleted);\n   * }\n   * ```\n   *\n   * @param props - Config state and callbacks\n   * @returns Custom config panel UI\n   *\n   * @example\n   * ```typescript\n   * renderConfigPanel: ({ config, onChange, onSave, onCancel }) => (\n   *   <div class=\"custom-config-panel\">\n   *     <h3>Configure Component</h3>\n   *     <div class=\"field\">\n   *       <label>Background Color</label>\n   *       <div class=\"color-picker\">\n   *         {['#ff0000', '#00ff00', '#0000ff'].map(color => (\n   *           <div\n   *             class={config.bgColor === color ? 'selected' : ''}\n   *             onClick={() => onChange('bgColor', color)}\n   *             style={{ background: color }}\n   *           />\n   *         ))}\n   *       </div>\n   *     </div>\n   *     <div class=\"actions\">\n   *       <button onClick={onCancel}>Cancel</button>\n   *       <button class=\"primary\" onClick={onSave}>Apply</button>\n   *     </div>\n   *   </div>\n   * )\n   * ```\n   */\n  renderConfigPanel?: (props: {\n    config: Record<string, any>;\n    onChange: (fieldName: string, value: any) => void;\n    onSave: () => void;\n    onCancel: () => void;\n  }) => any;\n\n  /**\n   * Validation function for placement\n   *\n   * **Optional**: If not provided, all placements allowed\n   * **Called**: When user drags component to canvas\n   * **Return**: true if placement is valid, false to reject\n   *\n   * **Use cases**:\n   * - Restrict to specific canvases (e.g., footer only in canvas3)\n   * - Prevent overlapping with other components\n   * - Enforce grid boundaries\n   * - Custom business rules\n   *\n   * @param canvasId - Target canvas ID\n   * @param position - Proposed position (x, y in grid units)\n   * @returns true if placement is valid\n   *\n   * @example\n   * ```typescript\n   * validatePlacement: (canvasId, position) => {\n   *   // Only allow in first canvas\n   *   return canvasId === 'canvas1';\n   * }\n   * ```\n   */\n  validatePlacement?: (canvasId: string, position: { x: number; y: number }) => boolean;\n\n  /**\n   * Validation function for resize\n   *\n   * **Optional**: If not provided, all resizes allowed (within min/max if specified)\n   * **Called**: When user resizes component\n   * **Return**: true if resize is valid, false to reject\n   *\n   * **Use cases**:\n   * - Enforce aspect ratio\n   * - Prevent specific sizes (e.g., must be even width)\n   * - Custom business rules\n   *\n   * **Note**: min/max size constraints are enforced automatically,\n   * this is for additional custom validation.\n   *\n   * @param newSize - Proposed size (width, height in grid units)\n   * @returns true if resize is valid\n   *\n   * @example\n   * ```typescript\n   * validateResize: (newSize) => {\n   *   // Enforce 16:9 aspect ratio\n   *   return Math.abs(newSize.width / newSize.height - 16/9) < 0.1;\n   * }\n   * ```\n   */\n  validateResize?: (newSize: { width: number; height: number }) => boolean;\n\n  /**\n   * Optional: Lifecycle hook called when component becomes visible\n   *\n   * **Note**: Virtual rendering is ALWAYS enabled for all components.\n   * This hook is optional and useful for:\n   * - Starting animations when component appears\n   * - Beginning data fetching for live data feeds\n   * - Initializing heavy resources (WebGL, video players)\n   * - Tracking analytics (component viewed)\n   *\n   * **Virtual rendering details**:\n   * - Components render when entering viewport (default: 20% margin)\n   * - Once rendered, stay rendered (no de-rendering)\n   * - Use this hook to pause/resume resources, not to manage DOM\n   *\n   * @param itemId - The component's unique ID\n   * @param config - The component's current configuration\n   *\n   * @example\n   * ```typescript\n   * onVisible: (itemId, config) => {\n   *   console.log(`Video ${itemId} visible, starting playback...`);\n   *   const video = document.querySelector(`#video-${itemId}`);\n   *   video?.play();\n   * }\n   * ```\n   */\n  onVisible?: (itemId: string, config: Record<string, any>) => void;\n\n  /**\n   * Optional: Lifecycle hook called when component leaves viewport\n   *\n   * **Important**: Component DOM stays rendered (not destroyed).\n   * Use this hook for resource cleanup, NOT DOM removal.\n   *\n   * **Useful for**:\n   * - Pausing videos/animations to save CPU\n   * - Stopping data fetching/polling\n   * - Cleaning up heavy resources (close WebSocket, pause WebGL)\n   * - Tracking analytics (component scrolled away)\n   *\n   * **Why no de-rendering**:\n   * - Prevents scroll jank (no reflow/repaint)\n   * - Preserves component state (form inputs, video position)\n   * - Faster scroll-back (already rendered)\n   * - Browser optimized for off-screen DOM\n   *\n   * @param itemId - The component's unique ID\n   *\n   * @example\n   * ```typescript\n   * onHidden: (itemId) => {\n   *   console.log(`Video ${itemId} hidden, pausing playback...`);\n   *   const video = document.querySelector(`#video-${itemId}`);\n   *   video?.pause(); // Pause but keep DOM\n   * }\n   * ```\n   */\n  onHidden?: (itemId: string) => void;\n\n  /**\n   * Optional: Custom palette item renderer\n   *\n   * **When provided**: Returns JSX element for custom palette item.\n   *\n   * **When NOT provided**: Library uses default palette item (icon + name).\n   *\n   * **Use cases**:\n   * - Custom branding or styling for palette items\n   * - Visual previews or thumbnails in palette\n   * - Enhanced component descriptions\n   *\n   * **Props provided**:\n   * - `componentType`: The component type\n   * - `name`: Component display name\n   * - `icon`: Component icon/emoji\n   *\n   * **Return value**: JSX element (StencilJS vNode)\n   *\n   * **Security**: Using JSX instead of HTML strings prevents XSS vulnerabilities\n   *\n   * @param props - Palette item rendering context\n   * @returns JSX element\n   *\n   * @example\n   * ```typescript\n   * renderPaletteItem: ({ componentType, name, icon }) => (\n   *   <custom-palette-item\n   *     component-type={componentType}\n   *     name={name}\n   *     icon={icon}\n   *   />\n   * )\n   * ```\n   */\n  renderPaletteItem?: (props: {\n    componentType: string;\n    name: string;\n    icon: string;\n  }) => any;\n\n  /**\n   * Custom drag clone renderer (REQUIRED)\n   *\n   * **Returns**: JSX element for custom drag clone preview.\n   *\n   * **Use cases**:\n   * - Custom visual preview matching your component's appearance\n   * - Rich drag feedback with realistic component representation\n   * - Branded or styled drag previews\n   *\n   * **Sizing**: The library automatically uses `defaultSize` from this definition\n   * and converts grid units to pixels. No need to specify size in renderDragClone.\n   *\n   * **Return value**: JSX element (StencilJS vNode)\n   * - Can be inline JSX with styles\n   * - Can be a dedicated Stencil component (recommended for complex previews)\n   *\n   * **Recommended Pattern**: Create a dedicated Stencil component for drag clones\n   * ```typescript\n   * // Component: blog-header-drag-clone.tsx\n   * @Component({ tag: 'blog-header-drag-clone' })\n   * export class BlogHeaderDragClone {\n   *   render() {\n   *     return (\n   *       <div class=\"header-preview\">\n   *         <h1>Header Title</h1>\n   *         <p>Subtitle preview</p>\n   *       </div>\n   *     );\n   *   }\n   * }\n   * ```\n   *\n   * **Library responsibilities**:\n   * - Wraps your JSX in a fixed-size container (width √ó height from defaultSize)\n   * - Applies base drag styling (border, shadow, cursor)\n   * - Positions during drag and cleans up after drop\n   * - Sets `overflow: hidden` to clip content to size\n   *\n   * **Your responsibility**:\n   * - Return JSX that looks good at the component's default size\n   * - Make it visually represent the actual component\n   *\n   * @returns JSX element (StencilJS vNode)\n   *\n   * @example\n   * ```typescript\n   * // Using a dedicated Stencil component (recommended)\n   * renderDragClone: () => (\n   *   <blog-header-drag-clone />\n   * )\n   *\n   * // Or inline JSX for simple cases\n   * renderDragClone: () => (\n   *   <div style={{\n   *     display: 'flex',\n   *     alignItems: 'center',\n   *     justifyContent: 'center',\n   *     height: '100%'\n   *   }}>\n   *     <h1>Header Preview</h1>\n   *   </div>\n   * )\n   * ```\n   */\n  renderDragClone: () => any;\n\n  /**\n   * Optional: Custom item wrapper/chrome renderer\n   *\n   * **When provided**: Returns JSX element for custom grid item wrapper\n   * that will replace the default grid item chrome (drag handle, header, controls).\n   *\n   * **When NOT provided**: Library uses default grid item wrapper.\n   *\n   * **Use cases**:\n   * - Custom control layouts\n   * - Different header designs\n   * - Alternative drag handles\n   * - Custom branding\n   *\n   * **Props provided**:\n   * - `itemId`: The grid item ID\n   * - `componentType`: The component type\n   * - `name`: Component display name\n   * - `icon`: Component icon/emoji\n   * - `isSelected`: Whether the item is currently selected\n   * - `contentSlotId`: ID for the content container (your component renders here)\n   *\n   * **Return value**: JSX element (StencilJS vNode)\n   *\n   * **Security**: Using JSX instead of HTML strings prevents XSS vulnerabilities\n   *\n   * **IMPORTANT REQUIREMENTS**:\n   * Your custom wrapper component MUST include:\n   *\n   * 1. **Content Slot**: A container with `id={contentSlotId}` where the actual component will render\n   *    ```jsx\n   *    <div id={contentSlotId} class=\"component-content\"></div>\n   *    ```\n   *\n   * 2. **Drag Handle**: An element with class `drag-handle` for dragging functionality\n   *    ```jsx\n   *    <div class=\"drag-handle\"></div>\n   *    ```\n   *\n   * 3. **Event Emission**: Your component must emit the following standard events for user actions\n   *    ```typescript\n   *    // Delete button clicked\n   *    this.el.dispatchEvent(new CustomEvent('item-delete', { bubbles: true, composed: true }));\n   *\n   *    // Bring to front button clicked\n   *    this.el.dispatchEvent(new CustomEvent('item-bring-to-front', { bubbles: true, composed: true }));\n   *\n   *    // Send to back button clicked\n   *    this.el.dispatchEvent(new CustomEvent('item-send-to-back', { bubbles: true, composed: true }));\n   *    ```\n   *\n   * **Event-based architecture**:\n   * The library uses Stencil's `@Listen` decorator to listen for these standard events.\n   * Your wrapper emits events ‚Üí Library handles the business logic (undo/redo, state updates, etc.).\n   * This provides clean separation of concerns and follows web component best practices.\n   *\n   * Without the required elements and events, drag, resize, and delete functionality will not work.\n   * The resize handles (8-point) are added automatically by the library outside your custom chrome.\n   *\n   * @param props - Item wrapper rendering context\n   * @returns JSX element\n   *\n   * @example\n   * ```typescript\n   * renderItemWrapper: ({ itemId, componentType, name, icon, isSelected, contentSlotId }) => (\n   *   <custom-item-wrapper\n   *     item-id={itemId}\n   *     component-type={componentType}\n   *     name={name}\n   *     icon={icon}\n   *     is-selected={isSelected}\n   *     content-slot-id={contentSlotId}\n   *   />\n   * )\n   * ```\n   *\n   * Example custom wrapper component:\n   * - Use @Element() decorator to get host element reference\n   * - Create handler methods that dispatch custom events\n   * - Include drag-handle element with class=\"drag-handle\"\n   * - Include content slot element with id={contentSlotId}\n   * - Dispatch 'item-delete', 'item-bring-to-front', 'item-send-to-back' events\n   */\n  renderItemWrapper?: (props: {\n    itemId: string;\n    componentType: string;\n    name: string;\n    icon: string;\n    isSelected: boolean;\n    contentSlotId: string;\n  }) => any;\n}\n"]}