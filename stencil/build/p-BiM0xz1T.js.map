{"version":3,"file":"p-BiM0xz1T.js","sources":["src/utils/dom-cache.ts","src/utils/grid-calculations.ts","node_modules/@stencil/store/dist/index.js","src/utils/debug.ts","src/utils/validation.ts","src/services/undo-redo.ts","src/services/shared-state-registry.ts","src/services/state-manager.ts"],"sourcesContent":["/**\n * DOM Cache Utility\n * =================\n *\n * Performance optimization layer that caches frequently accessed DOM elements to avoid\n * repeated `document.getElementById()` calls during drag/resize operations.\n *\n * ## Problem\n *\n * During interactive operations (drag, resize), we frequently need to access the same\n * DOM elements:\n * - Canvas containers for width calculations\n * - Grid items for position updates\n * - Parent elements for coordinate transforms\n *\n * Each `document.getElementById()` call:\n * - Traverses the DOM tree\n * - Can trigger layout calculations\n * - Becomes expensive when called hundreds of times per second during drag\n *\n * ## Solution\n *\n * Cache DOM references in memory after first lookup:\n * - **First access**: Query DOM once and store reference\n * - **Subsequent access**: Return cached reference (O(1) Map lookup)\n * - **Invalidation**: Clear cache when DOM structure changes\n *\n * ## Performance Impact\n *\n * **Without caching**:\n * - During drag: ~60 getElementById calls/second (60fps × multiple items)\n * - Each call traverses DOM tree\n * - Cumulative impact on frame budget\n *\n * **With caching**:\n * - First call: DOM query + cache store\n * - Subsequent: Map.get() (constant time)\n * - 90%+ reduction in DOM queries during operations\n *\n * ## When to Use This Pattern\n *\n * Apply DOM caching when:\n * ✅ Accessing same elements repeatedly in tight loops\n * ✅ During high-frequency events (mousemove, scroll, resize)\n * ✅ Elements are stable (not frequently added/removed)\n * ✅ Performance profiling shows getElementById as bottleneck\n *\n * Avoid when:\n * ❌ Elements change frequently (cache becomes stale)\n * ❌ Only accessing elements once\n * ❌ Using framework-managed refs (React useRef, Stencil @Element)\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n * ```typescript\n * class MyDOMCache {\n * private elements = new Map<string, HTMLElement>();\n *\n * get(id: string): HTMLElement | null {\n * if (this.elements.has(id)) return this.elements.get(id)!;\n * const el = document.getElementById(id);\n * if (el) this.elements.set(id, el);\n * return el;\n * }\n *\n * invalidate(id: string) { this.elements.delete(id); }\n * }\n * export const cache = new MyDOMCache();\n * ```\n *\n * ## Cache Invalidation Strategy\n *\n * Clear cache when:\n * - Canvas added/removed from DOM\n * - Component unmounts\n * - Major DOM restructuring\n * - Element IDs change\n * @module dom-cache\n */\n\n/**\n * DOM Cache for canvas containers and frequently accessed elements\n *\n * Singleton pattern ensures all code uses same cache instance\n */\nexport class DOMCache {\n  /** Canvas element cache - key: canvasId, value: HTMLElement */\n  private canvases: Map<string, HTMLElement> = new Map();\n\n  /**\n   * Get canvas element by ID with automatic caching\n   *\n   * **Caching behavior**:\n   * 1. Check Map cache first (O(1))\n   * 2. If miss, query DOM and cache result\n   * 3. Return cached or fresh element\n   *\n   * **Performance**:\n   * - Cached access: ~0.001ms (Map.get)\n   * - DOM query: ~0.1-1ms (getElementById + tree traversal)\n   * - Speedup: 100-1000x for cached access\n   *\n   * **Safety**:\n   * - Returns `null` if element doesn't exist\n   * - Safe to call before DOM ready (returns null, doesn't cache)\n   * - Cache automatically populated on first successful access\n   * @param canvasId - Canvas container element ID\n   * @returns HTMLElement or null if not found\n   * @example\n   * ```typescript\n   * // First call - queries DOM\n   * const canvas1 = domCache.getCanvas('canvas1'); // ~0.5ms\n   *\n   * // Subsequent calls - returns cached\n   * const canvas2 = domCache.getCanvas('canvas1'); // ~0.001ms\n   * const canvas3 = domCache.getCanvas('canvas1'); // ~0.001ms\n   *\n   * // Different canvas - new DOM query\n   * const canvas4 = domCache.getCanvas('canvas2'); // ~0.5ms\n   * ```\n   */\n  getCanvas(canvasId: string): HTMLElement | null {\n    // Check cache first\n    if (this.canvases.has(canvasId)) {\n      return this.canvases.get(canvasId)!;\n    }\n\n    // Query DOM and cache\n    const canvas = document.getElementById(canvasId);\n    if (canvas) {\n      this.canvases.set(canvasId, canvas);\n    }\n\n    return canvas;\n  }\n\n  /**\n   * Invalidate cache for a specific canvas\n   *\n   * **When to call**:\n   * - Canvas element removed from DOM\n   * - Canvas element replaced (same ID, different element)\n   * - Canvas component unmounts\n   * - Element ID changed\n   *\n   * **Why needed**:\n   * Cached references become stale when elements are removed or replaced.\n   * Invalidation ensures next access queries fresh element from DOM.\n   *\n   * **Performance**:\n   * Very cheap operation (Map.delete is O(1))\n   * @param canvasId - Canvas ID to remove from cache\n   * @example\n   * ```typescript\n   * // Component unmounting\n   * disconnectedCallback() {\n   *   domCache.invalidate(this.canvasId);\n   * }\n   *\n   * // Canvas removed from state\n   * delete gridState.canvases['canvas1'];\n   * domCache.invalidate('canvas1');\n   * ```\n   */\n  invalidate(canvasId: string): void {\n    this.canvases.delete(canvasId);\n  }\n\n  /**\n   * Clear entire DOM cache\n   *\n   * **When to call**:\n   * - Major DOM restructuring (e.g., navigation, full page reload)\n   * - All canvases removed/replaced\n   * - Test cleanup (afterEach hooks)\n   * - Memory cleanup when cache grows too large\n   *\n   * **Why needed**:\n   * Prevents memory leaks from cached references to removed elements\n   * and ensures clean slate after major DOM changes.\n   *\n   * **Performance**:\n   * Cheap operation - just clears Map references.\n   * Elements are garbage collected automatically.\n   * @example\n   * ```typescript\n   * // Test cleanup\n   * afterEach(() => {\n   *   domCache.clear();\n   * });\n   *\n   * // Navigation/route change\n   * router.beforeEach(() => {\n   *   domCache.clear();\n   * });\n   *\n   * // Memory management\n   * if (domCache.size() > 100) {\n   *   domCache.clear(); // Periodic cleanup\n   * }\n   * ```\n   */\n  clear(): void {\n    this.canvases.clear();\n  }\n}\n","/**\n * Grid Calculations Utility\n * ========================\n *\n * Core system for converting between pixel coordinates and grid units in the drag-and-drop\n * grid builder. This module provides pure functions with performance optimizations through\n * intelligent caching.\n *\n * ## Grid System Architecture\n *\n * The grid uses a hybrid approach combining responsive and fixed sizing:\n *\n * ### Horizontal Grid (Responsive)\n * - **Size**: 2% of container width (50 units across full width)\n * - **Behavior**: Scales proportionally with canvas width changes\n * - **Use case**: Enables responsive layouts that adapt to different screen sizes\n * - **Example**: At 1000px width, each grid unit = 20px (1000 * 0.02)\n *\n * ### Vertical Grid (Fixed)\n * - **Size**: Fixed 20px per grid unit\n * - **Behavior**: Remains constant regardless of viewport size\n * - **Use case**: Provides consistent vertical spacing and predictable heights\n * - **Rationale**: Vertical scrolling is unlimited, so fixed sizing provides better UX\n *\n * ## Performance Optimization Strategy\n *\n * ### Grid Size Caching\n * The horizontal grid size is calculated from DOM elements (container.clientWidth),\n * which is an expensive operation. To minimize performance impact:\n *\n * 1. **First access**: Calculate once per canvas and cache the result\n * 2. **Subsequent access**: Return cached value (no DOM reads)\n * 3. **Cache invalidation**: Clear when canvas resizes (via ResizeObserver)\n *\n * **Performance Impact**:\n * - Without caching: 100 items = 100+ DOM reads during viewport switch\n * - With caching: 100 items = 1 DOM read per canvas during viewport switch\n * - Prevents layout thrashing and reduces reflows\n *\n * ### DOM Caching Integration\n * Uses `domCache` utility to avoid repeated `getElementById` calls, providing\n * a second layer of performance optimization.\n *\n * ## Usage Examples\n *\n * ```typescript\n * // Convert grid position to pixels for rendering\n * const pixelX = gridToPixelsX(10, 'canvas1'); // Grid unit 10 → pixels\n * const pixelY = gridToPixelsY(5);              // Grid unit 5 → 100px\n *\n * // Convert mouse position to grid coordinates\n * const gridX = pixelsToGridX(250, 'canvas1');  // Pixels → grid units\n * const gridY = pixelsToGridY(120);             // 120px → 6 grid units\n *\n * // Clear cache on canvas resize\n * resizeObserver.observe(canvasContainer);\n * resizeObserver.addEventListener(() => clearGridSizeCache());\n * ```\n * @module grid-calculations\n */\n\nimport { DOMCache } from \"./dom-cache\";\nimport { GridConfig } from \"../types/grid-config\";\n\n/** Fixed vertical grid size in pixels - provides consistent vertical spacing */\nconst GRID_SIZE_VERTICAL = 20;\n\n/**\n * Horizontal grid size as percentage of container width\n * 0.02 = 2% = 50 grid units across full width\n */\nconst GRID_SIZE_HORIZONTAL_PERCENT = 0.02;\n\n/**\n * Default minimum grid size in pixels\n * Prevents grid from becoming too small on tiny screens\n */\nconst DEFAULT_MIN_GRID_SIZE = 10;\n\n/**\n * Default maximum grid size in pixels\n * Prevents grid from becoming too large on huge screens\n */\nconst DEFAULT_MAX_GRID_SIZE = 50;\n\n/**\n * Grid size cache to avoid repeated DOM queries\n *\n * **Cache key format**: `${instanceId}-${canvasId}-h` for horizontal grid sizes\n * **Instance isolation**: Each grid-builder instance gets its own cache namespace\n *\n * **Why instance-aware**:\n * - Multiple instances on same page can have different container widths for same canvasId\n * - Prevents cache collisions when instances share canvasIds\n * - Supports Storybook story switching (each story is a new instance)\n *\n * **Cleared on**:\n * - Canvas container resize (via ResizeObserver)\n * - Viewport changes (desktop ↔ mobile)\n * - Component unmount (disconnectedCallback)\n */\nconst gridSizeCache = new Map<string, number>();\n\n/**\n * Clear the grid size cache for all canvases or a specific instance\n *\n * **When to call**:\n * - Canvas container is resized (via ResizeObserver)\n * - Viewport changes (desktop ↔ mobile)\n * - Canvas is added/removed from DOM\n * - Component unmounts (clear only that instance's cache)\n *\n * **Instance-specific clearing**:\n * If instanceId provided, only clears cache entries for that instance.\n * Useful when unmounting a specific grid-builder instance.\n *\n * **Why needed**:\n * Cached grid sizes become stale when container widths change. This ensures\n * fresh calculations on next access.\n *\n * **Performance note**:\n * Clearing cache is cheap (O(1) for all, O(n) for instance-specific where n = cache size).\n * The cost is in recalculation, which happens lazily on next access.\n * @param instanceId - Optional instance ID to clear only that instance's cache\n * @example\n * ```typescript\n * // Clear all caches (all instances)\n * resizeObserver.observe(canvasElement);\n * resizeCallback = () => {\n *   clearGridSizeCache();\n *   // All instances will recalculate on next render\n * };\n *\n * // Clear only specific instance's cache (on unmount)\n * disconnectedCallback() {\n *   clearGridSizeCache(this.config?.instanceId);\n *   // Only this instance's cache is cleared\n * }\n * ```\n */\nexport function clearGridSizeCache(instanceId?: string) {\n  if (instanceId) {\n    // Clear only cache entries for this instance\n    const prefix = `${instanceId}-`;\n    for (const key of gridSizeCache.keys()) {\n      if (key.startsWith(prefix)) {\n        gridSizeCache.delete(key);\n      }\n    }\n  } else {\n    // Clear all (backward compatibility, window resize, etc.)\n    gridSizeCache.clear();\n  }\n}\n\n/**\n * Pre-populate grid size cache with known container width\n *\n * **Purpose**: Set cache value BEFORE triggering re-render to avoid reading DOM during transient state\n *\n * **Use case**: ResizeObserver gives us correct width via entry.contentRect.width.\n * By pre-calculating and caching this value before triggering re-render, we ensure\n * grid calculations never read clientWidth=0 during StencilJS re-render cycle.\n *\n * **Why needed**:\n * When ResizeObserver fires and we trigger re-render (renderVersion++), the DOM enters\n * a transient state where clientWidth returns 0. By pre-populating cache with the correct\n * value from ResizeObserver, we bypass DOM reads entirely during re-render.\n *\n * **Implementation**:\n * Uses same calculation logic as getGridSizeHorizontal() but accepts width parameter\n * instead of reading from DOM.\n * @param canvasId - Canvas element ID for cache key\n * @param containerWidth - Width from ResizeObserver entry.contentRect.width\n * @param config - Optional GridConfig for customization (gridSizePercent, min/max, instanceId)\n * @example\n * ```typescript\n * // In ResizeObserver callback\n * this.resizeObserver = new ResizeObserver((entries) => {\n *   for (const entry of entries) {\n *     const width = entry.contentRect.width;\n *\n *     // Pre-populate cache before triggering re-render\n *     setGridSizeCache(this.canvasId, width, this.config);\n *\n *     // Now trigger re-render - calculations will use cached value\n *     this.renderVersion++;\n *   }\n * });\n * ```\n */\nexport function setGridSizeCache(\n  canvasId: string,\n  containerWidth: number,\n  config?: GridConfig,\n): void {\n  // Build cache key (same logic as getGridSizeHorizontal)\n  const cacheKey = config?.instanceId\n    ? `${config.instanceId}-${canvasId}-h`\n    : `${canvasId}-h`;\n\n  // Get grid size percent from config or use default\n  const gridSizePercent = config?.gridSizePercent\n    ? config.gridSizePercent / 100\n    : GRID_SIZE_HORIZONTAL_PERCENT;\n\n  // Calculate raw grid size from provided width\n  const rawSize = containerWidth * gridSizePercent;\n\n  // Apply min/max constraints from config or use defaults\n  const minSize = config?.minGridSize ?? DEFAULT_MIN_GRID_SIZE;\n  const maxSize = config?.maxGridSize ?? DEFAULT_MAX_GRID_SIZE;\n  const size = Math.max(minSize, Math.min(maxSize, rawSize));\n\n  // Set in cache\n  gridSizeCache.set(cacheKey, size);\n}\n\n/**\n * Get the horizontal grid size for a specific canvas\n *\n * **Calculation**: `containerWidth * gridSizePercent` = size of one horizontal grid unit in pixels\n * **Min/Max constraints**: Applied from GridConfig (default: 10px-50px)\n *\n * **Caching behavior**:\n * - First call: Reads `container.clientWidth` from DOM and caches result\n * - Subsequent calls: Returns cached value (no DOM access)\n * - After resize: Cache cleared, recalculates on next call\n *\n * **Why responsive**:\n * Horizontal grid scales with container to support:\n * - Responsive layouts (desktop/mobile)\n * - Variable canvas widths\n * - Fluid grid-based designs\n *\n * **GridConfig customization**:\n * - `gridSizePercent`: Grid unit as % of width (default: 2% = 50 units per 100% width)\n * - `minGridSize`: Minimum size in pixels (default: 10px, prevents too small on mobile)\n * - `maxGridSize`: Maximum size in pixels (default: 50px, prevents too large on desktop)\n * @param canvasId - The canvas element ID to calculate grid size for\n * @param config - Optional GridConfig for customization\n * @param forceRecalc - Set true to bypass cache and force fresh calculation\n * @returns Size of one horizontal grid unit in pixels (constrained by min/max)\n * @example\n * ```typescript\n * // Default config (2% grid, 10px-50px)\n * const size1 = getGridSizeHorizontal('canvas1'); // → 20 (at 1000px width)\n *\n * // Custom config (3% grid, 15px-60px)\n * const size2 = getGridSizeHorizontal('canvas1', {\n *   gridSizePercent: 3,\n *   minGridSize: 15,\n *   maxGridSize: 60\n * }); // → 30 (at 1000px width)\n *\n * // Force recalculation\n * const size3 = getGridSizeHorizontal('canvas1', undefined, true);\n * ```\n */\nexport function getGridSizeHorizontal(\n  canvasId: string,\n  config?: GridConfig,\n  forceRecalc: boolean = false,\n  domCacheInstance?: DOMCache,\n): number {\n  // Instance-aware cache key: ${instanceId}-${canvasId}-h\n  // Fallback to ${canvasId}-h for backward compatibility if no instanceId\n  const cacheKey = config?.instanceId\n    ? `${config.instanceId}-${canvasId}-h`\n    : `${canvasId}-h`;\n\n  if (!forceRecalc && gridSizeCache.has(cacheKey)) {\n    return gridSizeCache.get(cacheKey)!;\n  }\n\n  // Use DOM cache instance if provided, otherwise create temporary instance\n  const cache = domCacheInstance || new DOMCache();\n  const container = cache.getCanvas(canvasId);\n  if (!container) {\n    console.warn(`Canvas container not found: ${canvasId}`);\n    return 0;\n  }\n\n  // Get grid size percent from config or use default\n  // Config gridSizePercent is whole number (2 = 2%), default is already decimal (0.02)\n  const gridSizePercent = config?.gridSizePercent\n    ? config.gridSizePercent / 100\n    : GRID_SIZE_HORIZONTAL_PERCENT;\n\n  // Calculate raw grid size\n  const rawSize = container.clientWidth * gridSizePercent;\n\n  // Apply min/max constraints from config or use defaults\n  const minSize = config?.minGridSize ?? DEFAULT_MIN_GRID_SIZE;\n  const maxSize = config?.maxGridSize ?? DEFAULT_MAX_GRID_SIZE;\n  const size = Math.max(minSize, Math.min(maxSize, rawSize));\n\n  // Don't cache if container not laid out yet (prevents caching 0-width or tiny containers)\n  // Critical for initial load: canvas element exists in DOM but CSS layout hasn't happened yet\n  // ResizeObserver will fire when layout completes, then we'll cache the correct value\n  if (container.clientWidth > 100) {\n    gridSizeCache.set(cacheKey, size);\n  }\n\n  return size;\n}\n\n/**\n * Get the vertical grid size\n *\n * **Configurable vertical grid**:\n * Unlike horizontal grid, vertical uses fixed sizing (default 20px) because:\n * - Vertical scrolling is infinite (no container height limit)\n * - Provides predictable, consistent heights across all viewports\n * - Simplifies calculations (no container dependency)\n * - Better UX for vertical spacing\n * @param config Optional GridConfig with verticalGridSize\n * @returns Vertical grid size in pixels (config.verticalGridSize || 20)\n * @example\n * ```typescript\n * const vSize = getGridSizeVertical(); // → 20 (default)\n * const vSize2 = getGridSizeVertical({ verticalGridSize: 25 }); // → 25\n * ```\n */\nexport function getGridSizeVertical(config?: GridConfig): number {\n  return config?.verticalGridSize ?? GRID_SIZE_VERTICAL;\n}\n\n/**\n * Convert grid units to pixels for horizontal positioning and sizing\n *\n * **Use cases**:\n * - Converting item `x` position from grid coordinates to CSS left/transform\n * - Converting item `width` from grid units to CSS width\n * - Rendering grid items at correct horizontal positions\n *\n * **Performance**:\n * Uses cached grid size via `getGridSizeHorizontal()` to avoid DOM reads\n *\n * **Rounding**:\n * Uses `Math.round()` to prevent subpixel rendering issues\n * @param gridUnits - Number of grid units\n * @param canvasId - Canvas ID for responsive grid size calculation\n * @param config - Optional GridConfig for customization\n * @returns Pixel value\n * @example\n * ```typescript\n * // Item at grid position x=10 (default 2% grid)\n * const leftPx = gridToPixelsX(10, 'canvas1'); // → 200px (at 1000px container)\n *\n * // Item with grid width=15 (custom 3% grid)\n * const widthPx = gridToPixelsX(15, 'canvas1', { gridSizePercent: 3 }); // → 450px\n * ```\n */\nexport function gridToPixelsX(\n  gridUnits: number,\n  canvasId: string,\n  config?: GridConfig,\n): number {\n  // Use cached grid size for better performance\n  const gridSize = getGridSizeHorizontal(canvasId, config);\n  return Math.round(gridUnits * gridSize);\n}\n\n/**\n * Convert grid units to pixels for vertical positioning and sizing\n *\n * **Use cases**:\n * - Converting item `y` position from grid coordinates to CSS top/transform\n * - Converting item `height` from grid units to CSS height\n * - Calculating vertical spacing\n *\n * **Configurable vertical grid**:\n * Uses config.verticalGridSize (default 20px) for calculation\n * @param gridUnits - Number of grid units\n * @param config - Optional GridConfig with verticalGridSize\n * @returns Pixel value (gridUnits * verticalGridSize)\n * @example\n * ```typescript\n * // Item at grid position y=5 (default 20px)\n * const topPx = gridToPixelsY(5); // → 100px\n *\n * // Item with grid height=8 (custom 25px)\n * const heightPx = gridToPixelsY(8, { verticalGridSize: 25 }); // → 200px\n * ```\n */\nexport function gridToPixelsY(gridUnits: number, config?: GridConfig): number {\n  return gridUnits * getGridSizeVertical(config);\n}\n\n/**\n * Convert pixel coordinates to grid units for horizontal values\n *\n * **Use cases**:\n * - Converting mouse/drop position to grid coordinates\n * - Snapping dragged items to grid\n * - Calculating item positions after drag\n *\n * **Rounding**:\n * Uses `Math.round()` to snap to nearest grid unit (implements grid snapping)\n *\n * **Safety**:\n * Returns 0 if grid size is 0 (container not found/initialized)\n * @param pixels - Pixel value to convert\n * @param canvasId - Canvas ID for responsive grid size calculation\n * @param config - Optional GridConfig for customization\n * @returns Number of grid units (rounded)\n * @example\n * ```typescript\n * // Mouse drop at 250px (default 2% grid)\n * const gridX = pixelsToGridX(250, 'canvas1'); // → 13 (at 1000px container)\n *\n * // After drag, element at 371px (custom 3% grid)\n * const snappedX = pixelsToGridX(371, 'canvas1', { gridSizePercent: 3 }); // → 12\n * ```\n */\nexport function pixelsToGridX(\n  pixels: number,\n  canvasId: string,\n  config?: GridConfig,\n): number {\n  // Use cached grid size for better performance\n  const gridSize = getGridSizeHorizontal(canvasId, config);\n  if (gridSize === 0) {\n    return 0;\n  }\n  return Math.round(pixels / gridSize);\n}\n\n/**\n * Convert pixel coordinates to grid units for vertical values\n *\n * **Use cases**:\n * - Converting mouse Y position to grid coordinates\n * - Snapping vertical positions to grid\n * - Calculating vertical offsets\n *\n * **Rounding**:\n * Implements automatic grid snapping via `Math.round()`\n * @param pixels - Pixel value to convert\n * @param config - Optional GridConfig with verticalGridSize\n * @returns Number of grid units (rounded)\n * @example\n * ```typescript\n * // Mouse at 127px vertically (default 20px grid)\n * const gridY = pixelsToGridY(127); // → 6 (rounded from 6.35)\n *\n * // Element height 165px (custom 25px grid)\n * const gridHeight = pixelsToGridY(165, { verticalGridSize: 25 }); // → 7 (rounded from 6.6)\n * ```\n */\nexport function pixelsToGridY(pixels: number, config?: GridConfig): number {\n  return Math.round(pixels / getGridSizeVertical(config));\n}\n","import { getRenderingRef, forceUpdate } from '@stencil/core';\n\nconst appendToMap = (map, propName, value) => {\n    const items = map.get(propName);\n    if (!items) {\n        map.set(propName, [value]);\n    }\n    else if (!items.includes(value)) {\n        items.push(value);\n    }\n};\nconst debounce = (fn, ms) => {\n    let timeoutId;\n    return (...args) => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = 0;\n            fn(...args);\n        }, ms);\n    };\n};\n\n/**\n * Check if a possible element isConnected.\n * The property might not be there, so we check for it.\n *\n * We want it to return true if isConnected is not a property,\n * otherwise we would remove these elements and would not update.\n *\n * Better leak in Edge than to be useless.\n */\nconst isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;\nconst cleanupElements = debounce((map) => {\n    for (let key of map.keys()) {\n        map.set(key, map.get(key).filter(isConnected));\n    }\n}, 2_000);\nconst stencilSubscription = () => {\n    if (typeof getRenderingRef !== 'function') {\n        // If we are not in a stencil project, we do nothing.\n        // This function is not really exported by @stencil/core.\n        return {};\n    }\n    const elmsToUpdate = new Map();\n    return {\n        dispose: () => elmsToUpdate.clear(),\n        get: (propName) => {\n            const elm = getRenderingRef();\n            if (elm) {\n                appendToMap(elmsToUpdate, propName, elm);\n            }\n        },\n        set: (propName) => {\n            const elements = elmsToUpdate.get(propName);\n            if (elements) {\n                elmsToUpdate.set(propName, elements.filter(forceUpdate));\n            }\n            cleanupElements(elmsToUpdate);\n        },\n        reset: () => {\n            elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));\n            cleanupElements(elmsToUpdate);\n        },\n    };\n};\n\nconst unwrap = (val) => (typeof val === 'function' ? val() : val);\nconst createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {\n    const unwrappedState = unwrap(defaultState);\n    let states = new Map(Object.entries(unwrappedState ?? {}));\n    const handlers = {\n        dispose: [],\n        get: [],\n        set: [],\n        reset: [],\n    };\n    // Track onChange listeners to enable removeListener functionality\n    const changeListeners = new Map();\n    const reset = () => {\n        // When resetting the state, the default state may be a function - unwrap it to invoke it.\n        // otherwise, the state won't be properly reset\n        states = new Map(Object.entries(unwrap(defaultState) ?? {}));\n        handlers.reset.forEach((cb) => cb());\n    };\n    const dispose = () => {\n        // Call first dispose as resetting the state would\n        // cause less updates ;)\n        handlers.dispose.forEach((cb) => cb());\n        reset();\n    };\n    const get = (propName) => {\n        handlers.get.forEach((cb) => cb(propName));\n        return states.get(propName);\n    };\n    const set = (propName, value) => {\n        const oldValue = states.get(propName);\n        if (shouldUpdate(value, oldValue, propName)) {\n            states.set(propName, value);\n            handlers.set.forEach((cb) => cb(propName, value, oldValue));\n        }\n    };\n    const state = (typeof Proxy === 'undefined'\n        ? {}\n        : new Proxy(unwrappedState, {\n            get(_, propName) {\n                return get(propName);\n            },\n            ownKeys(_) {\n                return Array.from(states.keys());\n            },\n            getOwnPropertyDescriptor() {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            },\n            has(_, propName) {\n                return states.has(propName);\n            },\n            set(_, propName, value) {\n                set(propName, value);\n                return true;\n            },\n        }));\n    const on = (eventName, callback) => {\n        handlers[eventName].push(callback);\n        return () => {\n            removeFromArray(handlers[eventName], callback);\n        };\n    };\n    const onChange = (propName, cb) => {\n        const setHandler = (key, newValue) => {\n            if (key === propName) {\n                cb(newValue);\n            }\n        };\n        const resetHandler = () => cb(unwrap(defaultState)[propName]);\n        // Register the handlers\n        const unSet = on('set', setHandler);\n        const unReset = on('reset', resetHandler);\n        // Track the relationship between the user callback and internal handlers\n        changeListeners.set(cb, { setHandler, resetHandler, propName });\n        return () => {\n            unSet();\n            unReset();\n            changeListeners.delete(cb);\n        };\n    };\n    const use = (...subscriptions) => {\n        const unsubs = subscriptions.reduce((unsubs, subscription) => {\n            if (subscription.set) {\n                unsubs.push(on('set', subscription.set));\n            }\n            if (subscription.get) {\n                unsubs.push(on('get', subscription.get));\n            }\n            if (subscription.reset) {\n                unsubs.push(on('reset', subscription.reset));\n            }\n            if (subscription.dispose) {\n                unsubs.push(on('dispose', subscription.dispose));\n            }\n            return unsubs;\n        }, []);\n        return () => unsubs.forEach((unsub) => unsub());\n    };\n    const forceUpdate = (key) => {\n        const oldValue = states.get(key);\n        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));\n    };\n    const removeListener = (propName, listener) => {\n        const listenerInfo = changeListeners.get(listener);\n        if (listenerInfo && listenerInfo.propName === propName) {\n            // Remove the specific handlers that were created for this listener\n            removeFromArray(handlers.set, listenerInfo.setHandler);\n            removeFromArray(handlers.reset, listenerInfo.resetHandler);\n            changeListeners.delete(listener);\n        }\n    };\n    return {\n        state,\n        get,\n        set,\n        on,\n        onChange,\n        use,\n        dispose,\n        reset,\n        forceUpdate,\n        removeListener,\n    };\n};\nconst removeFromArray = (array, item) => {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array[index] = array[array.length - 1];\n        array.length--;\n    }\n};\n\nconst createStore = (defaultState, shouldUpdate) => {\n    const map = createObservableMap(defaultState, shouldUpdate);\n    map.use(stencilSubscription());\n    return map;\n};\n\nexport { createObservableMap, createStore };\n","/**\n * Debug Utility\n * ==============\n *\n * Environment-aware logging utility for the grid-builder library. Provides conditional\n * logging that only outputs in development mode, keeping production console clean.\n *\n * ## Problem\n *\n * Development logging is helpful for debugging but pollutes production console:\n * - Performance tracking logs on every drag/resize\n * - Build timestamp logs on initialization\n * - State change debug messages\n * - Verbose interaction tracking\n *\n * ## Solution\n *\n * Centralized debug utility that checks environment before logging:\n * - Development: Full logging for debugging\n * - Production: Silent (no console pollution)\n * - Test: Configurable via `ENABLE_TEST_LOGS` flag\n *\n * ## Usage\n *\n * ```typescript\n * import { debug } from '../utils/debug';\n *\n * // Replace console.log with debug.log\n * debug.log('Component mounted', { itemId, canvasId });\n *\n * // Still use console.warn/error for actual issues\n * console.warn('Invalid configuration:', config);\n * ```\n *\n * ## Environment Detection\n *\n * **How it works**:\n * - Checks `process.env.NODE_ENV` at runtime\n * - StencilJS sets NODE_ENV during build\n * - Development builds: NODE_ENV = 'development'\n * - Production builds: NODE_ENV = 'production'\n * - Test builds: NODE_ENV = 'test'\n *\n * **Build-time optimization**:\n * - Production: debug.log() calls are no-ops (dead code elimination)\n * - Tree-shaking removes unused debug code\n * - Zero runtime overhead in production\n * @module debug\n */\n\n/**\n * Check if debug logging is enabled\n *\n * **Enabled when**:\n * - NODE_ENV === 'development'\n * - NODE_ENV === 'test' AND ENABLE_TEST_LOGS === true\n *\n * **Disabled when**:\n * - NODE_ENV === 'production'\n * - NODE_ENV === 'test' AND ENABLE_TEST_LOGS !== true\n * @returns true if debug logging should be enabled\n */\nfunction isDebugEnabled(): boolean {\n  // Check if we're in development mode\n  if (\n    typeof process !== \"undefined\" &&\n    process.env &&\n    process.env.NODE_ENV === \"development\"\n  ) {\n    return true;\n  }\n\n  // Allow test logs if explicitly enabled\n  if (\n    typeof process !== \"undefined\" &&\n    process.env &&\n    process.env.NODE_ENV === \"test\"\n  ) {\n    return process.env.ENABLE_TEST_LOGS === \"true\";\n  }\n\n  // Disable in production\n  return false;\n}\n\n/**\n * Debug logger instance\n *\n * Provides console.log-compatible methods that only log in development mode.\n * All methods are no-ops in production, allowing tree-shaking to remove them.\n */\nexport const debug = {\n  /**\n   * Log informational message\n   *\n   * **Use for**: General debugging, state changes, lifecycle events\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.log output\n   * @param args - Arguments to pass to console.log\n   * @example\n   * ```typescript\n   * debug.log('Item added:', item);\n   * debug.log('Grid size:', gridSize, 'for canvas:', canvasId);\n   * ```\n   */\n  log(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.log(...args);\n    }\n  },\n\n  /**\n   * Log warning message\n   *\n   * **Use for**: Recoverable issues, deprecation warnings, suspicious state\n   *\n   * **Note**: Consider using console.warn directly for warnings that should\n   * always be visible (even in production)\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.warn output\n   * @param args - Arguments to pass to console.warn\n   * @example\n   * ```typescript\n   * debug.warn('Deprecated API usage:', methodName);\n   * ```\n   */\n  warn(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.warn(...args);\n    }\n  },\n\n  /**\n   * Log error message\n   *\n   * **Use for**: Non-critical errors, caught exceptions, debugging errors\n   *\n   * **Note**: Use console.error directly for critical errors that should\n   * always be visible (even in production)\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.error output\n   * @param args - Arguments to pass to console.error\n   * @example\n   * ```typescript\n   * debug.error('Failed to initialize drag handler:', error);\n   * ```\n   */\n  error(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.error(...args);\n    }\n  },\n\n  /**\n   * Log grouped messages\n   *\n   * **Use for**: Complex debug output, nested data structures\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.group/groupEnd output\n   * @param label - Group label\n   * @param fn - Function to execute within group\n   * @example\n   * ```typescript\n   * debug.group('Drag operation', () => {\n   *   debug.log('Start position:', startPos);\n   *   debug.log('End position:', endPos);\n   *   debug.log('Delta:', delta);\n   * });\n   * ```\n   */\n  group(label: string, fn: () => void): void {\n    if (isDebugEnabled()) {\n      console.group(label);\n      fn();\n      console.groupEnd();\n    }\n  },\n\n  /**\n   * Check if debug mode is enabled\n   *\n   * **Use for**: Expensive debug operations that should be skipped in production\n   * @returns true if debug logging is enabled\n   * @example\n   * ```typescript\n   * if (debug.isEnabled()) {\n   *   // Expensive operation only in development\n   *   const stats = calculateDetailedStats();\n   *   debug.log('Stats:', stats);\n   * }\n   * ```\n   */\n  isEnabled(): boolean {\n    return isDebugEnabled();\n  },\n};\n\n/**\n * Create a namespaced debug logger\n *\n * **Use for**: Module-specific logging with consistent prefixes\n * @param namespace - Namespace for log messages (e.g., 'drag-handler', 'grid-calculations')\n * @returns Debug logger with namespace prefix\n * @example\n * ```typescript\n * // In drag-handler.ts\n * const debug = createDebugLogger('drag-handler');\n * debug.log('Drag started'); // → [drag-handler] Drag started\n * ```\n */\nexport function createDebugLogger(namespace: string) {\n  return {\n    log(...args: any[]): void {\n      debug.log(`[${namespace}]`, ...args);\n    },\n    warn(...args: any[]): void {\n      debug.warn(`[${namespace}]`, ...args);\n    },\n    error(...args: any[]): void {\n      debug.error(`[${namespace}]`, ...args);\n    },\n    group(label: string, fn: () => void): void {\n      debug.group(`[${namespace}] ${label}`, fn);\n    },\n    isEnabled(): boolean {\n      return debug.isEnabled();\n    },\n  };\n}\n","/**\n * Input Validation Utilities\n * ===========================\n *\n * Validates grid item data structure and bounds to prevent corrupt state.\n * Used for defensive programming in state-manager operations.\n *\n * ## Design Philosophy\n *\n * **Non-blocking validation**:\n * - All validation functions return results with warnings\n * - State operations proceed even if validation fails\n * - Warnings logged via debug utility (dev-only, tree-shaken in production)\n *\n * **What validation protects against**:\n * - State corruption (invalid layouts causing render errors)\n * - Layout integrity violations (out-of-bounds positions)\n * - Data persistence issues (malformed items in export)\n * - Undo/redo stack corruption (invalid snapshots)\n *\n * **What validation does NOT protect against**:\n * - XSS attacks (handled by API documentation in ComponentDefinition)\n * - Authentication/authorization (not library's responsibility)\n * - Network attacks (library is client-side only)\n *\n * ## Validation Rules\n *\n * **Desktop Layout**:\n * - x ≥ 0 (left boundary)\n * - y ≥ 0 (top boundary)\n * - width: 1-50 units (2%-100% of canvas)\n * - height: 1-100 units (20px-2000px typically)\n *\n * **Mobile Layout**:\n * - Same bounds as desktop if values present\n * - May be auto-generated (customized: false)\n *\n * **Item Properties**:\n * - id: non-empty string\n * - canvasId: non-empty string\n * - type: non-empty string\n * - zIndex: finite number\n * @module validation\n */\n\n/**\n * Validation result with success flag and error messages\n */\nexport interface ValidationResult {\n  /** True if validation passed, false if any errors */\n  valid: boolean;\n\n  /** Array of validation error messages */\n  errors: string[];\n}\n\n/**\n * Grid layout bounds configuration\n */\nconst LAYOUT_BOUNDS = {\n  x: { min: 0, max: Infinity },\n  y: { min: 0, max: Infinity },\n  width: { min: 1, max: 50 }, // 50 units = 100% canvas width\n  height: { min: 1, max: 100 }, // Reasonable maximum height\n};\n\n/**\n * Validate a single layout object (desktop or mobile)\n *\n * **Checks**:\n * - All required properties present (x, y, width, height)\n * - All values are finite numbers\n * - Values within valid bounds\n * @param layout - Layout object to validate\n * @param layoutType - 'desktop' or 'mobile' (for error messages)\n * @returns ValidationResult with errors if any\n */\nexport function validateLayout(\n  layout: any,\n  layoutType: string,\n): ValidationResult {\n  const errors: string[] = [];\n\n  // Check required properties\n  if (!layout) {\n    errors.push(`${layoutType} layout is missing or undefined`);\n    return { valid: false, errors };\n  }\n\n  // Check numeric properties\n  const numericProps = [\"x\", \"y\", \"width\", \"height\"];\n  for (const prop of numericProps) {\n    if (typeof layout[prop] !== \"number\" || !Number.isFinite(layout[prop])) {\n      errors.push(\n        `${layoutType} layout.${prop} must be a finite number, got: ${layout[prop]}`,\n      );\n    }\n  }\n\n  // Check bounds\n  if (Number.isFinite(layout.x) && layout.x < LAYOUT_BOUNDS.x.min) {\n    errors.push(\n      `${layoutType} layout.x must be >= ${LAYOUT_BOUNDS.x.min}, got: ${layout.x}`,\n    );\n  }\n\n  if (Number.isFinite(layout.y) && layout.y < LAYOUT_BOUNDS.y.min) {\n    errors.push(\n      `${layoutType} layout.y must be >= ${LAYOUT_BOUNDS.y.min}, got: ${layout.y}`,\n    );\n  }\n\n  if (\n    Number.isFinite(layout.width) &&\n    (layout.width < LAYOUT_BOUNDS.width.min ||\n      layout.width > LAYOUT_BOUNDS.width.max)\n  ) {\n    errors.push(\n      `${layoutType} layout.width must be between ${LAYOUT_BOUNDS.width.min}-${LAYOUT_BOUNDS.width.max}, got: ${layout.width}`,\n    );\n  }\n\n  if (\n    Number.isFinite(layout.height) &&\n    (layout.height < LAYOUT_BOUNDS.height.min ||\n      layout.height > LAYOUT_BOUNDS.height.max)\n  ) {\n    errors.push(\n      `${layoutType} layout.height must be between ${LAYOUT_BOUNDS.height.min}-${LAYOUT_BOUNDS.height.max}, got: ${layout.height}`,\n    );\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Validate a complete grid item structure\n *\n * **Checks**:\n * - Required properties: id, canvasId, type, zIndex, layouts\n * - String properties are non-empty\n * - zIndex is finite number\n * - Desktop layout is valid\n * - Mobile layout is valid (if present)\n *\n * **Usage**:\n * ```typescript\n * const result = validateGridItem(item);\n * if (!result.valid) {\n * debug.warn('Invalid item:', { itemId: item.id, errors: result.errors });\n * }\n * ```\n * @param item - Grid item to validate\n * @returns ValidationResult with errors if any\n */\nexport function validateGridItem(item: any): ValidationResult {\n  const errors: string[] = [];\n\n  // Check required properties exist\n  if (!item) {\n    errors.push(\"Item is null or undefined\");\n    return { valid: false, errors };\n  }\n\n  // Validate id\n  if (typeof item.id !== \"string\" || item.id.trim() === \"\") {\n    errors.push(`Item.id must be a non-empty string, got: ${item.id}`);\n  }\n\n  // Validate canvasId\n  if (typeof item.canvasId !== \"string\" || item.canvasId.trim() === \"\") {\n    errors.push(\n      `Item.canvasId must be a non-empty string, got: ${item.canvasId}`,\n    );\n  }\n\n  // Validate type\n  if (typeof item.type !== \"string\" || item.type.trim() === \"\") {\n    errors.push(`Item.type must be a non-empty string, got: ${item.type}`);\n  }\n\n  // Validate zIndex\n  if (typeof item.zIndex !== \"number\" || !Number.isFinite(item.zIndex)) {\n    errors.push(\n      `Item.zIndex must be a finite number, got: ${item.zIndex} (type: ${typeof item.zIndex})`,\n    );\n  }\n\n  // Validate layouts object\n  if (!item.layouts || typeof item.layouts !== \"object\") {\n    errors.push(\"Item.layouts must be an object\");\n    return { valid: false, errors };\n  }\n\n  // Validate desktop layout (required)\n  const desktopResult = validateLayout(item.layouts.desktop, \"desktop\");\n  if (!desktopResult.valid) {\n    errors.push(...desktopResult.errors);\n  }\n\n  // Validate mobile layout (optional, but if present must be valid)\n  if (item.layouts.mobile) {\n    const mobileResult = validateLayout(item.layouts.mobile, \"mobile\");\n    if (!mobileResult.valid) {\n      errors.push(...mobileResult.errors);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Validate item update object (partial updates)\n *\n * **Checks**:\n * - If layout updates present, validate layout structure\n * - If zIndex update present, validate it's a finite number\n * - If config update present, validate it's an object\n *\n * **Usage**:\n * ```typescript\n * const result = validateItemUpdates(updates);\n * if (!result.valid) {\n * debug.warn('Invalid updates:', { itemId, errors: result.errors });\n * }\n * ```\n * @param updates - Partial item updates to validate\n * @returns ValidationResult with errors if any\n */\nexport function validateItemUpdates(updates: any): ValidationResult {\n  const errors: string[] = [];\n\n  if (!updates || typeof updates !== \"object\") {\n    errors.push(\"Updates must be an object\");\n    return { valid: false, errors };\n  }\n\n  // Validate layouts if present\n  if (updates.layouts) {\n    if (typeof updates.layouts !== \"object\") {\n      errors.push(\"Updates.layouts must be an object\");\n    } else {\n      // Validate desktop layout if present\n      if (updates.layouts.desktop) {\n        const desktopResult = validateLayout(\n          updates.layouts.desktop,\n          \"desktop\",\n        );\n        if (!desktopResult.valid) {\n          errors.push(...desktopResult.errors);\n        }\n      }\n\n      // Validate mobile layout if present\n      if (updates.layouts.mobile) {\n        const mobileResult = validateLayout(updates.layouts.mobile, \"mobile\");\n        if (!mobileResult.valid) {\n          errors.push(...mobileResult.errors);\n        }\n      }\n    }\n  }\n\n  // Validate zIndex if present\n  if (\n    \"zIndex\" in updates &&\n    (typeof updates.zIndex !== \"number\" || !Number.isFinite(updates.zIndex))\n  ) {\n    errors.push(\n      `Updates.zIndex must be a finite number, got: ${updates.zIndex}`,\n    );\n  }\n\n  // Validate config if present (must be object, but any shape is allowed)\n  if (\"config\" in updates && typeof updates.config !== \"object\") {\n    errors.push(\n      `Updates.config must be an object, got: ${typeof updates.config}`,\n    );\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Undo/Redo Service\n * ==================\n *\n * Command pattern implementation for undo/redo functionality in the grid builder.\n * Provides stack-based history management with keyboard shortcuts and UI state tracking.\n *\n * ## Problem\n *\n * Interactive applications need undo/redo capabilities for:\n * - Recovering from mistakes (accidental delete)\n * - Experimenting with layouts (try different arrangements)\n * - Learning the interface (undo to see what changed)\n * - Building confidence (knowing you can undo)\n *\n * **Without undo/redo**:\n * - Users hesitant to experiment\n * - Mistakes are permanent\n * - No way to review history\n * - Poor user experience\n *\n * ## Solution\n *\n * Implement **Command Pattern** with stack-based history:\n *\n * 1. **Command Interface**: Each undoable action implements undo() and redo()\n * 2. **History Stack**: Array of command objects\n * 3. **Position Pointer**: Tracks current position in history\n * 4. **Bounded History**: Limited to 50 commands to prevent memory bloat\n * 5. **Branching**: New actions after undo discard \"future\" history\n *\n * ## Architecture: Command Pattern\n *\n * **Classic Gang of Four pattern** for undo/redo:\n *\n * **Key Components**:\n * - **Command Interface**: Defines undo() and redo() methods\n * - **Concrete Commands**: AddItemCommand, DeleteItemCommand, MoveItemCommand, ResizeCommand\n * - **Invoker**: undo-redo.ts (this file) manages command execution\n * - **Receiver**: state-manager.ts (receives state mutations)\n *\n * **Flow**:\n * ```\n * User Action → Create Command → pushCommand() → Execute & Store\n * Undo (Ctrl+Z) → Get command at position → command.undo() → Update position\n * Redo (Ctrl+Y) → Advance position → command.redo() → Execute\n * ```\n *\n * **Why Command Pattern**:\n * - ✅ Encapsulates actions as objects\n * - ✅ Enables undo/redo without coupling to specific operations\n * - ✅ Supports macro commands (batch operations)\n * - ✅ Easy to extend with new command types\n * - ✅ History can be serialized/persisted\n *\n * ## History Management\n *\n * **Stack-based with position pointer**:\n * ```\n * commandHistory = [cmd1, cmd2, cmd3, cmd4, cmd5]\n * ↑\n * historyPosition = 2\n * ```\n *\n * **Operations**:\n * - **Push new command**: Discard commands after position, append new command\n * - **Undo**: Execute command.undo() at position, decrement position\n * - **Redo**: Increment position, execute command.redo() at new position\n *\n * **Branching behavior** (discarding future on new action):\n * ```\n * Initial:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n * ↑ position = 2\n *\n * Undo 2x:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n * ↑ position = 0\n *\n * New cmd:  [cmd1, cmd6]  ← cmd2-cmd5 discarded!\n * ↑ position = 1\n * ```\n *\n * **Why branching (not tree)**:\n * - Simpler mental model for users\n * - No UI complexity for branch navigation\n * - Standard undo/redo UX pattern\n *\n * ## Memory Management\n *\n * **Bounded history** (MAX_HISTORY = 50):\n * - Prevents unbounded memory growth\n * - Removes oldest command when limit reached\n * - 50 commands ≈ typical user session\n *\n * **Memory per command**:\n * - Command object: ~200-500 bytes\n * - State snapshots: ~1-5 KB (JSON serialized GridItem)\n * - Total for 50 commands: ~50-250 KB (acceptable)\n *\n * **Sliding window approach**:\n * ```\n * When history full:\n * [cmd1, cmd2, ..., cmd50]  ← At capacity\n * Push cmd51:\n * [cmd2, cmd3, ..., cmd51]  ← cmd1 removed\n * ```\n *\n * ## State Snapshot Strategy\n *\n * Each command stores **before/after snapshots**:\n * ```typescript\n * class MoveItemCommand implements Command {\n * beforeState = JSON.parse(JSON.stringify(item));  // Deep clone\n * afterState = JSON.parse(JSON.stringify(updatedItem));\n *\n * undo() { restoreState(beforeState); }\n * redo() { restoreState(afterState); }\n * }\n * ```\n *\n * **Deep cloning required because**:\n * - Prevents mutations from affecting snapshots\n * - Ensures independent state copies\n * - Simple and reliable (no reference tracking needed)\n *\n * **Trade-off**:\n * - ✅ Simple implementation\n * - ✅ No reference bugs\n * - ❌ Higher memory usage than delta-based\n * - ❌ Slower than structural sharing (acceptable for this use case)\n *\n * ## Keyboard Shortcuts\n *\n * Implemented in grid-builder-app.tsx:\n * - **Ctrl+Z** (Cmd+Z on Mac): Undo last command\n * - **Ctrl+Y** (Cmd+Y on Mac): Redo next command\n * - **Ctrl+Shift+Z**: Alternative redo (common in design tools)\n *\n * ## UI Integration\n *\n * **Reactive state for buttons**:\n * ```typescript\n * undoRedoState = {\n * canUndo: boolean,  // Enable/disable undo button\n * canRedo: boolean   // Enable/disable redo button\n * }\n * ```\n *\n * **Updates on**:\n * - New command pushed\n * - Undo executed\n * - Redo executed\n * - History cleared\n *\n * **Button rendering**:\n * ```tsx\n * <button disabled={!undoRedoState.canUndo} onClick={undo}>\n * Undo\n * </button>\n * ```\n *\n * ## Extracting This Pattern\n *\n * To adapt Command pattern for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * interface Command {\n * undo(): void;\n * redo(): void;\n * }\n *\n * class UndoRedoManager {\n * private history: Command[] = [];\n * private position = -1;\n *\n * push(command: Command) {\n * this.history.splice(this.position + 1);  // Discard future\n * this.history.push(command);\n * this.position++;\n * }\n *\n * undo() {\n * if (this.position >= 0) {\n * this.history[this.position].undo();\n * this.position--;\n * }\n * }\n *\n * redo() {\n * if (this.position < this.history.length - 1) {\n * this.position++;\n * this.history[this.position].redo();\n * }\n * }\n * }\n * ```\n *\n * **Example commands**:\n * ```typescript\n * class AddItemCommand implements Command {\n * constructor(\n * private canvasId: string,\n * private item: GridItem\n * ) {}\n *\n * undo() { removeItemFromCanvas(this.canvasId, this.item.id); }\n * redo() { addItemToCanvas(this.canvasId, this.item); }\n * }\n * ```\n *\n * **For different frameworks**:\n * - React: Use useReducer or Zustand middleware\n * - Vue: Use Pinia plugin or custom composable\n * - Angular: Use NgRx effects or service\n * @module undo-redo\n */\n\nimport { createStore } from \"@stencil/store\";\nimport { createDebugLogger } from \"../utils/debug\";\n\nconst debug = createDebugLogger(\"undo-redo\");\n\n/**\n * Command Interface\n * =================\n *\n * Core abstraction for undoable operations. All commands must implement\n * both undo() and redo() methods to reverse and reapply their effects.\n *\n * **Design principle**: Commands are **self-contained** - they store all\n * data needed to both undo and redo without external dependencies.\n *\n * **Typical implementation**:\n * ```typescript\n * class MyCommand implements Command {\n * private beforeState: any;\n * private afterState: any;\n *\n * constructor(initialState) {\n * this.beforeState = JSON.parse(JSON.stringify(initialState));\n * // ... perform operation ...\n * this.afterState = JSON.parse(JSON.stringify(finalState));\n * }\n *\n * undo() { restoreState(this.beforeState); }\n * redo() { restoreState(this.afterState); }\n * }\n * ```\n *\n * **Why separate undo/redo methods**:\n * - ❌ Not: Single execute(reverse: boolean) method\n * - ✅ Yes: Separate undo() and redo() methods\n * - Reason: Clearer intent, easier to implement, matches user mental model\n *\n * **Concrete implementations**:\n * - AddItemCommand: Add/remove grid item\n * - DeleteItemCommand: Remove/restore grid item with index preservation\n * - MoveItemCommand: Update item position (cross-canvas support)\n * - ResizeCommand: Update item dimensions\n * @example\n * ```typescript\n * class DeleteItemCommand implements Command {\n *   constructor(\n *     private canvasId: string,\n *     private item: GridItem,\n *     private itemIndex: number\n *   ) {}\n *\n *   undo() {\n *     // Restore item at original index\n *     const canvas = gridState.canvases[this.canvasId];\n *     canvas.items.splice(this.itemIndex, 0, this.item);\n *     gridState.canvases = { ...gridState.canvases };\n *   }\n *\n *   redo() {\n *     // Remove item again\n *     removeItemFromCanvas(this.canvasId, this.item.id);\n *   }\n * }\n * ```\n */\nexport interface Command {\n  /**\n   * Reverse the effect of this command\n   *\n   * **Idempotent**: Calling undo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  undo(): void;\n\n  /**\n   * Reapply the effect of this command\n   *\n   * **Idempotent**: Calling redo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  redo(): void;\n\n  /**\n   * Get a description of this command (string or structured object)\n   *\n   * **Purpose**: Display in undo/redo UI, debugging, logging\n   * **Format**: Can be a string or object with action details (coordinates, dimensions, etc.)\n   * **Examples**:\n   * - String: \"Move item to x=5, y=3\"\n   * - Object: { action: 'move', position: { x: 5, y: 3 }, size: { width: 10, height: 6 } }\n   */\n  getDescription(): string | object;\n}\n\n/**\n * Undo/Redo State\n * ================\n *\n * Reactive state for UI button enable/disable logic.\n * Components subscribe to this state to update undo/redo button states.\n *\n * **Why reactive**:\n * - Automatic button state updates (no manual DOM manipulation)\n * - Components re-render when canUndo/canRedo changes\n * - Declarative UI logic\n *\n * **Usage in components**:\n * ```tsx\n * import { undoRedoState } from './undo-redo';\n *\n * render() {\n *   return (\n *     <div>\n *       <button\n *         disabled={!undoRedoState.canUndo}\n *         onClick={() => undo()}>\n *         Undo\n *       </button>\n *       <button\n *         disabled={!undoRedoState.canRedo}\n *         onClick={() => redo()}>\n *         Redo\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n */\nexport interface UndoRedoState {\n  /** Whether undo operation is available (historyPosition >= 0) */\n  canUndo: boolean;\n\n  /** Whether redo operation is available (historyPosition < commandHistory.length - 1) */\n  canRedo: boolean;\n}\n\n/**\n * Maximum number of commands in history\n *\n * **Why 50**: Balance between:\n * - ✅ Enough for typical user session\n * - ✅ Reasonable memory usage (~50-250 KB)\n * - ❌ Not unlimited (prevents memory bloat)\n *\n * **Behavior when exceeded**: Oldest command removed (sliding window)\n */\nconst MAX_HISTORY = 50;\n\n/**\n * UndoRedoManager Class\n * =====================\n *\n * Instance-based undo/redo management for grid builder.\n * Each grid-builder component can create its own UndoRedoManager instance.\n *\n * ## Architecture\n *\n * **Before (Singleton)**:\n * - Single global history shared by all grid-builder instances\n * - Multiple instances pollute each other's history\n * - Storybook stories contaminate each other\n *\n * **After (Instance-based)**:\n * - Each grid-builder creates its own UndoRedoManager\n * - Isolated history per instance\n * - Multiple grid-builders on same page work independently\n *\n * ## Usage\n *\n * **New code (instance-based)**:\n * ```typescript\n * // In grid-builder component\n * componentWillLoad() {\n *   this.undoRedoManager = new UndoRedoManager();\n *   this.undoRedoState = this.undoRedoManager.state;\n * }\n * ```\n *\n * **Legacy code (backward compatible)**:\n * ```typescript\n * // Still works via singleton export\n * import { undoRedo } from './services/undo-redo';\n * undoRedo.push(new AddItemCommand(...));\n * ```\n *\n * ## Instance State\n *\n * Each instance has:\n * - Independent reactive state (StencilJS store)\n * - Own command history stack\n * - Own history position pointer\n * - Own lifecycle (dispose() cleanup)\n */\nexport class UndoRedoManager {\n  /**\n   * Reactive state for button enable/disable\n   *\n   * **Access pattern**:\n   * ```typescript\n   * const canUndoNow = undoRedoManager.state.canUndo;\n   * ```\n   *\n   * **Updates**: Automatically triggered after each operation\n   */\n  public state: UndoRedoState;\n\n  /**\n   * Cleanup subscriptions (called on component unmount)\n   *\n   * **Usage**:\n   * ```typescript\n   * disconnectedCallback() {\n   *   this.undoRedoManager.dispose();\n   * }\n   * ```\n   */\n  public dispose: () => void;\n\n  /**\n   * Command history stack\n   *\n   * **Structure**: Array of Command objects in chronological order\n   * **Growth**: Appends new commands to end\n   * **Bounded**: Limited to MAX_HISTORY commands (50)\n   * **Branching**: Discards commands after current position on new push\n   */\n  private commandHistory: Command[] = [];\n\n  /**\n   * Current position in command history\n   *\n   * **Range**: -1 (empty history) to commandHistory.length - 1\n   * **Meaning**:\n   * - -1: No commands or all undone\n   * - 0: First command is current state\n   * - N: Command at index N is current state\n   */\n  private historyPosition: number = -1;\n\n  /**\n   * Create new UndoRedoManager instance\n   * @example\n   * ```typescript\n   * // Empty history (default)\n   * const manager = new UndoRedoManager();\n   * ```\n   */\n  constructor() {\n    // Create StencilJS reactive store\n    const { state, dispose } = createStore<UndoRedoState>({\n      canUndo: false,\n      canRedo: false,\n    });\n\n    this.state = state;\n    this.dispose = dispose;\n  }\n\n  /**\n   * Update reactive state for undo/redo button enablement\n   *\n   * **Called after**:\n   * - push() - New command added\n   * - undo() - Position moved backward\n   * - redo() - Position moved forward\n   * - clearHistory() - History reset\n   *\n   * **Updates**:\n   * - `canUndo`: true if historyPosition >= 0 (commands available to undo)\n   * - `canRedo`: true if historyPosition < commandHistory.length - 1 (commands available to redo)\n   */\n  private updateButtonStates(): void {\n    this.state.canUndo = this.historyPosition >= 0;\n    this.state.canRedo = this.historyPosition < this.commandHistory.length - 1;\n  }\n\n  /**\n   * Push a new command to the history stack\n   *\n   * **Use cases**:\n   * - After drag operation completes\n   * - After resize operation completes\n   * - After adding new item\n   * - After deleting item\n   *\n   * **Branching behavior** (discards future):\n   * ```\n   * Before: [cmd1, cmd2, cmd3, cmd4]\n   * ↑ position = 1 (undid twice)\n   *\n   * Push cmd5: [cmd1, cmd2, cmd5]\n   * ↑ position = 2\n   *\n   * Note: cmd3 and cmd4 discarded!\n   * ```\n   *\n   * **Why discard future**:\n   * - Matches user mental model (new action erases \"undone\" history)\n   * - Simpler implementation than tree-based history\n   * - Standard undo/redo UX pattern\n   *\n   * **Memory management**:\n   * - If history exceeds MAX_HISTORY (50), oldest command removed\n   * - Position adjusted to maintain integrity\n   *\n   * **Operation sequence**:\n   * 1. Discard commands after current position (splice)\n   * 2. Append new command to history\n   * 3. If over limit, remove oldest (shift)\n   * 4. Update position pointer\n   * 5. Update button states (triggers UI)\n   *\n   * **Typical usage**:\n   * ```typescript\n   * // After drag end\n   * const command = new MoveItemCommand(item, oldPos, newPos);\n   * pushCommand(command);\n   * ```\n   *\n   * **Important**: Command should be fully constructed (with snapshots taken)\n   * before being pushed. This function does NOT execute the command - it's\n   * assumed the operation already happened.\n   * @param command - Fully constructed command with before/after snapshots\n   * @example\n   * ```typescript\n   * // Delete item example\n   * handleDelete(itemId: string, canvasId: string) {\n   *   const item = getItem(canvasId, itemId);\n   *   const index = gridState.canvases[canvasId].items.indexOf(item);\n   *\n   *   // Perform the delete\n   *   removeItemFromCanvas(canvasId, itemId);\n   *\n   *   // Push command for undo (AFTER operation)\n   *   const command = new DeleteItemCommand(canvasId, item, index);\n   *   pushCommand(command);\n   * }\n   * ```\n   * @param command - Fully constructed command with before/after snapshots\n   */\n  push(command: Command): void {\n    debug.log(\n      \"➕ PUSH: Adding command to history:\",\n      (command as any).description || command,\n    );\n\n    // Remove any commands after current position\n    this.commandHistory.splice(this.historyPosition + 1);\n\n    // Add new command\n    this.commandHistory.push(command);\n\n    // Limit history size\n    if (this.commandHistory.length > MAX_HISTORY) {\n      this.commandHistory.shift();\n    } else {\n      this.historyPosition++;\n    }\n\n    debug.log(\n      \"  History position now:\",\n      this.historyPosition,\n      \", Total commands:\",\n      this.commandHistory.length,\n    );\n\n    // Update button states\n    this.updateButtonStates();\n  }\n\n  /**\n   * Undo the last command in history\n   *\n   * **Triggered by**:\n   * - Ctrl+Z / Cmd+Z keyboard shortcut\n   * - Undo button click\n   * - Programmatic undo (rare)\n   *\n   * **Operation sequence**:\n   * 1. Check if undo available (historyPosition >= 0)\n   * 2. Get command at current position\n   * 3. Execute command.undo() (reverses operation)\n   * 4. Decrement position pointer\n   * 5. Update button states (triggers UI)\n   *\n   * **Side effects**:\n   * - Mutates global state (via command.undo())\n   * - Triggers component re-renders\n   * - Updates undo/redo button states\n   * - May deselect items (depending on command)\n   *\n   * **Position before/after**:\n   * ```\n   * Before: [cmd1, cmd2, cmd3]\n   * ↑ position = 2\n   *\n   * After:  [cmd1, cmd2, cmd3]\n   * ↑ position = 1\n   * ```\n   *\n   * **Safety**: No-op if historyPosition < 0 (nothing to undo)\n   *\n   * **Multiple undo**: Can be called repeatedly to undo multiple commands\n   * @returns Command description object or string, or undefined if nothing to undo\n   * @example\n   * ```typescript\n   * // Keyboard shortcut handler\n   * window.addEventListener('keydown', (e) => {\n   *   if ((e.ctrlKey || e.metaKey) && e.key === 'z') {\n   *     const description = undo();\n   *     console.log('Undid:', description);\n   *     e.preventDefault();\n   *   }\n   * });\n   * ```\n   */\n  undo(): string | object | undefined {\n    if (this.historyPosition < 0) {\n      return undefined;\n    }\n\n    const command = this.commandHistory[this.historyPosition];\n    debug.log(\n      \"🔙 UNDO: Executing command at position\",\n      this.historyPosition,\n      \":\",\n      command,\n    );\n    debug.log(\"  Command description:\", (command as any).description);\n    const description = command.getDescription();\n    command.undo();\n    this.historyPosition--;\n    debug.log(\"  New position after undo:\", this.historyPosition);\n\n    this.updateButtonStates();\n    return description;\n  }\n\n  /**\n   * Redo the next command in history\n   *\n   * **Triggered by**:\n   * - Ctrl+Y / Cmd+Y keyboard shortcut\n   * - Ctrl+Shift+Z / Cmd+Shift+Z (alternative)\n   * - Redo button click\n   * - Programmatic redo (rare)\n   *\n   * **Operation sequence**:\n   * 1. Check if redo available (historyPosition < commandHistory.length - 1)\n   * 2. Increment position pointer\n   * 3. Get command at new position\n   * 4. Execute command.redo() (reapplies operation)\n   * 5. Update button states (triggers UI)\n   *\n   * **Side effects**:\n   * - Mutates global state (via command.redo())\n   * - Triggers component re-renders\n   * - Updates undo/redo button states\n   * - May select items (depending on command)\n   *\n   * **Position before/after**:\n   * ```\n   * Before: [cmd1, cmd2, cmd3]\n   * ↑ position = 1\n   *\n   * After:  [cmd1, cmd2, cmd3]\n   * ↑ position = 2\n   * ```\n   *\n   * **Safety**: No-op if no commands to redo (position at end)\n   *\n   * **Multiple redo**: Can be called repeatedly to redo multiple commands\n   *\n   * **Redo after new action**: Redo becomes unavailable after new command\n   * pushed (future history discarded)\n   * @returns Command description object or string, or undefined if nothing to redo\n   * @example\n   * ```typescript\n   * // Keyboard shortcut handler\n   * window.addEventListener('keydown', (e) => {\n   *   if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\n   *     const description = redo();\n   *     console.log('Redid:', description);\n   *     e.preventDefault();\n   *   }\n   * });\n   * ```\n   */\n  redo(): string | object | undefined {\n    if (this.historyPosition >= this.commandHistory.length - 1) {\n      return undefined;\n    }\n\n    this.historyPosition++;\n    const command = this.commandHistory[this.historyPosition];\n    const description = command.getDescription();\n    command.redo();\n\n    this.updateButtonStates();\n    return description;\n  }\n\n  /**\n   * Check if undo operation is available\n   *\n   * **Use cases**:\n   * - Enabling/disabling undo button\n   * - Showing undo keyboard hint\n   * - Programmatic checks before undo\n   *\n   * **Returns true when**: historyPosition >= 0 (commands in history)\n   * **Returns false when**: historyPosition = -1 (no history or all undone)\n   *\n   * **Note**: Prefer using `undoRedoState.canUndo` in UI components\n   * for automatic reactivity. This function is for imperative checks.\n   * @returns true if undo() can be called, false otherwise\n   * @example\n   * ```typescript\n   * // Imperative check\n   * if (canUndo()) {\n   *   debug.log('Undo available');\n   *   undo();\n   * }\n   *\n   * // Prefer reactive state in UI\n   * <button disabled={!undoRedoState.canUndo}>Undo</button>\n   * ```\n   */\n  canUndo(): boolean {\n    return this.historyPosition >= 0;\n  }\n\n  /**\n   * Check if redo operation is available\n   *\n   * **Use cases**:\n   * - Enabling/disabling redo button\n   * - Showing redo keyboard hint\n   * - Programmatic checks before redo\n   *\n   * **Returns true when**: historyPosition < commandHistory.length - 1\n   * **Returns false when**: At end of history or history empty\n   *\n   * **Becomes false after**: New command pushed (future discarded)\n   *\n   * **Note**: Prefer using `undoRedoState.canRedo` in UI components\n   * for automatic reactivity. This function is for imperative checks.\n   * @returns true if redo() can be called, false otherwise\n   * @example\n   * ```typescript\n   * // Imperative check\n   * if (canRedo()) {\n   *   debug.log('Redo available');\n   *   redo();\n   * }\n   *\n   * // Prefer reactive state in UI\n   * <button disabled={!undoRedoState.canRedo}>Redo</button>\n   * ```\n   */\n  canRedo(): boolean {\n    return this.historyPosition < this.commandHistory.length - 1;\n  }\n\n  /**\n   * Clear all command history\n   *\n   * **Use cases**:\n   * - Application reset\n   * - Loading new project\n   * - Test cleanup\n   * - Memory management (rare)\n   *\n   * **Effects**:\n   * - Empties command history array\n   * - Resets position to -1\n   * - Disables both undo and redo buttons\n   * - Does NOT affect current state (only history)\n   *\n   * **Memory**: Allows garbage collection of command objects and snapshots\n   *\n   * **Cannot be undone**: This operation itself is not undoable\n   *\n   * **Safety**: Safe to call even if history already empty\n   * @example\n   * ```typescript\n   * // Reset application\n   * function resetApp() {\n   *   clearHistory();\n   *   reset(); // Reset state\n   *   debug.log('Application reset');\n   * }\n   *\n   * // Test cleanup\n   * afterEach(() => {\n   *   clearHistory();\n   * });\n   * ```\n   */\n  clearHistory(): void {\n    this.commandHistory.length = 0;\n    this.historyPosition = -1;\n    this.updateButtonStates();\n  }\n\n  /**\n   * Get undo stack size\n   *\n   * **Purpose**: Return the number of commands that can be undone\n   * **Use case**: Debugging, analytics, UI display (e.g., \"5 actions can be undone\")\n   * @returns Number of commands that can be undone\n   */\n  getUndoStackSize(): number {\n    return this.historyPosition + 1; // Position 0 = 1 command, -1 = 0 commands\n  }\n\n  /**\n   * Get redo stack size\n   *\n   * **Purpose**: Return the number of commands that can be redone\n   * **Use case**: Debugging, analytics, UI display (e.g., \"3 actions can be redone\")\n   * @returns Number of commands that can be redone\n   */\n  getRedoStackSize(): number {\n    return this.commandHistory.length - 1 - this.historyPosition;\n  }\n}\n\n/**\n * Backward Compatibility Layer\n * ==============================\n *\n * Singleton instance and helper function exports for backward compatibility.\n * Existing code can continue using these while we migrate to instance-based architecture.\n *\n */\n\n// Create singleton instance (for backward compatibility only)\nconst defaultManager = new UndoRedoManager();\n\n// Export singleton state (backward compatible)\nexport const undoRedoState = defaultManager.state;\n\n// Export singleton instance methods as standalone functions (backward compatible)\nexport const pushCommand = (command: Command) => defaultManager.push(command);\nexport const undo = (): string | object | undefined => defaultManager.undo();\nexport const redo = (): string | object | undefined => defaultManager.redo();\nexport const canUndo = () => defaultManager.canUndo();\nexport const canRedo = () => defaultManager.canRedo();\nexport const clearHistory = () => defaultManager.clearHistory();\n\n// Export object wrapper for backward compatibility (deprecated, use standalone functions)\nexport const undoRedo = {\n  push: pushCommand,\n  undo,\n  redo,\n  canUndo,\n  canRedo,\n  clearHistory,\n};\n","/**\n * Shared State Registry\n * =====================\n *\n * Singleton registry that manages shared data stores across grid-builder instances.\n * Instances with the same API key share layout data (canvases) while maintaining\n * independent view state (viewport, selection).\n *\n * ## Purpose\n *\n * Enable multi-instance scenarios where users can see the same layout rendered\n * at different viewports simultaneously (e.g., mobile/tablet/desktop side-by-side).\n * When a component is moved in one instance, all instances sharing the same API\n * key update automatically.\n *\n * ## Architecture\n *\n * **Shared per API key:**\n * - Canvas data (items, positions, layouts, z-index)\n * - Undo/redo stack (shared history across instances)\n *\n * **Independent per instance:**\n * - Current viewport (mobile, tablet, desktop)\n * - Selection state (selectedItemId, activeCanvasId)\n * - Display preferences (showGrid, breakpoints)\n *\n * ## Reference Counting\n *\n * The registry uses reference counting to automatically clean up shared stores\n * when the last instance with a given API key disconnects:\n *\n * ```typescript\n * // First instance creates shared store\n * registry.addInstance('myApiKey', 'instance-1'); // refCount = 1\n *\n * // Second instance reuses shared store\n * registry.addInstance('myApiKey', 'instance-2'); // refCount = 2\n *\n * // First instance disconnects\n * registry.removeInstance('myApiKey', 'instance-1'); // refCount = 1, store kept\n *\n * // Last instance disconnects\n * registry.removeInstance('myApiKey', 'instance-2'); // refCount = 0, store disposed\n * ```\n *\n * ## Usage Example\n *\n * ```typescript\n * // Grid-builder instance 1 (mobile view)\n * const store1 = sharedStateRegistry.getOrCreate('demo', {\n * canvases: { canvas1: { items: [], zIndexCounter: 0 } }\n * });\n * sharedStateRegistry.addInstance('demo', 'instance-1');\n *\n * // Grid-builder instance 2 (desktop view)\n * const store2 = sharedStateRegistry.getOrCreate('demo'); // Reuses store1\n * sharedStateRegistry.addInstance('demo', 'instance-2');\n *\n * // Both instances share the same canvases data\n * store1.state.canvases === store2.state.canvases // true\n * ```\n * @module shared-state-registry\n */\n\nimport { createStore } from \"@stencil/store\";\nimport { UndoRedoManager } from \"./undo-redo\";\nimport { createDebugLogger } from \"../utils/debug\";\n\nconst debug = createDebugLogger(\"shared-state-registry\");\n\n/**\n * Shared data state structure (shared across instances with same API key)\n *\n * This represents the **data model** - the actual layout configuration that\n * should be synchronized across all instances.\n */\nexport interface SharedDataState {\n  /**\n   * Canvas data (items, positions, layouts)\n   *\n   * All grid items with their positions, sizes, and responsive layouts.\n   * This is the primary data that gets shared across instances.\n   */\n  canvases: Record<string, any>;\n}\n\n/**\n * Shared store entry\n *\n * Internal registry entry containing the shared store, undo manager,\n * and reference count for a given API key.\n */\ninterface SharedStoreEntry {\n  /**\n   * Shared data store (@stencil/store instance)\n   */\n  store: {\n    state: SharedDataState;\n    onChange: (key: string, callback: Function) => () => void;\n    dispose: () => void;\n  };\n\n  /**\n   * Undo/redo manager for this API key\n   *\n   * One undo stack per API key - all instances sharing the key\n   * share the same undo/redo history.\n   */\n  undoManager: UndoRedoManager;\n\n  /**\n   * Reference count - number of instances using this shared store\n   *\n   * When refCount reaches 0, the store and undo manager are disposed.\n   */\n  refCount: number;\n\n  /**\n   * Instance IDs tracked for debugging\n   */\n  instanceIds: Set<string>;\n}\n\n/**\n * Shared State Registry Class\n * ============================\n *\n * Manages shared data stores across grid-builder instances.\n *\n * **Key Responsibilities:**\n * 1. Create and manage shared stores per API key\n * 2. Reference counting for automatic cleanup\n * 3. Provide undo/redo manager per API key\n * 4. Track instance lifecycle for debugging\n */\nclass SharedStateRegistry {\n  /**\n   * Registry map: API key → shared store entry\n   */\n  private stores: Map<string, SharedStoreEntry> = new Map();\n\n  /**\n   * Get or create shared store for given API key\n   *\n   * **First call** (new API key):\n   * - Creates new shared data store\n   * - Initializes with provided initialState (or defaults)\n   * - Creates undo/redo manager\n   * - Sets refCount = 0 (caller must call addInstance)\n   *\n   * **Subsequent calls** (existing API key):\n   * - Returns existing shared store\n   * - Ignores initialState parameter\n   * - Reuses existing undo/redo manager\n   * @param apiKey - Unique identifier for shared store\n   * @param initialState - Initial state (only used on first call)\n   * @returns Shared store entry\n   */\n  getOrCreate(\n    apiKey: string,\n    initialState?: Partial<SharedDataState>,\n  ): SharedStoreEntry {\n    if (!this.stores.has(apiKey)) {\n      debug.log(`📦 Creating new shared store for API key: ${apiKey}`);\n\n      // Create shared data store using @stencil/store\n      const { state, onChange, dispose } = createStore<SharedDataState>({\n        canvases: initialState?.canvases || {},\n      });\n\n      // Create undo/redo manager for this API key\n      const undoManager = new UndoRedoManager();\n\n      // Store entry with refCount = 0 (caller must call addInstance)\n      const entry: SharedStoreEntry = {\n        store: { state, onChange, dispose },\n        undoManager,\n        refCount: 0,\n        instanceIds: new Set(),\n      };\n\n      this.stores.set(apiKey, entry);\n\n      debug.log(`✅ Shared store created for ${apiKey}`);\n      return entry;\n    }\n\n    debug.log(`♻️ Reusing existing shared store for API key: ${apiKey}`);\n    return this.stores.get(apiKey)!;\n  }\n\n  /**\n   * Add instance to reference count\n   *\n   * **Call this when:**\n   * - Grid-builder instance initializes with this API key\n   * - Grid-viewer instance initializes with this API key\n   *\n   * **Effect:**\n   * - Increments refCount\n   * - Tracks instanceId for debugging\n   * - Prevents store disposal while instances are active\n   * @param apiKey - API key of shared store\n   * @param instanceId - Unique instance identifier\n   */\n  addInstance(apiKey: string, instanceId: string): void {\n    const entry = this.stores.get(apiKey);\n    if (!entry) {\n      console.warn(\n        `SharedStateRegistry: Attempted to add instance ${instanceId} to non-existent API key ${apiKey}`,\n      );\n      return;\n    }\n\n    entry.refCount++;\n    entry.instanceIds.add(instanceId);\n\n    debug.log(\n      `➕ Instance added to ${apiKey}: ${instanceId} (refCount: ${entry.refCount})`,\n    );\n  }\n\n  /**\n   * Remove instance from reference count\n   *\n   * **Call this when:**\n   * - Grid-builder instance disconnects (disconnectedCallback)\n   * - Grid-viewer instance disconnects\n   *\n   * **Effect:**\n   * - Decrements refCount\n   * - Removes instanceId from tracking\n   * - **Auto-disposes store when refCount reaches 0**\n   * @param apiKey - API key of shared store\n   * @param instanceId - Unique instance identifier\n   */\n  removeInstance(apiKey: string, instanceId: string): void {\n    const entry = this.stores.get(apiKey);\n    if (!entry) {\n      console.warn(\n        `SharedStateRegistry: Attempted to remove instance ${instanceId} from non-existent API key ${apiKey}`,\n      );\n      return;\n    }\n\n    entry.refCount--;\n    entry.instanceIds.delete(instanceId);\n\n    debug.log(\n      `➖ Instance removed from ${apiKey}: ${instanceId} (refCount: ${entry.refCount})`,\n    );\n\n    // Auto-cleanup when last instance disconnects\n    if (entry.refCount <= 0) {\n      debug.log(\n        `🗑️ Last instance disconnected, disposing shared store for ${apiKey}`,\n      );\n      this.dispose(apiKey);\n    }\n  }\n\n  /**\n   * Get shared store (without creating if missing)\n   *\n   * **Use case:** Check if API key already has a shared store\n   * @param apiKey - API key to look up\n   * @returns Shared store entry or undefined\n   */\n  get(apiKey: string): SharedStoreEntry | undefined {\n    return this.stores.get(apiKey);\n  }\n\n  /**\n   * Dispose shared store for given API key\n   *\n   * **Cleanup:**\n   * - Disposes @stencil/store instance\n   * - Clears undo/redo history\n   * - Removes from registry\n   *\n   * **Usually called automatically** by removeInstance when refCount = 0.\n   * Can also be called manually for explicit cleanup.\n   * @param apiKey - API key to dispose\n   */\n  dispose(apiKey: string): void {\n    const entry = this.stores.get(apiKey);\n    if (!entry) {\n      return;\n    }\n\n    debug.log(`🗑️ Disposing shared store for ${apiKey}`);\n\n    // Dispose @stencil/store\n    entry.store.dispose();\n\n    // Clear undo/redo history\n    entry.undoManager.clearHistory();\n\n    // Remove from registry\n    this.stores.delete(apiKey);\n\n    debug.log(`✅ Shared store disposed for ${apiKey}`);\n  }\n\n  /**\n   * Get debug information about all registered stores\n   *\n   * **Returns:**\n   * ```typescript\n   * {\n   * 'api-key-1': {\n   * refCount: 2,\n   * instanceIds: ['instance-1', 'instance-2'],\n   * canvasCount: 1\n   * }\n   * }\n   * ```\n   * @returns Debug info object\n   */\n  getDebugInfo(): Record<string, any> {\n    const info: Record<string, any> = {};\n\n    this.stores.forEach((entry, apiKey) => {\n      info[apiKey] = {\n        refCount: entry.refCount,\n        instanceIds: Array.from(entry.instanceIds),\n        canvasCount: Object.keys(entry.store.state.canvases).length,\n        undoStackSize: entry.undoManager.getUndoStackSize(),\n        redoStackSize: entry.undoManager.getRedoStackSize(),\n      };\n    });\n\n    return info;\n  }\n\n  /**\n   * Clear all shared stores (for testing)\n   *\n   * **Warning:** This disposes ALL shared stores regardless of refCount.\n   * Only use in test cleanup or complete app reset.\n   */\n  clear(): void {\n    debug.log(\"🧹 Clearing all shared stores\");\n\n    this.stores.forEach((_, apiKey) => {\n      this.dispose(apiKey);\n    });\n\n    this.stores.clear();\n  }\n}\n\n/**\n * Module-level singleton instance for cross-instance coordination\n *\n * **Why a singleton?**\n *\n * Unlike StateManager (instantiated per grid-builder), SharedStateRegistry\n * is intentionally a module-level singleton to enable cross-instance coordination.\n *\n * **Multi-instance scenario**:\n * ```\n * Page with 3 grid-builders:\n * ┌─────────────────┐\n * │ Instance 1      │─┐\n * │ apiKey: \"demo\"  │ │\n * └─────────────────┘ │\n *                     ├──> SharedStateRegistry (one for entire page)\n * ┌─────────────────┐ │    ├─ \"demo\" → { refCount: 2, canvases: {...} }\n * │ Instance 2      │─┤    └─ \"other\" → { refCount: 1, canvases: {...} }\n * │ apiKey: \"demo\"  │ │\n * └─────────────────┘ │\n *                     │\n * ┌─────────────────┐ │\n * │ Instance 3      │─┘\n * │ apiKey: \"other\" │\n * └─────────────────┘\n * ```\n *\n * **Why not dependency injection?**\n * - Instances 1 & 2 need to share the SAME registry for reference counting\n * - If each had their own registry, they wouldn't know about each other\n * - Module-level singleton ensures all instances coordinate through one registry\n *\n * **This is the Stencil-y pattern**: Module-level service for cross-component state,\n * similar to how @stencil/store creates module-level reactive stores.\n *\n * Export single registry instance for the entire application.\n * All grid-builder and grid-viewer instances use this shared registry.\n */\nexport const sharedStateRegistry = new SharedStateRegistry();\n","/**\n * State Manager\n * ==============\n *\n * Centralized reactive state management for the grid builder using StencilJS Store.\n * Manages grid items, canvases, layouts, selection state, and viewport configuration\n * with automatic component re-renders on state changes.\n *\n * ## Problem\n *\n * Complex interactive applications need:\n * - Centralized state accessible across all components\n * - Automatic UI updates when state changes\n * - Type-safe state mutations\n * - Undo/redo support (requires state snapshots)\n * - Desktop + mobile layout management\n * - Selection tracking across multiple canvases\n *\n * Without centralized state:\n * - Props drilling through component hierarchies\n * - Manual event subscriptions and cleanup\n * - Synchronization issues between components\n * - Difficult undo/redo implementation\n *\n * ## Solution\n *\n * Use @stencil/store for reactive state management with:\n * 1. **Single source of truth**: All state in one store\n * 2. **Automatic reactivity**: Components re-render on state changes\n * 3. **Type safety**: Full TypeScript support\n * 4. **Simple API**: Direct property access (no actions/reducers)\n * 5. **Lightweight**: ~1KB, built into StencilJS\n *\n * ## Architecture Decisions\n *\n * ### Why @stencil/store vs Redux/Zustand?\n *\n * **@stencil/store chosen because**:\n * - ✅ Native StencilJS integration (zero setup)\n * - ✅ Automatic component subscriptions (no manual connect/subscribe)\n * - ✅ Simple mutation API (direct property assignment)\n * - ✅ Tiny bundle size (~1KB)\n * - ✅ Full TypeScript support\n * - ✅ Perfect for component-scoped state\n *\n * **Redux would add**:\n * - ❌ Boilerplate (actions, reducers, dispatch)\n * - ❌ Bundle size (~15KB min)\n * - ❌ Learning curve (middleware, selectors)\n * - ❌ Manual component subscriptions\n *\n * **Zustand would work but**:\n * - ⚠️ External dependency (not StencilJS native)\n * - ⚠️ Manual subscriptions in StencilJS\n * - ⚠️ Less TypeScript integration\n *\n * ### Dual Layout System (Desktop + Mobile)\n *\n * Each grid item has TWO layout configurations:\n *\n * **Desktop Layout** (always present):\n * - Primary layout with full positioning data\n * - x, y, width, height in grid units\n * - Never null, always has values\n *\n * **Mobile Layout** (optional/auto-generated):\n * - x, y, width, height can be null\n * - `customized: false` → auto-generated from desktop layout\n * - `customized: true` → user manually positioned in mobile view\n *\n * **Why dual layouts**:\n * - Different screen sizes need different layouts\n * - Mobile can auto-adapt OR be manually customized\n * - Single item definition works across viewports\n *\n * **Auto-generation strategy**:\n * ```typescript\n * // When mobile layout is null (not customized):\n * // - Full width items (span entire mobile viewport)\n * // - Stacked vertically\n * // - Responsive heights\n *\n * // When mobile.customized = true:\n * // - Use explicit mobile.x, mobile.y, mobile.width, mobile.height\n * // - Ignore desktop layout\n * ```\n *\n * ### State Mutation Pattern\n *\n * **Immutable spread pattern** for reactivity:\n * ```typescript\n * // ❌ Wrong: Direct mutation doesn't trigger updates\n * canvas.items.push(newItem);\n *\n * // ✅ Correct: Spread triggers reactivity\n * canvas.items.push(newItem);\n * state.canvases = { ...state.canvases };\n * ```\n *\n * **Why this pattern**:\n * - StencilJS store detects reference changes\n * - Object spread creates new reference\n * - Components automatically re-render\n * - Simple and performant\n *\n * ### Z-Index Management\n *\n * **Per-canvas z-index tracking**:\n * - Each canvas has `zIndexCounter` (monotonically increasing)\n * - New items get `zIndexCounter++`\n * - Ensures unique z-index per canvas\n * - Higher z-index = rendered on top\n *\n * **Why per-canvas**:\n * - Items in different canvases don't overlap\n * - Simplifies z-index calculations\n * - Prevents z-index conflicts\n * - Independent stacking contexts\n *\n * **Bringing to front**:\n * ```typescript\n * item.zIndex = canvas.zIndexCounter++;\n * state.canvases = { ...state.canvases }; // Trigger update\n * ```\n *\n * ## State Structure\n *\n * ```typescript\n * {\n * canvases: {\n * 'canvas1': {\n * items: [GridItem, GridItem, ...],\n * zIndexCounter: 5,\n * backgroundColor: '#ffffff'\n * },\n * 'canvas2': { ... },\n * ...\n * },\n * selectedItemId: 'item-3' | null,\n * selectedCanvasId: 'canvas1' | null,\n * currentViewport: 'desktop' | 'mobile',\n * showGrid: true | false\n * }\n * ```\n *\n * ## Performance Characteristics\n *\n * **State access**: O(1) - direct property access\n * **State updates**: O(n) - spread operation copies references\n * **Component re-renders**: Only components consuming changed state\n * **Memory**: Lightweight (~1KB store + actual state data)\n *\n * **Optimization**: Immutable updates only copy top-level references,\n * not deep clones. Child objects remain same reference if unchanged.\n *\n * ## Integration with Undo/Redo\n *\n * State structure supports undo/redo via snapshots:\n * ```typescript\n * // Save snapshot\n * const snapshot = JSON.parse(JSON.stringify(state.canvases));\n *\n * // Restore snapshot\n * state.canvases = JSON.parse(JSON.stringify(snapshot));\n * ```\n *\n * Deep cloning required because:\n * - Prevents mutations from affecting history\n * - Ensures independent state snapshots\n * - Simple and reliable (no ref tracking)\n *\n * ## Extracting This Pattern\n *\n * To adapt for other frameworks:\n *\n * **React + Zustand**:\n * ```typescript\n * import create from 'zustand';\n *\n * const useStore = create<GridState>((set) => ({\n * ...initialState,\n * addItem: (canvasId, item) => set((state) => ({\n * canvases: {\n * ...state.canvases,\n * [canvasId]: {\n * ...state.canvases[canvasId],\n * items: [...state.canvases[canvasId].items, item]\n * }\n * }\n * }))\n * }));\n * ```\n *\n * **Vue + Pinia**:\n * ```typescript\n * import { defineStore } from 'pinia';\n *\n * export const useGridStore = defineStore('grid', {\n * state: () => initialState,\n * actions: {\n * addItem(canvasId, item) {\n * this.canvases[canvasId].items.push(item);\n * }\n * }\n * });\n * ```\n *\n * **Angular + NgRx**:\n * ```typescript\n * export const addItem = createAction(\n * '[Grid] Add Item',\n * props<{ canvasId: string; item: GridItem }>()\n * );\n *\n * export const gridReducer = createReducer(\n * initialState,\n * on(addItem, (state, { canvasId, item }) => ({\n * ...state,\n * canvases: {\n * ...state.canvases,\n * [canvasId]: {\n * ...state.canvases[canvasId],\n * items: [...state.canvases[canvasId].items, item]\n * }\n * }\n * }))\n * );\n * ```\n * @module state-manager\n */\n\nimport { createStore } from \"@stencil/store\";\nimport { createDebugLogger } from \"../utils/debug\";\nimport { validateGridItem, validateItemUpdates } from \"../utils/validation\";\nimport { sharedStateRegistry } from \"./shared-state-registry\";\n\n/**\n * Breakpoint & Layout Type Definitions\n * ======================================\n *\n * Multi-breakpoint responsive system supporting configurable breakpoints\n * with per-breakpoint layout modes (manual positioning, auto-stacking, inheritance).\n *\n * ## Overview\n *\n * The grid builder supports flexible responsive breakpoints beyond the default\n * desktop/mobile setup. Each breakpoint can have its own layout behavior:\n *\n * - **manual**: Items must be individually positioned (desktop-style)\n * - **stack**: Items auto-stack vertically at full-width (mobile-style)\n * - **inherit**: Inherit layout from another breakpoint\n *\n * ## Example Configurations\n *\n * **Default (backwards compatible)**:\n * ```typescript\n * {\n *   mobile: { minWidth: 0, layoutMode: 'stack' },\n *   desktop: { minWidth: 768, layoutMode: 'manual' }\n * }\n * ```\n *\n * **3-breakpoint (mobile/tablet/desktop)**:\n * ```typescript\n * {\n *   mobile: { minWidth: 0, layoutMode: 'stack' },\n *   tablet: { minWidth: 768, layoutMode: 'inherit', inheritFrom: 'desktop' },\n *   desktop: { minWidth: 1024, layoutMode: 'manual' }\n * }\n * ```\n *\n * **5-breakpoint (Bootstrap-style)**:\n * ```typescript\n * {\n *   xs: { minWidth: 0, layoutMode: 'stack' },\n *   sm: { minWidth: 576, layoutMode: 'stack' },\n *   md: { minWidth: 768, layoutMode: 'inherit', inheritFrom: 'lg' },\n *   lg: { minWidth: 992, layoutMode: 'manual' },\n *   xl: { minWidth: 1200, layoutMode: 'manual' }\n * }\n * ```\n */\n\n/**\n * Layout mode for a breakpoint\n *\n * - **manual**: Items must be individually positioned (desktop-style)\n * - **stack**: Items auto-stack vertically, full-width (mobile-style)\n * - **inherit**: Inherit layout from another breakpoint\n */\nexport type LayoutMode = \"stack\" | \"manual\" | \"inherit\";\n\n/**\n * Configuration for a single breakpoint\n *\n * **Properties**:\n * - `minWidth`: Minimum container width in pixels (mobile-first approach)\n * - `layoutMode`: How items should be laid out (default: 'manual')\n * - `inheritFrom`: Which breakpoint to inherit from (for layoutMode='inherit')\n *\n * **Example**:\n * ```typescript\n * {\n *   minWidth: 768,\n *   layoutMode: 'inherit',\n *   inheritFrom: 'desktop'\n * }\n * ```\n */\nexport interface BreakpointDefinition {\n  /** Min container width in pixels (mobile-first) */\n  minWidth: number;\n\n  /** How items should be laid out (default: 'manual') */\n  layoutMode?: LayoutMode;\n\n  /** Which breakpoint to inherit from (for layoutMode='inherit') */\n  inheritFrom?: string;\n}\n\n/**\n * Breakpoint configuration object\n *\n * Maps breakpoint names to their definitions.\n *\n * **Example**:\n * ```typescript\n * {\n *   mobile: { minWidth: 0, layoutMode: 'stack' },\n *   tablet: { minWidth: 768, layoutMode: 'inherit', inheritFrom: 'desktop' },\n *   desktop: { minWidth: 1024, layoutMode: 'manual' }\n * }\n * ```\n */\nexport interface BreakpointConfig {\n  [name: string]: BreakpointDefinition;\n}\n\n/**\n * Simplified breakpoint config (backwards compatible)\n *\n * Allows defining breakpoints as just min-width numbers:\n * ```typescript\n * { mobile: 0, desktop: 768 }\n * ```\n *\n * This is automatically normalized to full BreakpointConfig format.\n */\nexport type SimpleBreakpointConfig = {\n  [name: string]: number;\n};\n\n/**\n * Default breakpoints (backwards compatible)\n *\n * Maintains existing mobile/desktop behavior:\n * - Mobile: Auto-stacking at container width < 768px\n * - Desktop: Manual positioning at container width >= 768px\n */\nexport const DEFAULT_BREAKPOINTS: BreakpointConfig = {\n  mobile: {\n    minWidth: 0,\n    layoutMode: \"stack\",\n  },\n  desktop: {\n    minWidth: 768,\n    layoutMode: \"manual\",\n  },\n};\n\n/**\n * Normalize simple config to full config\n *\n * Converts shorthand `{ mobile: 0, desktop: 768 }` to full format:\n * ```typescript\n * {\n *   mobile: { minWidth: 0, layoutMode: 'manual' },\n *   desktop: { minWidth: 768, layoutMode: 'manual' }\n * }\n * ```\n *\n * **Usage**:\n * ```typescript\n * const config = normalizeBreakpoints(props.breakpoints || DEFAULT_BREAKPOINTS);\n * ```\n */\nexport function normalizeBreakpoints(\n  config: BreakpointConfig | SimpleBreakpointConfig,\n): BreakpointConfig {\n  const normalized: BreakpointConfig = {};\n\n  for (const [name, value] of Object.entries(config)) {\n    if (typeof value === \"number\") {\n      // Simple format: { mobile: 0, desktop: 768 }\n      normalized[name] = {\n        minWidth: value,\n        layoutMode: \"manual\",\n      };\n    } else {\n      // Full format: { mobile: { minWidth: 0, layoutMode: 'stack' } }\n      normalized[name] = value;\n    }\n  }\n\n  return normalized;\n}\n\n/**\n * Layout configuration for a single breakpoint\n *\n * **Coordinates**: All positions in grid units (not pixels)\n * **Null values**: Indicate auto-generated/inherited layout\n * **customized flag**: Determines whether to use explicit values or auto-generate\n *\n * **Example (manual layout)**:\n * ```typescript\n * {\n *   x: 5,\n *   y: 2,\n *   width: 20,\n *   height: 8,\n *   customized: true\n * }\n * ```\n *\n * **Example (auto-stack layout)**:\n * ```typescript\n * {\n *   x: 0,\n *   y: 0,  // Will be calculated from cumulative heights\n *   width: 50,  // Full width\n *   height: 8,\n *   customized: false\n * }\n * ```\n */\nexport interface LayoutConfig {\n  /** Horizontal position in grid units (or null for auto-generation) */\n  x: number | null;\n\n  /** Vertical position in grid units (or null for auto-generation) */\n  y: number | null;\n\n  /** Width in grid units (or null for auto-generation) */\n  width: number | null;\n\n  /** Height in grid units (or null for auto-generation) */\n  height: number | null;\n\n  /**\n   * Whether user manually customized this breakpoint's layout\n   *\n   * **false**: Auto-generate based on breakpoint's layoutMode\n   * - layoutMode='stack': Calculate stacked position\n   * - layoutMode='inherit': Use inheritFrom breakpoint\n   * - layoutMode='manual': Use nearest defined breakpoint\n   *\n   * **true**: Use explicit x/y/width/height values\n   * - User dragged/resized in this breakpoint\n   * - Ignore auto-generation logic\n   * - Persist custom positioning\n   */\n  customized: boolean;\n}\n\n/**\n * Grid Item Interface\n * ====================\n *\n * Core data structure representing a single component instance in the grid.\n * Each item has dual layouts (desktop + mobile) and positioning metadata.\n *\n * **Lifecycle**:\n * 1. Created when dropped from palette or added programmatically\n * 2. Updated during drag/resize operations\n * 3. Persisted in state for undo/redo\n * 4. Removed when deleted\n *\n * **Key Properties**:\n * - `id`: Unique identifier (generated via generateItemId)\n * - `canvasId`: Which canvas owns this item\n * - `type`: Component type ('header', 'text', 'button', etc.)\n * - `name`: Display name (shown in UI)\n * - `layouts`: Desktop and mobile positioning\n * - `zIndex`: Stacking order within canvas\n *\n * **Type System Integration**:\n * The `type` field determines which component renders via dynamic imports:\n * ```typescript\n * switch (item.type) {\n *   case 'header': return <component-header />;\n *   case 'text': return <component-text-block />;\n *   case 'button': return <component-button />;\n *   // ...\n * }\n * ```\n */\nexport interface GridItem {\n  /** Unique item identifier (e.g., 'item-1', 'item-2') */\n  id: string;\n\n  /** Canvas ID this item belongs to (e.g., 'canvas1', 'canvas2') */\n  canvasId: string;\n\n  /** Component type determining which component renders ('header', 'text', 'button', etc.) */\n  type: string;\n\n  /** Display name shown in UI */\n  name: string;\n\n  /**\n   * Multi-breakpoint layout system for responsive design\n   *\n   * **Dynamic breakpoints**: Supports any number of custom breakpoints\n   * - Keys match breakpoint names from BreakpointConfig\n   * - Each breakpoint has LayoutConfig (x, y, width, height, customized)\n   * - Backwards compatible with desktop/mobile\n   *\n   * **Default breakpoints** (backwards compatible):\n   * - `desktop`: Manual positioning (layoutMode='manual')\n   * - `mobile`: Auto-stacking (layoutMode='stack')\n   *\n   * **Custom breakpoints** (example):\n   * - `mobile`: Auto-stack at 0-767px\n   * - `tablet`: Inherit from desktop at 768-1023px\n   * - `desktop`: Manual positioning at 1024px+\n   *\n   * **Layout resolution**:\n   * 1. If breakpoint layout exists and `customized: true`, use it\n   * 2. If layoutMode='inherit', follow inheritFrom chain\n   * 3. Otherwise, fall back to nearest defined breakpoint by width\n   *\n   * **Auto-stacking behavior** (when layoutMode='stack' and customized=false):\n   * ```typescript\n   * // grid-item-wrapper.tsx calculates cumulative y-position:\n   * x: 0 (left edge)\n   * y: sum of previous items' heights\n   * width: 50 (full width = 100% of viewport)\n   * height: source breakpoint's height\n   * ```\n   *\n   * **Example usage (default 2-breakpoint)**:\n   * ```typescript\n   * const item: GridItem = {\n   *   id: 'item-1',\n   *   canvasId: 'canvas1',\n   *   type: 'header',\n   *   name: 'Hero Header',\n   *   layouts: {\n   *     desktop: { x: 5, y: 2, width: 20, height: 8, customized: true },\n   *     mobile: { x: 0, y: 0, width: 50, height: 8, customized: false }\n   *   },\n   *   zIndex: 1\n   * };\n   * ```\n   *\n   * **Example usage (3-breakpoint)**:\n   * ```typescript\n   * const item: GridItem = {\n   *   id: 'item-2',\n   *   canvasId: 'canvas1',\n   *   type: 'text',\n   *   name: 'Content Block',\n   *   layouts: {\n   *     desktop: { x: 10, y: 10, width: 30, height: 15, customized: true },\n   *     tablet: { x: null, y: null, width: null, height: null, customized: false }, // Inherits from desktop\n   *     mobile: { x: 0, y: 0, width: 50, height: 15, customized: false } // Auto-stacks\n   *   },\n   *   zIndex: 2\n   * };\n   * ```\n   */\n  layouts: {\n    /** Dynamic breakpoint layouts (keys match BreakpointConfig names) */\n    [breakpointName: string]: LayoutConfig;\n  };\n\n  /**\n   * Stacking order within canvas (higher = on top)\n   *\n   * **Assignment**: New items get `canvas.zIndexCounter++`\n   * **Bringing to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Per-canvas**: Z-indexes only compete within same canvas\n   */\n  zIndex: number;\n\n  /**\n   * Component configuration data\n   *\n   * **Purpose**: Store component-specific settings (text, color, etc.)\n   * **Structure**: Record<string, any> matching ComponentDefinition.configSchema\n   * **Default**: Empty object {} when component created\n   *\n   * **Example**:\n   * ```typescript\n   * // Header component config\n   * config: {\n   *   text: 'Welcome!',\n   *   level: 'H1',\n   *   color: '#000000',\n   *   alignment: 'center'\n   * }\n   * ```\n   */\n  config?: Record<string, any>;\n}\n\n/**\n * Canvas Interface\n * =================\n *\n * Represents a single canvas container (section) in the grid builder.\n * Each canvas is an independent dropzone with its own items and z-index tracking.\n *\n * **Typical usage**: Multi-section landing pages\n * - canvas1 = Hero section\n * - canvas2 = Content section\n * - canvas3 = Footer section\n *\n * **Why multiple canvases**:\n * - Logical content sections\n * - Independent z-index contexts\n * - Different background colors per section\n * - Easier content organization\n *\n * **Example**:\n * ```typescript\n * const heroCanvas: Canvas = {\n *   items: [headerItem, textItem, buttonItem, imageItem],\n *   zIndexCounter: 5, // Next item gets zIndex: 5\n *   backgroundColor: '#ffffff'\n * };\n * ```\n */\n/**\n * Canvas Interface\n * ==================\n *\n * Minimal canvas structure focused purely on item placement management.\n *\n * **Library responsibilities** (what IS in this interface):\n * - Item placement and layouts\n * - Z-index management for stacking\n *\n * **Host app responsibilities** (what is NOT in this interface):\n * - Canvas styling (backgroundColor, themes, etc.)\n * - Canvas metadata (title, description, etc.)\n * - Presentation concerns (how canvases look)\n *\n * **Why this separation**:\n * - Different apps have different styling needs\n * - Library focuses on layout, not presentation\n * - Host app owns the complete data model\n * - Enables library to be used in any context\n *\n * **Host app pattern**:\n * ```typescript\n * // Host app maintains its own canvas metadata\n * const canvasMetadata = {\n *   'canvas1': { title: 'Hero Section', backgroundColor: '#f0f4f8', ... },\n *   'canvas2': { title: 'Footer', backgroundColor: '#e8f0f2', ... }\n * };\n *\n * // Library only knows about item placement\n * const gridState = {\n *   canvases: {\n *     'canvas1': { items: [...], zIndexCounter: 5 },\n *     'canvas2': { items: [...], zIndexCounter: 3 }\n *   }\n * };\n * ```\n */\nexport interface Canvas {\n  /**\n   * Array of grid items in this canvas\n   *\n   * **Rendering**: Items render in DOM order, styled with z-index for stacking\n   * **Mutation**: Always use spread pattern to trigger reactivity\n   */\n  items: GridItem[];\n\n  /**\n   * Monotonically increasing counter for z-index assignment\n   *\n   * **New items**: `item.zIndex = canvas.zIndexCounter++`\n   * **Bring to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Never decreases**: Only increments to prevent conflicts\n   */\n  zIndexCounter: number;\n}\n\n/**\n * Grid State Interface\n * =====================\n *\n * Root state structure for entire grid builder application.\n * Manages all canvases, selection state, and viewport configuration.\n *\n * **Single source of truth**: All app state in this one object\n * **Reactivity**: Changes trigger automatic component re-renders\n * **Persistence**: Can be serialized to JSON for save/export\n *\n * **Access pattern**:\n * ```typescript\n * import { gridState } from './state-manager';\n *\n * // Read state\n * const items = gridState.canvases['canvas1'].items;\n *\n * // Mutate state (triggers reactivity)\n * gridState.selectedItemId = 'item-5';\n * gridState.canvases = { ...gridState.canvases }; // After mutations\n * ```\n */\nexport interface GridState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': Canvas, 'canvas2': Canvas, ... }`\n   * **Access**: `gridState.canvases['canvas1']`\n   * **Dynamic canvases**: Can add/remove canvases at runtime\n   */\n  canvases: Record<string, Canvas>;\n\n  /**\n   * Currently selected item ID or null if no selection\n   *\n   * **Selection flow**:\n   * 1. User clicks item → `selectItem(itemId, canvasId)`\n   * 2. State updates → `selectedItemId = 'item-3'`\n   * 3. Components re-render with visual selection indicators\n   *\n   * **Deselection**: Click canvas background → `deselectItem()` → `null`\n   */\n  selectedItemId: string | null;\n\n  /**\n   * Canvas ID containing currently selected item\n   *\n   * **Why needed**: Item IDs are unique across canvases, but need canvas\n   * for operations like delete, move, etc.\n   *\n   * **Always paired**: When `selectedItemId` is set, `selectedCanvasId` must be set\n   */\n  selectedCanvasId: string | null;\n\n  /**\n   * Currently active/focused canvas ID or null if none active\n   *\n   * **Selection flow**:\n   * 1. User interacts with canvas (click, drag, resize) → `setActiveCanvas(canvasId)`\n   * 2. State updates → `activeCanvasId = 'canvas1'`\n   * 3. Canvas section component receives isActive prop\n   * 4. Visual feedback applied (title opacity, border, etc.)\n   *\n   * **Activation triggers**:\n   * - Clicking item on canvas\n   * - Clicking canvas background\n   * - Starting drag operation on item\n   * - Starting resize operation on item\n   *\n   * **Use cases**:\n   * - Highlight which section user is working on\n   * - Show canvas-specific settings panel\n   * - Provide visual context in multi-section layouts\n   *\n   * **Difference from selectedCanvasId**:\n   * - `selectedCanvasId`: Canvas containing selected **item** (editing focus)\n   * - `activeCanvasId`: Canvas that is **active** for interaction (section focus)\n   */\n  activeCanvasId: string | null;\n\n  /**\n   * Current viewport/breakpoint name\n   *\n   * **Dynamic**: Matches one of the breakpoint names from `breakpoints` config\n   * **Automatic**: Determined by ResizeObserver based on container width\n   * **Examples**: 'mobile', 'tablet', 'desktop', 'xs', 'sm', 'md', 'lg', 'xl'\n   *\n   * **Affects**:\n   * - Which layout is rendered for each item\n   * - Auto-stacking behavior (if layoutMode='stack')\n   * - Layout inheritance (if layoutMode='inherit')\n   *\n   * **Resolution**:\n   * Container width is compared against breakpoint minWidth values:\n   * - Width >= 1024px → 'desktop' (with default config)\n   * - Width >= 768px && < 1024px → 'tablet' (with 3-breakpoint config)\n   * - Width < 768px → 'mobile'\n   *\n   * **Backwards compatible**: Defaults to 'desktop' or 'mobile' with DEFAULT_BREAKPOINTS\n   */\n  currentViewport: string;\n\n  /**\n   * Whether to show grid lines on canvases\n   *\n   * **Visual aid**: Helps users align items to grid\n   * **Toggle**: User clicks grid visibility button\n   * **Rendering**: CSS background-image with grid pattern\n   */\n  showGrid: boolean;\n\n  /**\n   * Breakpoint configuration for responsive layouts\n   *\n   * **Purpose**: Defines all available breakpoints and their behavior\n   * **Source**: Set from component prop or defaults to DEFAULT_BREAKPOINTS\n   * **Normalized**: Always in full BreakpointConfig format (not SimpleBreakpointConfig)\n   *\n   * **Default** (backwards compatible):\n   * ```typescript\n   * {\n   *   mobile: { minWidth: 0, layoutMode: 'stack' },\n   *   desktop: { minWidth: 768, layoutMode: 'manual' }\n   * }\n   * ```\n   *\n   * **Per-instance**: Each grid-builder/grid-viewer can have different breakpoints\n   * **Reactive**: Changes trigger re-render and viewport recalculation\n   */\n  breakpoints: BreakpointConfig;\n}\n\n/**\n * Viewer-Only State Interfaces\n * ==============================\n *\n * Minimal state types for grid-viewer component (rendering-only mode).\n * These are subsets of the full editing state, excluding editing-specific properties.\n *\n * ## Separation of Concerns\n *\n * **Builder App** (grid-builder):\n * - Full GridState with selection, z-index tracking, etc.\n * - Includes interact.js for drag-and-drop (~45KB)\n * - Bundle size: ~150KB\n *\n * **Viewer App** (grid-viewer):\n * - Minimal ViewerState without editing features\n * - No interact.js dependency\n * - Bundle size: ~30KB (80% reduction)\n *\n * ## Export/Import Workflow\n *\n * ```typescript\n * // Builder App → Export layout\n * const builder = document.querySelector('grid-builder');\n * const exportData = await builder.exportState();\n * await fetch('/api/layouts', {\n *   method: 'POST',\n *   body: JSON.stringify(exportData)\n * });\n *\n * // Viewer App → Import layout\n * const layout = await fetch('/api/layouts/123').then(r => r.json());\n * const viewer = document.querySelector('grid-viewer');\n * viewer.initialState = layout;\n * ```\n *\n * ## What's Excluded from Viewer\n *\n * **Canvas.zIndexCounter** - Editing-only state:\n * - Tracks next z-index for new items\n * - Not needed in viewer (items already have zIndex)\n * - Viewer reads item.zIndex directly\n *\n * **GridState.selectedItemId/selectedCanvasId** - Editing-only state:\n * - Tracks which item is selected for editing\n * - Not needed in viewer (no selection UI)\n * - Viewer only renders, never selects\n *\n * **GridState.showGrid** - Editing-only state:\n * - Visual aid for aligning items during editing\n * - Not needed in viewer (no editing)\n * - Viewer renders clean output without grid lines\n *\n * ## Type Compatibility\n *\n * ViewerState is intentionally compatible with GridExport format:\n * ```typescript\n * // GridExport can be used as ViewerState\n * const exportData: GridExport = await builder.exportState();\n * viewer.initialState = exportData; // Type-safe!\n * ```\n */\n\n/**\n * Viewer Canvas Interface\n * ========================\n *\n * Minimal canvas structure for viewer mode (rendering-only).\n * Excludes editing-specific properties like zIndexCounter.\n *\n * **Differences from Canvas**:\n * - ✅ items: Array of ViewerItem (same as GridItem)\n * - ❌ zIndexCounter: Not needed (items already have zIndex)\n *\n * **Use in viewer**:\n * ```typescript\n * const canvas: ViewerCanvas = {\n *   items: [\n *     { id: 'item-1', type: 'header', zIndex: 1, ... },\n *     { id: 'item-2', type: 'text', zIndex: 2, ... }\n *   ]\n * };\n *\n * // Render items in z-index order\n * const sortedItems = canvas.items.sort((a, b) => a.zIndex - b.zIndex);\n * ```\n */\nexport interface ViewerCanvas {\n  /** Grid items in this canvas (rendering-only, no editing state) */\n  items: GridItem[]; // Reuse GridItem - it's already clean and serializable\n}\n\n/**\n * Viewer State Interface\n * =======================\n *\n * Minimal state structure for grid-viewer component (rendering-only mode).\n * Subset of GridState excluding all editing-specific properties.\n *\n * **Differences from GridState**:\n * - ✅ canvases: Record<string, ViewerCanvas>\n * - ✅ currentViewport: 'desktop' | 'mobile'\n * - ❌ selectedItemId: Not needed (no selection in viewer)\n * - ❌ selectedCanvasId: Not needed (no selection in viewer)\n * - ❌ showGrid: Not needed (no grid lines in viewer)\n *\n * **Why minimal state**:\n * - Smaller bundle size (no editing logic)\n * - Simpler component tree (no interact.js)\n * - Faster initialization (no drag/drop setup)\n * - Clean separation of concerns\n *\n * **Use in viewer**:\n * ```typescript\n * // Initialize viewer from exported layout\n * const viewerState: ViewerState = {\n *   canvases: {\n *     'hero-section': {\n *       items: [\n *         {\n *           id: 'header-1',\n *           canvasId: 'hero-section',\n *           type: 'header',\n *           name: 'Hero Header',\n *           layouts: {\n *             desktop: { x: 0, y: 0, width: 50, height: 6 },\n *             mobile: { x: null, y: null, width: null, height: null, customized: false }\n *           },\n *           zIndex: 1,\n *           config: { title: 'Welcome!' }\n *         }\n *       ]\n *     }\n *   },\n *   currentViewport: 'desktop'\n * };\n * ```\n *\n * **Type-safe import from GridExport**:\n * ```typescript\n * import { GridExport } from '../types/grid-export';\n *\n * function convertExportToViewerState(exportData: GridExport): ViewerState {\n *   return {\n *     canvases: exportData.canvases,\n *     currentViewport: exportData.viewport\n *   };\n * }\n * ```\n */\nexport interface ViewerState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': ViewerCanvas, 'canvas2': ViewerCanvas, ... }`\n   * **Rendering**: Each canvas section renders its items in z-index order\n   * **Responsive**: Switches between desktop/mobile layouts based on currentViewport\n   */\n  canvases: Record<string, ViewerCanvas>;\n\n  /**\n   * Current viewport/breakpoint name\n   *\n   * **Dynamic**: Matches one of the breakpoint names from `breakpoints` config\n   * **Examples**: 'mobile', 'tablet', 'desktop', 'xs', 'sm', 'md', 'lg', 'xl'\n   *\n   * **Affects**:\n   * - Which layout is rendered for each item (item.layouts[currentViewport])\n   * - Responsive layout calculations\n   * - Canvas width and item positioning\n   *\n   * **Auto-switching**: Can use ResizeObserver for container-based switching\n   * **Manual override**: Can be set via props or API\n   */\n  currentViewport: string;\n\n  /**\n   * Selected item ID (editing-only, always null in viewer mode)\n   *\n   * **Purpose**: Allows grid-item-wrapper to access this field without defensive guards\n   * **Value**: Always null in viewer mode (no selection support)\n   * **Builder mode**: This field is actively used for selection tracking\n   */\n  selectedItemId: string | null;\n\n  /**\n   * Selected canvas ID (editing-only, always null in viewer mode)\n   *\n   * **Purpose**: Allows grid-item-wrapper to access this field without defensive guards\n   * **Value**: Always null in viewer mode (no selection support)\n   * **Builder mode**: This field is actively used for selection tracking\n   */\n  selectedCanvasId: string | null;\n\n  /**\n   * Active canvas ID (editing-only, always null in viewer mode)\n   *\n   * **Purpose**: Allows grid-item-wrapper to access this field without defensive guards\n   * **Value**: Always null in viewer mode (no active canvas concept)\n   * **Builder mode**: This field tracks which canvas is currently focused for editing\n   */\n  activeCanvasId: string | null;\n\n  /**\n   * Breakpoint configuration (instance-specific for multi-breakpoint demos)\n   *\n   * **Purpose**: Each grid-builder instance can have different breakpoint configs\n   * **Source**: Set from component prop or defaults to DEFAULT_BREAKPOINTS\n   *\n   * **Example**:\n   * - Demo 1 uses 3 breakpoints (mobile/tablet/desktop)\n   * - Demo 2 uses 5 breakpoints (xs/sm/md/lg/xl)\n   */\n  breakpoints: BreakpointConfig;\n}\n\n/**\n * Instance View State Interface\n * ===============================\n *\n * Instance-specific view state (per grid-builder instance).\n * This is the state that should NOT be shared across instances with the same API key.\n *\n * ## Split State Architecture\n *\n * When multiple instances share the same API key, they share **data state** but\n * maintain independent **view state**:\n *\n * **Shared Data State** (SharedDataState):\n * - `canvases` - All grid items, positions, layouts, z-index\n * - Stored in SharedStateRegistry, one per API key\n * - Changes propagate to all instances sharing the same key\n *\n * **Instance View State** (InstanceViewState):\n * - `currentViewport` - Current breakpoint display (mobile, tablet, desktop)\n * - `selectedItemId`, `selectedCanvasId`, `activeCanvasId` - Selection state\n * - `showGrid`, `breakpoints` - Display preferences\n * - Unique per grid-builder instance\n * - Changes only affect the specific instance\n *\n * ## Use Case: Multi-Viewport Demo\n *\n * Three grid-builder instances showing same layout at different viewports:\n *\n * ```typescript\n * // All share API key 'multiViewportDemo'\n * <grid-builder apiRef={{ key: 'multiViewportDemo' }} style=\"width: 375px\" />  // Mobile\n * <grid-builder apiRef={{ key: 'multiViewportDemo' }} style=\"width: 768px\" />  // Tablet\n * <grid-builder apiRef={{ key: 'multiViewportDemo' }} style=\"width: 1200px\" /> // Desktop\n *\n * // Shared state: All three show same items/positions (canvases)\n * // Instance state: Each has different currentViewport based on container width\n * // Result: Move item in desktop → all three instances update, each displaying at their viewport\n * ```\n *\n * ## Why Split State?\n *\n * **Problem with full state sharing**:\n * When instances share all state including `currentViewport`, they fight over the value:\n * - Mobile (375px) sets `currentViewport = 'mobile'`\n * - Tablet (768px) sets `currentViewport = 'tablet'`\n * - Desktop (1200px) sets `currentViewport = 'desktop'`\n * - Last one to update wins → all instances render at that viewport ❌\n *\n * **Solution with split state**:\n * Each instance has its own `currentViewport` that responds to its container width:\n * - Mobile instance always shows 'mobile' viewport\n * - Tablet instance always shows 'tablet' viewport\n * - Desktop instance always shows 'desktop' viewport\n * - All share the same `canvases` data ✅\n */\nexport interface InstanceViewState {\n  /**\n   * Current viewport/breakpoint name for this instance\n   *\n   * **Instance-specific**: Each grid-builder has its own viewport\n   * **Container-based**: Automatically updated by ResizeObserver watching container width\n   * **Examples**: 'mobile', 'tablet', 'desktop', 'xs', 'sm', 'md', 'lg', 'xl'\n   *\n   * **Affects**:\n   * - Which layout is rendered for each item (item.layouts[currentViewport])\n   * - Auto-stacking behavior (if layoutMode='stack')\n   * - Layout inheritance resolution (if layoutMode='inherit')\n   */\n  currentViewport: string;\n\n  /**\n   * Currently selected item ID (editing UI state)\n   *\n   * **Instance-specific**: Selection is per grid-builder instance\n   * **Use cases**:\n   * - Highlight selected item with border/shadow\n   * - Show config panel for selected item\n   * - Enable delete/duplicate actions\n   *\n   * **Deselection**: Set to null when clicking canvas background\n   */\n  selectedItemId: string | null;\n\n  /**\n   * Canvas containing selected item (editing UI state)\n   *\n   * **Instance-specific**: Each instance tracks its own selection\n   * **Paired with**: selectedItemId (both set together or both null)\n   */\n  selectedCanvasId: string | null;\n\n  /**\n   * Currently active/focused canvas (editing UI state)\n   *\n   * **Instance-specific**: Each instance has its own active canvas\n   * **Use cases**:\n   * - Visual feedback (highlight active canvas)\n   * - Canvas-specific settings panel\n   * - Multi-section editing context\n   */\n  activeCanvasId: string | null;\n\n  /**\n   * Whether to show grid lines (display preference)\n   *\n   * **Instance-specific**: Each instance can toggle grid independently\n   * **Visual aid**: Helps align items during editing\n   * **Default**: true (grid visible)\n   */\n  showGrid: boolean;\n\n  /**\n   * Breakpoint configuration (instance-specific)\n   *\n   * **Instance-specific**: Each instance can have different breakpoint configs\n   * **Source**: Set from component prop or defaults to DEFAULT_BREAKPOINTS\n   * **Normalized**: Always in full BreakpointConfig format\n   *\n   * **Why instance-specific**:\n   * - Different demos may use different breakpoint configurations\n   * - 3-breakpoint demo uses mobile/tablet/desktop\n   * - 5-breakpoint demo uses xs/sm/md/lg/xl\n   * - Each instance needs its own config for proper viewport detection\n   */\n  breakpoints: BreakpointConfig;\n}\n\n/**\n * Initial State Configuration\n * ============================\n *\n * Default empty state for new StateManager instances.\n * Library starts with NO canvases by default.\n *\n * **Why completely empty**:\n * - Prevents state pollution between instances\n * - Ensures each grid-builder instance starts fresh\n * - Avoids \"Unknown component type\" errors\n * - Each instance builds its own canvas structure\n */\nconst defaultInitialState: GridState = {\n  canvases: {},\n  selectedItemId: null,\n  selectedCanvasId: null,\n  activeCanvasId: null,\n  currentViewport: \"desktop\",\n  showGrid: true,\n  breakpoints: DEFAULT_BREAKPOINTS,\n};\n\n/**\n * Debug logger for validation warnings\n */\nconst debug = createDebugLogger(\"state-manager\");\n\n/**\n * StateManager Class\n * ==================\n *\n * Instance-based state management for grid builder.\n * Each grid-builder component can create its own StateManager instance.\n *\n * ## Architecture\n *\n * **Before (Singleton)**:\n * - Single global state shared by all grid-builder instances\n * - Multiple instances pollute each other's state\n * - Storybook stories contaminate each other\n *\n * **After (Instance-based)**:\n * - Each grid-builder creates its own StateManager\n * - Isolated state per instance\n * - Multiple grid-builders on same page work independently\n *\n * ## Usage\n *\n * **New code (instance-based)**:\n * ```typescript\n * // In grid-builder component\n * componentWillLoad() {\n *   this.stateManager = new StateManager();\n *   this.state = this.stateManager.state;\n * }\n * ```\n *\n * **Legacy code (backward compatible)**:\n * ```typescript\n * // Still works via singleton export\n * import { gridState } from './state-manager';\n * const items = gridState.canvases['canvas1'].items;\n * ```\n *\n * ## Instance State\n *\n * Each instance has:\n * - Independent reactive state (StencilJS store)\n * - Own item ID counter (no collision between instances)\n * - Own change listeners\n * - Own lifecycle (dispose() cleanup)\n */\nexport class StateManager {\n  /**\n   * Reactive state proxy (mutate to trigger updates)\n   *\n   * **Split state architecture**:\n   * - When apiKey provided: Merges shared data store + instance view store via Proxy\n   * - When no apiKey: Single local store (backward compatible)\n   *\n   * **Access pattern**:\n   * ```typescript\n   * const items = stateManager.state.canvases['canvas1'].items;\n   * ```\n   *\n   * **Mutation pattern**:\n   * ```typescript\n   * stateManager.state.selectedItemId = 'item-5';\n   * stateManager.state.canvases = { ...stateManager.state.canvases };\n   * ```\n   */\n  public state: GridState;\n\n  /**\n   * Subscribe to state changes\n   *\n   * **Usage**:\n   * ```typescript\n   * const unsubscribe = stateManager.onChange('canvases', (newVal, oldVal) => {\n   *   console.log('Canvases changed:', newVal);\n   * });\n   * ```\n   *\n   * **Type**: Inferred from StencilJS store (OnChangeHandler<GridState>)\n   */\n  public onChange;\n\n  /**\n   * Cleanup subscriptions (called on component unmount)\n   *\n   * **Usage**:\n   * ```typescript\n   * disconnectedCallback() {\n   *   this.stateManager.dispose();\n   * }\n   * ```\n   */\n  public dispose: () => void;\n\n  /**\n   * Item ID counter for generating unique IDs\n   *\n   * **Starts at 0**: Each instance has independent counter\n   * **Increments**: Each generateItemId() call returns next ID\n   * **Format**: 'item-N' where N is the counter value\n   */\n  private itemIdCounter: number = 0;\n\n  /**\n   * Initial state snapshot for reset()\n   *\n   * **Purpose**: Deep clone of initial state for reset functionality\n   * **Updated**: When constructor receives custom initial state\n   */\n  private initialState: GridState;\n\n  /**\n   * API key for state sharing (optional)\n   *\n   * **Purpose**: When provided, multiple instances with same key share data state\n   * **Default**: null (instance-specific state, no sharing)\n   */\n  private apiKey: string | null = null;\n\n  /**\n   * Instance ID for reference counting\n   *\n   * **Purpose**: Track this instance in SharedStateRegistry for cleanup\n   * **Generated**: Unique ID per StateManager instance\n   */\n  private instanceId: string | null = null;\n\n  /**\n   * Shared data store (when apiKey provided)\n   *\n   * **Contains**: canvases (items, positions, layouts, z-index)\n   * **Shared**: All instances with same apiKey share this store\n   * **Source**: SharedStateRegistry\n   */\n  private sharedStore: any = null;\n\n  /**\n   * Instance view store (when apiKey provided)\n   *\n   * **Contains**: currentViewport, selectedItemId, showGrid, etc.\n   * **Instance-specific**: Each instance has its own view store\n   * **Source**: Created locally per instance\n   */\n  private instanceStore: any = null;\n\n  /**\n   * Create new StateManager instance\n   *\n   * **New: Split State Architecture**\n   * @param apiKey - Optional API key for state sharing (multi-instance support)\n   * @param instanceId - Optional instance ID for reference counting\n   * @param initialState - Optional custom initial state (for import/restore)\n   * @example\n   * ```typescript\n   * // Single instance (backward compatible)\n   * const manager = new StateManager();\n   *\n   * // Multi-instance with shared state\n   * const manager1 = new StateManager('demoAPI', 'instance-1');\n   * const manager2 = new StateManager('demoAPI', 'instance-2'); // Shares data with manager1\n   *\n   * // Restore from saved state\n   * const savedState = JSON.parse(localStorage.getItem('grid-state'));\n   * const manager = new StateManager('myAPI', 'instance-1', savedState);\n   * ```\n   */\n  constructor(\n    apiKey?: string | null,\n    instanceId?: string | null,\n    initialState?: Partial<GridState>,\n  ) {\n    // Handle backward compatibility: if first param is object, it's initialState (old signature)\n    if (typeof apiKey === \"object\" && apiKey !== null) {\n      initialState = apiKey as any;\n      apiKey = null;\n      instanceId = null;\n    }\n\n    this.apiKey = apiKey || null;\n    this.instanceId =\n      instanceId ||\n      `instance-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    // Merge custom initial state with defaults\n    const fullInitialState: GridState = {\n      ...defaultInitialState,\n      ...initialState,\n    };\n\n    if (this.apiKey) {\n      // **Split state mode**: Shared data + instance view state\n      debug.log(\n        `Creating StateManager with split state (apiKey: ${this.apiKey}, instanceId: ${this.instanceId})`,\n      );\n\n      // Get or create shared data store from registry\n      const registryEntry = sharedStateRegistry.getOrCreate(this.apiKey, {\n        canvases: fullInitialState.canvases,\n      });\n      this.sharedStore = registryEntry.store;\n\n      // Register this instance for reference counting\n      sharedStateRegistry.addInstance(this.apiKey, this.instanceId);\n\n      // Create instance-specific view store\n      const {\n        state: viewState,\n        onChange: viewOnChange,\n        dispose: viewDispose,\n      } = createStore<InstanceViewState>({\n        currentViewport: fullInitialState.currentViewport,\n        selectedItemId: fullInitialState.selectedItemId,\n        selectedCanvasId: fullInitialState.selectedCanvasId,\n        activeCanvasId: fullInitialState.activeCanvasId,\n        showGrid: fullInitialState.showGrid,\n        breakpoints: fullInitialState.breakpoints,\n      });\n\n      this.instanceStore = {\n        state: viewState,\n        onChange: viewOnChange,\n        dispose: viewDispose,\n      };\n\n      // Create unified state proxy that merges both stores\n      this.state = this.createStateProxy();\n\n      // Create unified onChange handler\n      this.onChange = this.createUnifiedOnChangeHandler();\n\n      // Create unified dispose handler\n      const originalDispose = viewDispose;\n      this.dispose = () => {\n        // Dispose instance view store\n        originalDispose();\n\n        // Unregister from shared state registry\n        if (this.apiKey && this.instanceId) {\n          sharedStateRegistry.removeInstance(this.apiKey, this.instanceId);\n        }\n      };\n    } else {\n      // **Single store mode**: Backward compatible behavior\n      debug.log(\n        `Creating StateManager with single store (backward compatible mode)`,\n      );\n\n      // Create StencilJS reactive store (original behavior)\n      const { state, onChange, dispose } =\n        createStore<GridState>(fullInitialState);\n\n      this.state = state;\n      this.onChange = onChange;\n      this.dispose = dispose;\n    }\n\n    // Store initial state for reset() (deep clone to prevent mutations)\n    this.initialState = JSON.parse(JSON.stringify(fullInitialState));\n  }\n\n  /**\n   * Create state proxy that merges shared data store + instance view store\n   *\n   * **Purpose**: Provide unified GridState interface that routes reads/writes\n   * to the appropriate store (shared or instance)\n   *\n   * **Shared properties**: canvases\n   * **Instance properties**: currentViewport, selectedItemId, selectedCanvasId, activeCanvasId, showGrid, breakpoints\n   */\n  private createStateProxy(): GridState {\n    if (!this.sharedStore || !this.instanceStore) {\n      throw new Error(\"createStateProxy called without shared/instance stores\");\n    }\n\n    return new Proxy({} as GridState, {\n      get: (_target, prop) => {\n        // Shared data properties\n        if (prop === \"canvases\") {\n          return this.sharedStore.state.canvases;\n        }\n\n        // Instance view properties\n        if (\n          [\n            \"currentViewport\",\n            \"selectedItemId\",\n            \"selectedCanvasId\",\n            \"activeCanvasId\",\n            \"showGrid\",\n            \"breakpoints\",\n          ].includes(prop as string)\n        ) {\n          return this.instanceStore.state[prop];\n        }\n\n        return undefined;\n      },\n      set: (_target, prop, value) => {\n        // Shared data properties\n        if (prop === \"canvases\") {\n          this.sharedStore.state.canvases = value;\n          return true;\n        }\n\n        // Instance view properties\n        if (\n          [\n            \"currentViewport\",\n            \"selectedItemId\",\n            \"selectedCanvasId\",\n            \"activeCanvasId\",\n            \"showGrid\",\n            \"breakpoints\",\n          ].includes(prop as string)\n        ) {\n          this.instanceStore.state[prop] = value;\n          return true;\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * Create unified onChange handler that subscribes to both stores\n   *\n   * **Purpose**: Allow components to subscribe to state changes from either store\n   * using a single onChange() method\n   */\n  private createUnifiedOnChangeHandler() {\n    if (!this.sharedStore || !this.instanceStore) {\n      throw new Error(\n        \"createUnifiedOnChangeHandler called without shared/instance stores\",\n      );\n    }\n\n    return (key: string, callback: Function) => {\n      // Subscribe to shared store for 'canvases'\n      if (key === \"canvases\") {\n        return this.sharedStore.onChange(key, callback);\n      }\n\n      // Subscribe to instance store for view properties\n      if (\n        [\n          \"currentViewport\",\n          \"selectedItemId\",\n          \"selectedCanvasId\",\n          \"activeCanvasId\",\n          \"showGrid\",\n          \"breakpoints\",\n        ].includes(key)\n      ) {\n        return this.instanceStore.onChange(key, callback);\n      }\n\n      // Unknown key - no-op\n      return () => {};\n    };\n  }\n\n  /**\n   * Reset state to initial empty configuration\n   *\n   * **When to call**:\n   * - User clicks \"Reset\" button\n   * - Starting fresh\n   * - Test cleanup (afterEach hooks)\n   *\n   * **What it resets**:\n   * - Clears all items from all canvases\n   * - Resets z-index counters\n   * - Clears selection state\n   * - Resets viewport to desktop\n   * - Shows grid\n   * - Resets item ID counter to 0\n   *\n   * **Deep clone pattern**:\n   * Uses `JSON.parse(JSON.stringify())` to create independent copy\n   * of initial state. Prevents mutations from affecting initialState.\n   * @example\n   * ```typescript\n   * // Reset button handler\n   * handleReset() {\n   *   if (confirm('Reset to initial state?')) {\n   *     this.stateManager.reset();\n   *     console.log('State reset to empty');\n   *   }\n   * }\n   * ```\n   */\n  reset(): void {\n    this.itemIdCounter = 0;\n\n    // Restore initial state (deep clone to prevent mutations)\n    this.state.canvases = JSON.parse(\n      JSON.stringify(this.initialState.canvases),\n    );\n    this.state.selectedItemId = this.initialState.selectedItemId;\n    this.state.selectedCanvasId = this.initialState.selectedCanvasId;\n    this.state.activeCanvasId = this.initialState.activeCanvasId;\n    this.state.currentViewport = this.initialState.currentViewport;\n    this.state.showGrid = this.initialState.showGrid;\n  }\n\n  /**\n   * Add item to canvas\n   *\n   * **Use cases**:\n   * - Dropping component from palette\n   * - Undo delete operation\n   * - Duplicating existing item\n   * - Programmatic item creation\n   *\n   * **Reactivity pattern**:\n   * 1. Push item to canvas.items array\n   * 2. Spread canvases object to trigger update\n   * 3. Components automatically re-render\n   *\n   * **Z-index assignment**:\n   * Item should have `zIndex: canvas.zIndexCounter++` before calling.\n   * This function doesn't assign z-index automatically.\n   *\n   * **Safety**: No-op if canvas doesn't exist\n   * @param canvasId - Target canvas ID\n   * @param item - GridItem to add (should have zIndex assigned)\n   * @example\n   * ```typescript\n   * // Add new item from palette drop\n   * const newItem: GridItem = {\n   *   id: stateManager.generateItemId(),\n   *   canvasId: 'canvas1',\n   *   type: 'header',\n   *   name: 'Header',\n   *   layouts: {\n   *     desktop: { x: 5, y: 5, width: 20, height: 8 },\n   *     mobile: { x: null, y: null, width: null, height: null, customized: false }\n   *   },\n   *   zIndex: stateManager.state.canvases['canvas1'].zIndexCounter++\n   * };\n   * stateManager.addItemToCanvas('canvas1', newItem);\n   * ```\n   */\n  addItemToCanvas(canvasId: string, item: GridItem): void {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Validate item structure (dev-only, tree-shaken in production)\n    const validation = validateGridItem(item);\n    if (!validation.valid) {\n      debug.warn(\"⚠️ [addItemToCanvas] with validation issues:\", {\n        itemId: item.id,\n        canvasId,\n        errors: validation.errors,\n      });\n    }\n\n    canvas.items.push(item);\n    this.state.canvases = { ...this.state.canvases }; // Trigger update\n  }\n\n  /**\n   * Remove item from canvas\n   *\n   * **Use cases**:\n   * - User deletes item (Delete key or button)\n   * - Undo add operation\n   * - Clearing canvas\n   *\n   * **Filter pattern**:\n   * Creates new array without the item, preserving array order.\n   * Reassignment triggers reactivity.\n   *\n   * **Index preservation**:\n   * Array order maintained for z-index rendering.\n   * Other items' indexes shift down by 1.\n   *\n   * **Safety**: No-op if canvas or item doesn't exist\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to remove\n   * @example\n   * ```typescript\n   * // Delete selected item\n   * if (gridState.selectedItemId && gridState.selectedCanvasId) {\n   *   removeItemFromCanvas(\n   *     gridState.selectedCanvasId,\n   *     gridState.selectedItemId\n   *   );\n   *   deselectItem(); // Clear selection\n   * }\n   * ```\n   */\n  removeItemFromCanvas(canvasId: string, itemId: string): void {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    canvas.items = canvas.items.filter((item) => item.id !== itemId);\n    this.state.canvases = { ...this.state.canvases }; // Trigger update\n  }\n\n  /**\n   * Update item properties in canvas\n   *\n   * **Use cases**:\n   * - After drag operation (update position)\n   * - After resize operation (update dimensions)\n   * - Changing item name or type\n   * - Bringing item to front (update zIndex)\n   *\n   * **Partial updates**:\n   * Uses `Partial<GridItem>` to allow updating subset of properties.\n   * Object.assign merges updates into existing item.\n   *\n   * **Typical update patterns**:\n   * ```typescript\n   * // Update position after drag\n   * updateItem(canvasId, itemId, {\n   * layouts: { ...item.layouts, desktop: { x: 10, y: 5, width: 20, height: 8 } }\n   * });\n   *\n   * // Bring to front\n   * updateItem(canvasId, itemId, {\n   * zIndex: gridState.canvases[canvasId].zIndexCounter++\n   * });\n   * ```\n   *\n   * **Safety**: No-op if canvas or item doesn't exist\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to update\n   * @param updates - Partial GridItem with properties to update\n   * @example\n   * ```typescript\n   * // After drag end\n   * const item = getItem('canvas1', 'item-3');\n   * if (item) {\n   *   item.layouts.desktop.x = newX;\n   *   item.layouts.desktop.y = newY;\n   *   updateItem('canvas1', 'item-3', item);\n   * }\n   * ```\n   */\n  updateItem(\n    canvasId: string,\n    itemId: string,\n    updates: Partial<GridItem>,\n  ): void {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return;\n    }\n\n    // Validate updates (dev-only, tree-shaken in production)\n    const validation = validateItemUpdates(updates);\n    if (!validation.valid) {\n      debug.warn(\"⚠️ [updateItem] with validation issues:\", {\n        itemId,\n        canvasId,\n        updates,\n        errors: validation.errors,\n      });\n    }\n\n    Object.assign(item, updates);\n    this.state.canvases = { ...this.state.canvases }; // Trigger update\n  }\n\n  /**\n   * Get item by ID\n   *\n   * **Use cases**:\n   * - Reading item data before update\n   * - Validation checks\n   * - Getting item for undo/redo snapshots\n   * - Checking if item exists\n   *\n   * **Read-only**: Returns reference to item in state.\n   * To modify, use `updateItem()` to trigger reactivity.\n   *\n   * **Safety**: Returns null if canvas or item doesn't exist\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to retrieve\n   * @returns GridItem or null if not found\n   * @example\n   * ```typescript\n   * // Check item before operation\n   * const item = getItem('canvas1', 'item-3');\n   * if (item) {\n   *   console.log(`Item at (${item.layouts.desktop.x}, ${item.layouts.desktop.y})`);\n   * }\n   *\n   * // Create snapshot for undo\n   * const snapshot = JSON.parse(JSON.stringify(getItem(canvasId, itemId)));\n   * ```\n   */\n  getItem(canvasId: string, itemId: string): GridItem | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    return canvas.items.find((i) => i.id === itemId) || null;\n  }\n\n  /**\n   * Move item to different canvas\n   *\n   * **Use cases**:\n   * - Dragging item across canvas boundaries\n   * - Reorganizing multi-section layouts\n   * - Undo move operation\n   *\n   * **Operation flow**:\n   * 1. Find item in source canvas\n   * 2. Remove from source canvas items array\n   * 3. Update item's canvasId property\n   * 4. Add to destination canvas items array\n   * 5. Trigger reactivity with spread\n   *\n   * **Important**: Item keeps its existing zIndex.\n   * May want to update with destination canvas's zIndexCounter.\n   *\n   * **Position handling**:\n   * Item keeps its grid coordinates. Caller should validate/adjust\n   * position fits within destination canvas bounds.\n   *\n   * **Safety**: No-op if either canvas doesn't exist or item not found\n   * @param fromCanvasId - Source canvas ID\n   * @param toCanvasId - Destination canvas ID\n   * @param itemId - Item to move\n   * @example\n   * ```typescript\n   * // Move item on cross-canvas drag\n   * handleDragEnd(event) {\n   *   const targetCanvasId = event.dropTarget.id;\n   *   if (targetCanvasId !== item.canvasId) {\n   *     moveItemToCanvas(item.canvasId, targetCanvasId, item.id);\n   *\n   *     // Optionally update z-index for new canvas\n   *     const canvas = gridState.canvases[targetCanvasId];\n   *     updateItem(targetCanvasId, item.id, {\n   *       zIndex: canvas.zIndexCounter++\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  moveItemToCanvas(\n    fromCanvasId: string,\n    toCanvasId: string,\n    itemId: string,\n  ): void {\n    const fromCanvas = this.state.canvases[fromCanvasId];\n    const toCanvas = this.state.canvases[toCanvasId];\n\n    if (!fromCanvas || !toCanvas) {\n      return;\n    }\n\n    const item = fromCanvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return;\n    }\n\n    // Validate item before moving (dev-only, tree-shaken in production)\n    const validation = validateGridItem(item);\n    if (!validation.valid) {\n      debug.warn(\"⚠️ [moveItemToCanvas] with validation issues:\", {\n        itemId,\n        fromCanvasId,\n        toCanvasId,\n        errors: validation.errors,\n      });\n    }\n\n    // Remove from old canvas\n    fromCanvas.items = fromCanvas.items.filter((i) => i.id !== itemId);\n\n    // Update item's canvasId\n    item.canvasId = toCanvasId;\n\n    // Add to new canvas\n    toCanvas.items.push(item);\n\n    this.state.canvases = { ...this.state.canvases }; // Trigger update\n  }\n\n  /**\n   * Generate unique item ID\n   *\n   * **Use cases**:\n   * - Creating new item from palette drop\n   * - Duplicating existing item\n   * - Any programmatic item creation\n   *\n   * **Uniqueness guarantee**:\n   * Monotonically increasing counter ensures no collisions.\n   * Even after delete, IDs never reused.\n   *\n   * **Format**: Returns 'item-N' (e.g., 'item-11', 'item-12')\n   *\n   * **Thread safety**: Not thread-safe, but not an issue in\n   * single-threaded JavaScript environment.\n   * @returns Unique item ID string\n   * @example\n   * ```typescript\n   * // Create new item from palette drop\n   * const newItem: GridItem = {\n   *   id: stateManager.generateItemId(), // 'item-11'\n   *   canvasId: 'canvas1',\n   *   type: 'button',\n   *   name: 'Button',\n   *   layouts: { ... },\n   *   zIndex: stateManager.state.canvases['canvas1'].zIndexCounter++\n   * };\n   * ```\n   */\n  generateItemId(): string {\n    return `item-${++this.itemIdCounter}`;\n  }\n\n  /**\n   * Set z-index for an item\n   *\n   * **Use cases**:\n   * - Layer panel drag-to-reorder\n   * - Bring to front / send to back operations\n   * - Manual z-index adjustment\n   *\n   * **Operation flow**:\n   * 1. Find item in canvas\n   * 2. Store old z-index for undo/redo\n   * 3. Update item's zIndex property\n   * 4. Update canvas zIndexCounter if needed\n   * 5. Trigger reactivity\n   * 6. Return old/new values for undo/redo\n   *\n   * **Safety**: Returns null if canvas or item doesn't exist\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to update\n   * @param newZIndex - New z-index value\n   * @returns Object with old and new z-index, or null if not found\n   */\n  setItemZIndex(\n    canvasId: string,\n    itemId: string,\n    newZIndex: number,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    const oldZIndex = item.zIndex;\n\n    // Update z-index\n    item.zIndex = newZIndex;\n\n    // Update counter if needed (maintain monotonically increasing counter)\n    if (newZIndex >= canvas.zIndexCounter) {\n      canvas.zIndexCounter = newZIndex + 1;\n    }\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Move item forward in z-index (one layer up)\n   *\n   * **Use cases**:\n   * - Layer panel \"move up\" button\n   * - Keyboard shortcut (e.g., Ctrl+Up)\n   * - Context menu \"Bring forward\"\n   *\n   * **Operation**:\n   * Finds next higher z-index and swaps with that item.\n   * If already on top, does nothing.\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to move forward\n   * @returns Object with old and new z-index, or null if not found/already on top\n   */\n  moveItemForward(\n    canvasId: string,\n    itemId: string,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    // Find next higher z-index\n    const sortedItems = [...canvas.items].sort((a, b) => a.zIndex - b.zIndex);\n    const currentIndex = sortedItems.findIndex((i) => i.id === itemId);\n\n    // Already on top\n    if (currentIndex === sortedItems.length - 1) {\n      return null;\n    }\n\n    const nextItem = sortedItems[currentIndex + 1];\n    const oldZIndex = item.zIndex;\n    const newZIndex = nextItem.zIndex;\n\n    // Swap z-index values\n    item.zIndex = newZIndex;\n    nextItem.zIndex = oldZIndex;\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Move item backward in z-index (one layer down)\n   *\n   * **Use cases**:\n   * - Layer panel \"move down\" button\n   * - Keyboard shortcut (e.g., Ctrl+Down)\n   * - Context menu \"Send backward\"\n   *\n   * **Operation**:\n   * Finds next lower z-index and swaps with that item.\n   * If already on bottom, does nothing.\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to move backward\n   * @returns Object with old and new z-index, or null if not found/already on bottom\n   */\n  moveItemBackward(\n    canvasId: string,\n    itemId: string,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    // Find next lower z-index\n    const sortedItems = [...canvas.items].sort((a, b) => a.zIndex - b.zIndex);\n    const currentIndex = sortedItems.findIndex((i) => i.id === itemId);\n\n    // Already on bottom\n    if (currentIndex === 0) {\n      return null;\n    }\n\n    const prevItem = sortedItems[currentIndex - 1];\n    const oldZIndex = item.zIndex;\n    const newZIndex = prevItem.zIndex;\n\n    // Swap z-index values\n    item.zIndex = newZIndex;\n    prevItem.zIndex = oldZIndex;\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Bring item to front (highest z-index)\n   *\n   * **Use cases**:\n   * - Layer panel \"bring to front\" button\n   * - Context menu \"Bring to front\"\n   * - Double-click to bring to front\n   *\n   * **Operation**:\n   * Sets z-index to highest value in canvas + 1\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to bring to front\n   * @returns Object with old and new z-index, or null if not found/already on top\n   */\n  bringItemToFront(\n    canvasId: string,\n    itemId: string,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    const oldZIndex = item.zIndex;\n    const maxZIndex = Math.max(...canvas.items.map((i) => i.zIndex));\n\n    // Already on top\n    if (oldZIndex === maxZIndex) {\n      return null;\n    }\n\n    const newZIndex = canvas.zIndexCounter++;\n    item.zIndex = newZIndex;\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Send item to back (lowest z-index)\n   *\n   * **Use cases**:\n   * - Layer panel \"send to back\" button\n   * - Context menu \"Send to back\"\n   *\n   * **Operation**:\n   * Sets z-index to lowest value in canvas - 1\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to send to back\n   * @returns Object with old and new z-index, or null if not found/already on bottom\n   */\n  sendItemToBack(\n    canvasId: string,\n    itemId: string,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    const oldZIndex = item.zIndex;\n    const minZIndex = Math.min(...canvas.items.map((i) => i.zIndex));\n\n    // Already on bottom\n    if (oldZIndex === minZIndex) {\n      return null;\n    }\n\n    const newZIndex = minZIndex - 1;\n    item.zIndex = newZIndex;\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Select item and set active canvas\n   *\n   * **Use cases**:\n   * - User clicks item\n   * - After creating new item (auto-select)\n   * - Keyboard navigation\n   *\n   * **Visual effects**:\n   * - Selected item gets visual highlight (via CSS)\n   * - Resize/drag handles appear\n   * - Item can be deleted with Delete key\n   *\n   * **State changes**:\n   * - `selectedItemId` = itemId\n   * - `selectedCanvasId` = canvasId\n   * - Components re-render with selection styles\n   *\n   * **Single selection**: Selecting new item automatically deselects previous\n   * @param itemId - Item to select\n   * @param canvasId - Canvas containing the item\n   */\n  selectItem(itemId: string, canvasId: string): void {\n    this.state.selectedItemId = itemId;\n    this.state.selectedCanvasId = canvasId;\n  }\n\n  /**\n   * Deselect currently selected item\n   *\n   * **Use cases**:\n   * - User clicks canvas background\n   * - After deleting selected item\n   * - Escape key pressed\n   * - Starting drag operation\n   *\n   * **Visual effects**:\n   * - Selection highlight removed\n   * - Resize/drag handles hidden\n   * - Item no longer delete-able with Delete key\n   *\n   * **State changes**:\n   * - `selectedItemId` = null\n   * - `selectedCanvasId` = null\n   * - Components re-render without selection styles\n   *\n   * **Safety**: Safe to call even if nothing selected\n   */\n  deselectItem(): void {\n    this.state.selectedItemId = null;\n    this.state.selectedCanvasId = null;\n  }\n\n  /**\n   * Set active canvas\n   *\n   * **Use cases**:\n   * - User clicks item on canvas → activate that canvas\n   * - User clicks canvas background → activate that canvas\n   * - User starts dragging item → activate canvas containing item\n   * - User starts resizing item → activate canvas containing item\n   * - Programmatic canvas focus (e.g., after adding item)\n   *\n   * **Visual effects**:\n   * - Canvas title opacity changes (consumer-controlled CSS)\n   * - Canvas border/highlight applied\n   * - Canvas-specific settings panel shown\n   *\n   * **State changes**:\n   * - `activeCanvasId` = canvasId\n   * - Components re-render with isActive prop\n   * - 'canvasActivated' event emitted\n   *\n   * **Reactivity**: Direct assignment (no spread needed for primitive)\n   * @param canvasId - Canvas ID to activate\n   */\n  setActiveCanvas(canvasId: string): void {\n    this.state.activeCanvasId = canvasId;\n  }\n\n  /**\n   * Clear active canvas\n   *\n   * **Use cases**:\n   * - Reset application state\n   * - Close all panels\n   * - Deactivate all canvases\n   *\n   * **Visual effects**:\n   * - All canvas titles return to inactive state\n   * - No canvas highlighted\n   * - Canvas settings panel hidden\n   *\n   * **State changes**:\n   * - `activeCanvasId` = null\n   * - Components re-render without active state\n   *\n   * **Safety**: Safe to call even if no canvas active\n   */\n  clearActiveCanvas(): void {\n    this.state.activeCanvasId = null;\n  }\n\n  /**\n   * Add multiple items in a single batch\n   *\n   * **Performance benefit**: 1000 items added in ~10ms with single re-render\n   * vs ~200-500ms with 1000 individual add calls and 1000 re-renders.\n   *\n   * **Use cases**:\n   * - Stress testing (adding 100-1000 items)\n   * - Template/preset loading (page templates with many components)\n   * - Undo batch delete\n   * - Import from saved layout\n   *\n   * **Reactivity pattern**:\n   * 1. Clone canvases object\n   * 2. Add all items to cloned canvases\n   * 3. Single state assignment triggers single re-render\n   * 4. Single undo/redo command for entire batch\n   * @param items - Array of partial GridItem specs (missing id, zIndex auto-assigned)\n   * @returns Array of created item IDs\n   */\n  addItemsBatch(items: Partial<GridItem>[]): string[] {\n    const itemIds: string[] = [];\n    const updatedCanvases = { ...this.state.canvases };\n\n    for (const itemData of items) {\n      const id = this.generateItemId();\n      const canvasId = itemData.canvasId!;\n      const canvas = updatedCanvases[canvasId];\n\n      if (!canvas) {\n        console.warn(`Canvas ${canvasId} not found, skipping item`);\n        continue;\n      }\n\n      const newItem: GridItem = {\n        id,\n        canvasId,\n        type: itemData.type || \"unknown\",\n        name: itemData.name || \"Unnamed\",\n        layouts: itemData.layouts || {\n          desktop: { x: 0, y: 0, width: 20, height: 10, customized: true },\n          mobile: {\n            x: null,\n            y: null,\n            width: null,\n            height: null,\n            customized: false,\n          },\n        },\n        zIndex: canvas.zIndexCounter++,\n        config: itemData.config || {},\n      };\n\n      // Validate item before adding (dev-only, tree-shaken in production)\n      const validation = validateGridItem(newItem);\n      if (!validation.valid) {\n        debug.warn(\"⚠️ [addItemsBatch] with validation issues:\", {\n          itemId: id,\n          canvasId,\n          errors: validation.errors,\n        });\n      }\n\n      canvas.items.push(newItem);\n      itemIds.push(id);\n    }\n\n    // Single state update triggers single re-render\n    this.state.canvases = updatedCanvases;\n\n    return itemIds;\n  }\n\n  /**\n   * Delete multiple items in a single batch\n   *\n   * **Performance benefit**: 1000 items deleted in ~5ms with single re-render\n   * vs ~100-200ms with 1000 individual delete calls and 1000 re-renders.\n   *\n   * **Use cases**:\n   * - Clear canvas (delete all)\n   * - Delete selection group\n   * - Undo batch add\n   * - Cleanup operations\n   *\n   * **Reactivity pattern**:\n   * 1. Clone canvases object\n   * 2. Filter out all items from cloned canvases\n   * 3. Single state assignment triggers single re-render\n   * 4. Single undo/redo command for entire batch\n   * @param itemIds - Array of item IDs to delete\n   */\n  deleteItemsBatch(itemIds: string[]): void {\n    const itemIdSet = new Set(itemIds);\n    const updatedCanvases = { ...this.state.canvases };\n\n    // Filter out items from all canvases\n    for (const canvasId in updatedCanvases) {\n      updatedCanvases[canvasId] = {\n        ...updatedCanvases[canvasId],\n        items: updatedCanvases[canvasId].items.filter(\n          (item) => !itemIdSet.has(item.id),\n        ),\n      };\n    }\n\n    // Single state update triggers single re-render\n    this.state.canvases = updatedCanvases;\n  }\n\n  /**\n   * Update multiple item configs in a single batch\n   *\n   * **Performance benefit**: 1000 items updated in ~8ms with single re-render\n   * vs ~150-300ms with 1000 individual update calls and 1000 re-renders.\n   *\n   * **Use cases**:\n   * - Theme changes (update colors for all items)\n   * - Bulk property changes\n   * - Undo batch config change\n   * - Template application\n   *\n   * **Reactivity pattern**:\n   * 1. Clone canvases object\n   * 2. Apply all updates to cloned canvases\n   * 3. Single state assignment triggers single re-render\n   * 4. Single undo/redo command for entire batch\n   * @param updates - Array of { itemId, canvasId, updates } objects\n   */\n  updateItemsBatch(\n    updates: {\n      itemId: string;\n      canvasId: string;\n      updates: Partial<GridItem>;\n    }[],\n  ): void {\n    const updatedCanvases = { ...this.state.canvases };\n\n    for (const { itemId, canvasId, updates: itemUpdates } of updates) {\n      const canvas = updatedCanvases[canvasId];\n      if (!canvas) {\n        console.warn(`Canvas ${canvasId} not found, skipping item ${itemId}`);\n        continue;\n      }\n\n      const item = canvas.items.find((i) => i.id === itemId);\n      if (!item) {\n        console.warn(`Item ${itemId} not found in canvas ${canvasId}`);\n        continue;\n      }\n\n      Object.assign(item, itemUpdates);\n    }\n\n    // Single state update triggers single re-render\n    this.state.canvases = updatedCanvases;\n  }\n}\n\n/**\n * Backward Compatibility Layer\n * ==============================\n *\n * Singleton instance and helper function exports for backward compatibility.\n */\n\n// Create singleton instance (for backward compatibility only)\nconst defaultManager = new StateManager();\n\n// Export singleton state (backward compatible)\nexport const gridState = defaultManager.state;\nexport const state = defaultManager.state; // Alternative export name\nexport const onChange = defaultManager.onChange;\n\n// Export singleton instance methods as standalone functions (backward compatible)\nexport const reset = () => defaultManager.reset();\nexport const addItemToCanvas = (canvasId: string, item: GridItem) =>\n  defaultManager.addItemToCanvas(canvasId, item);\nexport const removeItemFromCanvas = (canvasId: string, itemId: string) =>\n  defaultManager.removeItemFromCanvas(canvasId, itemId);\nexport const updateItem = (\n  canvasId: string,\n  itemId: string,\n  updates: Partial<GridItem>,\n) => defaultManager.updateItem(canvasId, itemId, updates);\nexport const getItem = (canvasId: string, itemId: string) =>\n  defaultManager.getItem(canvasId, itemId);\nexport const moveItemToCanvas = (\n  fromCanvasId: string,\n  toCanvasId: string,\n  itemId: string,\n) => defaultManager.moveItemToCanvas(fromCanvasId, toCanvasId, itemId);\nexport const generateItemId = () => defaultManager.generateItemId();\nexport const setItemZIndex = (\n  canvasId: string,\n  itemId: string,\n  newZIndex: number,\n) => defaultManager.setItemZIndex(canvasId, itemId, newZIndex);\nexport const moveItemForward = (canvasId: string, itemId: string) =>\n  defaultManager.moveItemForward(canvasId, itemId);\nexport const moveItemBackward = (canvasId: string, itemId: string) =>\n  defaultManager.moveItemBackward(canvasId, itemId);\nexport const bringItemToFront = (canvasId: string, itemId: string) =>\n  defaultManager.bringItemToFront(canvasId, itemId);\nexport const sendItemToBack = (canvasId: string, itemId: string) =>\n  defaultManager.sendItemToBack(canvasId, itemId);\nexport const selectItem = (itemId: string, canvasId: string) =>\n  defaultManager.selectItem(itemId, canvasId);\nexport const deselectItem = () => defaultManager.deselectItem();\nexport const setActiveCanvas = (canvasId: string) =>\n  defaultManager.setActiveCanvas(canvasId);\nexport const clearActiveCanvas = () => defaultManager.clearActiveCanvas();\nexport const addItemsBatch = (items: Partial<GridItem>[]) =>\n  defaultManager.addItemsBatch(items);\nexport const deleteItemsBatch = (itemIds: string[]) =>\n  defaultManager.deleteItemsBatch(itemIds);\nexport const updateItemsBatch = (\n  updates: {\n    itemId: string;\n    canvasId: string;\n    updates: Partial<GridItem>;\n  }[],\n) => defaultManager.updateItemsBatch(updates);\n"],"names":["debug","defaultManager"],"mappings":"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","x_google_ignoreList":[2]}