{"file":"canvas-section.entry.esm.js","mappings":"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","names":["interact","gridState"],"sources":["src/components/canvas-section/canvas-section.scss?tag=canvas-section","src/components/canvas-section/canvas-section.tsx"],"sourcesContent":["@import '../../global/variables';\n\n/* Canvas Section */\n.canvas-item {\n  position: relative;\n  display: flex;\n  width: 100%;\n  flex-direction: column;\n}\n\n.canvas-item-header {\n  position: absolute;\n  z-index: 1000;\n  top: 10px;\n  right: 10px;\n  display: flex;\n  align-items: center;\n  padding: 8px 12px;\n  border-radius: 4px;\n  background: rgba(255, 255, 255, 95%);\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 10%);\n  color: #666;\n  font-size: 12px;\n  gap: 10px;\n  opacity: 0.7;\n  transition: opacity 0.2s;\n}\n\n.canvas-item:hover .canvas-item-header {\n  opacity: 1;\n}\n\n.canvas-item-header h3 {\n  margin: 0;\n  color: #999;\n  font-size: 11px;\n  letter-spacing: 0.5px;\n  text-transform: uppercase;\n}\n\n.canvas-controls {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n}\n\n.canvas-controls label {\n  display: flex;\n  align-items: center;\n  color: #999;\n  cursor: pointer;\n  font-size: 11px;\n  gap: 4px;\n}\n\n.canvas-bg-color {\n  width: 30px;\n  height: 24px;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  cursor: pointer;\n}\n\n.clear-canvas-btn,\n.delete-section-btn {\n  padding: 4px 10px;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  background: white;\n  color: #666;\n  cursor: pointer;\n  font-size: 11px;\n  transition: all 0.2s;\n}\n\n.clear-canvas-btn:hover {\n  border-color: #4a90e2;\n  background: #f5f5f5;\n  color: #4a90e2;\n}\n\n.delete-section-btn {\n  padding: 4px 8px;\n}\n\n.delete-section-btn:hover {\n  border-color: #dc3545;\n  background: #fee;\n}\n\n/* Grid Builder Container */\n.grid-builder {\n  width: 100%;\n  padding: 0;\n  border-radius: 0;\n  margin-bottom: 0;\n  background: transparent;\n}\n\n/* Grid Container */\n.grid-container {\n  position: relative;\n  width: 100%;\n  min-height: 400px;\n  background-image: linear-gradient(rgba(0, 0, 0, 5%) 1px, transparent 1px),\n    linear-gradient(90deg, rgba(0, 0, 0, 5%) 1px, transparent 1px);\n  background-size: 2% 20px;\n  transition: background-color 0.2s;\n}\n\n.grid-container.hide-grid {\n  background-image: none;\n}\n","/**\n * Canvas Section Component\n * ========================\n *\n * Individual canvas container providing drag-and-drop dropzone functionality,\n * grid background rendering, and item management for multi-section layouts.\n * Each canvas section is an independent workspace that can receive dropped\n * components and manage its own collection of grid items.\n *\n * ## Problem\n *\n * Multi-section page builders need:\n * - Independent content sections with visual boundaries\n * - Drag-and-drop target areas for adding components\n * - Visual grid alignment guides\n * - Responsive layout with auto-resize handling\n * - Section-level controls (color, clear, delete)\n * - Cross-canvas drag support\n * - Reactive updates when items change\n *\n * **Without canvases**:\n * - Single monolithic workspace\n * - No logical content separation\n * - Difficult to organize complex layouts\n * - No section-specific styling\n *\n * ## Solution\n *\n * Dedicated canvas component providing:\n * 1. **Dropzone integration**: interact.js dropzone for receiving drops\n * 2. **Grid rendering**: Visual grid background for alignment\n * 3. **Reactive state**: Auto-updates when items added/removed/changed\n * 4. **ResizeObserver**: Invalidates grid cache on container resize\n * 5. **Section controls**: Background color picker, clear, delete\n * 6. **Item rendering**: Loop through items, render grid-item-wrapper\n * 7. **Custom events**: Dispatches events to parent app for coordination\n *\n * ## Architecture: Canvas as Dropzone Container\n *\n * **Separation of concerns**:\n * - **Canvas**: Detects drops, dispatches events to app\n * - **Palette**: Creates drag preview\n * - **App**: Coordinates operations, creates grid items, manages state\n * - **Grid Item Wrapper**: Individual item rendering and interaction\n *\n * **Drop flow**:\n * ```\n * 1. Palette creates drag clone\n * 2. User drags over canvas\n * 3. Canvas dropzone detects drop\n * 4. Canvas calculates drop position (grid coordinates)\n * 5. Canvas dispatches custom event with details\n * 6. App receives event, creates GridItem, adds to state\n * 7. Canvas re-renders with new item\n * ```\n *\n * **Cross-canvas drag flow**:\n * ```\n * 1. User drags existing item from canvas A\n * 2. User drops on canvas B\n * 3. Canvas B detects drop, checks sourceCanvasId !== targetCanvasId\n * 4. Canvas B dispatches 'canvas-move' event\n * 5. App receives event, moves item between canvases\n * 6. Both canvases re-render\n * ```\n *\n * ## Dropzone Setup with interact.js\n *\n * **Configuration**:\n * ```typescript\n * interact(gridContainer).dropzone({\n *   accept: '.palette-item, .grid-item',  // Both new and existing items\n *   overlap: 'pointer',                   // Use pointer position, not element\n *   ondrop: (event) => { ... }\n * })\n * ```\n *\n * **Why pointer overlap**:\n * - More intuitive drop detection\n * - Matches user expectations (drop where cursor is)\n * - Works better with large dragged elements\n * - Consistent with design tools (Figma, Sketch)\n *\n * **Accept pattern**:\n * - `.palette-item` - New components from palette\n * - `.grid-item` - Existing items dragged between canvases\n *\n * ## Drop Event Handling\n *\n * **Two drop types**:\n *\n * ### 1. Palette Item Drop (Create New)\n * ```typescript\n * if (isPaletteItem) {\n *   const componentType = element.getAttribute('data-component-type');\n *   const x = event.dragEvent.clientX - rect.left - halfWidth;\n *   const y = event.dragEvent.clientY - rect.top - halfHeight;\n *\n *   // Dispatch 'canvas-drop' event\n *   dispatchEvent(new CustomEvent('canvas-drop', {\n *     detail: { canvasId, componentType, x, y }\n *   }));\n * }\n * ```\n *\n * **Position calculation**:\n * - Uses clientX/Y for cursor position\n * - Subtracts container offset (getBoundingClientRect)\n * - Centers item on cursor (subtract half dimensions)\n * - Result: x/y in pixels relative to canvas top-left\n *\n * ### 2. Grid Item Drop (Cross-Canvas Move)\n * ```typescript\n * if (isGridItem && sourceCanvasId !== targetCanvasId) {\n *   const droppedRect = element.getBoundingClientRect();\n *   const x = droppedRect.left - rect.left;\n *   const y = droppedRect.top - rect.top;\n *\n *   // Dispatch 'canvas-move' event\n *   dispatchEvent(new CustomEvent('canvas-move', {\n *     detail: { itemId, sourceCanvasId, targetCanvasId, x, y }\n *   }));\n * }\n * ```\n *\n * **Why different position calculation**:\n * - Grid item already positioned by drag handler\n * - Use element's current screen position\n * - Calculate relative to target canvas\n * - Preserves visual position during cross-canvas move\n *\n * ## Grid Background Rendering\n *\n * **CSS-based grid pattern**:\n * ```scss\n * .grid-container {\n *   background-size: 2% 20px;  // Responsive width, fixed height\n *   background-image:\n *     linear-gradient(to right, rgba(0,0,0,0.1) 1px, transparent 1px),\n *     linear-gradient(to bottom, rgba(0,0,0,0.1) 1px, transparent 1px);\n * }\n *\n * .grid-container.hide-grid {\n *   background-image: none;  // Toggle visibility\n * }\n * ```\n *\n * **Grid specifications**:\n * - Horizontal: 2% width per unit (50 units = 100% width)\n * - Vertical: 20px height per unit (fixed)\n * - Color: Semi-transparent black (rgba(0,0,0,0.1))\n * - Toggle: `.hide-grid` class removes background-image\n *\n * **Why CSS grid over canvas/SVG**:\n * - ‚úÖ No JavaScript overhead\n * - ‚úÖ Automatic responsive scaling (2% = relative to container)\n * - ‚úÖ No redraw on scroll/zoom\n * - ‚úÖ Simple toggle (add/remove class)\n * - ‚ùå Limited customization (vs canvas API)\n *\n * ## ResizeObserver Integration\n *\n * **Purpose**: Detect canvas container size changes and invalidate grid cache\n *\n * **Setup**:\n * ```typescript\n * this.resizeObserver = new ResizeObserver(() => {\n *   clearGridSizeCache();    // Invalidate cached grid calculations\n *   this.renderVersion++;    // Force re-render of items\n * });\n * this.resizeObserver.observe(gridContainerRef);\n * ```\n *\n * **Why needed**:\n * - Grid calculations cached for performance (grid-calculations.ts)\n * - Cache based on container width (responsive grid)\n * - Container resize ‚Üí cache invalid ‚Üí wrong positioning\n * - ResizeObserver detects resize ‚Üí clears cache ‚Üí recalculates\n *\n * **Triggers**:\n * - Browser window resize\n * - Sidebar collapse/expand\n * - DevTools open/close\n * - Zoom level change\n * - Mobile orientation change\n *\n * **Performance**:\n * - ResizeObserver fires ~1-5ms after resize\n * - clearGridSizeCache() is O(1) (just sets flag)\n * - renderVersion++ triggers efficient re-render (StencilJS diffing)\n * - Total overhead: ~2-10ms per resize event\n *\n * ## Section Numbering System\n *\n * **Props**:\n * ```typescript\n * @Prop() canvasId: string;      // 'canvas1', 'canvas2', etc.\n * @Prop() sectionNumber: number; // 1, 2, 3, etc.\n * ```\n *\n * **Why separate from canvasId**:\n * - canvasId = state management key (technical)\n * - sectionNumber = user-facing label (UX)\n * - Allows reordering sections without breaking state\n * - Clearer section headers (\"Section 1\", not \"canvas1\")\n *\n * **Example usage in parent**:\n * ```tsx\n * {Object.keys(gridState.canvases).map((canvasId, index) => (\n *   <canvas-section\n *     canvasId={canvasId}\n *     sectionNumber={index + 1}\n *   />\n * ))}\n * ```\n *\n * ## Item Rendering Loop\n *\n * **Pattern**:\n * ```tsx\n * {this.canvas?.items.map((item: GridItem) => (\n *   <grid-item-wrapper\n *     key={item.id}\n *     item={item}\n *     renderVersion={this.renderVersion}\n *   />\n * ))}\n * ```\n *\n * **Key props**:\n * - `key={item.id}` - React-style key for efficient diffing\n * - `item={item}` - Full GridItem data (position, size, type, etc.)\n * - `renderVersion={this.renderVersion}` - Force re-render trigger\n *\n * **Why renderVersion prop**:\n * - Items positioned using grid calculations (cached)\n * - Cache cleared on resize, but items don't re-render automatically\n * - Incrementing renderVersion forces grid-item-wrapper to recalculate\n * - Ensures items reposition correctly after resize\n *\n * **Optional chaining** (`.canvas?.items`):\n * - Prevents errors during component mounting\n * - Canvas state may not be loaded yet\n * - Returns empty array if canvas undefined\n *\n * ## Desktop vs Mobile Viewport Switching\n *\n * **Handled by grid-item-wrapper**:\n * - Canvas section doesn't directly handle viewport switching\n * - Renders all items with current gridState.currentViewport\n * - grid-item-wrapper reads viewport and selects correct layout\n *\n * **Why delegated to wrapper**:\n * - Each item has dual layouts (desktop/mobile)\n * - Wrapper applies correct layout based on viewport\n * - Canvas just provides container\n * - Cleaner separation of concerns\n *\n * **Canvas still responsive**:\n * - Container width affects grid calculations\n * - Grid units (2% width) scale with container\n * - Items automatically reposition via renderVersion\n *\n * ## State Subscription Pattern\n *\n * **componentWillLoad setup**:\n * ```typescript\n * onChange('canvases', () => {\n *   this.canvas = gridState.canvases[this.canvasId];\n *   this.renderVersion++;  // Force re-render\n * });\n * ```\n *\n * **Why subscribe in componentWillLoad**:\n * - Runs before first render\n * - Ensures subscription active for entire lifecycle\n * - Captures initial state before mount\n *\n * **Try/catch pattern**:\n * ```typescript\n * try {\n *   if (this.canvasId && gridState.canvases[this.canvasId]) {\n *     this.canvas = gridState.canvases[this.canvasId];\n *   }\n * } catch (error) {\n *   console.debug('Canvas section state update skipped:', error);\n * }\n * ```\n *\n * **Why needed**:\n * - Tests may mount/unmount rapidly\n * - Component may not be fully initialized\n * - Guards against accessing undefined properties\n * - Prevents test failures from timing issues\n *\n * **componentWillUpdate**:\n * - Also updates canvas reference\n * - Runs before each re-render\n * - Ensures fresh data from state\n *\n * ## Custom Event Dispatching\n *\n * **Three event types**:\n *\n * ### 1. canvas-drop (New Item)\n * ```typescript\n * new CustomEvent('canvas-drop', {\n *   detail: { canvasId, componentType, x, y },\n *   bubbles: true,    // Event bubbles to parent\n *   composed: true    // Event crosses shadow DOM\n * })\n * ```\n *\n * ### 2. canvas-move (Cross-Canvas)\n * ```typescript\n * new CustomEvent('canvas-move', {\n *   detail: { itemId, sourceCanvasId, targetCanvasId, x, y },\n *   bubbles: true,\n *   composed: true\n * })\n * ```\n *\n * ### 3. section-delete (Delete Section)\n * ```typescript\n * new CustomEvent('section-delete', {\n *   detail: { canvasId },\n *   bubbles: true,\n *   composed: true\n * })\n * ```\n *\n * **Why custom events**:\n * - Decouples canvas from app logic\n * - Canvas doesn't manage state directly\n * - App coordinates all state changes\n * - Testable (can spy on events)\n * - Standard DOM pattern\n *\n * ## Section Controls\n *\n * ### Background Color Picker\n * ```tsx\n * <input\n *   type=\"color\"\n *   value={backgroundColor}\n *   onInput={(e) => this.handleColorChange(e)}\n * />\n * ```\n *\n * **Dual update pattern**:\n * 1. Update state: `this.canvas.backgroundColor = color`\n * 2. Update DOM: `this.gridContainerRef.style.backgroundColor = color`\n *\n * **Why both**:\n * - State update triggers re-render (reactivity)\n * - DOM update provides immediate visual feedback\n * - Prevents flash of old color during re-render\n *\n * ### Clear Canvas Button\n * - Confirms before clearing (`confirm()` dialog)\n * - Clears `canvas.items` array\n * - Clears selection if on this canvas\n * - Resets container min-height\n *\n * ### Delete Section Button\n * - Confirms if section has items\n * - Dispatches 'section-delete' event\n * - App handles actual deletion (state management)\n *\n * ## Performance Characteristics\n *\n * **ResizeObserver overhead**: ~2-10ms per resize event\n * **Dropzone detection**: <1ms (pointer-based, no calculations)\n * **Re-render on state change**: ~5-20ms (depends on item count)\n * **Grid background**: 0ms (CSS-only, no JavaScript)\n * **Item rendering**: O(n) where n = number of items\n *\n * **Optimization**: Uses renderVersion prop to force re-renders\n * only when needed (resize, state change), not on every interaction.\n *\n * ## StencilJS Lifecycle\n *\n * **componentWillLoad**: Subscribe to state changes\n * - Runs before first render\n * - Sets up onChange subscription\n * - Loads initial canvas state\n *\n * **componentWillUpdate**: Update canvas reference\n * - Runs before each re-render\n * - Ensures fresh state data\n *\n * **componentDidLoad**: Initialize interactions\n * - Runs after first render (DOM available)\n * - Sets up dropzone\n * - Sets up ResizeObserver\n *\n * **disconnectedCallback**: Cleanup\n * - Runs when component removed from DOM\n * - Unsets interact.js dropzone\n * - Disconnects ResizeObserver\n * - Prevents memory leaks\n *\n * **render**: Reactive template\n * - Renders section header with controls\n * - Renders grid container with background\n * - Loops through items, renders grid-item-wrapper\n *\n * ## Extracting This Pattern\n *\n * To adapt canvas dropzone pattern for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * // 1. Setup dropzone\n * interact(container).dropzone({\n *   accept: '.draggable-item',\n *   overlap: 'pointer',\n *   ondrop: (event) => {\n *     const rect = container.getBoundingClientRect();\n *     const x = event.dragEvent.clientX - rect.left;\n *     const y = event.dragEvent.clientY - rect.top;\n *\n *     // Dispatch event to parent\n *     container.dispatchEvent(new CustomEvent('item-drop', {\n *       detail: { x, y, type: event.relatedTarget.dataset.type },\n *       bubbles: true\n *     }));\n *   }\n * });\n *\n * // 2. Setup ResizeObserver\n * new ResizeObserver(() => {\n *   clearCache();\n *   forceRerender();\n * }).observe(container);\n *\n * // 3. Render items\n * {items.map(item => (\n *   <ItemWrapper key={item.id} item={item} renderVersion={version} />\n * ))}\n * ```\n *\n * **For different frameworks**:\n * - **React**: Use useEffect for setup, useRef for container, useState for renderVersion\n * - **Vue**: Use onMounted for setup, ref() for container, reactive for renderVersion\n * - **Angular**: Use ngAfterViewInit for setup, ViewChild for container, signals for renderVersion\n *\n * **Multi-canvas layouts**:\n * ```typescript\n * // Parent component\n * {canvases.map((canvas, index) => (\n *   <CanvasSection\n *     key={canvas.id}\n *     canvasId={canvas.id}\n *     sectionNumber={index + 1}\n *     onDrop={(e) => handleDrop(e)}\n *     onMove={(e) => handleMove(e)}\n *   />\n * ))}\n * ```\n *\n * @module canvas-section\n */\n\n// External libraries (alphabetical)\nimport { Component, h, Prop, State } from '@stencil/core';\nimport interact from 'interactjs';\n\n// Internal imports (alphabetical)\nimport { Canvas, GridItem, gridState, onChange } from '../../services/state-manager';\nimport { clearGridSizeCache, gridToPixelsX, gridToPixelsY } from '../../utils/grid-calculations';\n\n/**\n * CanvasSection Component\n * =======================\n *\n * StencilJS component providing individual canvas dropzone with item management.\n *\n * **Tag**: `<canvas-section>`\n * **Shadow DOM**: Disabled (required for interact.js compatibility)\n * **Lifecycle**: Standard StencilJS (componentWillLoad ‚Üí componentDidLoad ‚Üí render ‚Üí disconnectedCallback)\n */\n@Component({\n  tag: 'canvas-section',\n  styleUrl: 'canvas-section.scss',\n  shadow: false, // Use light DOM for compatibility with interact.js\n})\nexport class CanvasSection {\n  /**\n   * Canvas ID for state management\n   *\n   * **Format**: 'canvas1', 'canvas2', etc.\n   * **Purpose**: Key for accessing canvas data in gridState.canvases\n   * **Required**: Component won't render without valid canvasId\n   */\n  @Prop() canvasId!: string;\n\n  /**\n   * Section number for UI display\n   *\n   * **Format**: 1, 2, 3, etc.\n   * **Purpose**: User-facing label (\"Section 1\", \"Section 2\")\n   * **Decoupled from canvasId**: Allows reordering without breaking state\n   */\n  @Prop() sectionNumber!: number;\n\n  /**\n   * Canvas state (reactive)\n   *\n   * **Source**: gridState.canvases[canvasId]\n   * **Updates**: componentWillLoad, componentWillUpdate, onChange subscription\n   * **Contains**: items array, zIndexCounter, backgroundColor\n   */\n  @State() canvas: Canvas;\n\n  /**\n   * Render version counter (forces re-renders)\n   *\n   * **Purpose**: Trigger re-renders when grid calculations change\n   * **Incremented on**: ResizeObserver events, state changes\n   * **Passed to**: grid-item-wrapper as prop\n   * **Why needed**: Grid calculations cached, need to recalculate on resize\n   */\n  @State() renderVersion: number = 0;\n\n  /**\n   * Grid container DOM reference\n   *\n   * **Used for**:\n   * - interact.js dropzone setup\n   * - ResizeObserver monitoring\n   * - Position calculations (getBoundingClientRect)\n   * - Direct DOM updates (backgroundColor)\n   */\n  private gridContainerRef: HTMLElement;\n\n  /**\n   * Dropzone initialization flag\n   *\n   * **Prevents**: Multiple dropzone setups on same element\n   * **Set in**: initializeDropzone()\n   * **Checked in**: initializeDropzone(), disconnectedCallback()\n   */\n  private dropzoneInitialized: boolean = false;\n\n  /**\n   * ResizeObserver instance\n   *\n   * **Monitors**: gridContainerRef size changes\n   * **Callback**: Clears grid cache, increments renderVersion\n   * **Cleanup**: disconnectedCallback() disconnects observer\n   */\n  private resizeObserver: ResizeObserver;\n\n  /**\n   * Component will load lifecycle hook\n   *\n   * **Called**: Before first render\n   * **Purpose**: Load initial canvas state and subscribe to changes\n   *\n   * **Operations**:\n   * 1. Load canvas from global state\n   * 2. Subscribe to 'canvases' state changes\n   * 3. Update local canvas state on changes\n   * 4. Increment renderVersion to trigger item re-renders\n   *\n   * **Error handling**:\n   * - Try/catch guards against rapid mount/unmount in tests\n   * - Checks canvasId and canvas existence before update\n   * - Logs debug message if update skipped\n   *\n   * **Why try/catch**:\n   * - Tests may mount components before state fully initialized\n   * - Component may be unmounting while state update fires\n   * - Prevents test failures from timing issues\n   */\n  componentWillLoad() {\n    // Initial load\n    this.canvas = gridState.canvases[this.canvasId];\n\n    // Subscribe to state changes\n    onChange('canvases', () => {\n      // Guard against accessing properties when component is not fully initialized\n      try {\n        if (this.canvasId && gridState.canvases[this.canvasId]) {\n          this.canvas = gridState.canvases[this.canvasId];\n          this.renderVersion++; // Force re-render\n        }\n      } catch (error) {\n        // Component may not be fully initialized yet (e.g., during test setup)\n        // This can happen during rapid component mounting/unmounting in tests\n        console.debug('Canvas section state update skipped:', error);\n      }\n    });\n  }\n\n  /**\n   * Component will update lifecycle hook\n   *\n   * **Called**: Before each re-render\n   * **Purpose**: Ensure canvas reference is fresh from state\n   *\n   * **Why needed**:\n   * - State may have changed since last render\n   * - Local canvas reference might be stale\n   * - Ensures render uses latest data\n   *\n   * **Complements**: onChange subscription in componentWillLoad\n   */\n  componentWillUpdate() {\n    // Update canvas reference when state changes\n    this.canvas = gridState.canvases[this.canvasId];\n  }\n\n  /**\n   * Component did load lifecycle hook\n   *\n   * **Called**: After first render (DOM available)\n   * **Purpose**: Initialize interact.js dropzone and ResizeObserver\n   *\n   * **Why after render**:\n   * - Needs gridContainerRef to be assigned (happens during render)\n   * - interact.js requires actual DOM element\n   * - ResizeObserver requires element to observe\n   *\n   * **One-time setup**:\n   * - Only runs once after mount\n   * - Handlers persist across re-renders\n   * - Cleanup in disconnectedCallback\n   */\n  componentDidLoad() {\n    this.initializeDropzone();\n    this.setupResizeObserver();\n  }\n\n  /**\n   * Disconnected callback (cleanup)\n   *\n   * **Called**: When component removed from DOM\n   * **Purpose**: Clean up interact.js and ResizeObserver\n   *\n   * **Cleanup operations**:\n   * 1. Unset interact.js dropzone if initialized\n   * 2. Disconnect ResizeObserver if created\n   *\n   * **Why important**:\n   * - Prevents memory leaks\n   * - Removes event listeners\n   * - Stops observation of removed elements\n   * - Standard web component lifecycle pattern\n   *\n   * **Safety checks**:\n   * - Verifies gridContainerRef exists before interact unset\n   * - Verifies dropzoneInitialized before interact unset\n   * - Verifies resizeObserver exists before disconnect\n   */\n  disconnectedCallback() {\n    // Cleanup interact.js\n    if (this.gridContainerRef && this.dropzoneInitialized) {\n      interact(this.gridContainerRef).unset();\n    }\n\n    // Cleanup ResizeObserver\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  }\n\n  /**\n   * Setup ResizeObserver for grid cache invalidation\n   *\n   * **Purpose**: Detect container size changes and force grid recalculation\n   *\n   * **Observer callback**:\n   * 1. Clear grid size cache (grid-calculations.ts)\n   * 2. Increment renderVersion (triggers item re-renders)\n   *\n   * **Why needed**:\n   * - Grid calculations cached for performance\n   * - Cache based on container width (responsive 2% units)\n   * - Container resize invalidates cache\n   * - Items need to recalculate positions with new dimensions\n   *\n   * **Resize triggers**:\n   * - Browser window resize\n   * - Sidebar expand/collapse\n   * - DevTools open/close\n   * - Mobile orientation change\n   * - Zoom level change\n   *\n   * **Performance impact**:\n   * - ResizeObserver: ~1-2ms per event\n   * - clearGridSizeCache(): O(1) flag set\n   * - renderVersion++: ~5-20ms re-render (varies by item count)\n   * - Total: ~7-23ms per resize (acceptable)\n   *\n   * **Safety**: Returns early if gridContainerRef not available\n   *\n   * @private\n   */\n  private setupResizeObserver = () => {\n    if (!this.gridContainerRef) {\n      return;\n    }\n\n    // Watch for canvas container size changes\n    this.resizeObserver = new ResizeObserver(() => {\n      // Clear grid size cache when container resizes\n      clearGridSizeCache();\n\n      // Force re-render to update item positions\n      this.renderVersion++;\n    });\n\n    this.resizeObserver.observe(this.gridContainerRef);\n  };\n\n  /**\n   * Render component template\n   *\n   * **Reactive**: Re-runs when canvas state or renderVersion changes\n   * **Pure**: No side effects, only returns JSX\n   *\n   * ## Template Structure\n   *\n   * **Outer container** (`.canvas-item`):\n   * - Section wrapper with canvas ID\n   * - Contains header and grid builder\n   *\n   * **Header** (`.canvas-item-header`):\n   * - Section number (h3)\n   * - Controls container:\n   *   - Color picker (background color)\n   *   - Clear button (clear all items)\n   *   - Delete button (delete section)\n   *\n   * **Grid builder** (`.grid-builder`):\n   * - Grid container (`.grid-container`):\n   *   - Dynamic class: `.hide-grid` when showGrid = false\n   *   - Background color from canvas state\n   *   - Ref assigned to gridContainerRef\n   *   - Item rendering loop\n   *\n   * ## Grid Container Classes\n   *\n   * **Dynamic class binding**:\n   * ```tsx\n   * class={{\n   *   'grid-container': true,      // Always present\n   *   'hide-grid': !showGrid       // Conditional\n   * }}\n   * ```\n   *\n   * **CSS grid visibility**:\n   * - `.grid-container`: Shows grid background\n   * - `.grid-container.hide-grid`: Hides grid background\n   * - Controlled by `gridState.showGrid` toggle\n   *\n   * ## Item Rendering Loop\n   *\n   * **Mapping pattern**:\n   * ```tsx\n   * {this.canvas?.items.map((item: GridItem) => (\n   *   <grid-item-wrapper\n   *     key={item.id}\n   *     item={item}\n   *     renderVersion={this.renderVersion}\n   *   />\n   * ))}\n   * ```\n   *\n   * **Optional chaining** (`.canvas?.items`):\n   * - Guards against undefined canvas during mounting\n   * - Returns empty array if canvas not loaded\n   * - Prevents \"Cannot read property 'items' of undefined\"\n   *\n   * **Props passed to wrapper**:\n   * - `key={item.id}`: React-style key for efficient diffing\n   * - `item={item}`: Full GridItem data\n   * - `renderVersion={this.renderVersion}`: Triggers recalculation\n   *\n   * ## Background Color Binding\n   *\n   * **Inline style**:\n   * ```tsx\n   * style={{ backgroundColor }}\n   * ```\n   *\n   * **Value source**: `this.canvas?.backgroundColor || '#ffffff'`\n   * - Reads from canvas state\n   * - Falls back to white if undefined\n   * - Reactive: updates when canvas.backgroundColor changes\n   *\n   * **Also updated directly** in handleColorChange for immediate feedback\n   *\n   * @returns JSX template for canvas section\n   *\n   * @example\n   * ```tsx\n   * // Rendered output structure:\n   * <div class=\"canvas-item\" data-canvas-id=\"canvas1\">\n   *   <div class=\"canvas-item-header\">\n   *     <h3>Section 1</h3>\n   *     <div class=\"canvas-controls\">\n   *       <input type=\"color\" value=\"#ffffff\" />\n   *       <button>Clear</button>\n   *       <button>üóëÔ∏è</button>\n   *     </div>\n   *   </div>\n   *   <div class=\"grid-builder\">\n   *     <div class=\"grid-container\" style=\"background-color: #ffffff\">\n   *       <grid-item-wrapper item={...} renderVersion={0} />\n   *       <grid-item-wrapper item={...} renderVersion={0} />\n   *       ...\n   *     </div>\n   *   </div>\n   * </div>\n   * ```\n   */\n  render() {\n    const showGrid = gridState.showGrid;\n    const backgroundColor = this.canvas?.backgroundColor || '#ffffff';\n\n    return (\n      <div class=\"canvas-item\" data-canvas-id={this.canvasId}>\n        <div class=\"canvas-item-header\">\n          <h3>Section {this.sectionNumber}</h3>\n          <div class=\"canvas-controls\">\n            <label>\n              <input\n                type=\"color\"\n                class=\"canvas-bg-color\"\n                value={backgroundColor}\n                onInput={(e) => this.handleColorChange(e)}\n              />\n            </label>\n            <button class=\"clear-canvas-btn\" onClick={() => this.handleClearCanvas()}>\n              Clear\n            </button>\n            <button class=\"delete-section-btn\" onClick={() => this.handleDeleteSection()} title=\"Delete Section\">\n              üóëÔ∏è\n            </button>\n          </div>\n        </div>\n        <div class=\"grid-builder\">\n          <div\n            class={{\n              'grid-container': true,\n              'hide-grid': !showGrid,\n            }}\n            id={this.canvasId}\n            data-canvas-id={this.canvasId}\n            style={{\n              backgroundColor,\n            }}\n            ref={(el) => (this.gridContainerRef = el)}\n          >\n            {/* Grid items will be rendered here by grid-item-wrapper components */}\n            {this.canvas?.items.map((item: GridItem) => (\n              <grid-item-wrapper key={item.id} item={item} renderVersion={this.renderVersion} />\n            ))}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  /**\n   * Initialize interact.js dropzone\n   *\n   * **Called from**: componentDidLoad (after DOM available)\n   * **Purpose**: Setup dropzone to receive palette items and grid items\n   *\n   * ## Dropzone Configuration\n   *\n   * **Accept pattern**: `.palette-item, .grid-item`\n   * - `.palette-item` - New components from palette\n   * - `.grid-item` - Existing items for cross-canvas moves\n   *\n   * **Overlap mode**: `'pointer'`\n   * - Drop detection based on cursor position\n   * - More intuitive than element overlap\n   * - Matches design tool behavior\n   *\n   * **Checker function**: `(dragEvent, event, dropped) => dropped`\n   * - Returns true if drop should be accepted\n   * - Currently accepts all drops (could add validation)\n   *\n   * ## Drop Event Handling\n   *\n   * **Two drop scenarios**:\n   *\n   * ### 1. Palette Item Drop (Create New)\n   *\n   * **Detection**:\n   * ```typescript\n   * const isPaletteItem = droppedElement.classList.contains('palette-item');\n   * ```\n   *\n   * **Component type extraction**:\n   * ```typescript\n   * const componentType = droppedElement.getAttribute('data-component-type');\n   * ```\n   *\n   * **Position calculation**:\n   * ```typescript\n   * // Get half dimensions (default: 10 units √ó 6 units)\n   * const widthPx = gridToPixelsX(10, canvasId);\n   * const heightPx = gridToPixelsY(6);\n   * const halfWidth = widthPx / 2;\n   * const halfHeight = heightPx / 2;\n   *\n   * // Calculate position (cursor-centered)\n   * const rect = gridContainerRef.getBoundingClientRect();\n   * const x = event.dragEvent.clientX - rect.left - halfWidth;\n   * const y = event.dragEvent.clientY - rect.top - halfHeight;\n   * ```\n   *\n   * **Why subtract half dimensions**:\n   * - Centers item on cursor position\n   * - Matches drag clone visual (cursor in center)\n   * - Better UX (item appears where user expects)\n   *\n   * **Custom event dispatch**:\n   * ```typescript\n   * dispatchEvent(new CustomEvent('canvas-drop', {\n   *   detail: { canvasId, componentType, x, y },\n   *   bubbles: true,    // Event reaches parent\n   *   composed: true    // Event crosses shadow DOM\n   * }));\n   * ```\n   *\n   * ### 2. Grid Item Drop (Cross-Canvas Move)\n   *\n   * **Detection**:\n   * ```typescript\n   * const isGridItem = droppedElement.classList.contains('grid-item');\n   * const sourceCanvasId = droppedElement.getAttribute('data-canvas-id');\n   * if (sourceCanvasId !== this.canvasId) { ... }\n   * ```\n   *\n   * **Only process cross-canvas moves**:\n   * - Same-canvas moves handled by drag handler directly\n   * - No need for canvas coordination\n   * - Prevents duplicate events\n   *\n   * **Position calculation**:\n   * ```typescript\n   * // Item already positioned by drag handler\n   * const droppedRect = droppedElement.getBoundingClientRect();\n   * const rect = gridContainerRef.getBoundingClientRect();\n   *\n   * // Use element's current screen position\n   * const x = droppedRect.left - rect.left;\n   * const y = droppedRect.top - rect.top;\n   * ```\n   *\n   * **Why different from palette**:\n   * - Grid item already has position from drag handler\n   * - Use element's bounding rect, not cursor position\n   * - Preserves visual position during move\n   * - More accurate for cross-canvas transfers\n   *\n   * **Custom event dispatch**:\n   * ```typescript\n   * dispatchEvent(new CustomEvent('canvas-move', {\n   *   detail: { itemId, sourceCanvasId, targetCanvasId, x, y },\n   *   bubbles: true,\n   *   composed: true\n   * }));\n   * ```\n   *\n   * ## Initialization Guard\n   *\n   * **Early return conditions**:\n   * - `!gridContainerRef` - DOM not ready\n   * - `dropzoneInitialized` - Already setup\n   *\n   * **Prevents**:\n   * - Multiple dropzone setups on same element\n   * - Errors from missing DOM element\n   * - Duplicate event handlers\n   *\n   * **Sets flag**: `this.dropzoneInitialized = true` after setup\n   *\n   * @private\n   */\n  private initializeDropzone = () => {\n    if (!this.gridContainerRef || this.dropzoneInitialized) {\n      return;\n    }\n\n    const interactable = interact(this.gridContainerRef);\n\n    interactable.dropzone({\n      accept: '.palette-item, .grid-item', // Accept both palette items and grid items\n      overlap: 'pointer', // Use pointer position instead of element overlap\n\n      checker: (_dragEvent: any, _event: any, dropped: boolean) => {\n        return dropped;\n      },\n\n      ondrop: (event: any) => {\n        const droppedElement = event.relatedTarget;\n        const isPaletteItem = droppedElement.classList.contains('palette-item');\n        const isGridItem = droppedElement.classList.contains('grid-item');\n\n        if (isPaletteItem) {\n          // Dropping from palette - create new item\n          const componentType = droppedElement.getAttribute('data-component-type');\n\n          // Calculate half dimensions for centering (default: 10 units wide, 6 units tall)\n          const defaultWidth = 10;\n          const defaultHeight = 6;\n          const widthPx = gridToPixelsX(defaultWidth, this.canvasId);\n          const heightPx = gridToPixelsY(defaultHeight);\n          const halfWidth = widthPx / 2;\n          const halfHeight = heightPx / 2;\n\n          // Get drop position relative to grid container\n          const rect = this.gridContainerRef.getBoundingClientRect();\n          const x = event.dragEvent.clientX - rect.left - halfWidth;\n          const y = event.dragEvent.clientY - rect.top - halfHeight;\n\n          // Dispatch custom event for grid-builder-app to handle\n          const dropEvent = new CustomEvent('canvas-drop', {\n            detail: {\n              canvasId: this.canvasId,\n              componentType,\n              x,\n              y,\n            },\n            bubbles: true,\n            composed: true,\n          });\n          this.gridContainerRef.dispatchEvent(dropEvent);\n        } else if (isGridItem) {\n          // Moving existing grid item to different canvas\n          const itemId = droppedElement.id;\n          const sourceCanvasId = droppedElement.getAttribute('data-canvas-id');\n\n          // Only process if moving to a different canvas\n          if (sourceCanvasId !== this.canvasId) {\n            // For cross-canvas moves, get the element's actual screen position\n            // (the drag handler has already positioned it during the drag)\n            const droppedRect = droppedElement.getBoundingClientRect();\n            const rect = this.gridContainerRef.getBoundingClientRect();\n\n            // Use the element's top-left corner relative to the target canvas\n            const x = droppedRect.left - rect.left;\n            const y = droppedRect.top - rect.top;\n\n            // Dispatch custom event for moving item between canvases\n            const moveEvent = new CustomEvent('canvas-move', {\n              detail: {\n                itemId,\n                sourceCanvasId,\n                targetCanvasId: this.canvasId,\n                x,\n                y,\n              },\n              bubbles: true,\n              composed: true,\n            });\n            this.gridContainerRef.dispatchEvent(moveEvent);\n          }\n        }\n      },\n    });\n\n    this.dropzoneInitialized = true;\n  };\n\n  /**\n   * Handle background color change\n   *\n   * **Triggered by**: User selects color from color picker input\n   *\n   * ## Dual Update Pattern\n   *\n   * **1. State update** (reactivity):\n   * ```typescript\n   * this.canvas.backgroundColor = color;\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   *\n   * **Why spread**: Triggers StencilJS reactivity\n   * - Object reference change detected\n   * - Components re-render\n   * - Persists color in state\n   *\n   * **2. DOM update** (immediate feedback):\n   * ```typescript\n   * this.gridContainerRef.style.backgroundColor = color;\n   * ```\n   *\n   * **Why needed**:\n   * - State update triggers async re-render\n   * - User sees delay (~16ms) without DOM update\n   * - Direct style update provides instant visual feedback\n   * - Better UX (no flash of old color)\n   *\n   * ## Event Handling\n   *\n   * **Input type**: `type=\"color\"` (native HTML5 color picker)\n   * **Event**: `onInput` (fires during color selection)\n   * **Value**: `e.target.value` (hex color string, e.g., '#ff0000')\n   *\n   * **Why onInput vs onChange**:\n   * - onInput fires immediately during selection\n   * - onChange only fires on blur (after closing picker)\n   * - Better real-time feedback\n   *\n   * @param e - Input event from color picker\n   *\n   * @example\n   * ```typescript\n   * // User selects red (#ff0000)\n   * handleColorChange(event)\n   * // ‚Üí State updated: canvas.backgroundColor = '#ff0000'\n   * // ‚Üí DOM updated: container.style.backgroundColor = '#ff0000'\n   * // ‚Üí Visual feedback instant, state persisted\n   * ```\n   *\n   * @private\n   */\n  private handleColorChange = (e: Event) => {\n    const target = e.target as HTMLInputElement;\n    const color = target.value;\n\n    // Update state\n    this.canvas.backgroundColor = color;\n    gridState.canvases = { ...gridState.canvases }; // Trigger update\n\n    // Also update DOM directly for immediate feedback\n    if (this.gridContainerRef) {\n      this.gridContainerRef.style.backgroundColor = color;\n    }\n  };\n\n  /**\n   * Handle clear canvas (delete all items)\n   *\n   * **Triggered by**: User clicks \"Clear\" button\n   *\n   * ## Confirmation Dialog\n   *\n   * **Pattern**:\n   * ```typescript\n   * if (confirm('Are you sure you want to clear all items from this section?'))\n   * ```\n   *\n   * **Why needed**:\n   * - Prevents accidental clears\n   * - Destructive operation (cannot undo via undo/redo)\n   * - Standard UX pattern for dangerous actions\n   *\n   * **Native confirm**:\n   * - Blocks execution until user responds\n   * - Simple and reliable\n   * - No dependencies needed\n   * - Could be replaced with custom modal for better UX\n   *\n   * ## Clear Operations\n   *\n   * **1. Clear items array**:\n   * ```typescript\n   * this.canvas.items = [];\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   *\n   * **Why assignment vs splice**:\n   * - Assignment creates new array reference\n   * - Triggers reactivity\n   * - Simpler than splice(0, items.length)\n   *\n   * **2. Clear selection** (if on this canvas):\n   * ```typescript\n   * if (gridState.selectedCanvasId === this.canvasId) {\n   *   gridState.selectedItemId = null;\n   *   gridState.selectedCanvasId = null;\n   * }\n   * ```\n   *\n   * **Why needed**:\n   * - Selected item no longer exists after clear\n   * - Prevents dangling reference\n   * - Avoids errors when accessing selectedItemId\n   *\n   * **3. Reset container height**:\n   * ```typescript\n   * this.gridContainerRef.style.minHeight = '400px';\n   * ```\n   *\n   * **Why needed**:\n   * - Canvas may have grown with many items\n   * - Empty canvas should return to default height\n   * - Provides visual feedback (canvas shrinks)\n   * - 400px = comfortable minimum workspace\n   *\n   * ## No Undo Support\n   *\n   * **Note**: Clear operation NOT added to undo history\n   * - Too destructive for standard undo\n   * - Would require full state snapshot\n   * - Confirmation dialog is safety mechanism\n   * - Could be enhanced to support undo if needed\n   *\n   * @example\n   * ```typescript\n   * // User clicks \"Clear\" on canvas with 5 items\n   * handleClearCanvas()\n   * // ‚Üí Dialog: \"Are you sure you want to clear all items from this section?\"\n   * // ‚Üí User confirms\n   * // ‚Üí Items cleared: canvas.items = []\n   * // ‚Üí Selection cleared: selectedItemId = null\n   * // ‚Üí Height reset: container.style.minHeight = '400px'\n   * ```\n   *\n   * @private\n   */\n  private handleClearCanvas = () => {\n    if (confirm(`Are you sure you want to clear all items from this section?`)) {\n      // Clear items from state\n      this.canvas.items = [];\n      gridState.canvases = { ...gridState.canvases }; // Trigger update\n\n      // Clear selection if on this canvas\n      if (gridState.selectedCanvasId === this.canvasId) {\n        gridState.selectedItemId = null;\n        gridState.selectedCanvasId = null;\n      }\n\n      // Reset canvas height\n      if (this.gridContainerRef) {\n        this.gridContainerRef.style.minHeight = '400px';\n      }\n    }\n  };\n\n  /**\n   * Handle delete section\n   *\n   * **Triggered by**: User clicks delete button (üóëÔ∏è)\n   *\n   * ## Confirmation Dialog\n   *\n   * **Conditional confirmation**:\n   * ```typescript\n   * if (canvas.items.length > 0) {\n   *   if (!confirm(`This section has ${items.length} items. Are you sure?`))\n   *     return;\n   * }\n   * ```\n   *\n   * **Confirmation only if items exist**:\n   * - Empty section can be deleted without confirmation\n   * - Section with items requires confirmation\n   * - Shows item count for context\n   *\n   * **Early return on cancel**:\n   * - Prevents event dispatch\n   * - No state changes\n   * - Operation fully cancelled\n   *\n   * ## Custom Event Dispatch\n   *\n   * **Pattern**:\n   * ```typescript\n   * dispatchEvent(new CustomEvent('section-delete', {\n   *   detail: { canvasId },\n   *   bubbles: true,\n   *   composed: true\n   * }));\n   * ```\n   *\n   * **Why custom event**:\n   * - Canvas doesn't manage global state\n   * - App coordinates section deletion\n   * - Decouples canvas from app logic\n   * - Testable (can spy on events)\n   *\n   * **Event details**:\n   * - `canvasId`: Which section to delete\n   * - `bubbles: true`: Event reaches parent\n   * - `composed: true`: Event crosses shadow DOM\n   *\n   * ## App Coordination\n   *\n   * **grid-builder-app.tsx handles**:\n   * 1. Receives 'section-delete' event\n   * 2. Removes canvas from gridState.canvases\n   * 3. Clears selection if on deleted canvas\n   * 4. Updates canvas numbering\n   * 5. Re-renders canvas list\n   *\n   * **Why delegate to app**:\n   * - App owns canvas collection state\n   * - Single responsibility (canvas = UI, app = state)\n   * - Easier to test and maintain\n   * - Follows React/StencilJS patterns\n   *\n   * ## No Undo Support\n   *\n   * **Note**: Section deletion NOT added to undo history\n   * - Very destructive operation\n   * - Would require full section snapshot\n   * - Confirmation dialog is safety mechanism\n   * - Could be enhanced to support undo if needed\n   *\n   * @example\n   * ```typescript\n   * // User clicks delete on section with 3 items\n   * handleDeleteSection()\n   * // ‚Üí Dialog: \"This section has 3 items. Are you sure you want to delete it?\"\n   * // ‚Üí User confirms\n   * // ‚Üí Event dispatched: { detail: { canvasId: 'canvas2' } }\n   * // ‚Üí App receives event, deletes canvas from state\n   * // ‚Üí Section removed from DOM\n   * ```\n   *\n   * @private\n   */\n  private handleDeleteSection = () => {\n    if (this.canvas.items.length > 0) {\n      if (!confirm(`This section has ${this.canvas.items.length} items. Are you sure you want to delete it?`)) {\n        return;\n      }\n    }\n\n    // Dispatch custom event for grid-builder-app to handle\n    const deleteEvent = new CustomEvent('section-delete', {\n      detail: { canvasId: this.canvasId },\n      bubbles: true,\n      composed: true,\n    });\n    this.gridContainerRef.dispatchEvent(deleteEvent);\n  };\n}\n"],"version":3}