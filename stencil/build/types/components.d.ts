/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { GridConfig } from "./types/grid-config";
import { ComponentDefinition } from "./types/component-definition";
import { GridItem, GridState, ViewerState } from "./services/state-manager";
import { ConfirmationModalData } from "./demo/types/confirmation-modal-data";
import { GridBuilderAPI } from "./types/api";
import { GridBuilderTheme } from "./types/theme";
import { GridBuilderPlugin } from "./types/plugin";
import { UIComponentOverrides } from "./types/ui-overrides";
import { DeletionHook } from "./types/deletion-hook";
import { GridExport } from "./types/grid-export";
import { SectionEditorData } from "./demo/types/section-editor-data";
export { GridConfig } from "./types/grid-config";
export { ComponentDefinition } from "./types/component-definition";
export { GridItem, GridState, ViewerState } from "./services/state-manager";
export { ConfirmationModalData } from "./demo/types/confirmation-modal-data";
export { GridBuilderAPI } from "./types/api";
export { GridBuilderTheme } from "./types/theme";
export { GridBuilderPlugin } from "./types/plugin";
export { UIComponentOverrides } from "./types/ui-overrides";
export { DeletionHook } from "./types/deletion-hook";
export { GridExport } from "./types/grid-export";
export { SectionEditorData } from "./demo/types/section-editor-data";
export namespace Components {
    /**
     * Blog App Demo - Host Application for grid-builder Library
     * ==========================================================
     * This component demonstrates how to build a complete page builder application
     * using the
     * @lucidworks /stencil-grid-builder library.
     * Key Library Features Demonstrated:
     * ----------------------------------
     * 1. **Component Registry** (components prop)
     * - Pass array of ComponentDefinition objects to grid-builder
     * - Library uses these to render palette and components
     * - See: blogComponentDefinitions in component-definitions.tsx
     * 2. **Initial State** (initialState prop)
     * - Pre-populate canvases with components
     * - Define layouts for desktop and mobile viewports
     * - Library manages state updates via internal store
     * 3. **Canvas Metadata** (canvasMetadata prop)
     * - Host app owns presentation metadata (titles, colors, settings)
     * - Library owns placement state (items, layouts, zIndex)
     * - Separation of concerns pattern
     * 4. **Deletion Hook** (onBeforeDelete prop)
     * - Intercept component deletion requests
     * - Show confirmation modals before deletion
     * - Make API calls or run custom validation
     * - Return Promise<boolean> to approve/cancel deletion
     * 5. **Grid Builder API** (configurable storage via api-ref prop)
     * - Programmatic control of grid state
     * - Methods: addCanvas, removeCanvas, undo, redo, etc.
     * - Event system: canvasAdded, canvasRemoved, etc.
     * - **Demo uses custom storage**: api-ref={{ target: this, key: 'api' }}
     * - API stored on component instance (this.api) instead of window
     * 6. **Event System** (canvas-click, custom events)
     * - Listen to library events for state synchronization
     * - React to user interactions (canvas clicks, etc.)
     * 7. **Multiple Palettes Pattern** (Demonstrated in this demo)
     * - Multiple `<component-palette>` instances with different components
     * - Categorized/grouped components (Content, Interactive, etc.)
     * - Collapsible category sections
     * - All palettes drag to the same canvases
     * 8. **Custom Config Panel** (Demonstrated with custom-config-panel component)
     * - Replace library's default config panel with custom UI
     * - Access grid state via API (this.api in this demo)
     * - Implement live preview for real-time updates
     * - Support cancel/revert functionality
     * - Subscribe to componentDeleted events for auto-close
     * - See: src/demo/components/custom-config-panel/
     * Architecture Pattern:
     * --------------------
     * - Library: Manages component placement, drag/drop, resize, undo/redo
     * - Host App: Manages canvas metadata, custom UI (headers, modals), business logic
     * ## Multiple Palettes Pattern (Featured in this Demo)
     * **Why use multiple palettes:**
     * - Better component organization (group by category, purpose, or feature)
     * - Collapsible sections save screen space
     * - Easier to find components in large libraries
     * - Matches common UI patterns (like the example mockup)
     * **How it works:**
     * 1. Create categorized component arrays:
     * ```typescript
     * const contentComponents = [header, article, ...];
     * const interactiveComponents = [button, link, ...];
     * ```
     * 2. Render multiple `<component-palette>` instances:
     * ```typescript
     * <component-palette components={contentComponents} showHeader={false} />
     * <component-palette components={interactiveComponents} showHeader={false} />
     * ```
     * 3. All palettes work with the same canvases:
     * - Each palette initializes its own drag handlers
     * - All drag to the same `<canvas-section>` dropzones
     * - Component type (not palette source) determines behavior
     * - grid-builder registers ALL components for rendering
     * **Key Points:**
     * - Pass all components to grid-builder (for type registration)
     * - Use chromeless mode (`showHeader={false}`) for custom headers
     * - Each palette manages its own drag/drop independently
     * - Canvases accept drops from any palette
     * - No coordination needed between palettes
     * **Implementation in this demo:**
     * - Content category: Headers, Articles (text-based components)
     * - Interactive category: Buttons, CTAs (action components)
     * - Collapsible sections with expand/collapse state
     * - Clean categorized UI matching modern design patterns
     * ## Custom Config Panel Pattern (Featured in this Demo)
     * **Why use a custom config panel:**
     * - Match your application's design system and branding
     * - Add custom validation or business logic
     * - Integrate with other parts of your application
     * - Control the user experience and workflow
     * **How it works:**
     * 1. Disable the library's default config panel using the showConfigPanel prop:
     * ```typescript
     * <grid-builder
     * components={components}
     * showConfigPanel={false}  // Hide default config panel
     * ...
     * />
     * ```
     * 2. Access the Grid Builder API:
     * ```typescript
     * const api = (window as any).gridBuilderAPI;
     * ```
     * 3. Listen for item-click events:
     * ```typescript
     * document.addEventListener('item-click', (event: CustomEvent) => {
     * const { itemId, canvasId } = event.detail;
     * // Open your custom panel
     * });
     * ```
     * 4. Implement live preview by directly updating state:
     * ```typescript
     * const state = api.getState();
     * const canvas = state.canvases[canvasId];
     * canvas.items[itemIndex] = {
     * ...canvas.items[itemIndex],
     * name: newValue
     * };
     * // Trigger reactivity
     * state.canvases = { ...state.canvases };
     * ```
     * 5. Implement cancel/revert by storing original state:
     * ```typescript
     * // On panel open, store original values
     * this.originalState = {
     * name: item.name,
     * config: { ...item.config }
     * };
     * // On cancel, restore original values
     * api.updateConfig(itemId, this.originalState.config);
     * // Restore name using same pattern as live preview
     * ```
     * 6. Subscribe to componentDeleted for auto-close:
     * ```typescript
     * api.on('componentDeleted', (event) => {
     * if (event.itemId === this.selectedItemId) {
     * this.closePanel();
     * }
     * });
     * ```
     * **Key Library APIs Used:**
     * - `window.gridBuilderAPI` - Global API instance
     * - `api.getState()` - Get current grid state for direct manipulation
     * - `api.getItem(itemId)` - Find item across all canvases
     * - `api.updateConfig(itemId, config)` - Update item configuration
     * - `api.on(event, handler)` - Subscribe to library events
     * - `api.off(event, handler)` - Unsubscribe from library events
     * **Event-driven Integration:**
     * - `item-click` - Fired when user clicks a component (use document.addEventListener)
     * - `componentDeleted` - Fired when a component is deleted (use api.on)
     * - Manual event listeners required for custom events on document
     * **Implementation in this demo:**
     * - See `custom-config-panel.tsx` for complete implementation
     * - Purple gradient styling matching blog theme
     * - Live preview for component name and config fields
     * - Cancel button reverts all changes
     * - Save button persists changes
     * - Auto-closes when selected component is deleted
     */
    interface BlogApp {
    }
    interface BlogArticle {
        "author"?: string;
        /**
          * @default 'Article content goes here'
         */
        "content": string;
        "date"?: string;
    }
    interface BlogButton {
        "href"?: string;
        /**
          * @default 'Click me!'
         */
        "label": string;
        /**
          * @default 'primary'
         */
        "variant": 'primary' | 'secondary';
    }
    interface BlogHeader {
        /**
          * @default 'Default Header'
         */
        "headerTitle": string;
        "subtitle"?: string;
    }
    interface BlogImage {
        /**
          * @default 'Placeholder image'
         */
        "alt": string;
        "caption"?: string;
        /**
          * @default 'contain'
         */
        "objectFit": 'contain' | 'cover';
        /**
          * @default 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600&fit=crop'
         */
        "src": string;
    }
    /**
     * CanvasHeader Component
     * ======================
     * Declarative header component for canvas sections.
     * **Tag**: `<canvas-header>`
     * **Shadow DOM**: Disabled (matches blog-app styling)
     */
    interface CanvasHeader {
        /**
          * Canvas ID for data tracking  **Purpose**: Identify which canvas this header belongs to **Required**: Yes
         */
        "canvasId": string;
        /**
          * Whether this section can be deleted  **Purpose**: Control delete button visibility **Default**: true **Note**: Default sections (hero, articles, footer) should set to false
          * @default true
         */
        "isDeletable": boolean;
        /**
          * Display title for the canvas section  **Purpose**: Text shown in the title badge **Required**: Yes **Note**: Named sectionTitle to avoid conflict with standard HTML title attribute
         */
        "sectionTitle": string;
    }
    /**
     * CanvasSection Component
     * =======================
     * Library component providing individual canvas dropzone.
     * **Tag**: `<canvas-section>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Reactivity**: Listens to gridState changes via StencilJS store
     */
    interface CanvasSection {
        /**
          * Background color for this canvas  **Host app responsibility**: Pass canvas styling from host app **Library does NOT store**: backgroundColor is presentation concern **Optional**: Defaults to '#ffffff'
          * @example ```tsx <canvas-section   canvasId="hero-section"   backgroundColor="#f0f4f8" /> ```
         */
        "backgroundColor"?: string;
        /**
          * Canvas ID for state management  **Format**: 'canvas1', 'canvas2', etc. **Purpose**: Key for accessing canvas data in gridState.canvases **Required**: Component won't render without valid canvasId
         */
        "canvasId": string;
        /**
          * Canvas title (from canvasMetadata)  **Optional**: Display title for this section **Renders as**: Rotated tab on right side, outside section bounds **Builder mode only**: Title tabs visible in builder, not viewer **Source**: Passed from grid-builder via canvasMetadata[canvasId].title
          * @example ```tsx <canvas-section   canvasId="hero-section"   canvasTitle="Hero Section" /> ```
         */
        "canvasTitle"?: string;
        /**
          * Component registry (from parent grid-builder)  **Source**: grid-builder component (built from components prop) **Structure**: Map<type, ComponentDefinition> **Purpose**: Pass to grid-item-wrapper for dynamic rendering
         */
        "componentRegistry"?: Map<string, ComponentDefinition>;
        /**
          * Grid configuration options  **Optional**: Customizes grid system behavior **Passed from**: grid-builder component **Used for**: Grid size calculations, constraints
         */
        "config"?: GridConfig;
        /**
          * Whether this canvas is currently active  **Purpose**: Indicate which canvas is currently focused/active **Source**: Computed from gridState.activeCanvasId in grid-builder **Default**: false **Visual effect**: Applies 'active' CSS class to grid-container  **Canvas becomes active when**: - User clicks item on canvas - User clicks canvas background - User starts dragging item on canvas - User starts resizing item on canvas - Programmatically via api.setActiveCanvas()  **Consumer styling hook**: Consumer can style active canvas via CSS: ```css .grid-container.active .canvas-title {   opacity: 1; } ```
          * @example ```tsx <canvas-section   canvasId="hero-section"   isActive={gridState.activeCanvasId === 'hero-section'} /> ```
          * @default false
         */
        "isActive"?: boolean;
        /**
          * Deletion hook (from parent grid-builder)  **Source**: grid-builder component (from onBeforeDelete prop) **Purpose**: Pass through to grid-item-wrapper for deletion interception **Optional**: If not provided, components delete immediately
         */
        "onBeforeDelete"?: (context: any) => boolean | Promise<boolean>;
    }
    /**
     * CanvasSectionViewer Component
     * ==============================
     * Rendering-only canvas component for grid-viewer.
     * **Tag**: `<canvas-section-viewer>`
     * **Shadow DOM**: Disabled (consistent with canvas-section)
     * **Reactivity**: Props-based (no global state subscription)
     */
    interface CanvasSectionViewer {
        /**
          * Background color for this canvas  **Optional**: Canvas background color **Default**: '#ffffff'
         */
        "backgroundColor"?: string;
        /**
          * Canvas ID for identification  **Format**: 'canvas1', 'hero-section', etc. **Purpose**: Element ID and data attribute
         */
        "canvasId": string;
        /**
          * Component registry (from parent grid-viewer)  **Source**: grid-viewer component **Structure**: Map<type, ComponentDefinition> **Purpose**: Pass to grid-item-wrapper for dynamic rendering
         */
        "componentRegistry"?: Map<string, ComponentDefinition>;
        /**
          * Grid configuration options  **Optional**: Customizes grid system behavior **Passed from**: grid-viewer component
         */
        "config"?: GridConfig;
        /**
          * Current viewport mode  **Required**: 'desktop' | 'mobile' **Source**: Passed from grid-viewer component  **Purpose**: Determines which layout to render for each item
         */
        "currentViewport": 'desktop' | 'mobile';
        /**
          * Items to render in this canvas  **Required**: Array of GridItem objects **Source**: Passed from grid-viewer component  **Unlike canvas-section**: Items passed via props, not from global state
         */
        "items": GridItem[];
    }
    /**
     * ComponentPalette Component
     * ===========================
     * Library component providing draggable component palette UI.
     * **Tag**: `<component-palette>`
     * **Shadow DOM**: Disabled (for consistency with other components)
     * **Reactivity**: Re-renders when components prop changes
     * ## Usage Patterns
     * **Pattern 1: Default (inside grid-builder)**
     * ```typescript
     * // Palette automatically rendered by grid-builder
     * <grid-builder components={componentDefinitions} />
     * ```
     * **Pattern 2: Independent placement**
     * ```typescript
     * // Place palette anywhere in your app
     * <div class="my-layout">
     *   <aside class="sidebar">
     *     <component-palette
     *       components={componentDefinitions}
     *       config={gridConfig}
     *     />
     *   </aside>
     *   <main>
     *     <grid-builder
     *       components={componentDefinitions}
     *       config={gridConfig}
     *       uiOverrides={{
     *         ComponentPalette: () => null  // Hide default palette
     *       }}
     *     />
     *   </main>
     * </div>
     * ```
     * **Pattern 3: Custom wrapper component**
     * ```typescript
     * // Wrap in your own component for styling
     * @Component ({ tag: 'my-palette-sidebar' })
     * export class MyPaletteSidebar {
     * @Prop () components: ComponentDefinition[];
     * render() {
     * return (
     *  <div class="custom-sidebar">
     *    <h3>Components</h3>
     *    <component-palette components={this.components} />
     *  </div>
     * );
     * }
     * }
     * ```
     * ## Key Features
     * - **Self-contained**: Works independently of grid-builder
     * - **Drag/drop ready**: Uses interact.js for drag functionality
     * - **Flexible placement**: Can be rendered anywhere in DOM
     * - **Works across boundaries**: Drag from palette to any canvas-section
     */
    interface ComponentPalette {
        /**
          * Component definitions to render in palette  **Required prop**: Array of ComponentDefinition objects **Source**: Passed from grid-builder component  **Each definition provides**: - type: Unique identifier for component - name: Display name in palette - icon: Visual identifier (emoji recommended) - defaultSize: Size when dropped (for drag clone sizing)  **Example**: ```typescript const components = [   {     type: 'header',     name: 'Header',     icon: 'üìÑ',     defaultSize: { width: 20, height: 8 },     render: ({ itemId, config }) => <my-header itemId={itemId} config={config} />   } ]; ```
         */
        "components": ComponentDefinition[];
        /**
          * Grid configuration options  **Optional prop**: Customizes grid system behavior **Passed from**: grid-builder component **Used for**: Drag clone sizing (gridToPixelsX/Y calculations)
         */
        "config"?: GridConfig;
        /**
          * Show palette header (title)  **Optional prop**: Controls whether the "Components" header is displayed **Default**: true (shows header for backward compatibility)  **Use cases**: - `showHeader={true}` (default): Standard palette with "Components" title - `showHeader={false}`: Chromeless mode - just the component list  **Chromeless mode benefits**: - Embed palette in custom layouts - Add your own headers/titles - Integrate into existing UI structures - More flexible component placement  **Example - Chromeless with custom wrapper**: ```typescript <div class="my-custom-sidebar">   <h3 class="my-title">Available Components</h3>   <p class="my-description">Drag to add</p>   <component-palette     components={componentDefinitions}     showHeader={false}   /> </div> ```
          * @default true
         */
        "showHeader"?: boolean;
    }
    /**
     * ConfigPanel Component
     * =====================
     * Library component providing configuration panel with auto-generated and custom forms.
     * **Tag**: `<config-panel>`
     * **Shadow DOM**: Disabled (for consistency with other components)
     */
    interface ConfigPanel {
        /**
          * Component registry (from parent grid-builder)  **Source**: grid-builder component **Purpose**: Look up component definitions for config forms
         */
        "componentRegistry"?: Map<string, ComponentDefinition>;
    }
    /**
     * Confirmation Modal Component
     * =============================
     * Demo Component - NOT Part of Library
     * This component demonstrates how to implement the grid-builder library's
     * deletion hook system with a custom confirmation modal.
     * Library Feature Being Demonstrated:
     * -----------------------------------
     * This modal is used with the library's **onBeforeDelete hook** system.
     * How It Works:
     * -------------
     * 1. Library calls onBeforeDelete hook when user deletes component
     * 2. Hook returns a Promise that doesn't resolve immediately
     * 3. Host app shows this modal (or any modal library)
     * 4. User clicks "Delete" or "Cancel"
     * 5. Modal fires confirm/cancel event
     * 6. Host app resolves Promise with true/false
     * 7. Library proceeds with or cancels deletion
     * Code Flow Example:
     * ------------------
     * ```typescript
     * // In parent component (blog-app.tsx):
     * private handleBeforeDelete = (context: DeletionHookContext): Promise<boolean> => {
     *   return new Promise((resolve) => {
     *     this.deleteResolve = resolve;
     *     this.isConfirmModalOpen = true;  // Show this modal
     *   });
     * };
     * private handleConfirmDelete = () => {
     *   this.deleteResolve(true);   // Tell library to proceed
     * };
     * private handleCancelDelete = () => {
     *   this.deleteResolve(false);  // Tell library to cancel
     * };
     * ```
     * Why This Pattern:
     * -----------------
     * - **Library agnostic**: Library doesn't provide modal UI
     * - **Flexibility**: Use any modal library (Material, Bootstrap, Ant Design, etc.)
     * - **Customization**: Full control over modal appearance and behavior
     * - **Async support**: Can make API calls before resolving
     * Alternative Implementations:
     * ---------------------------
     * You could replace this component with:
     * - Material Design modal
     * - Bootstrap modal
     * - Ant Design modal
     * - Native browser confirm() (not recommended)
     * - Custom modal from your design system
     * The library doesn't care what modal you use - it just waits for the
     * Promise to resolve with true/false.
     */
    interface ConfirmationModal {
        /**
          * Modal content (title and message) Passed from parent when showing confirmation
          * @default null
         */
        "data": ConfirmationModalData | null;
        /**
          * Modal open/closed state Controlled by parent component (blog-app)
          * @default false
         */
        "isOpen": boolean;
    }
    interface CustomConfigPanel {
        /**
          * Grid Builder API (accessed from window.gridBuilderAPI or passed as prop)  **Source**: window.gridBuilderAPI (set by grid-builder component) **Purpose**: Access grid state and methods **Required**: Component won't work without valid API reference
         */
        "api"?: GridBuilderAPI;
    }
    /**
     * Custom Drag Clone Component
     * ============================
     * Custom drag clone that shows a visual preview of the component being dragged.
     * Each component type has a unique appearance that matches what will be placed
     * on the canvas, helping with visual alignment and user understanding.
     * The component fills the exact width and height provided, scaled to match
     * the actual drop size.
     */
    interface CustomDragClone {
        /**
          * Component type being dragged
         */
        "componentType": string;
        /**
          * Height in pixels
         */
        "height": number;
        /**
          * Icon/emoji
         */
        "icon": string;
        /**
          * Display name
         */
        "name": string;
        /**
          * Width in pixels
         */
        "width": number;
    }
    /**
     * Custom Palette Item Component
     * ==============================
     * Example custom palette item that shows how consumers can create
     * fully customized palette entries for their components.
     * Updated to display SVG icons on top with titles below (similar to UI builder pattern)
     */
    interface CustomPaletteItem {
        /**
          * Component type
         */
        "componentType": string;
        /**
          * Icon/emoji or SVG identifier
         */
        "icon": string;
        /**
          * Display name
         */
        "name": string;
    }
    interface DashboardWidget {
    }
    /**
     * GridBuilder Component
     * ======================
     * Main library component providing complete grid builder functionality.
     * **Tag**: `<grid-builder>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Reactivity**: Listens to gridState changes via StencilJS store
     */
    interface GridBuilder {
        /**
          * Add a new canvas programmatically  **Purpose**: Create new section/canvas in the grid  **Example**: ```typescript const builder = document.querySelector('grid-builder'); await builder.addCanvas('new-section'); ```
          * @param canvasId - Unique canvas identifier
         */
        "addCanvas": (canvasId: string) => Promise<void>;
        /**
          * Add a component programmatically  **Purpose**: Add new component to canvas without dragging from palette  **Example**: ```typescript const builder = document.querySelector('grid-builder'); const itemId = await builder.addComponent('canvas1', 'header', {   x: 10, y: 10, width: 30, height: 6 }, { title: 'My Header' }); ```
          * @param canvasId - Canvas to add component to
          * @param componentType - Component type from registry
          * @param position - Grid position and size
          * @param config - Optional component configuration
          * @returns Promise<string | null> - New item ID or null if failed
         */
        "addComponent": (canvasId: string, componentType: string, position: { x: number; y: number; width: number; height: number; }, config?: Record<string, any>) => Promise<string | null>;
        /**
          * Custom API exposure configuration  **Optional prop**: Control where and how the Grid Builder API is exposed **Default**: `{ target: window, key: 'gridBuilderAPI' }` **Purpose**: Allows multiple grid-builder instances and flexible API access patterns  **Options**: 1. **Custom key on window** (multiple instances): ```typescript <grid-builder api-ref={{ key: 'gridAPI1' }}></grid-builder> <grid-builder api-ref={{ key: 'gridAPI2' }}></grid-builder> // Access: window.gridAPI1, window.gridAPI2 ```  2. **Custom storage object**: ```typescript const myStore = {}; <grid-builder api-ref={{ target: myStore, key: 'api' }}></grid-builder> // Access: myStore.api ```  3. **Disable automatic exposure** (use ref instead): ```typescript <grid-builder api-ref={null}></grid-builder> // Access via ref: <grid-builder ref={el => this.api = el?.api}></grid-builder> ```
          * @default { target: undefined, key: 'gridBuilderAPI' }
         */
        "apiRef"?: { target?: any; key?: string } | null;
        /**
          * Check if redo is available  **Purpose**: Determine if there are actions to redo  **Example**: ```typescript const builder = document.querySelector('grid-builder'); const canRedo = await builder.canRedo(); redoButton.disabled = !canRedo; ```
          * @returns Promise<boolean> - True if redo is available
         */
        "canRedo": () => Promise<boolean>;
        /**
          * Check if undo is available  **Purpose**: Determine if there are actions to undo  **Example**: ```typescript const builder = document.querySelector('grid-builder'); const canUndo = await builder.canUndo(); undoButton.disabled = !canUndo; ```
          * @returns Promise<boolean> - True if undo is available
         */
        "canUndo": () => Promise<boolean>;
        /**
          * Canvas metadata storage (host app responsibility)  **Optional prop**: Store canvas-level presentation metadata **Purpose**: Host app owns canvas metadata (titles, colors, settings)  **Separation of concerns**: - Library owns placement state (items, layouts, zIndex) - Host app owns presentation state (colors, titles, custom metadata)  **Structure**: Record<canvasId, any>  **Example**: ```typescript const canvasMetadata = {   'hero-section': {     title: 'Hero Section',     backgroundColor: '#f0f4f8',     customSettings: { ... }   },   'articles-grid': {     title: 'Articles Grid',     backgroundColor: '#ffffff'   } }; <grid-builder canvasMetadata={canvasMetadata} ... /> ```  **Use with canvas-click events**: - Library fires canvas-click event when canvas background clicked - Host app shows canvas settings panel - Host app updates canvasMetadata state - Library passes metadata to canvas-section via props
         */
        "canvasMetadata"?: Record<string, any>;
        /**
          * Component definitions registry  **Required prop**: Array of ComponentDefinition objects **Purpose**: Defines available component types (header, text, button, etc.)  **Each definition includes**: - type: Unique identifier (e.g., 'header', 'text-block') - name: Display name in palette - icon: Visual identifier (emoji recommended) - defaultSize: Initial size when dropped - render: Function returning component to render - configSchema: Optional auto-generated config form - renderConfigPanel: Optional custom config UI - Lifecycle hooks: onVisible, onHidden for virtual rendering  **Example**: ```typescript const components = [   {     type: 'header',     name: 'Header',     icon: 'üìÑ',     defaultSize: { width: 20, height: 8 },     render: ({ itemId, config }) => (       <my-header itemId={itemId} config={config} />     ),     configSchema: [       { name: 'text', label: 'Text', type: 'text', defaultValue: 'Header' }     ]   } ]; ```
         */
        "components": ComponentDefinition[];
        /**
          * Grid configuration options  **Optional prop**: Customizes grid system behavior **Default**: Standard 2% grid with 10px-50px constraints  **Configuration options**: - gridSizePercent: Grid unit as % of width (default: 2) - minGridSize: Minimum size in pixels (default: 10) - maxGridSize: Maximum size in pixels (default: 50) - snapToGrid: Enable snap-to-grid (default: true) - showGridLines: Show visual grid (default: true) - minItemSize: Minimum item dimensions (default: { width: 5, height: 4 }) - virtualRenderMargin: Pre-render margin (default: '20%')  **Example**: ```typescript const config = {   gridSizePercent: 3,           // 3% grid (33 units per 100%)   minGridSize: 15,              // 15px minimum   maxGridSize: 60,              // 60px maximum   snapToGrid: true,   virtualRenderMargin: '30%'    // Aggressive pre-loading }; ```
         */
        "config"?: GridConfig;
        /**
          * Delete a component programmatically  **Purpose**: Remove component from grid  **Example**: ```typescript const builder = document.querySelector('grid-builder'); const success = await builder.deleteComponent('item-123'); ```
          * @param itemId - Item ID to delete
          * @returns Promise<boolean> - True if deleted successfully
         */
        "deleteComponent": (itemId: string) => Promise<boolean>;
        /**
          * Export current state to JSON-serializable format  **Purpose**: Export grid layout for saving or transferring to viewer app  **Use Cases**: - Save layout to database/localStorage - Transfer layout to viewer app via API - Create layout templates/presets - Backup/restore functionality  **Example - Save to API**: ```typescript const builder = document.querySelector('grid-builder'); const exportData = await builder.exportState(); await fetch('/api/layouts', {   method: 'POST',   headers: { 'Content-Type': 'application/json' },   body: JSON.stringify(exportData) }); ```  **Example - Save to localStorage**: ```typescript const exportData = await builder.exportState(); localStorage.setItem('grid-layout', JSON.stringify(exportData)); ```
          * @returns Promise<GridExport> - JSON-serializable export object
         */
        "exportState": () => Promise<GridExport>;
        /**
          * Get currently active canvas ID  **Purpose**: Check which canvas is currently active/focused
          * @returns Promise<string | null> - Active canvas ID or null if none active
          * @example ```typescript const builder = document.querySelector('grid-builder'); const activeId = await builder.getActiveCanvas(); if (activeId === 'canvas1') {   console.log('Canvas 1 is active'); } ```
         */
        "getActiveCanvas": () => Promise<string | null>;
        /**
          * Get current grid state  **Purpose**: Direct access to grid state for reading  **Example**: ```typescript const builder = document.querySelector('grid-builder'); const state = await builder.getState(); console.log('Current viewport:', state.currentViewport); ```
          * @returns Promise<GridState> - Current grid state
         */
        "getState": () => Promise<GridState>;
        /**
          * Import state from JSON-serializable format  **Purpose**: Restore previously exported grid state  **Example**: ```typescript const builder = document.querySelector('grid-builder'); const savedState = JSON.parse(localStorage.getItem('grid-layout')); await builder.importState(savedState); ```
          * @param state - GridExport or partial GridState object
         */
        "importState": (state: Partial<GridState> | GridExport) => Promise<void>;
        /**
          * Initial state to restore  **Optional prop**: Restore saved layout **Purpose**: Load previously saved grid state  **State structure**: Same as gridState (canvases, viewport, etc.)  **Example**: ```typescript const savedState = JSON.parse(localStorage.getItem('grid-state')); <grid-builder initialState={savedState} ... /> ```
         */
        "initialState"?: Partial<GridState>;
        /**
          * Hook called before deleting a component  **Optional prop**: Intercept deletion requests for custom workflows **Purpose**: Allow host app to show confirmation, make API calls, etc.  **Hook behavior**: - Return `true` to proceed with deletion - Return `false` to cancel the deletion - Return a Promise for async operations (modals, API calls)  **Example - Confirmation modal**: ```typescript const onBeforeDelete = async (context) => {   const confirmed = await showConfirmModal(     `Delete ${context.item.name}?`,     'This action cannot be undone.'   );   return confirmed; }; <grid-builder onBeforeDelete={onBeforeDelete} ... /> ```  **Example - API call + confirmation**: ```typescript const onBeforeDelete = async (context) => {   // Show loading modal   const modal = showLoadingModal('Deleting...');    try {     // Make API call     await fetch(`/api/components/${context.itemId}`, {       method: 'DELETE'     });     modal.close();     return true; // Proceed with deletion   } catch (error) {     modal.close();     showErrorModal('Failed to delete component');     return false; // Cancel deletion   } }; ```  **Default behavior**: If not provided, components delete immediately
         */
        "onBeforeDelete"?: DeletionHook;
        /**
          * Plugin instances for extending functionality  **Optional prop**: Array of GridBuilderPlugin instances **Purpose**: Add custom features, analytics, integrations  **Plugin lifecycle**: 1. Library calls plugin.init(api) on componentDidLoad 2. Plugin subscribes to events, adds UI, etc. 3. Library calls plugin.destroy() on disconnectedCallback  **Example**: ```typescript class AnalyticsPlugin implements GridBuilderPlugin {   name = 'analytics';    init(api: GridBuilderAPI) {     api.on('componentAdded', (e) => {       analytics.track('Component Added', { type: e.item.type });     });   }    destroy() {     // Cleanup   } }  const plugins = [new AnalyticsPlugin()]; ```
         */
        "plugins"?: GridBuilderPlugin[];
        /**
          * Redo last undone action  **Purpose**: Re-apply last undone action  **Example**: ```typescript const builder = document.querySelector('grid-builder'); await builder.redo(); ```
         */
        "redo": () => Promise<void>;
        /**
          * Remove a canvas programmatically  **Purpose**: Delete section/canvas from the grid  **Example**: ```typescript const builder = document.querySelector('grid-builder'); await builder.removeCanvas('old-section'); ```
          * @param canvasId - Canvas identifier to remove
         */
        "removeCanvas": (canvasId: string) => Promise<void>;
        /**
          * Set active canvas programmatically  **Purpose**: Activate a specific canvas for focused editing  **Use cases**: - Focus specific section after adding items - Programmatic navigation between sections - Show canvas-specific settings panel  **Events triggered**: 'canvasActivated'
          * @param canvasId - Canvas to activate
          * @example ```typescript const builder = document.querySelector('grid-builder'); await builder.setActiveCanvas('canvas2'); ```
         */
        "setActiveCanvas": (canvasId: string) => Promise<void>;
        /**
          * Visual theme customization  **Optional prop**: Customizes colors, fonts, and styling **Default**: Bootstrap-inspired blue theme  **Theme options**: - primaryColor: Accent color (default: '#007bff') - paletteBackground: Palette sidebar color (default: '#f5f5f5') - canvasBackground: Canvas background (default: '#ffffff') - gridLineColor: Grid line color (default: 'rgba(0,0,0,0.1)') - selectionColor: Selection outline (default: '#007bff') - resizeHandleColor: Resize handle color (default: '#007bff') - fontFamily: UI font (default: system font stack) - customProperties: CSS variables for advanced theming  **Example**: ```typescript const theme = {   primaryColor: '#ff6b6b',        // Brand red   paletteBackground: '#fff5f5',   // Light red   customProperties: {     '--text-color': '#ffffff',     '--border-radius': '8px'   } }; ```
         */
        "theme"?: GridBuilderTheme;
        /**
          * Custom UI component overrides  **Optional prop**: Replace default UI components **Purpose**: Fully customize visual appearance  **Overridable components**: - ConfigPanel: Configuration panel UI - ComponentPalette: Component palette sidebar - Toolbar: Top toolbar with controls  **Example**: ```typescript const uiOverrides = {   Toolbar: (props) => (     <div class="my-toolbar">       <button onClick={props.onUndo}>Undo</button>       <button onClick={props.onRedo}>Redo</button>     </div>   ) }; ```
         */
        "uiOverrides"?: UIComponentOverrides;
        /**
          * Undo last action  **Purpose**: Revert last user action (move, resize, add, delete, etc.)  **Example**: ```typescript const builder = document.querySelector('grid-builder'); await builder.undo(); ```
         */
        "undo": () => Promise<void>;
        /**
          * Update component configuration  **Purpose**: Update component properties/config  **Example**: ```typescript const builder = document.querySelector('grid-builder'); const success = await builder.updateConfig('item-123', {   title: 'Updated Title',   color: '#ff0000' }); ```
          * @param itemId - Item ID to update
          * @param config - Configuration updates
          * @returns Promise<boolean> - True if updated successfully
         */
        "updateConfig": (itemId: string, config: Record<string, any>) => Promise<boolean>;
    }
    /**
     * GridItemWrapper Component
     * ==========================
     * Library component wrapping individual grid items with drag/resize/selection.
     * **Tag**: `<grid-item-wrapper>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Dynamic rendering**: Uses ComponentDefinition.render() from registry
     */
    interface GridItemWrapper {
        /**
          * All items in the canvas (for viewer mode auto-layout)  **Purpose**: Calculate mobile auto-layout positions **Source**: grid-viewer ‚Üí canvas-section-viewer ‚Üí grid-item-wrapper **Used by**: render() to calculate stacked positions in mobile viewport  **Note**: When in builder mode (viewerMode=false), this is ignored and gridState.canvases is used instead. When in viewer mode (viewerMode=true), this prop is required for mobile auto-layout.
         */
        "canvasItems"?: GridItem[];
        /**
          * Component registry (from parent grid-builder)  **Source**: grid-builder component (built from components prop) **Structure**: Map<type, ComponentDefinition> **Purpose**: Look up component definitions for dynamic rendering  **Note**: This is passed as a workaround since StencilJS doesn't have good support for context/provide-inject patterns. In a production app, consider using a global registry or context provider.
         */
        "componentRegistry"?: Map<string, ComponentDefinition>;
        /**
          * Grid configuration options  **Optional**: Customizes grid system behavior **Passed from**: grid-builder ‚Üí canvas-section ‚Üí grid-item-wrapper **Used for**: Grid size calculations with constraints
         */
        "config"?: GridConfig;
        /**
          * Current viewport (for viewer mode)  **Purpose**: Determine which layout to render (desktop or mobile) **Source**: grid-viewer ‚Üí canvas-section-viewer ‚Üí grid-item-wrapper **Used by**: render() to select appropriate layout  **Note**: When in builder mode (viewerMode=false), this is ignored and gridState.currentViewport is used instead. When in viewer mode (viewerMode=true), this prop is required.
         */
        "currentViewport"?: 'desktop' | 'mobile';
        /**
          * Grid item data (position, size, type, etc.)  **Source**: Parent canvas-section component **Contains**: id, canvasId, type, name, layouts (desktop/mobile), zIndex, config
         */
        "item": GridItem;
        /**
          * Deletion hook (from parent grid-builder)  **Source**: grid-builder component (from onBeforeDelete prop) **Purpose**: Allow host app to intercept deletion requests  **Hook behavior**: - Called before deleting a component - Receives context with item data - Returns true/false or Promise<boolean> - If false, deletion is cancelled - If true, deletion proceeds  **Default**: If not provided, components delete immediately
         */
        "onBeforeDelete"?: (context: any) => boolean | Promise<boolean>;
        /**
          * Render version (force re-render trigger)  **Source**: Parent canvas-section (incremented on resize) **Purpose**: Force grid calculation refresh when container resizes
         */
        "renderVersion"?: number;
        /**
          * Viewer mode flag  **Purpose**: Disable editing features for rendering-only mode **Default**: false (editing enabled)  **When true**: - ‚ùå No drag-and-drop handlers - ‚ùå No resize handles - ‚ùå No item header (drag handle) - ‚ùå No delete button - ‚ùå No selection state - ‚úÖ Only renders component content  **Use case**: grid-viewer component for display-only mode
          * @default false
         */
        "viewerMode"?: boolean;
    }
    /**
     * GridViewer Component
     * ====================
     * Rendering-only grid component for displaying layouts created in grid-builder.
     * **Tag**: `<grid-viewer>`
     * **Shadow DOM**: Disabled (consistent with grid-builder)
     * **Reactivity**: Uses local store for viewer state
     * **Key differences from grid-builder**:
     * - No interact.js dependency (80% bundle size reduction)
     * - No palette, config panel, or editing UI
     * - Simplified state (no selection, no z-index tracking)
     * - Rendering-only canvas sections
     */
    interface GridViewer {
        /**
          * Canvas metadata storage (host app responsibility)  **Optional prop**: Store canvas-level presentation metadata **Purpose**: Host app owns canvas metadata (titles, colors, settings)  **Structure**: Record<canvasId, any>  **Example**: ```typescript const canvasMetadata = {   'hero-section': {     backgroundColor: '#f0f4f8',     customSettings: { ... }   } }; ```
         */
        "canvasMetadata"?: Record<string, any>;
        /**
          * Component definitions registry  **Required prop**: Array of ComponentDefinition objects **Purpose**: Defines how to render each component type  **Must match builder definitions**: Same component types as used in builder  **Example**: ```typescript const components = [   {     type: 'header',     name: 'Header',     icon: 'üìÑ',     render: ({ itemId, config }) => (       <my-header itemId={itemId} config={config} />     )   } ]; ```
         */
        "components": ComponentDefinition[];
        /**
          * Grid configuration options  **Optional prop**: Grid system configuration **Default**: Standard 2% grid with 10px-50px constraints  **Should match builder config**: Use same config as builder for consistent rendering
         */
        "config"?: GridConfig;
        /**
          * Initial state to display  **Optional prop**: Layout data to render **Accepts**: ViewerState or GridExport (both compatible)  **From builder export**: ```typescript const exportData = await builder.exportState(); viewer.initialState = exportData; // Type-safe! ```  **From API**: ```typescript const layout = await fetch('/api/layouts/123').then(r => r.json()); viewer.initialState = layout; ```
         */
        "initialState"?: Partial<ViewerState> | GridExport;
        /**
          * Visual theme customization  **Optional prop**: Customizes colors, fonts, and styling **Default**: Bootstrap-inspired blue theme
         */
        "theme"?: GridBuilderTheme;
    }
    interface ImageGallery {
        /**
          * @default 6
         */
        "imageCount": number;
    }
    interface LiveData {
    }
    /**
     * Section Editor Panel Component
     * ===============================
     * Demo Component - NOT Part of Library
     * This component demonstrates how to build custom UI for editing canvas metadata
     * in applications using the grid-builder library.
     * Purpose:
     * --------
     * Shows how to create a side panel for editing section/canvas settings.
     * This is completely custom to your application - the library doesn't provide this.
     * Library Relationship:
     * ---------------------
     * - Library owns: Component placement, layouts, zIndex (grid state)
     * - Host app owns: Canvas metadata (titles, colors, settings) - THIS COMPONENT
     * - Metadata flows: App ‚Üí Library via canvasMetadata prop
     * Pattern Demonstrated:
     * ---------------------
     * 1. User clicks section header (demo UI)
     * 2. App opens this panel (demo component)
     * 3. User edits title/color
     * 4. App updates canvasMetadata state
     * 5. Library receives updated metadata via prop
     * 6. Library passes backgroundColor to canvas-section
     * Why This Approach:
     * ------------------
     * - Library stays focused on grid logic
     * - Host app controls all presentation/metadata UI
     * - You can use any UI framework (Material, Bootstrap, etc.)
     * - Complete flexibility over settings panel design
     */
    interface SectionEditorPanel {
        /**
          * Panel open/closed state Controlled by parent component (blog-app)
          * @default false
         */
        "isOpen": boolean;
        /**
          * Section data being edited Passed from parent when user clicks section header
          * @default null
         */
        "sectionData": SectionEditorData | null;
    }
}
export interface BlogButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBlogButtonElement;
}
export interface CanvasHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCanvasHeaderElement;
}
export interface ConfirmationModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLConfirmationModalElement;
}
export interface SectionEditorPanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSectionEditorPanelElement;
}
declare global {
    /**
     * Blog App Demo - Host Application for grid-builder Library
     * ==========================================================
     * This component demonstrates how to build a complete page builder application
     * using the
     * @lucidworks /stencil-grid-builder library.
     * Key Library Features Demonstrated:
     * ----------------------------------
     * 1. **Component Registry** (components prop)
     * - Pass array of ComponentDefinition objects to grid-builder
     * - Library uses these to render palette and components
     * - See: blogComponentDefinitions in component-definitions.tsx
     * 2. **Initial State** (initialState prop)
     * - Pre-populate canvases with components
     * - Define layouts for desktop and mobile viewports
     * - Library manages state updates via internal store
     * 3. **Canvas Metadata** (canvasMetadata prop)
     * - Host app owns presentation metadata (titles, colors, settings)
     * - Library owns placement state (items, layouts, zIndex)
     * - Separation of concerns pattern
     * 4. **Deletion Hook** (onBeforeDelete prop)
     * - Intercept component deletion requests
     * - Show confirmation modals before deletion
     * - Make API calls or run custom validation
     * - Return Promise<boolean> to approve/cancel deletion
     * 5. **Grid Builder API** (configurable storage via api-ref prop)
     * - Programmatic control of grid state
     * - Methods: addCanvas, removeCanvas, undo, redo, etc.
     * - Event system: canvasAdded, canvasRemoved, etc.
     * - **Demo uses custom storage**: api-ref={{ target: this, key: 'api' }}
     * - API stored on component instance (this.api) instead of window
     * 6. **Event System** (canvas-click, custom events)
     * - Listen to library events for state synchronization
     * - React to user interactions (canvas clicks, etc.)
     * 7. **Multiple Palettes Pattern** (Demonstrated in this demo)
     * - Multiple `<component-palette>` instances with different components
     * - Categorized/grouped components (Content, Interactive, etc.)
     * - Collapsible category sections
     * - All palettes drag to the same canvases
     * 8. **Custom Config Panel** (Demonstrated with custom-config-panel component)
     * - Replace library's default config panel with custom UI
     * - Access grid state via API (this.api in this demo)
     * - Implement live preview for real-time updates
     * - Support cancel/revert functionality
     * - Subscribe to componentDeleted events for auto-close
     * - See: src/demo/components/custom-config-panel/
     * Architecture Pattern:
     * --------------------
     * - Library: Manages component placement, drag/drop, resize, undo/redo
     * - Host App: Manages canvas metadata, custom UI (headers, modals), business logic
     * ## Multiple Palettes Pattern (Featured in this Demo)
     * **Why use multiple palettes:**
     * - Better component organization (group by category, purpose, or feature)
     * - Collapsible sections save screen space
     * - Easier to find components in large libraries
     * - Matches common UI patterns (like the example mockup)
     * **How it works:**
     * 1. Create categorized component arrays:
     * ```typescript
     * const contentComponents = [header, article, ...];
     * const interactiveComponents = [button, link, ...];
     * ```
     * 2. Render multiple `<component-palette>` instances:
     * ```typescript
     * <component-palette components={contentComponents} showHeader={false} />
     * <component-palette components={interactiveComponents} showHeader={false} />
     * ```
     * 3. All palettes work with the same canvases:
     * - Each palette initializes its own drag handlers
     * - All drag to the same `<canvas-section>` dropzones
     * - Component type (not palette source) determines behavior
     * - grid-builder registers ALL components for rendering
     * **Key Points:**
     * - Pass all components to grid-builder (for type registration)
     * - Use chromeless mode (`showHeader={false}`) for custom headers
     * - Each palette manages its own drag/drop independently
     * - Canvases accept drops from any palette
     * - No coordination needed between palettes
     * **Implementation in this demo:**
     * - Content category: Headers, Articles (text-based components)
     * - Interactive category: Buttons, CTAs (action components)
     * - Collapsible sections with expand/collapse state
     * - Clean categorized UI matching modern design patterns
     * ## Custom Config Panel Pattern (Featured in this Demo)
     * **Why use a custom config panel:**
     * - Match your application's design system and branding
     * - Add custom validation or business logic
     * - Integrate with other parts of your application
     * - Control the user experience and workflow
     * **How it works:**
     * 1. Disable the library's default config panel using the showConfigPanel prop:
     * ```typescript
     * <grid-builder
     * components={components}
     * showConfigPanel={false}  // Hide default config panel
     * ...
     * />
     * ```
     * 2. Access the Grid Builder API:
     * ```typescript
     * const api = (window as any).gridBuilderAPI;
     * ```
     * 3. Listen for item-click events:
     * ```typescript
     * document.addEventListener('item-click', (event: CustomEvent) => {
     * const { itemId, canvasId } = event.detail;
     * // Open your custom panel
     * });
     * ```
     * 4. Implement live preview by directly updating state:
     * ```typescript
     * const state = api.getState();
     * const canvas = state.canvases[canvasId];
     * canvas.items[itemIndex] = {
     * ...canvas.items[itemIndex],
     * name: newValue
     * };
     * // Trigger reactivity
     * state.canvases = { ...state.canvases };
     * ```
     * 5. Implement cancel/revert by storing original state:
     * ```typescript
     * // On panel open, store original values
     * this.originalState = {
     * name: item.name,
     * config: { ...item.config }
     * };
     * // On cancel, restore original values
     * api.updateConfig(itemId, this.originalState.config);
     * // Restore name using same pattern as live preview
     * ```
     * 6. Subscribe to componentDeleted for auto-close:
     * ```typescript
     * api.on('componentDeleted', (event) => {
     * if (event.itemId === this.selectedItemId) {
     * this.closePanel();
     * }
     * });
     * ```
     * **Key Library APIs Used:**
     * - `window.gridBuilderAPI` - Global API instance
     * - `api.getState()` - Get current grid state for direct manipulation
     * - `api.getItem(itemId)` - Find item across all canvases
     * - `api.updateConfig(itemId, config)` - Update item configuration
     * - `api.on(event, handler)` - Subscribe to library events
     * - `api.off(event, handler)` - Unsubscribe from library events
     * **Event-driven Integration:**
     * - `item-click` - Fired when user clicks a component (use document.addEventListener)
     * - `componentDeleted` - Fired when a component is deleted (use api.on)
     * - Manual event listeners required for custom events on document
     * **Implementation in this demo:**
     * - See `custom-config-panel.tsx` for complete implementation
     * - Purple gradient styling matching blog theme
     * - Live preview for component name and config fields
     * - Cancel button reverts all changes
     * - Save button persists changes
     * - Auto-closes when selected component is deleted
     */
    interface HTMLBlogAppElement extends Components.BlogApp, HTMLStencilElement {
    }
    var HTMLBlogAppElement: {
        prototype: HTMLBlogAppElement;
        new (): HTMLBlogAppElement;
    };
    interface HTMLBlogArticleElement extends Components.BlogArticle, HTMLStencilElement {
    }
    var HTMLBlogArticleElement: {
        prototype: HTMLBlogArticleElement;
        new (): HTMLBlogArticleElement;
    };
    interface HTMLBlogButtonElementEventMap {
        "buttonClick": void;
    }
    interface HTMLBlogButtonElement extends Components.BlogButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBlogButtonElementEventMap>(type: K, listener: (this: HTMLBlogButtonElement, ev: BlogButtonCustomEvent<HTMLBlogButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBlogButtonElementEventMap>(type: K, listener: (this: HTMLBlogButtonElement, ev: BlogButtonCustomEvent<HTMLBlogButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBlogButtonElement: {
        prototype: HTMLBlogButtonElement;
        new (): HTMLBlogButtonElement;
    };
    interface HTMLBlogHeaderElement extends Components.BlogHeader, HTMLStencilElement {
    }
    var HTMLBlogHeaderElement: {
        prototype: HTMLBlogHeaderElement;
        new (): HTMLBlogHeaderElement;
    };
    interface HTMLBlogImageElement extends Components.BlogImage, HTMLStencilElement {
    }
    var HTMLBlogImageElement: {
        prototype: HTMLBlogImageElement;
        new (): HTMLBlogImageElement;
    };
    interface HTMLCanvasHeaderElementEventMap {
        "headerClick": { canvasId: string };
        "deleteClick": { canvasId: string };
    }
    /**
     * CanvasHeader Component
     * ======================
     * Declarative header component for canvas sections.
     * **Tag**: `<canvas-header>`
     * **Shadow DOM**: Disabled (matches blog-app styling)
     */
    interface HTMLCanvasHeaderElement extends Components.CanvasHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCanvasHeaderElementEventMap>(type: K, listener: (this: HTMLCanvasHeaderElement, ev: CanvasHeaderCustomEvent<HTMLCanvasHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCanvasHeaderElementEventMap>(type: K, listener: (this: HTMLCanvasHeaderElement, ev: CanvasHeaderCustomEvent<HTMLCanvasHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCanvasHeaderElement: {
        prototype: HTMLCanvasHeaderElement;
        new (): HTMLCanvasHeaderElement;
    };
    /**
     * CanvasSection Component
     * =======================
     * Library component providing individual canvas dropzone.
     * **Tag**: `<canvas-section>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Reactivity**: Listens to gridState changes via StencilJS store
     */
    interface HTMLCanvasSectionElement extends Components.CanvasSection, HTMLStencilElement {
    }
    var HTMLCanvasSectionElement: {
        prototype: HTMLCanvasSectionElement;
        new (): HTMLCanvasSectionElement;
    };
    /**
     * CanvasSectionViewer Component
     * ==============================
     * Rendering-only canvas component for grid-viewer.
     * **Tag**: `<canvas-section-viewer>`
     * **Shadow DOM**: Disabled (consistent with canvas-section)
     * **Reactivity**: Props-based (no global state subscription)
     */
    interface HTMLCanvasSectionViewerElement extends Components.CanvasSectionViewer, HTMLStencilElement {
    }
    var HTMLCanvasSectionViewerElement: {
        prototype: HTMLCanvasSectionViewerElement;
        new (): HTMLCanvasSectionViewerElement;
    };
    /**
     * ComponentPalette Component
     * ===========================
     * Library component providing draggable component palette UI.
     * **Tag**: `<component-palette>`
     * **Shadow DOM**: Disabled (for consistency with other components)
     * **Reactivity**: Re-renders when components prop changes
     * ## Usage Patterns
     * **Pattern 1: Default (inside grid-builder)**
     * ```typescript
     * // Palette automatically rendered by grid-builder
     * <grid-builder components={componentDefinitions} />
     * ```
     * **Pattern 2: Independent placement**
     * ```typescript
     * // Place palette anywhere in your app
     * <div class="my-layout">
     *   <aside class="sidebar">
     *     <component-palette
     *       components={componentDefinitions}
     *       config={gridConfig}
     *     />
     *   </aside>
     *   <main>
     *     <grid-builder
     *       components={componentDefinitions}
     *       config={gridConfig}
     *       uiOverrides={{
     *         ComponentPalette: () => null  // Hide default palette
     *       }}
     *     />
     *   </main>
     * </div>
     * ```
     * **Pattern 3: Custom wrapper component**
     * ```typescript
     * // Wrap in your own component for styling
     * @Component ({ tag: 'my-palette-sidebar' })
     * export class MyPaletteSidebar {
     * @Prop () components: ComponentDefinition[];
     * render() {
     * return (
     *  <div class="custom-sidebar">
     *    <h3>Components</h3>
     *    <component-palette components={this.components} />
     *  </div>
     * );
     * }
     * }
     * ```
     * ## Key Features
     * - **Self-contained**: Works independently of grid-builder
     * - **Drag/drop ready**: Uses interact.js for drag functionality
     * - **Flexible placement**: Can be rendered anywhere in DOM
     * - **Works across boundaries**: Drag from palette to any canvas-section
     */
    interface HTMLComponentPaletteElement extends Components.ComponentPalette, HTMLStencilElement {
    }
    var HTMLComponentPaletteElement: {
        prototype: HTMLComponentPaletteElement;
        new (): HTMLComponentPaletteElement;
    };
    /**
     * ConfigPanel Component
     * =====================
     * Library component providing configuration panel with auto-generated and custom forms.
     * **Tag**: `<config-panel>`
     * **Shadow DOM**: Disabled (for consistency with other components)
     */
    interface HTMLConfigPanelElement extends Components.ConfigPanel, HTMLStencilElement {
    }
    var HTMLConfigPanelElement: {
        prototype: HTMLConfigPanelElement;
        new (): HTMLConfigPanelElement;
    };
    interface HTMLConfirmationModalElementEventMap {
        "confirm": void;
        "cancel": void;
    }
    /**
     * Confirmation Modal Component
     * =============================
     * Demo Component - NOT Part of Library
     * This component demonstrates how to implement the grid-builder library's
     * deletion hook system with a custom confirmation modal.
     * Library Feature Being Demonstrated:
     * -----------------------------------
     * This modal is used with the library's **onBeforeDelete hook** system.
     * How It Works:
     * -------------
     * 1. Library calls onBeforeDelete hook when user deletes component
     * 2. Hook returns a Promise that doesn't resolve immediately
     * 3. Host app shows this modal (or any modal library)
     * 4. User clicks "Delete" or "Cancel"
     * 5. Modal fires confirm/cancel event
     * 6. Host app resolves Promise with true/false
     * 7. Library proceeds with or cancels deletion
     * Code Flow Example:
     * ------------------
     * ```typescript
     * // In parent component (blog-app.tsx):
     * private handleBeforeDelete = (context: DeletionHookContext): Promise<boolean> => {
     *   return new Promise((resolve) => {
     *     this.deleteResolve = resolve;
     *     this.isConfirmModalOpen = true;  // Show this modal
     *   });
     * };
     * private handleConfirmDelete = () => {
     *   this.deleteResolve(true);   // Tell library to proceed
     * };
     * private handleCancelDelete = () => {
     *   this.deleteResolve(false);  // Tell library to cancel
     * };
     * ```
     * Why This Pattern:
     * -----------------
     * - **Library agnostic**: Library doesn't provide modal UI
     * - **Flexibility**: Use any modal library (Material, Bootstrap, Ant Design, etc.)
     * - **Customization**: Full control over modal appearance and behavior
     * - **Async support**: Can make API calls before resolving
     * Alternative Implementations:
     * ---------------------------
     * You could replace this component with:
     * - Material Design modal
     * - Bootstrap modal
     * - Ant Design modal
     * - Native browser confirm() (not recommended)
     * - Custom modal from your design system
     * The library doesn't care what modal you use - it just waits for the
     * Promise to resolve with true/false.
     */
    interface HTMLConfirmationModalElement extends Components.ConfirmationModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLConfirmationModalElementEventMap>(type: K, listener: (this: HTMLConfirmationModalElement, ev: ConfirmationModalCustomEvent<HTMLConfirmationModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLConfirmationModalElementEventMap>(type: K, listener: (this: HTMLConfirmationModalElement, ev: ConfirmationModalCustomEvent<HTMLConfirmationModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLConfirmationModalElement: {
        prototype: HTMLConfirmationModalElement;
        new (): HTMLConfirmationModalElement;
    };
    interface HTMLCustomConfigPanelElement extends Components.CustomConfigPanel, HTMLStencilElement {
    }
    var HTMLCustomConfigPanelElement: {
        prototype: HTMLCustomConfigPanelElement;
        new (): HTMLCustomConfigPanelElement;
    };
    /**
     * Custom Drag Clone Component
     * ============================
     * Custom drag clone that shows a visual preview of the component being dragged.
     * Each component type has a unique appearance that matches what will be placed
     * on the canvas, helping with visual alignment and user understanding.
     * The component fills the exact width and height provided, scaled to match
     * the actual drop size.
     */
    interface HTMLCustomDragCloneElement extends Components.CustomDragClone, HTMLStencilElement {
    }
    var HTMLCustomDragCloneElement: {
        prototype: HTMLCustomDragCloneElement;
        new (): HTMLCustomDragCloneElement;
    };
    /**
     * Custom Palette Item Component
     * ==============================
     * Example custom palette item that shows how consumers can create
     * fully customized palette entries for their components.
     * Updated to display SVG icons on top with titles below (similar to UI builder pattern)
     */
    interface HTMLCustomPaletteItemElement extends Components.CustomPaletteItem, HTMLStencilElement {
    }
    var HTMLCustomPaletteItemElement: {
        prototype: HTMLCustomPaletteItemElement;
        new (): HTMLCustomPaletteItemElement;
    };
    interface HTMLDashboardWidgetElement extends Components.DashboardWidget, HTMLStencilElement {
    }
    var HTMLDashboardWidgetElement: {
        prototype: HTMLDashboardWidgetElement;
        new (): HTMLDashboardWidgetElement;
    };
    /**
     * GridBuilder Component
     * ======================
     * Main library component providing complete grid builder functionality.
     * **Tag**: `<grid-builder>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Reactivity**: Listens to gridState changes via StencilJS store
     */
    interface HTMLGridBuilderElement extends Components.GridBuilder, HTMLStencilElement {
    }
    var HTMLGridBuilderElement: {
        prototype: HTMLGridBuilderElement;
        new (): HTMLGridBuilderElement;
    };
    /**
     * GridItemWrapper Component
     * ==========================
     * Library component wrapping individual grid items with drag/resize/selection.
     * **Tag**: `<grid-item-wrapper>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Dynamic rendering**: Uses ComponentDefinition.render() from registry
     */
    interface HTMLGridItemWrapperElement extends Components.GridItemWrapper, HTMLStencilElement {
    }
    var HTMLGridItemWrapperElement: {
        prototype: HTMLGridItemWrapperElement;
        new (): HTMLGridItemWrapperElement;
    };
    /**
     * GridViewer Component
     * ====================
     * Rendering-only grid component for displaying layouts created in grid-builder.
     * **Tag**: `<grid-viewer>`
     * **Shadow DOM**: Disabled (consistent with grid-builder)
     * **Reactivity**: Uses local store for viewer state
     * **Key differences from grid-builder**:
     * - No interact.js dependency (80% bundle size reduction)
     * - No palette, config panel, or editing UI
     * - Simplified state (no selection, no z-index tracking)
     * - Rendering-only canvas sections
     */
    interface HTMLGridViewerElement extends Components.GridViewer, HTMLStencilElement {
    }
    var HTMLGridViewerElement: {
        prototype: HTMLGridViewerElement;
        new (): HTMLGridViewerElement;
    };
    interface HTMLImageGalleryElement extends Components.ImageGallery, HTMLStencilElement {
    }
    var HTMLImageGalleryElement: {
        prototype: HTMLImageGalleryElement;
        new (): HTMLImageGalleryElement;
    };
    interface HTMLLiveDataElement extends Components.LiveData, HTMLStencilElement {
    }
    var HTMLLiveDataElement: {
        prototype: HTMLLiveDataElement;
        new (): HTMLLiveDataElement;
    };
    interface HTMLSectionEditorPanelElementEventMap {
        "closePanel": void;
        "updateSection": { canvasId: string; title: string; backgroundColor: string };
        "previewColorChange": { canvasId: string; backgroundColor: string };
        "previewTitleChange": { canvasId: string; title: string };
        "deleteSection": { canvasId: string };
    }
    /**
     * Section Editor Panel Component
     * ===============================
     * Demo Component - NOT Part of Library
     * This component demonstrates how to build custom UI for editing canvas metadata
     * in applications using the grid-builder library.
     * Purpose:
     * --------
     * Shows how to create a side panel for editing section/canvas settings.
     * This is completely custom to your application - the library doesn't provide this.
     * Library Relationship:
     * ---------------------
     * - Library owns: Component placement, layouts, zIndex (grid state)
     * - Host app owns: Canvas metadata (titles, colors, settings) - THIS COMPONENT
     * - Metadata flows: App ‚Üí Library via canvasMetadata prop
     * Pattern Demonstrated:
     * ---------------------
     * 1. User clicks section header (demo UI)
     * 2. App opens this panel (demo component)
     * 3. User edits title/color
     * 4. App updates canvasMetadata state
     * 5. Library receives updated metadata via prop
     * 6. Library passes backgroundColor to canvas-section
     * Why This Approach:
     * ------------------
     * - Library stays focused on grid logic
     * - Host app controls all presentation/metadata UI
     * - You can use any UI framework (Material, Bootstrap, etc.)
     * - Complete flexibility over settings panel design
     */
    interface HTMLSectionEditorPanelElement extends Components.SectionEditorPanel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLSectionEditorPanelElementEventMap>(type: K, listener: (this: HTMLSectionEditorPanelElement, ev: SectionEditorPanelCustomEvent<HTMLSectionEditorPanelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLSectionEditorPanelElementEventMap>(type: K, listener: (this: HTMLSectionEditorPanelElement, ev: SectionEditorPanelCustomEvent<HTMLSectionEditorPanelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLSectionEditorPanelElement: {
        prototype: HTMLSectionEditorPanelElement;
        new (): HTMLSectionEditorPanelElement;
    };
    interface HTMLElementTagNameMap {
        "blog-app": HTMLBlogAppElement;
        "blog-article": HTMLBlogArticleElement;
        "blog-button": HTMLBlogButtonElement;
        "blog-header": HTMLBlogHeaderElement;
        "blog-image": HTMLBlogImageElement;
        "canvas-header": HTMLCanvasHeaderElement;
        "canvas-section": HTMLCanvasSectionElement;
        "canvas-section-viewer": HTMLCanvasSectionViewerElement;
        "component-palette": HTMLComponentPaletteElement;
        "config-panel": HTMLConfigPanelElement;
        "confirmation-modal": HTMLConfirmationModalElement;
        "custom-config-panel": HTMLCustomConfigPanelElement;
        "custom-drag-clone": HTMLCustomDragCloneElement;
        "custom-palette-item": HTMLCustomPaletteItemElement;
        "dashboard-widget": HTMLDashboardWidgetElement;
        "grid-builder": HTMLGridBuilderElement;
        "grid-item-wrapper": HTMLGridItemWrapperElement;
        "grid-viewer": HTMLGridViewerElement;
        "image-gallery": HTMLImageGalleryElement;
        "live-data": HTMLLiveDataElement;
        "section-editor-panel": HTMLSectionEditorPanelElement;
    }
}
declare namespace LocalJSX {
    /**
     * Blog App Demo - Host Application for grid-builder Library
     * ==========================================================
     * This component demonstrates how to build a complete page builder application
     * using the
     * @lucidworks /stencil-grid-builder library.
     * Key Library Features Demonstrated:
     * ----------------------------------
     * 1. **Component Registry** (components prop)
     * - Pass array of ComponentDefinition objects to grid-builder
     * - Library uses these to render palette and components
     * - See: blogComponentDefinitions in component-definitions.tsx
     * 2. **Initial State** (initialState prop)
     * - Pre-populate canvases with components
     * - Define layouts for desktop and mobile viewports
     * - Library manages state updates via internal store
     * 3. **Canvas Metadata** (canvasMetadata prop)
     * - Host app owns presentation metadata (titles, colors, settings)
     * - Library owns placement state (items, layouts, zIndex)
     * - Separation of concerns pattern
     * 4. **Deletion Hook** (onBeforeDelete prop)
     * - Intercept component deletion requests
     * - Show confirmation modals before deletion
     * - Make API calls or run custom validation
     * - Return Promise<boolean> to approve/cancel deletion
     * 5. **Grid Builder API** (configurable storage via api-ref prop)
     * - Programmatic control of grid state
     * - Methods: addCanvas, removeCanvas, undo, redo, etc.
     * - Event system: canvasAdded, canvasRemoved, etc.
     * - **Demo uses custom storage**: api-ref={{ target: this, key: 'api' }}
     * - API stored on component instance (this.api) instead of window
     * 6. **Event System** (canvas-click, custom events)
     * - Listen to library events for state synchronization
     * - React to user interactions (canvas clicks, etc.)
     * 7. **Multiple Palettes Pattern** (Demonstrated in this demo)
     * - Multiple `<component-palette>` instances with different components
     * - Categorized/grouped components (Content, Interactive, etc.)
     * - Collapsible category sections
     * - All palettes drag to the same canvases
     * 8. **Custom Config Panel** (Demonstrated with custom-config-panel component)
     * - Replace library's default config panel with custom UI
     * - Access grid state via API (this.api in this demo)
     * - Implement live preview for real-time updates
     * - Support cancel/revert functionality
     * - Subscribe to componentDeleted events for auto-close
     * - See: src/demo/components/custom-config-panel/
     * Architecture Pattern:
     * --------------------
     * - Library: Manages component placement, drag/drop, resize, undo/redo
     * - Host App: Manages canvas metadata, custom UI (headers, modals), business logic
     * ## Multiple Palettes Pattern (Featured in this Demo)
     * **Why use multiple palettes:**
     * - Better component organization (group by category, purpose, or feature)
     * - Collapsible sections save screen space
     * - Easier to find components in large libraries
     * - Matches common UI patterns (like the example mockup)
     * **How it works:**
     * 1. Create categorized component arrays:
     * ```typescript
     * const contentComponents = [header, article, ...];
     * const interactiveComponents = [button, link, ...];
     * ```
     * 2. Render multiple `<component-palette>` instances:
     * ```typescript
     * <component-palette components={contentComponents} showHeader={false} />
     * <component-palette components={interactiveComponents} showHeader={false} />
     * ```
     * 3. All palettes work with the same canvases:
     * - Each palette initializes its own drag handlers
     * - All drag to the same `<canvas-section>` dropzones
     * - Component type (not palette source) determines behavior
     * - grid-builder registers ALL components for rendering
     * **Key Points:**
     * - Pass all components to grid-builder (for type registration)
     * - Use chromeless mode (`showHeader={false}`) for custom headers
     * - Each palette manages its own drag/drop independently
     * - Canvases accept drops from any palette
     * - No coordination needed between palettes
     * **Implementation in this demo:**
     * - Content category: Headers, Articles (text-based components)
     * - Interactive category: Buttons, CTAs (action components)
     * - Collapsible sections with expand/collapse state
     * - Clean categorized UI matching modern design patterns
     * ## Custom Config Panel Pattern (Featured in this Demo)
     * **Why use a custom config panel:**
     * - Match your application's design system and branding
     * - Add custom validation or business logic
     * - Integrate with other parts of your application
     * - Control the user experience and workflow
     * **How it works:**
     * 1. Disable the library's default config panel using the showConfigPanel prop:
     * ```typescript
     * <grid-builder
     * components={components}
     * showConfigPanel={false}  // Hide default config panel
     * ...
     * />
     * ```
     * 2. Access the Grid Builder API:
     * ```typescript
     * const api = (window as any).gridBuilderAPI;
     * ```
     * 3. Listen for item-click events:
     * ```typescript
     * document.addEventListener('item-click', (event: CustomEvent) => {
     * const { itemId, canvasId } = event.detail;
     * // Open your custom panel
     * });
     * ```
     * 4. Implement live preview by directly updating state:
     * ```typescript
     * const state = api.getState();
     * const canvas = state.canvases[canvasId];
     * canvas.items[itemIndex] = {
     * ...canvas.items[itemIndex],
     * name: newValue
     * };
     * // Trigger reactivity
     * state.canvases = { ...state.canvases };
     * ```
     * 5. Implement cancel/revert by storing original state:
     * ```typescript
     * // On panel open, store original values
     * this.originalState = {
     * name: item.name,
     * config: { ...item.config }
     * };
     * // On cancel, restore original values
     * api.updateConfig(itemId, this.originalState.config);
     * // Restore name using same pattern as live preview
     * ```
     * 6. Subscribe to componentDeleted for auto-close:
     * ```typescript
     * api.on('componentDeleted', (event) => {
     * if (event.itemId === this.selectedItemId) {
     * this.closePanel();
     * }
     * });
     * ```
     * **Key Library APIs Used:**
     * - `window.gridBuilderAPI` - Global API instance
     * - `api.getState()` - Get current grid state for direct manipulation
     * - `api.getItem(itemId)` - Find item across all canvases
     * - `api.updateConfig(itemId, config)` - Update item configuration
     * - `api.on(event, handler)` - Subscribe to library events
     * - `api.off(event, handler)` - Unsubscribe from library events
     * **Event-driven Integration:**
     * - `item-click` - Fired when user clicks a component (use document.addEventListener)
     * - `componentDeleted` - Fired when a component is deleted (use api.on)
     * - Manual event listeners required for custom events on document
     * **Implementation in this demo:**
     * - See `custom-config-panel.tsx` for complete implementation
     * - Purple gradient styling matching blog theme
     * - Live preview for component name and config fields
     * - Cancel button reverts all changes
     * - Save button persists changes
     * - Auto-closes when selected component is deleted
     */
    interface BlogApp {
    }
    interface BlogArticle {
        "author"?: string;
        /**
          * @default 'Article content goes here'
         */
        "content"?: string;
        "date"?: string;
    }
    interface BlogButton {
        "href"?: string;
        /**
          * @default 'Click me!'
         */
        "label"?: string;
        "onButtonClick"?: (event: BlogButtonCustomEvent<void>) => void;
        /**
          * @default 'primary'
         */
        "variant"?: 'primary' | 'secondary';
    }
    interface BlogHeader {
        /**
          * @default 'Default Header'
         */
        "headerTitle"?: string;
        "subtitle"?: string;
    }
    interface BlogImage {
        /**
          * @default 'Placeholder image'
         */
        "alt"?: string;
        "caption"?: string;
        /**
          * @default 'contain'
         */
        "objectFit"?: 'contain' | 'cover';
        /**
          * @default 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600&fit=crop'
         */
        "src"?: string;
    }
    /**
     * CanvasHeader Component
     * ======================
     * Declarative header component for canvas sections.
     * **Tag**: `<canvas-header>`
     * **Shadow DOM**: Disabled (matches blog-app styling)
     */
    interface CanvasHeader {
        /**
          * Canvas ID for data tracking  **Purpose**: Identify which canvas this header belongs to **Required**: Yes
         */
        "canvasId": string;
        /**
          * Whether this section can be deleted  **Purpose**: Control delete button visibility **Default**: true **Note**: Default sections (hero, articles, footer) should set to false
          * @default true
         */
        "isDeletable"?: boolean;
        /**
          * Event emitted when delete button is clicked  **Detail**: { canvasId: string } **Use case**: Delete the canvas section
         */
        "onDeleteClick"?: (event: CanvasHeaderCustomEvent<{ canvasId: string }>) => void;
        /**
          * Event emitted when header title is clicked  **Detail**: { canvasId: string } **Use case**: Activate canvas and open section editor
         */
        "onHeaderClick"?: (event: CanvasHeaderCustomEvent<{ canvasId: string }>) => void;
        /**
          * Display title for the canvas section  **Purpose**: Text shown in the title badge **Required**: Yes **Note**: Named sectionTitle to avoid conflict with standard HTML title attribute
         */
        "sectionTitle": string;
    }
    /**
     * CanvasSection Component
     * =======================
     * Library component providing individual canvas dropzone.
     * **Tag**: `<canvas-section>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Reactivity**: Listens to gridState changes via StencilJS store
     */
    interface CanvasSection {
        /**
          * Background color for this canvas  **Host app responsibility**: Pass canvas styling from host app **Library does NOT store**: backgroundColor is presentation concern **Optional**: Defaults to '#ffffff'
          * @example ```tsx <canvas-section   canvasId="hero-section"   backgroundColor="#f0f4f8" /> ```
         */
        "backgroundColor"?: string;
        /**
          * Canvas ID for state management  **Format**: 'canvas1', 'canvas2', etc. **Purpose**: Key for accessing canvas data in gridState.canvases **Required**: Component won't render without valid canvasId
         */
        "canvasId": string;
        /**
          * Canvas title (from canvasMetadata)  **Optional**: Display title for this section **Renders as**: Rotated tab on right side, outside section bounds **Builder mode only**: Title tabs visible in builder, not viewer **Source**: Passed from grid-builder via canvasMetadata[canvasId].title
          * @example ```tsx <canvas-section   canvasId="hero-section"   canvasTitle="Hero Section" /> ```
         */
        "canvasTitle"?: string;
        /**
          * Component registry (from parent grid-builder)  **Source**: grid-builder component (built from components prop) **Structure**: Map<type, ComponentDefinition> **Purpose**: Pass to grid-item-wrapper for dynamic rendering
         */
        "componentRegistry"?: Map<string, ComponentDefinition>;
        /**
          * Grid configuration options  **Optional**: Customizes grid system behavior **Passed from**: grid-builder component **Used for**: Grid size calculations, constraints
         */
        "config"?: GridConfig;
        /**
          * Whether this canvas is currently active  **Purpose**: Indicate which canvas is currently focused/active **Source**: Computed from gridState.activeCanvasId in grid-builder **Default**: false **Visual effect**: Applies 'active' CSS class to grid-container  **Canvas becomes active when**: - User clicks item on canvas - User clicks canvas background - User starts dragging item on canvas - User starts resizing item on canvas - Programmatically via api.setActiveCanvas()  **Consumer styling hook**: Consumer can style active canvas via CSS: ```css .grid-container.active .canvas-title {   opacity: 1; } ```
          * @example ```tsx <canvas-section   canvasId="hero-section"   isActive={gridState.activeCanvasId === 'hero-section'} /> ```
          * @default false
         */
        "isActive"?: boolean;
        /**
          * Deletion hook (from parent grid-builder)  **Source**: grid-builder component (from onBeforeDelete prop) **Purpose**: Pass through to grid-item-wrapper for deletion interception **Optional**: If not provided, components delete immediately
         */
        "onBeforeDelete"?: (context: any) => boolean | Promise<boolean>;
    }
    /**
     * CanvasSectionViewer Component
     * ==============================
     * Rendering-only canvas component for grid-viewer.
     * **Tag**: `<canvas-section-viewer>`
     * **Shadow DOM**: Disabled (consistent with canvas-section)
     * **Reactivity**: Props-based (no global state subscription)
     */
    interface CanvasSectionViewer {
        /**
          * Background color for this canvas  **Optional**: Canvas background color **Default**: '#ffffff'
         */
        "backgroundColor"?: string;
        /**
          * Canvas ID for identification  **Format**: 'canvas1', 'hero-section', etc. **Purpose**: Element ID and data attribute
         */
        "canvasId": string;
        /**
          * Component registry (from parent grid-viewer)  **Source**: grid-viewer component **Structure**: Map<type, ComponentDefinition> **Purpose**: Pass to grid-item-wrapper for dynamic rendering
         */
        "componentRegistry"?: Map<string, ComponentDefinition>;
        /**
          * Grid configuration options  **Optional**: Customizes grid system behavior **Passed from**: grid-viewer component
         */
        "config"?: GridConfig;
        /**
          * Current viewport mode  **Required**: 'desktop' | 'mobile' **Source**: Passed from grid-viewer component  **Purpose**: Determines which layout to render for each item
         */
        "currentViewport": 'desktop' | 'mobile';
        /**
          * Items to render in this canvas  **Required**: Array of GridItem objects **Source**: Passed from grid-viewer component  **Unlike canvas-section**: Items passed via props, not from global state
         */
        "items": GridItem[];
    }
    /**
     * ComponentPalette Component
     * ===========================
     * Library component providing draggable component palette UI.
     * **Tag**: `<component-palette>`
     * **Shadow DOM**: Disabled (for consistency with other components)
     * **Reactivity**: Re-renders when components prop changes
     * ## Usage Patterns
     * **Pattern 1: Default (inside grid-builder)**
     * ```typescript
     * // Palette automatically rendered by grid-builder
     * <grid-builder components={componentDefinitions} />
     * ```
     * **Pattern 2: Independent placement**
     * ```typescript
     * // Place palette anywhere in your app
     * <div class="my-layout">
     *   <aside class="sidebar">
     *     <component-palette
     *       components={componentDefinitions}
     *       config={gridConfig}
     *     />
     *   </aside>
     *   <main>
     *     <grid-builder
     *       components={componentDefinitions}
     *       config={gridConfig}
     *       uiOverrides={{
     *         ComponentPalette: () => null  // Hide default palette
     *       }}
     *     />
     *   </main>
     * </div>
     * ```
     * **Pattern 3: Custom wrapper component**
     * ```typescript
     * // Wrap in your own component for styling
     * @Component ({ tag: 'my-palette-sidebar' })
     * export class MyPaletteSidebar {
     * @Prop () components: ComponentDefinition[];
     * render() {
     * return (
     *  <div class="custom-sidebar">
     *    <h3>Components</h3>
     *    <component-palette components={this.components} />
     *  </div>
     * );
     * }
     * }
     * ```
     * ## Key Features
     * - **Self-contained**: Works independently of grid-builder
     * - **Drag/drop ready**: Uses interact.js for drag functionality
     * - **Flexible placement**: Can be rendered anywhere in DOM
     * - **Works across boundaries**: Drag from palette to any canvas-section
     */
    interface ComponentPalette {
        /**
          * Component definitions to render in palette  **Required prop**: Array of ComponentDefinition objects **Source**: Passed from grid-builder component  **Each definition provides**: - type: Unique identifier for component - name: Display name in palette - icon: Visual identifier (emoji recommended) - defaultSize: Size when dropped (for drag clone sizing)  **Example**: ```typescript const components = [   {     type: 'header',     name: 'Header',     icon: 'üìÑ',     defaultSize: { width: 20, height: 8 },     render: ({ itemId, config }) => <my-header itemId={itemId} config={config} />   } ]; ```
         */
        "components": ComponentDefinition[];
        /**
          * Grid configuration options  **Optional prop**: Customizes grid system behavior **Passed from**: grid-builder component **Used for**: Drag clone sizing (gridToPixelsX/Y calculations)
         */
        "config"?: GridConfig;
        /**
          * Show palette header (title)  **Optional prop**: Controls whether the "Components" header is displayed **Default**: true (shows header for backward compatibility)  **Use cases**: - `showHeader={true}` (default): Standard palette with "Components" title - `showHeader={false}`: Chromeless mode - just the component list  **Chromeless mode benefits**: - Embed palette in custom layouts - Add your own headers/titles - Integrate into existing UI structures - More flexible component placement  **Example - Chromeless with custom wrapper**: ```typescript <div class="my-custom-sidebar">   <h3 class="my-title">Available Components</h3>   <p class="my-description">Drag to add</p>   <component-palette     components={componentDefinitions}     showHeader={false}   /> </div> ```
          * @default true
         */
        "showHeader"?: boolean;
    }
    /**
     * ConfigPanel Component
     * =====================
     * Library component providing configuration panel with auto-generated and custom forms.
     * **Tag**: `<config-panel>`
     * **Shadow DOM**: Disabled (for consistency with other components)
     */
    interface ConfigPanel {
        /**
          * Component registry (from parent grid-builder)  **Source**: grid-builder component **Purpose**: Look up component definitions for config forms
         */
        "componentRegistry"?: Map<string, ComponentDefinition>;
    }
    /**
     * Confirmation Modal Component
     * =============================
     * Demo Component - NOT Part of Library
     * This component demonstrates how to implement the grid-builder library's
     * deletion hook system with a custom confirmation modal.
     * Library Feature Being Demonstrated:
     * -----------------------------------
     * This modal is used with the library's **onBeforeDelete hook** system.
     * How It Works:
     * -------------
     * 1. Library calls onBeforeDelete hook when user deletes component
     * 2. Hook returns a Promise that doesn't resolve immediately
     * 3. Host app shows this modal (or any modal library)
     * 4. User clicks "Delete" or "Cancel"
     * 5. Modal fires confirm/cancel event
     * 6. Host app resolves Promise with true/false
     * 7. Library proceeds with or cancels deletion
     * Code Flow Example:
     * ------------------
     * ```typescript
     * // In parent component (blog-app.tsx):
     * private handleBeforeDelete = (context: DeletionHookContext): Promise<boolean> => {
     *   return new Promise((resolve) => {
     *     this.deleteResolve = resolve;
     *     this.isConfirmModalOpen = true;  // Show this modal
     *   });
     * };
     * private handleConfirmDelete = () => {
     *   this.deleteResolve(true);   // Tell library to proceed
     * };
     * private handleCancelDelete = () => {
     *   this.deleteResolve(false);  // Tell library to cancel
     * };
     * ```
     * Why This Pattern:
     * -----------------
     * - **Library agnostic**: Library doesn't provide modal UI
     * - **Flexibility**: Use any modal library (Material, Bootstrap, Ant Design, etc.)
     * - **Customization**: Full control over modal appearance and behavior
     * - **Async support**: Can make API calls before resolving
     * Alternative Implementations:
     * ---------------------------
     * You could replace this component with:
     * - Material Design modal
     * - Bootstrap modal
     * - Ant Design modal
     * - Native browser confirm() (not recommended)
     * - Custom modal from your design system
     * The library doesn't care what modal you use - it just waits for the
     * Promise to resolve with true/false.
     */
    interface ConfirmationModal {
        /**
          * Modal content (title and message) Passed from parent when showing confirmation
          * @default null
         */
        "data"?: ConfirmationModalData | null;
        /**
          * Modal open/closed state Controlled by parent component (blog-app)
          * @default false
         */
        "isOpen"?: boolean;
        /**
          * Event: User cancelled deletion Parent resolves deletion hook Promise with `false`
         */
        "onCancel"?: (event: ConfirmationModalCustomEvent<void>) => void;
        /**
          * Event: User confirmed deletion Parent resolves deletion hook Promise with `true`
         */
        "onConfirm"?: (event: ConfirmationModalCustomEvent<void>) => void;
    }
    interface CustomConfigPanel {
        /**
          * Grid Builder API (accessed from window.gridBuilderAPI or passed as prop)  **Source**: window.gridBuilderAPI (set by grid-builder component) **Purpose**: Access grid state and methods **Required**: Component won't work without valid API reference
         */
        "api"?: GridBuilderAPI;
    }
    /**
     * Custom Drag Clone Component
     * ============================
     * Custom drag clone that shows a visual preview of the component being dragged.
     * Each component type has a unique appearance that matches what will be placed
     * on the canvas, helping with visual alignment and user understanding.
     * The component fills the exact width and height provided, scaled to match
     * the actual drop size.
     */
    interface CustomDragClone {
        /**
          * Component type being dragged
         */
        "componentType": string;
        /**
          * Height in pixels
         */
        "height": number;
        /**
          * Icon/emoji
         */
        "icon": string;
        /**
          * Display name
         */
        "name": string;
        /**
          * Width in pixels
         */
        "width": number;
    }
    /**
     * Custom Palette Item Component
     * ==============================
     * Example custom palette item that shows how consumers can create
     * fully customized palette entries for their components.
     * Updated to display SVG icons on top with titles below (similar to UI builder pattern)
     */
    interface CustomPaletteItem {
        /**
          * Component type
         */
        "componentType": string;
        /**
          * Icon/emoji or SVG identifier
         */
        "icon": string;
        /**
          * Display name
         */
        "name": string;
    }
    interface DashboardWidget {
    }
    /**
     * GridBuilder Component
     * ======================
     * Main library component providing complete grid builder functionality.
     * **Tag**: `<grid-builder>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Reactivity**: Listens to gridState changes via StencilJS store
     */
    interface GridBuilder {
        /**
          * Custom API exposure configuration  **Optional prop**: Control where and how the Grid Builder API is exposed **Default**: `{ target: window, key: 'gridBuilderAPI' }` **Purpose**: Allows multiple grid-builder instances and flexible API access patterns  **Options**: 1. **Custom key on window** (multiple instances): ```typescript <grid-builder api-ref={{ key: 'gridAPI1' }}></grid-builder> <grid-builder api-ref={{ key: 'gridAPI2' }}></grid-builder> // Access: window.gridAPI1, window.gridAPI2 ```  2. **Custom storage object**: ```typescript const myStore = {}; <grid-builder api-ref={{ target: myStore, key: 'api' }}></grid-builder> // Access: myStore.api ```  3. **Disable automatic exposure** (use ref instead): ```typescript <grid-builder api-ref={null}></grid-builder> // Access via ref: <grid-builder ref={el => this.api = el?.api}></grid-builder> ```
          * @default { target: undefined, key: 'gridBuilderAPI' }
         */
        "apiRef"?: { target?: any; key?: string } | null;
        /**
          * Canvas metadata storage (host app responsibility)  **Optional prop**: Store canvas-level presentation metadata **Purpose**: Host app owns canvas metadata (titles, colors, settings)  **Separation of concerns**: - Library owns placement state (items, layouts, zIndex) - Host app owns presentation state (colors, titles, custom metadata)  **Structure**: Record<canvasId, any>  **Example**: ```typescript const canvasMetadata = {   'hero-section': {     title: 'Hero Section',     backgroundColor: '#f0f4f8',     customSettings: { ... }   },   'articles-grid': {     title: 'Articles Grid',     backgroundColor: '#ffffff'   } }; <grid-builder canvasMetadata={canvasMetadata} ... /> ```  **Use with canvas-click events**: - Library fires canvas-click event when canvas background clicked - Host app shows canvas settings panel - Host app updates canvasMetadata state - Library passes metadata to canvas-section via props
         */
        "canvasMetadata"?: Record<string, any>;
        /**
          * Component definitions registry  **Required prop**: Array of ComponentDefinition objects **Purpose**: Defines available component types (header, text, button, etc.)  **Each definition includes**: - type: Unique identifier (e.g., 'header', 'text-block') - name: Display name in palette - icon: Visual identifier (emoji recommended) - defaultSize: Initial size when dropped - render: Function returning component to render - configSchema: Optional auto-generated config form - renderConfigPanel: Optional custom config UI - Lifecycle hooks: onVisible, onHidden for virtual rendering  **Example**: ```typescript const components = [   {     type: 'header',     name: 'Header',     icon: 'üìÑ',     defaultSize: { width: 20, height: 8 },     render: ({ itemId, config }) => (       <my-header itemId={itemId} config={config} />     ),     configSchema: [       { name: 'text', label: 'Text', type: 'text', defaultValue: 'Header' }     ]   } ]; ```
         */
        "components": ComponentDefinition[];
        /**
          * Grid configuration options  **Optional prop**: Customizes grid system behavior **Default**: Standard 2% grid with 10px-50px constraints  **Configuration options**: - gridSizePercent: Grid unit as % of width (default: 2) - minGridSize: Minimum size in pixels (default: 10) - maxGridSize: Maximum size in pixels (default: 50) - snapToGrid: Enable snap-to-grid (default: true) - showGridLines: Show visual grid (default: true) - minItemSize: Minimum item dimensions (default: { width: 5, height: 4 }) - virtualRenderMargin: Pre-render margin (default: '20%')  **Example**: ```typescript const config = {   gridSizePercent: 3,           // 3% grid (33 units per 100%)   minGridSize: 15,              // 15px minimum   maxGridSize: 60,              // 60px maximum   snapToGrid: true,   virtualRenderMargin: '30%'    // Aggressive pre-loading }; ```
         */
        "config"?: GridConfig;
        /**
          * Initial state to restore  **Optional prop**: Restore saved layout **Purpose**: Load previously saved grid state  **State structure**: Same as gridState (canvases, viewport, etc.)  **Example**: ```typescript const savedState = JSON.parse(localStorage.getItem('grid-state')); <grid-builder initialState={savedState} ... /> ```
         */
        "initialState"?: Partial<GridState>;
        /**
          * Hook called before deleting a component  **Optional prop**: Intercept deletion requests for custom workflows **Purpose**: Allow host app to show confirmation, make API calls, etc.  **Hook behavior**: - Return `true` to proceed with deletion - Return `false` to cancel the deletion - Return a Promise for async operations (modals, API calls)  **Example - Confirmation modal**: ```typescript const onBeforeDelete = async (context) => {   const confirmed = await showConfirmModal(     `Delete ${context.item.name}?`,     'This action cannot be undone.'   );   return confirmed; }; <grid-builder onBeforeDelete={onBeforeDelete} ... /> ```  **Example - API call + confirmation**: ```typescript const onBeforeDelete = async (context) => {   // Show loading modal   const modal = showLoadingModal('Deleting...');    try {     // Make API call     await fetch(`/api/components/${context.itemId}`, {       method: 'DELETE'     });     modal.close();     return true; // Proceed with deletion   } catch (error) {     modal.close();     showErrorModal('Failed to delete component');     return false; // Cancel deletion   } }; ```  **Default behavior**: If not provided, components delete immediately
         */
        "onBeforeDelete"?: DeletionHook;
        /**
          * Plugin instances for extending functionality  **Optional prop**: Array of GridBuilderPlugin instances **Purpose**: Add custom features, analytics, integrations  **Plugin lifecycle**: 1. Library calls plugin.init(api) on componentDidLoad 2. Plugin subscribes to events, adds UI, etc. 3. Library calls plugin.destroy() on disconnectedCallback  **Example**: ```typescript class AnalyticsPlugin implements GridBuilderPlugin {   name = 'analytics';    init(api: GridBuilderAPI) {     api.on('componentAdded', (e) => {       analytics.track('Component Added', { type: e.item.type });     });   }    destroy() {     // Cleanup   } }  const plugins = [new AnalyticsPlugin()]; ```
         */
        "plugins"?: GridBuilderPlugin[];
        /**
          * Visual theme customization  **Optional prop**: Customizes colors, fonts, and styling **Default**: Bootstrap-inspired blue theme  **Theme options**: - primaryColor: Accent color (default: '#007bff') - paletteBackground: Palette sidebar color (default: '#f5f5f5') - canvasBackground: Canvas background (default: '#ffffff') - gridLineColor: Grid line color (default: 'rgba(0,0,0,0.1)') - selectionColor: Selection outline (default: '#007bff') - resizeHandleColor: Resize handle color (default: '#007bff') - fontFamily: UI font (default: system font stack) - customProperties: CSS variables for advanced theming  **Example**: ```typescript const theme = {   primaryColor: '#ff6b6b',        // Brand red   paletteBackground: '#fff5f5',   // Light red   customProperties: {     '--text-color': '#ffffff',     '--border-radius': '8px'   } }; ```
         */
        "theme"?: GridBuilderTheme;
        /**
          * Custom UI component overrides  **Optional prop**: Replace default UI components **Purpose**: Fully customize visual appearance  **Overridable components**: - ConfigPanel: Configuration panel UI - ComponentPalette: Component palette sidebar - Toolbar: Top toolbar with controls  **Example**: ```typescript const uiOverrides = {   Toolbar: (props) => (     <div class="my-toolbar">       <button onClick={props.onUndo}>Undo</button>       <button onClick={props.onRedo}>Redo</button>     </div>   ) }; ```
         */
        "uiOverrides"?: UIComponentOverrides;
    }
    /**
     * GridItemWrapper Component
     * ==========================
     * Library component wrapping individual grid items with drag/resize/selection.
     * **Tag**: `<grid-item-wrapper>`
     * **Shadow DOM**: Disabled (required for interact.js compatibility)
     * **Dynamic rendering**: Uses ComponentDefinition.render() from registry
     */
    interface GridItemWrapper {
        /**
          * All items in the canvas (for viewer mode auto-layout)  **Purpose**: Calculate mobile auto-layout positions **Source**: grid-viewer ‚Üí canvas-section-viewer ‚Üí grid-item-wrapper **Used by**: render() to calculate stacked positions in mobile viewport  **Note**: When in builder mode (viewerMode=false), this is ignored and gridState.canvases is used instead. When in viewer mode (viewerMode=true), this prop is required for mobile auto-layout.
         */
        "canvasItems"?: GridItem[];
        /**
          * Component registry (from parent grid-builder)  **Source**: grid-builder component (built from components prop) **Structure**: Map<type, ComponentDefinition> **Purpose**: Look up component definitions for dynamic rendering  **Note**: This is passed as a workaround since StencilJS doesn't have good support for context/provide-inject patterns. In a production app, consider using a global registry or context provider.
         */
        "componentRegistry"?: Map<string, ComponentDefinition>;
        /**
          * Grid configuration options  **Optional**: Customizes grid system behavior **Passed from**: grid-builder ‚Üí canvas-section ‚Üí grid-item-wrapper **Used for**: Grid size calculations with constraints
         */
        "config"?: GridConfig;
        /**
          * Current viewport (for viewer mode)  **Purpose**: Determine which layout to render (desktop or mobile) **Source**: grid-viewer ‚Üí canvas-section-viewer ‚Üí grid-item-wrapper **Used by**: render() to select appropriate layout  **Note**: When in builder mode (viewerMode=false), this is ignored and gridState.currentViewport is used instead. When in viewer mode (viewerMode=true), this prop is required.
         */
        "currentViewport"?: 'desktop' | 'mobile';
        /**
          * Grid item data (position, size, type, etc.)  **Source**: Parent canvas-section component **Contains**: id, canvasId, type, name, layouts (desktop/mobile), zIndex, config
         */
        "item": GridItem;
        /**
          * Deletion hook (from parent grid-builder)  **Source**: grid-builder component (from onBeforeDelete prop) **Purpose**: Allow host app to intercept deletion requests  **Hook behavior**: - Called before deleting a component - Receives context with item data - Returns true/false or Promise<boolean> - If false, deletion is cancelled - If true, deletion proceeds  **Default**: If not provided, components delete immediately
         */
        "onBeforeDelete"?: (context: any) => boolean | Promise<boolean>;
        /**
          * Render version (force re-render trigger)  **Source**: Parent canvas-section (incremented on resize) **Purpose**: Force grid calculation refresh when container resizes
         */
        "renderVersion"?: number;
        /**
          * Viewer mode flag  **Purpose**: Disable editing features for rendering-only mode **Default**: false (editing enabled)  **When true**: - ‚ùå No drag-and-drop handlers - ‚ùå No resize handles - ‚ùå No item header (drag handle) - ‚ùå No delete button - ‚ùå No selection state - ‚úÖ Only renders component content  **Use case**: grid-viewer component for display-only mode
          * @default false
         */
        "viewerMode"?: boolean;
    }
    /**
     * GridViewer Component
     * ====================
     * Rendering-only grid component for displaying layouts created in grid-builder.
     * **Tag**: `<grid-viewer>`
     * **Shadow DOM**: Disabled (consistent with grid-builder)
     * **Reactivity**: Uses local store for viewer state
     * **Key differences from grid-builder**:
     * - No interact.js dependency (80% bundle size reduction)
     * - No palette, config panel, or editing UI
     * - Simplified state (no selection, no z-index tracking)
     * - Rendering-only canvas sections
     */
    interface GridViewer {
        /**
          * Canvas metadata storage (host app responsibility)  **Optional prop**: Store canvas-level presentation metadata **Purpose**: Host app owns canvas metadata (titles, colors, settings)  **Structure**: Record<canvasId, any>  **Example**: ```typescript const canvasMetadata = {   'hero-section': {     backgroundColor: '#f0f4f8',     customSettings: { ... }   } }; ```
         */
        "canvasMetadata"?: Record<string, any>;
        /**
          * Component definitions registry  **Required prop**: Array of ComponentDefinition objects **Purpose**: Defines how to render each component type  **Must match builder definitions**: Same component types as used in builder  **Example**: ```typescript const components = [   {     type: 'header',     name: 'Header',     icon: 'üìÑ',     render: ({ itemId, config }) => (       <my-header itemId={itemId} config={config} />     )   } ]; ```
         */
        "components": ComponentDefinition[];
        /**
          * Grid configuration options  **Optional prop**: Grid system configuration **Default**: Standard 2% grid with 10px-50px constraints  **Should match builder config**: Use same config as builder for consistent rendering
         */
        "config"?: GridConfig;
        /**
          * Initial state to display  **Optional prop**: Layout data to render **Accepts**: ViewerState or GridExport (both compatible)  **From builder export**: ```typescript const exportData = await builder.exportState(); viewer.initialState = exportData; // Type-safe! ```  **From API**: ```typescript const layout = await fetch('/api/layouts/123').then(r => r.json()); viewer.initialState = layout; ```
         */
        "initialState"?: Partial<ViewerState> | GridExport;
        /**
          * Visual theme customization  **Optional prop**: Customizes colors, fonts, and styling **Default**: Bootstrap-inspired blue theme
         */
        "theme"?: GridBuilderTheme;
    }
    interface ImageGallery {
        /**
          * @default 6
         */
        "imageCount"?: number;
    }
    interface LiveData {
    }
    /**
     * Section Editor Panel Component
     * ===============================
     * Demo Component - NOT Part of Library
     * This component demonstrates how to build custom UI for editing canvas metadata
     * in applications using the grid-builder library.
     * Purpose:
     * --------
     * Shows how to create a side panel for editing section/canvas settings.
     * This is completely custom to your application - the library doesn't provide this.
     * Library Relationship:
     * ---------------------
     * - Library owns: Component placement, layouts, zIndex (grid state)
     * - Host app owns: Canvas metadata (titles, colors, settings) - THIS COMPONENT
     * - Metadata flows: App ‚Üí Library via canvasMetadata prop
     * Pattern Demonstrated:
     * ---------------------
     * 1. User clicks section header (demo UI)
     * 2. App opens this panel (demo component)
     * 3. User edits title/color
     * 4. App updates canvasMetadata state
     * 5. Library receives updated metadata via prop
     * 6. Library passes backgroundColor to canvas-section
     * Why This Approach:
     * ------------------
     * - Library stays focused on grid logic
     * - Host app controls all presentation/metadata UI
     * - You can use any UI framework (Material, Bootstrap, etc.)
     * - Complete flexibility over settings panel design
     */
    interface SectionEditorPanel {
        /**
          * Panel open/closed state Controlled by parent component (blog-app)
          * @default false
         */
        "isOpen"?: boolean;
        /**
          * Event: Close panel Fired when user clicks Cancel, Save, or overlay
         */
        "onClosePanel"?: (event: SectionEditorPanelCustomEvent<void>) => void;
        /**
          * Event: Delete section Fired when user clicks Delete button Parent handles canvas removal
         */
        "onDeleteSection"?: (event: SectionEditorPanelCustomEvent<{ canvasId: string }>) => void;
        /**
          * Event: Preview color change Fired when user changes color picker (live preview) Parent temporarily updates canvas background
         */
        "onPreviewColorChange"?: (event: SectionEditorPanelCustomEvent<{ canvasId: string; backgroundColor: string }>) => void;
        /**
          * Event: Preview title change Fired when user types in title input (live preview) Parent temporarily updates canvas title
         */
        "onPreviewTitleChange"?: (event: SectionEditorPanelCustomEvent<{ canvasId: string; title: string }>) => void;
        /**
          * Event: Update section Fired when user clicks Save with edited values Parent updates canvasMetadata state in response
         */
        "onUpdateSection"?: (event: SectionEditorPanelCustomEvent<{ canvasId: string; title: string; backgroundColor: string }>) => void;
        /**
          * Section data being edited Passed from parent when user clicks section header
          * @default null
         */
        "sectionData"?: SectionEditorData | null;
    }
    interface IntrinsicElements {
        "blog-app": BlogApp;
        "blog-article": BlogArticle;
        "blog-button": BlogButton;
        "blog-header": BlogHeader;
        "blog-image": BlogImage;
        "canvas-header": CanvasHeader;
        "canvas-section": CanvasSection;
        "canvas-section-viewer": CanvasSectionViewer;
        "component-palette": ComponentPalette;
        "config-panel": ConfigPanel;
        "confirmation-modal": ConfirmationModal;
        "custom-config-panel": CustomConfigPanel;
        "custom-drag-clone": CustomDragClone;
        "custom-palette-item": CustomPaletteItem;
        "dashboard-widget": DashboardWidget;
        "grid-builder": GridBuilder;
        "grid-item-wrapper": GridItemWrapper;
        "grid-viewer": GridViewer;
        "image-gallery": ImageGallery;
        "live-data": LiveData;
        "section-editor-panel": SectionEditorPanel;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Blog App Demo - Host Application for grid-builder Library
             * ==========================================================
             * This component demonstrates how to build a complete page builder application
             * using the
             * @lucidworks /stencil-grid-builder library.
             * Key Library Features Demonstrated:
             * ----------------------------------
             * 1. **Component Registry** (components prop)
             * - Pass array of ComponentDefinition objects to grid-builder
             * - Library uses these to render palette and components
             * - See: blogComponentDefinitions in component-definitions.tsx
             * 2. **Initial State** (initialState prop)
             * - Pre-populate canvases with components
             * - Define layouts for desktop and mobile viewports
             * - Library manages state updates via internal store
             * 3. **Canvas Metadata** (canvasMetadata prop)
             * - Host app owns presentation metadata (titles, colors, settings)
             * - Library owns placement state (items, layouts, zIndex)
             * - Separation of concerns pattern
             * 4. **Deletion Hook** (onBeforeDelete prop)
             * - Intercept component deletion requests
             * - Show confirmation modals before deletion
             * - Make API calls or run custom validation
             * - Return Promise<boolean> to approve/cancel deletion
             * 5. **Grid Builder API** (configurable storage via api-ref prop)
             * - Programmatic control of grid state
             * - Methods: addCanvas, removeCanvas, undo, redo, etc.
             * - Event system: canvasAdded, canvasRemoved, etc.
             * - **Demo uses custom storage**: api-ref={{ target: this, key: 'api' }}
             * - API stored on component instance (this.api) instead of window
             * 6. **Event System** (canvas-click, custom events)
             * - Listen to library events for state synchronization
             * - React to user interactions (canvas clicks, etc.)
             * 7. **Multiple Palettes Pattern** (Demonstrated in this demo)
             * - Multiple `<component-palette>` instances with different components
             * - Categorized/grouped components (Content, Interactive, etc.)
             * - Collapsible category sections
             * - All palettes drag to the same canvases
             * 8. **Custom Config Panel** (Demonstrated with custom-config-panel component)
             * - Replace library's default config panel with custom UI
             * - Access grid state via API (this.api in this demo)
             * - Implement live preview for real-time updates
             * - Support cancel/revert functionality
             * - Subscribe to componentDeleted events for auto-close
             * - See: src/demo/components/custom-config-panel/
             * Architecture Pattern:
             * --------------------
             * - Library: Manages component placement, drag/drop, resize, undo/redo
             * - Host App: Manages canvas metadata, custom UI (headers, modals), business logic
             * ## Multiple Palettes Pattern (Featured in this Demo)
             * **Why use multiple palettes:**
             * - Better component organization (group by category, purpose, or feature)
             * - Collapsible sections save screen space
             * - Easier to find components in large libraries
             * - Matches common UI patterns (like the example mockup)
             * **How it works:**
             * 1. Create categorized component arrays:
             * ```typescript
             * const contentComponents = [header, article, ...];
             * const interactiveComponents = [button, link, ...];
             * ```
             * 2. Render multiple `<component-palette>` instances:
             * ```typescript
             * <component-palette components={contentComponents} showHeader={false} />
             * <component-palette components={interactiveComponents} showHeader={false} />
             * ```
             * 3. All palettes work with the same canvases:
             * - Each palette initializes its own drag handlers
             * - All drag to the same `<canvas-section>` dropzones
             * - Component type (not palette source) determines behavior
             * - grid-builder registers ALL components for rendering
             * **Key Points:**
             * - Pass all components to grid-builder (for type registration)
             * - Use chromeless mode (`showHeader={false}`) for custom headers
             * - Each palette manages its own drag/drop independently
             * - Canvases accept drops from any palette
             * - No coordination needed between palettes
             * **Implementation in this demo:**
             * - Content category: Headers, Articles (text-based components)
             * - Interactive category: Buttons, CTAs (action components)
             * - Collapsible sections with expand/collapse state
             * - Clean categorized UI matching modern design patterns
             * ## Custom Config Panel Pattern (Featured in this Demo)
             * **Why use a custom config panel:**
             * - Match your application's design system and branding
             * - Add custom validation or business logic
             * - Integrate with other parts of your application
             * - Control the user experience and workflow
             * **How it works:**
             * 1. Disable the library's default config panel using the showConfigPanel prop:
             * ```typescript
             * <grid-builder
             * components={components}
             * showConfigPanel={false}  // Hide default config panel
             * ...
             * />
             * ```
             * 2. Access the Grid Builder API:
             * ```typescript
             * const api = (window as any).gridBuilderAPI;
             * ```
             * 3. Listen for item-click events:
             * ```typescript
             * document.addEventListener('item-click', (event: CustomEvent) => {
             * const { itemId, canvasId } = event.detail;
             * // Open your custom panel
             * });
             * ```
             * 4. Implement live preview by directly updating state:
             * ```typescript
             * const state = api.getState();
             * const canvas = state.canvases[canvasId];
             * canvas.items[itemIndex] = {
             * ...canvas.items[itemIndex],
             * name: newValue
             * };
             * // Trigger reactivity
             * state.canvases = { ...state.canvases };
             * ```
             * 5. Implement cancel/revert by storing original state:
             * ```typescript
             * // On panel open, store original values
             * this.originalState = {
             * name: item.name,
             * config: { ...item.config }
             * };
             * // On cancel, restore original values
             * api.updateConfig(itemId, this.originalState.config);
             * // Restore name using same pattern as live preview
             * ```
             * 6. Subscribe to componentDeleted for auto-close:
             * ```typescript
             * api.on('componentDeleted', (event) => {
             * if (event.itemId === this.selectedItemId) {
             * this.closePanel();
             * }
             * });
             * ```
             * **Key Library APIs Used:**
             * - `window.gridBuilderAPI` - Global API instance
             * - `api.getState()` - Get current grid state for direct manipulation
             * - `api.getItem(itemId)` - Find item across all canvases
             * - `api.updateConfig(itemId, config)` - Update item configuration
             * - `api.on(event, handler)` - Subscribe to library events
             * - `api.off(event, handler)` - Unsubscribe from library events
             * **Event-driven Integration:**
             * - `item-click` - Fired when user clicks a component (use document.addEventListener)
             * - `componentDeleted` - Fired when a component is deleted (use api.on)
             * - Manual event listeners required for custom events on document
             * **Implementation in this demo:**
             * - See `custom-config-panel.tsx` for complete implementation
             * - Purple gradient styling matching blog theme
             * - Live preview for component name and config fields
             * - Cancel button reverts all changes
             * - Save button persists changes
             * - Auto-closes when selected component is deleted
             */
            "blog-app": LocalJSX.BlogApp & JSXBase.HTMLAttributes<HTMLBlogAppElement>;
            "blog-article": LocalJSX.BlogArticle & JSXBase.HTMLAttributes<HTMLBlogArticleElement>;
            "blog-button": LocalJSX.BlogButton & JSXBase.HTMLAttributes<HTMLBlogButtonElement>;
            "blog-header": LocalJSX.BlogHeader & JSXBase.HTMLAttributes<HTMLBlogHeaderElement>;
            "blog-image": LocalJSX.BlogImage & JSXBase.HTMLAttributes<HTMLBlogImageElement>;
            /**
             * CanvasHeader Component
             * ======================
             * Declarative header component for canvas sections.
             * **Tag**: `<canvas-header>`
             * **Shadow DOM**: Disabled (matches blog-app styling)
             */
            "canvas-header": LocalJSX.CanvasHeader & JSXBase.HTMLAttributes<HTMLCanvasHeaderElement>;
            /**
             * CanvasSection Component
             * =======================
             * Library component providing individual canvas dropzone.
             * **Tag**: `<canvas-section>`
             * **Shadow DOM**: Disabled (required for interact.js compatibility)
             * **Reactivity**: Listens to gridState changes via StencilJS store
             */
            "canvas-section": LocalJSX.CanvasSection & JSXBase.HTMLAttributes<HTMLCanvasSectionElement>;
            /**
             * CanvasSectionViewer Component
             * ==============================
             * Rendering-only canvas component for grid-viewer.
             * **Tag**: `<canvas-section-viewer>`
             * **Shadow DOM**: Disabled (consistent with canvas-section)
             * **Reactivity**: Props-based (no global state subscription)
             */
            "canvas-section-viewer": LocalJSX.CanvasSectionViewer & JSXBase.HTMLAttributes<HTMLCanvasSectionViewerElement>;
            /**
             * ComponentPalette Component
             * ===========================
             * Library component providing draggable component palette UI.
             * **Tag**: `<component-palette>`
             * **Shadow DOM**: Disabled (for consistency with other components)
             * **Reactivity**: Re-renders when components prop changes
             * ## Usage Patterns
             * **Pattern 1: Default (inside grid-builder)**
             * ```typescript
             * // Palette automatically rendered by grid-builder
             * <grid-builder components={componentDefinitions} />
             * ```
             * **Pattern 2: Independent placement**
             * ```typescript
             * // Place palette anywhere in your app
             * <div class="my-layout">
             *   <aside class="sidebar">
             *     <component-palette
             *       components={componentDefinitions}
             *       config={gridConfig}
             *     />
             *   </aside>
             *   <main>
             *     <grid-builder
             *       components={componentDefinitions}
             *       config={gridConfig}
             *       uiOverrides={{
             *         ComponentPalette: () => null  // Hide default palette
             *       }}
             *     />
             *   </main>
             * </div>
             * ```
             * **Pattern 3: Custom wrapper component**
             * ```typescript
             * // Wrap in your own component for styling
             * @Component ({ tag: 'my-palette-sidebar' })
             * export class MyPaletteSidebar {
             * @Prop () components: ComponentDefinition[];
             * render() {
             * return (
             *  <div class="custom-sidebar">
             *    <h3>Components</h3>
             *    <component-palette components={this.components} />
             *  </div>
             * );
             * }
             * }
             * ```
             * ## Key Features
             * - **Self-contained**: Works independently of grid-builder
             * - **Drag/drop ready**: Uses interact.js for drag functionality
             * - **Flexible placement**: Can be rendered anywhere in DOM
             * - **Works across boundaries**: Drag from palette to any canvas-section
             */
            "component-palette": LocalJSX.ComponentPalette & JSXBase.HTMLAttributes<HTMLComponentPaletteElement>;
            /**
             * ConfigPanel Component
             * =====================
             * Library component providing configuration panel with auto-generated and custom forms.
             * **Tag**: `<config-panel>`
             * **Shadow DOM**: Disabled (for consistency with other components)
             */
            "config-panel": LocalJSX.ConfigPanel & JSXBase.HTMLAttributes<HTMLConfigPanelElement>;
            /**
             * Confirmation Modal Component
             * =============================
             * Demo Component - NOT Part of Library
             * This component demonstrates how to implement the grid-builder library's
             * deletion hook system with a custom confirmation modal.
             * Library Feature Being Demonstrated:
             * -----------------------------------
             * This modal is used with the library's **onBeforeDelete hook** system.
             * How It Works:
             * -------------
             * 1. Library calls onBeforeDelete hook when user deletes component
             * 2. Hook returns a Promise that doesn't resolve immediately
             * 3. Host app shows this modal (or any modal library)
             * 4. User clicks "Delete" or "Cancel"
             * 5. Modal fires confirm/cancel event
             * 6. Host app resolves Promise with true/false
             * 7. Library proceeds with or cancels deletion
             * Code Flow Example:
             * ------------------
             * ```typescript
             * // In parent component (blog-app.tsx):
             * private handleBeforeDelete = (context: DeletionHookContext): Promise<boolean> => {
             *   return new Promise((resolve) => {
             *     this.deleteResolve = resolve;
             *     this.isConfirmModalOpen = true;  // Show this modal
             *   });
             * };
             * private handleConfirmDelete = () => {
             *   this.deleteResolve(true);   // Tell library to proceed
             * };
             * private handleCancelDelete = () => {
             *   this.deleteResolve(false);  // Tell library to cancel
             * };
             * ```
             * Why This Pattern:
             * -----------------
             * - **Library agnostic**: Library doesn't provide modal UI
             * - **Flexibility**: Use any modal library (Material, Bootstrap, Ant Design, etc.)
             * - **Customization**: Full control over modal appearance and behavior
             * - **Async support**: Can make API calls before resolving
             * Alternative Implementations:
             * ---------------------------
             * You could replace this component with:
             * - Material Design modal
             * - Bootstrap modal
             * - Ant Design modal
             * - Native browser confirm() (not recommended)
             * - Custom modal from your design system
             * The library doesn't care what modal you use - it just waits for the
             * Promise to resolve with true/false.
             */
            "confirmation-modal": LocalJSX.ConfirmationModal & JSXBase.HTMLAttributes<HTMLConfirmationModalElement>;
            "custom-config-panel": LocalJSX.CustomConfigPanel & JSXBase.HTMLAttributes<HTMLCustomConfigPanelElement>;
            /**
             * Custom Drag Clone Component
             * ============================
             * Custom drag clone that shows a visual preview of the component being dragged.
             * Each component type has a unique appearance that matches what will be placed
             * on the canvas, helping with visual alignment and user understanding.
             * The component fills the exact width and height provided, scaled to match
             * the actual drop size.
             */
            "custom-drag-clone": LocalJSX.CustomDragClone & JSXBase.HTMLAttributes<HTMLCustomDragCloneElement>;
            /**
             * Custom Palette Item Component
             * ==============================
             * Example custom palette item that shows how consumers can create
             * fully customized palette entries for their components.
             * Updated to display SVG icons on top with titles below (similar to UI builder pattern)
             */
            "custom-palette-item": LocalJSX.CustomPaletteItem & JSXBase.HTMLAttributes<HTMLCustomPaletteItemElement>;
            "dashboard-widget": LocalJSX.DashboardWidget & JSXBase.HTMLAttributes<HTMLDashboardWidgetElement>;
            /**
             * GridBuilder Component
             * ======================
             * Main library component providing complete grid builder functionality.
             * **Tag**: `<grid-builder>`
             * **Shadow DOM**: Disabled (required for interact.js compatibility)
             * **Reactivity**: Listens to gridState changes via StencilJS store
             */
            "grid-builder": LocalJSX.GridBuilder & JSXBase.HTMLAttributes<HTMLGridBuilderElement>;
            /**
             * GridItemWrapper Component
             * ==========================
             * Library component wrapping individual grid items with drag/resize/selection.
             * **Tag**: `<grid-item-wrapper>`
             * **Shadow DOM**: Disabled (required for interact.js compatibility)
             * **Dynamic rendering**: Uses ComponentDefinition.render() from registry
             */
            "grid-item-wrapper": LocalJSX.GridItemWrapper & JSXBase.HTMLAttributes<HTMLGridItemWrapperElement>;
            /**
             * GridViewer Component
             * ====================
             * Rendering-only grid component for displaying layouts created in grid-builder.
             * **Tag**: `<grid-viewer>`
             * **Shadow DOM**: Disabled (consistent with grid-builder)
             * **Reactivity**: Uses local store for viewer state
             * **Key differences from grid-builder**:
             * - No interact.js dependency (80% bundle size reduction)
             * - No palette, config panel, or editing UI
             * - Simplified state (no selection, no z-index tracking)
             * - Rendering-only canvas sections
             */
            "grid-viewer": LocalJSX.GridViewer & JSXBase.HTMLAttributes<HTMLGridViewerElement>;
            "image-gallery": LocalJSX.ImageGallery & JSXBase.HTMLAttributes<HTMLImageGalleryElement>;
            "live-data": LocalJSX.LiveData & JSXBase.HTMLAttributes<HTMLLiveDataElement>;
            /**
             * Section Editor Panel Component
             * ===============================
             * Demo Component - NOT Part of Library
             * This component demonstrates how to build custom UI for editing canvas metadata
             * in applications using the grid-builder library.
             * Purpose:
             * --------
             * Shows how to create a side panel for editing section/canvas settings.
             * This is completely custom to your application - the library doesn't provide this.
             * Library Relationship:
             * ---------------------
             * - Library owns: Component placement, layouts, zIndex (grid state)
             * - Host app owns: Canvas metadata (titles, colors, settings) - THIS COMPONENT
             * - Metadata flows: App ‚Üí Library via canvasMetadata prop
             * Pattern Demonstrated:
             * ---------------------
             * 1. User clicks section header (demo UI)
             * 2. App opens this panel (demo component)
             * 3. User edits title/color
             * 4. App updates canvasMetadata state
             * 5. Library receives updated metadata via prop
             * 6. Library passes backgroundColor to canvas-section
             * Why This Approach:
             * ------------------
             * - Library stays focused on grid logic
             * - Host app controls all presentation/metadata UI
             * - You can use any UI framework (Material, Bootstrap, etc.)
             * - Complete flexibility over settings panel design
             */
            "section-editor-panel": LocalJSX.SectionEditorPanel & JSXBase.HTMLAttributes<HTMLSectionEditorPanelElement>;
        }
    }
}
