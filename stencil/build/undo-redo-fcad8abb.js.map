{"file":"undo-redo-fcad8abb.js","mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuVA;;;;;;MAMM,EAAE,KAAK,EAAE,aAAa,EAAE,GAAG,WAAW,CAAgB;IAC1D,OAAO,EAAE,KAAK;IACd,OAAO,EAAE,KAAK;CACf,EAAE;AAIH;;;;;;;AAQA;;;;;;;;;;;;;;;AAeA,MAAM,cAAc,GAAc,EAAE,CAAC;AAErC;;;;;;;;;;;;;;;;AAgBA,IAAI,eAAe,GAAW,CAAC,CAAC,CAAC;AAEjC;;;;;;;;;;AAUA,MAAM,WAAW,GAAG,EAAE,CAAC;AAEvB;;;;AAIA,SAAS,kBAAkB;IACzB,aAAa,CAAC,OAAO,GAAG,eAAe,IAAI,CAAC,CAAC;IAC7C,aAAa,CAAC,OAAO,GAAG,eAAe,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;AACtE,CAAC;AAED;;;;SAIgB,WAAW,CAAC,OAAgB;;IAE1C,cAAc,CAAC,MAAM,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;;IAG3C,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;;IAG7B,IAAI,cAAc,CAAC,MAAM,GAAG,WAAW,EAAE;QACvC,cAAc,CAAC,KAAK,EAAE,CAAC;KACxB;SAAM;QACL,eAAe,EAAE,CAAC;KACnB;;IAGD,kBAAkB,EAAE,CAAC;AACvB,CAAC;AAED;;;SAGgB,IAAI;IAClB,IAAI,eAAe,GAAG,CAAC,EAAE;QACvB,OAAO;KACR;IAED,MAAM,OAAO,GAAG,cAAc,CAAC,eAAe,CAAC,CAAC;IAChD,OAAO,CAAC,IAAI,EAAE,CAAC;IACf,eAAe,EAAE,CAAC;IAElB,kBAAkB,EAAE,CAAC;AACvB,CAAC;AAED;;;SAGgB,IAAI;IAClB,IAAI,eAAe,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;QAChD,OAAO;KACR;IAED,eAAe,EAAE,CAAC;IAClB,MAAM,OAAO,GAAG,cAAc,CAAC,eAAe,CAAC,CAAC;IAChD,OAAO,CAAC,IAAI,EAAE,CAAC;IAEf,kBAAkB,EAAE,CAAC;AACvB,CAAC;AAED;;;SAGgB,OAAO;IACrB,OAAO,eAAe,IAAI,CAAC,CAAC;AAC9B,CAAC;AAED;;;SAGgB,OAAO;IACrB,OAAO,eAAe,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;AACrD,CAAC;AAED;;;SAGgB,YAAY;IAC1B,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;IAC1B,eAAe,GAAG,CAAC,CAAC,CAAC;IACrB,kBAAkB,EAAE,CAAC;AACvB;;;;","names":[],"sources":["src/services/undo-redo.ts"],"sourcesContent":["/**\n * Undo/Redo Service\n * ==================\n *\n * Command pattern implementation for undo/redo functionality in the grid builder.\n * Provides stack-based history management with keyboard shortcuts and UI state tracking.\n *\n * ## Problem\n *\n * Interactive applications need undo/redo capabilities for:\n * - Recovering from mistakes (accidental delete)\n * - Experimenting with layouts (try different arrangements)\n * - Learning the interface (undo to see what changed)\n * - Building confidence (knowing you can undo)\n *\n * **Without undo/redo**:\n * - Users hesitant to experiment\n * - Mistakes are permanent\n * - No way to review history\n * - Poor user experience\n *\n * ## Solution\n *\n * Implement **Command Pattern** with stack-based history:\n *\n * 1. **Command Interface**: Each undoable action implements undo() and redo()\n * 2. **History Stack**: Array of command objects\n * 3. **Position Pointer**: Tracks current position in history\n * 4. **Bounded History**: Limited to 50 commands to prevent memory bloat\n * 5. **Branching**: New actions after undo discard \"future\" history\n *\n * ## Architecture: Command Pattern\n *\n * **Classic Gang of Four pattern** for undo/redo:\n *\n * **Key Components**:\n * - **Command Interface**: Defines undo() and redo() methods\n * - **Concrete Commands**: AddItemCommand, DeleteItemCommand, MoveItemCommand, ResizeCommand\n * - **Invoker**: undo-redo.ts (this file) manages command execution\n * - **Receiver**: state-manager.ts (receives state mutations)\n *\n * **Flow**:\n * ```\n * User Action → Create Command → pushCommand() → Execute & Store\n * Undo (Ctrl+Z) → Get command at position → command.undo() → Update position\n * Redo (Ctrl+Y) → Advance position → command.redo() → Execute\n * ```\n *\n * **Why Command Pattern**:\n * - ✅ Encapsulates actions as objects\n * - ✅ Enables undo/redo without coupling to specific operations\n * - ✅ Supports macro commands (batch operations)\n * - ✅ Easy to extend with new command types\n * - ✅ History can be serialized/persisted\n *\n * ## History Management\n *\n * **Stack-based with position pointer**:\n * ```\n * commandHistory = [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                                  ↑\n *                            historyPosition = 2\n * ```\n *\n * **Operations**:\n * - **Push new command**: Discard commands after position, append new command\n * - **Undo**: Execute command.undo() at position, decrement position\n * - **Redo**: Increment position, execute command.redo() at new position\n *\n * **Branching behavior** (discarding future on new action):\n * ```\n * Initial:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                         ↑ position = 2\n *\n * Undo 2x:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                  ↑ position = 0\n *\n * New cmd:  [cmd1, cmd6]  ← cmd2-cmd5 discarded!\n *                  ↑ position = 1\n * ```\n *\n * **Why branching (not tree)**:\n * - Simpler mental model for users\n * - No UI complexity for branch navigation\n * - Standard undo/redo UX pattern\n *\n * ## Memory Management\n *\n * **Bounded history** (MAX_HISTORY = 50):\n * - Prevents unbounded memory growth\n * - Removes oldest command when limit reached\n * - 50 commands ≈ typical user session\n *\n * **Memory per command**:\n * - Command object: ~200-500 bytes\n * - State snapshots: ~1-5 KB (JSON serialized GridItem)\n * - Total for 50 commands: ~50-250 KB (acceptable)\n *\n * **Sliding window approach**:\n * ```\n * When history full:\n * [cmd1, cmd2, ..., cmd50]  ← At capacity\n * Push cmd51:\n * [cmd2, cmd3, ..., cmd51]  ← cmd1 removed\n * ```\n *\n * ## State Snapshot Strategy\n *\n * Each command stores **before/after snapshots**:\n * ```typescript\n * class MoveItemCommand implements Command {\n *   beforeState = JSON.parse(JSON.stringify(item));  // Deep clone\n *   afterState = JSON.parse(JSON.stringify(updatedItem));\n *\n *   undo() { restoreState(beforeState); }\n *   redo() { restoreState(afterState); }\n * }\n * ```\n *\n * **Deep cloning required because**:\n * - Prevents mutations from affecting snapshots\n * - Ensures independent state copies\n * - Simple and reliable (no reference tracking needed)\n *\n * **Trade-off**:\n * - ✅ Simple implementation\n * - ✅ No reference bugs\n * - ❌ Higher memory usage than delta-based\n * - ❌ Slower than structural sharing (acceptable for this use case)\n *\n * ## Keyboard Shortcuts\n *\n * Implemented in grid-builder-app.tsx:\n * - **Ctrl+Z** (Cmd+Z on Mac): Undo last command\n * - **Ctrl+Y** (Cmd+Y on Mac): Redo next command\n * - **Ctrl+Shift+Z**: Alternative redo (common in design tools)\n *\n * ## UI Integration\n *\n * **Reactive state for buttons**:\n * ```typescript\n * undoRedoState = {\n *   canUndo: boolean,  // Enable/disable undo button\n *   canRedo: boolean   // Enable/disable redo button\n * }\n * ```\n *\n * **Updates on**:\n * - New command pushed\n * - Undo executed\n * - Redo executed\n * - History cleared\n *\n * **Button rendering**:\n * ```tsx\n * <button disabled={!undoRedoState.canUndo} onClick={undo}>\n *   Undo\n * </button>\n * ```\n *\n * ## Extracting This Pattern\n *\n * To adapt Command pattern for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * interface Command {\n *   undo(): void;\n *   redo(): void;\n * }\n *\n * class UndoRedoManager {\n *   private history: Command[] = [];\n *   private position = -1;\n *\n *   push(command: Command) {\n *     this.history.splice(this.position + 1);  // Discard future\n *     this.history.push(command);\n *     this.position++;\n *   }\n *\n *   undo() {\n *     if (this.position >= 0) {\n *       this.history[this.position].undo();\n *       this.position--;\n *     }\n *   }\n *\n *   redo() {\n *     if (this.position < this.history.length - 1) {\n *       this.position++;\n *       this.history[this.position].redo();\n *     }\n *   }\n * }\n * ```\n *\n * **Example commands**:\n * ```typescript\n * class AddItemCommand implements Command {\n *   constructor(\n *     private canvasId: string,\n *     private item: GridItem\n *   ) {}\n *\n *   undo() { removeItemFromCanvas(this.canvasId, this.item.id); }\n *   redo() { addItemToCanvas(this.canvasId, this.item); }\n * }\n * ```\n *\n * **For different frameworks**:\n * - React: Use useReducer or Zustand middleware\n * - Vue: Use Pinia plugin or custom composable\n * - Angular: Use NgRx effects or service\n *\n * @module undo-redo\n */\n\nimport { createStore } from '@stencil/store';\n\n/**\n * Command Interface\n * =================\n *\n * Core abstraction for undoable operations. All commands must implement\n * both undo() and redo() methods to reverse and reapply their effects.\n *\n * **Design principle**: Commands are **self-contained** - they store all\n * data needed to both undo and redo without external dependencies.\n *\n * **Typical implementation**:\n * ```typescript\n * class MyCommand implements Command {\n *   private beforeState: any;\n *   private afterState: any;\n *\n *   constructor(initialState) {\n *     this.beforeState = JSON.parse(JSON.stringify(initialState));\n *     // ... perform operation ...\n *     this.afterState = JSON.parse(JSON.stringify(finalState));\n *   }\n *\n *   undo() { restoreState(this.beforeState); }\n *   redo() { restoreState(this.afterState); }\n * }\n * ```\n *\n * **Why separate undo/redo methods**:\n * - ❌ Not: Single execute(reverse: boolean) method\n * - ✅ Yes: Separate undo() and redo() methods\n * - Reason: Clearer intent, easier to implement, matches user mental model\n *\n * **Concrete implementations**:\n * - AddItemCommand: Add/remove grid item\n * - DeleteItemCommand: Remove/restore grid item with index preservation\n * - MoveItemCommand: Update item position (cross-canvas support)\n * - ResizeCommand: Update item dimensions\n *\n * @example\n * ```typescript\n * class DeleteItemCommand implements Command {\n *   constructor(\n *     private canvasId: string,\n *     private item: GridItem,\n *     private itemIndex: number\n *   ) {}\n *\n *   undo() {\n *     // Restore item at original index\n *     const canvas = gridState.canvases[this.canvasId];\n *     canvas.items.splice(this.itemIndex, 0, this.item);\n *     gridState.canvases = { ...gridState.canvases };\n *   }\n *\n *   redo() {\n *     // Remove item again\n *     removeItemFromCanvas(this.canvasId, this.item.id);\n *   }\n * }\n * ```\n */\nexport interface Command {\n  /**\n   * Reverse the effect of this command\n   *\n   * **Idempotent**: Calling undo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  undo(): void;\n\n  /**\n   * Reapply the effect of this command\n   *\n   * **Idempotent**: Calling redo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  redo(): void;\n}\n\n/**\n * Undo/Redo State\n * ================\n *\n * Reactive state for UI button enable/disable logic.\n * Components subscribe to this state to update undo/redo button states.\n *\n * **Why reactive**:\n * - Automatic button state updates (no manual DOM manipulation)\n * - Components re-render when canUndo/canRedo changes\n * - Declarative UI logic\n *\n * **Usage in components**:\n * ```tsx\n * import { undoRedoState } from './undo-redo';\n *\n * render() {\n *   return (\n *     <div>\n *       <button\n *         disabled={!undoRedoState.canUndo}\n *         onClick={() => undo()}>\n *         Undo\n *       </button>\n *       <button\n *         disabled={!undoRedoState.canRedo}\n *         onClick={() => redo()}>\n *         Redo\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n */\ninterface UndoRedoState {\n  /** Whether undo operation is available (historyPosition >= 0) */\n  canUndo: boolean;\n\n  /** Whether redo operation is available (historyPosition < commandHistory.length - 1) */\n  canRedo: boolean;\n}\n\n/**\n * Reactive state store for undo/redo button states\n *\n * **StencilJS integration**: Components automatically subscribe when accessing properties\n * **Updates**: Modified by updateButtonStates() after each operation\n */\nconst { state: undoRedoState } = createStore<UndoRedoState>({\n  canUndo: false,\n  canRedo: false,\n});\n\nexport { undoRedoState };\n\n/**\n * Internal Command History State\n * ===============================\n *\n * Private state managing command stack and position.\n * Not exported - accessed only through public functions.\n */\n\n/**\n * Command history stack\n *\n * **Structure**: Array of Command objects in chronological order\n * **Growth**: Appends new commands to end\n * **Bounded**: Limited to MAX_HISTORY commands (50)\n * **Branching**: Discards commands after current position on new push\n *\n * @example\n * ```\n * [AddItemCommand, DeleteItemCommand, MoveItemCommand]\n *  ↑                ↑                  ↑\n *  0                1                  2 (historyPosition)\n * ```\n */\nconst commandHistory: Command[] = [];\n\n/**\n * Current position in command history\n *\n * **Range**: -1 (empty history) to commandHistory.length - 1\n * **Meaning**:\n * - -1: No commands or all undone\n * - 0: First command is current state\n * - N: Command at index N is current state\n *\n * **Operations**:\n * - Push command: position++\n * - Undo: position--\n * - Redo: position++\n *\n * **Invariant**: position < commandHistory.length\n */\nlet historyPosition: number = -1;\n\n/**\n * Maximum number of commands in history\n *\n * **Why 50**: Balance between:\n * - ✅ Enough for typical user session\n * - ✅ Reasonable memory usage (~50-250 KB)\n * - ❌ Not unlimited (prevents memory bloat)\n *\n * **Behavior when exceeded**: Oldest command removed (sliding window)\n */\nconst MAX_HISTORY = 50;\n\n/**\n * Update undo/redo button states\n * This triggers UI updates via the store\n */\nfunction updateButtonStates(): void {\n  undoRedoState.canUndo = historyPosition >= 0;\n  undoRedoState.canRedo = historyPosition < commandHistory.length - 1;\n}\n\n/**\n * Push a new command to the history\n * Removes any commands after current position (if we undid and then did something new)\n */\nexport function pushCommand(command: Command): void {\n  // Remove any commands after current position\n  commandHistory.splice(historyPosition + 1);\n\n  // Add new command\n  commandHistory.push(command);\n\n  // Limit history size\n  if (commandHistory.length > MAX_HISTORY) {\n    commandHistory.shift();\n  } else {\n    historyPosition++;\n  }\n\n  // Update button states\n  updateButtonStates();\n}\n\n/**\n * Undo the last command\n */\nexport function undo(): void {\n  if (historyPosition < 0) {\n    return;\n  }\n\n  const command = commandHistory[historyPosition];\n  command.undo();\n  historyPosition--;\n\n  updateButtonStates();\n}\n\n/**\n * Redo the next command\n */\nexport function redo(): void {\n  if (historyPosition >= commandHistory.length - 1) {\n    return;\n  }\n\n  historyPosition++;\n  const command = commandHistory[historyPosition];\n  command.redo();\n\n  updateButtonStates();\n}\n\n/**\n * Check if undo is available\n */\nexport function canUndo(): boolean {\n  return historyPosition >= 0;\n}\n\n/**\n * Check if redo is available\n */\nexport function canRedo(): boolean {\n  return historyPosition < commandHistory.length - 1;\n}\n\n/**\n * Clear all history\n */\nexport function clearHistory(): void {\n  commandHistory.length = 0;\n  historyPosition = -1;\n  updateButtonStates();\n}\n"],"version":3}