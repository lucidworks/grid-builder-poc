{"file":"grid-calculations-e64c8272.js","mappings":"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","names":[],"sources":["src/utils/dom-cache.ts","src/utils/grid-calculations.ts"],"sourcesContent":["/**\n * DOM Cache Utility\n * =================\n *\n * Performance optimization layer that caches frequently accessed DOM elements to avoid\n * repeated `document.getElementById()` calls during drag/resize operations.\n *\n * ## Problem\n *\n * During interactive operations (drag, resize), we frequently need to access the same\n * DOM elements:\n * - Canvas containers for width calculations\n * - Grid items for position updates\n * - Parent elements for coordinate transforms\n *\n * Each `document.getElementById()` call:\n * - Traverses the DOM tree\n * - Can trigger layout calculations\n * - Becomes expensive when called hundreds of times per second during drag\n *\n * ## Solution\n *\n * Cache DOM references in memory after first lookup:\n * - **First access**: Query DOM once and store reference\n * - **Subsequent access**: Return cached reference (O(1) Map lookup)\n * - **Invalidation**: Clear cache when DOM structure changes\n *\n * ## Performance Impact\n *\n * **Without caching**:\n * - During drag: ~60 getElementById calls/second (60fps × multiple items)\n * - Each call traverses DOM tree\n * - Cumulative impact on frame budget\n *\n * **With caching**:\n * - First call: DOM query + cache store\n * - Subsequent: Map.get() (constant time)\n * - 90%+ reduction in DOM queries during operations\n *\n * ## When to Use This Pattern\n *\n * Apply DOM caching when:\n * ✅ Accessing same elements repeatedly in tight loops\n * ✅ During high-frequency events (mousemove, scroll, resize)\n * ✅ Elements are stable (not frequently added/removed)\n * ✅ Performance profiling shows getElementById as bottleneck\n *\n * Avoid when:\n * ❌ Elements change frequently (cache becomes stale)\n * ❌ Only accessing elements once\n * ❌ Using framework-managed refs (React useRef, Stencil @Element)\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n * ```typescript\n * class MyDOMCache {\n *   private elements = new Map<string, HTMLElement>();\n *\n *   get(id: string): HTMLElement | null {\n *     if (this.elements.has(id)) return this.elements.get(id)!;\n *     const el = document.getElementById(id);\n *     if (el) this.elements.set(id, el);\n *     return el;\n *   }\n *\n *   invalidate(id: string) { this.elements.delete(id); }\n * }\n * export const cache = new MyDOMCache();\n * ```\n *\n * ## Cache Invalidation Strategy\n *\n * Clear cache when:\n * - Canvas added/removed from DOM\n * - Component unmounts\n * - Major DOM restructuring\n * - Element IDs change\n *\n * @module dom-cache\n */\n\n/**\n * DOM Cache for canvas containers and frequently accessed elements\n *\n * Singleton pattern ensures all code uses same cache instance\n */\nclass DOMCache {\n  /** Canvas element cache - key: canvasId, value: HTMLElement */\n  private canvases: Map<string, HTMLElement> = new Map();\n\n  /**\n   * Get canvas element by ID with automatic caching\n   *\n   * **Caching behavior**:\n   * 1. Check Map cache first (O(1))\n   * 2. If miss, query DOM and cache result\n   * 3. Return cached or fresh element\n   *\n   * **Performance**:\n   * - Cached access: ~0.001ms (Map.get)\n   * - DOM query: ~0.1-1ms (getElementById + tree traversal)\n   * - Speedup: 100-1000x for cached access\n   *\n   * **Safety**:\n   * - Returns `null` if element doesn't exist\n   * - Safe to call before DOM ready (returns null, doesn't cache)\n   * - Cache automatically populated on first successful access\n   *\n   * @param canvasId - Canvas container element ID\n   * @returns HTMLElement or null if not found\n   *\n   * @example\n   * ```typescript\n   * // First call - queries DOM\n   * const canvas1 = domCache.getCanvas('canvas1'); // ~0.5ms\n   *\n   * // Subsequent calls - returns cached\n   * const canvas2 = domCache.getCanvas('canvas1'); // ~0.001ms\n   * const canvas3 = domCache.getCanvas('canvas1'); // ~0.001ms\n   *\n   * // Different canvas - new DOM query\n   * const canvas4 = domCache.getCanvas('canvas2'); // ~0.5ms\n   * ```\n   */\n  getCanvas(canvasId: string): HTMLElement | null {\n    // Check cache first\n    if (this.canvases.has(canvasId)) {\n      return this.canvases.get(canvasId)!;\n    }\n\n    // Query DOM and cache\n    const canvas = document.getElementById(canvasId);\n    if (canvas) {\n      this.canvases.set(canvasId, canvas);\n    }\n\n    return canvas;\n  }\n\n  /**\n   * Invalidate cache for a specific canvas\n   *\n   * **When to call**:\n   * - Canvas element removed from DOM\n   * - Canvas element replaced (same ID, different element)\n   * - Canvas component unmounts\n   * - Element ID changed\n   *\n   * **Why needed**:\n   * Cached references become stale when elements are removed or replaced.\n   * Invalidation ensures next access queries fresh element from DOM.\n   *\n   * **Performance**:\n   * Very cheap operation (Map.delete is O(1))\n   *\n   * @param canvasId - Canvas ID to remove from cache\n   *\n   * @example\n   * ```typescript\n   * // Component unmounting\n   * disconnectedCallback() {\n   *   domCache.invalidate(this.canvasId);\n   * }\n   *\n   * // Canvas removed from state\n   * delete gridState.canvases['canvas1'];\n   * domCache.invalidate('canvas1');\n   * ```\n   */\n  invalidate(canvasId: string): void {\n    this.canvases.delete(canvasId);\n  }\n\n  /**\n   * Clear entire DOM cache\n   *\n   * **When to call**:\n   * - Major DOM restructuring (e.g., navigation, full page reload)\n   * - All canvases removed/replaced\n   * - Test cleanup (afterEach hooks)\n   * - Memory cleanup when cache grows too large\n   *\n   * **Why needed**:\n   * Prevents memory leaks from cached references to removed elements\n   * and ensures clean slate after major DOM changes.\n   *\n   * **Performance**:\n   * Cheap operation - just clears Map references.\n   * Elements are garbage collected automatically.\n   *\n   * @example\n   * ```typescript\n   * // Test cleanup\n   * afterEach(() => {\n   *   domCache.clear();\n   * });\n   *\n   * // Navigation/route change\n   * router.beforeEach(() => {\n   *   domCache.clear();\n   * });\n   *\n   * // Memory management\n   * if (domCache.size() > 100) {\n   *   domCache.clear(); // Periodic cleanup\n   * }\n   * ```\n   */\n  clear(): void {\n    this.canvases.clear();\n  }\n}\n\n/**\n * Singleton DOM cache instance\n *\n * Export as const to ensure single instance across entire application.\n * All modules import same cache, preventing duplicate element caching\n * and ensuring consistent cache state.\n *\n * @example\n * ```typescript\n * import { domCache } from './dom-cache';\n *\n * // All modules use same cache instance\n * const el1 = domCache.getCanvas('canvas1');\n * const el2 = domCache.getCanvas('canvas1'); // Same reference\n * ```\n */\nexport const domCache = new DOMCache();\n","/**\n * Grid Calculations Utility\n * ========================\n *\n * Core system for converting between pixel coordinates and grid units in the drag-and-drop\n * grid builder. This module provides pure functions with performance optimizations through\n * intelligent caching.\n *\n * ## Grid System Architecture\n *\n * The grid uses a hybrid approach combining responsive and fixed sizing:\n *\n * ### Horizontal Grid (Responsive)\n * - **Size**: 2% of container width (50 units across full width)\n * - **Behavior**: Scales proportionally with canvas width changes\n * - **Use case**: Enables responsive layouts that adapt to different screen sizes\n * - **Example**: At 1000px width, each grid unit = 20px (1000 * 0.02)\n *\n * ### Vertical Grid (Fixed)\n * - **Size**: Fixed 20px per grid unit\n * - **Behavior**: Remains constant regardless of viewport size\n * - **Use case**: Provides consistent vertical spacing and predictable heights\n * - **Rationale**: Vertical scrolling is unlimited, so fixed sizing provides better UX\n *\n * ## Performance Optimization Strategy\n *\n * ### Grid Size Caching\n * The horizontal grid size is calculated from DOM elements (container.clientWidth),\n * which is an expensive operation. To minimize performance impact:\n *\n * 1. **First access**: Calculate once per canvas and cache the result\n * 2. **Subsequent access**: Return cached value (no DOM reads)\n * 3. **Cache invalidation**: Clear when canvas resizes (via ResizeObserver)\n *\n * **Performance Impact**:\n * - Without caching: 100 items = 100+ DOM reads during viewport switch\n * - With caching: 100 items = 1 DOM read per canvas during viewport switch\n * - Prevents layout thrashing and reduces reflows\n *\n * ### DOM Caching Integration\n * Uses `domCache` utility to avoid repeated `getElementById` calls, providing\n * a second layer of performance optimization.\n *\n * ## Usage Examples\n *\n * ```typescript\n * // Convert grid position to pixels for rendering\n * const pixelX = gridToPixelsX(10, 'canvas1'); // Grid unit 10 → pixels\n * const pixelY = gridToPixelsY(5);              // Grid unit 5 → 100px\n *\n * // Convert mouse position to grid coordinates\n * const gridX = pixelsToGridX(250, 'canvas1');  // Pixels → grid units\n * const gridY = pixelsToGridY(120);             // 120px → 6 grid units\n *\n * // Clear cache on canvas resize\n * resizeObserver.observe(canvasContainer);\n * resizeObserver.addEventListener(() => clearGridSizeCache());\n * ```\n *\n * @module grid-calculations\n */\n\nimport { domCache } from './dom-cache';\n\n/** Fixed vertical grid size in pixels - provides consistent vertical spacing */\nconst GRID_SIZE_VERTICAL = 20;\n\n/**\n * Horizontal grid size as percentage of container width\n * 0.02 = 2% = 50 grid units across full width\n */\nconst GRID_SIZE_HORIZONTAL_PERCENT = 0.02;\n\n/**\n * Grid size cache to avoid repeated DOM queries\n * Key format: `${canvasId}-h` for horizontal grid sizes\n * Cleared on canvas resize events\n */\nconst gridSizeCache = new Map<string, number>();\n\n/**\n * Clear the grid size cache for all canvases\n *\n * **When to call**:\n * - Canvas container is resized (via ResizeObserver)\n * - Viewport changes (desktop ↔ mobile)\n * - Canvas is added/removed from DOM\n *\n * **Why needed**:\n * Cached grid sizes become stale when container widths change. This ensures\n * fresh calculations on next access.\n *\n * **Performance note**:\n * Clearing cache is cheap (O(1)). The cost is in recalculation, which happens\n * lazily on next access.\n *\n * @example\n * ```typescript\n * resizeObserver.observe(canvasElement);\n * resizeCallback = () => {\n *   clearGridSizeCache();\n *   // Components will recalculate on next render\n * };\n * ```\n */\nexport function clearGridSizeCache() {\n  gridSizeCache.clear();\n}\n\n/**\n * Get the horizontal grid size for a specific canvas\n *\n * **Calculation**: `containerWidth * 2%` = size of one horizontal grid unit in pixels\n *\n * **Caching behavior**:\n * - First call: Reads `container.clientWidth` from DOM and caches result\n * - Subsequent calls: Returns cached value (no DOM access)\n * - After resize: Cache cleared, recalculates on next call\n *\n * **Why responsive**:\n * Horizontal grid scales with container to support:\n * - Responsive layouts (desktop/mobile)\n * - Variable canvas widths\n * - Fluid grid-based designs\n *\n * **Extracting this pattern**:\n * To adapt for your project:\n * 1. Adjust `GRID_SIZE_HORIZONTAL_PERCENT` for different grid densities\n * 2. Consider using viewport width instead of container width for full-page grids\n * 3. Add separate caches for different viewports if needed\n *\n * @param canvasId - The canvas element ID to calculate grid size for\n * @param forceRecalc - Set true to bypass cache and force fresh calculation\n * @returns Size of one horizontal grid unit in pixels\n *\n * @example\n * ```typescript\n * // First call - calculates from DOM\n * const size1 = getGridSizeHorizontal('canvas1'); // → 20 (at 1000px width)\n *\n * // Second call - returns cached value\n * const size2 = getGridSizeHorizontal('canvas1'); // → 20 (no DOM read)\n *\n * // Force recalculation\n * const size3 = getGridSizeHorizontal('canvas1', true); // → recalculates\n * ```\n */\nexport function getGridSizeHorizontal(canvasId: string, forceRecalc: boolean = false): number {\n  const cacheKey = `${canvasId}-h`;\n\n  if (!forceRecalc && gridSizeCache.has(cacheKey)) {\n    return gridSizeCache.get(cacheKey)!;\n  }\n\n  // Use DOM cache instead of getElementById\n  const container = domCache.getCanvas(canvasId);\n  if (!container) {\n    console.warn(`Canvas container not found: ${canvasId}`);\n    return 0;\n  }\n\n  const size = container.clientWidth * GRID_SIZE_HORIZONTAL_PERCENT;\n  gridSizeCache.set(cacheKey, size);\n  return size;\n}\n\n/**\n * Get the vertical grid size (constant)\n *\n * **Why fixed**:\n * Unlike horizontal grid, vertical uses fixed 20px sizing because:\n * - Vertical scrolling is infinite (no container height limit)\n * - Provides predictable, consistent heights across all viewports\n * - Simplifies calculations (no container dependency)\n * - Better UX for vertical spacing\n *\n * @returns Fixed vertical grid size (20px)\n *\n * @example\n * ```typescript\n * const vSize = getGridSizeVertical(); // → 20 (always)\n * ```\n */\nexport function getGridSizeVertical(): number {\n  return GRID_SIZE_VERTICAL;\n}\n\n/**\n * Convert grid units to pixels for horizontal positioning and sizing\n *\n * **Use cases**:\n * - Converting item `x` position from grid coordinates to CSS left/transform\n * - Converting item `width` from grid units to CSS width\n * - Rendering grid items at correct horizontal positions\n *\n * **Performance**:\n * Uses cached grid size via `getGridSizeHorizontal()` to avoid DOM reads\n *\n * **Rounding**:\n * Uses `Math.round()` to prevent subpixel rendering issues\n *\n * @param gridUnits - Number of grid units\n * @param canvasId - Canvas ID for responsive grid size calculation\n * @returns Pixel value\n *\n * @example\n * ```typescript\n * // Item at grid position x=10\n * const leftPx = gridToPixelsX(10, 'canvas1'); // → 200px (at 1000px container)\n *\n * // Item with grid width=15\n * const widthPx = gridToPixelsX(15, 'canvas1'); // → 300px\n * ```\n */\nexport function gridToPixelsX(gridUnits: number, canvasId: string): number {\n  // Use cached grid size for better performance\n  const gridSize = getGridSizeHorizontal(canvasId);\n  return Math.round(gridUnits * gridSize);\n}\n\n/**\n * Convert grid units to pixels for vertical positioning and sizing\n *\n * **Use cases**:\n * - Converting item `y` position from grid coordinates to CSS top/transform\n * - Converting item `height` from grid units to CSS height\n * - Calculating vertical spacing\n *\n * **Why no canvas ID**:\n * Vertical grid is fixed (20px), so no container-specific calculation needed\n *\n * @param gridUnits - Number of grid units\n * @returns Pixel value (gridUnits * 20)\n *\n * @example\n * ```typescript\n * // Item at grid position y=5\n * const topPx = gridToPixelsY(5); // → 100px\n *\n * // Item with grid height=8\n * const heightPx = gridToPixelsY(8); // → 160px\n * ```\n */\nexport function gridToPixelsY(gridUnits: number): number {\n  return gridUnits * GRID_SIZE_VERTICAL;\n}\n\n/**\n * Convert pixel coordinates to grid units for horizontal values\n *\n * **Use cases**:\n * - Converting mouse/drop position to grid coordinates\n * - Snapping dragged items to grid\n * - Calculating item positions after drag\n *\n * **Rounding**:\n * Uses `Math.round()` to snap to nearest grid unit (implements grid snapping)\n *\n * **Safety**:\n * Returns 0 if grid size is 0 (container not found/initialized)\n *\n * @param pixels - Pixel value to convert\n * @param canvasId - Canvas ID for responsive grid size calculation\n * @returns Number of grid units (rounded)\n *\n * @example\n * ```typescript\n * // Mouse drop at 250px\n * const gridX = pixelsToGridX(250, 'canvas1'); // → 13 (at 1000px container)\n *\n * // After drag, element at 371px\n * const snappedX = pixelsToGridX(371, 'canvas1'); // → 19 (snapped)\n * ```\n */\nexport function pixelsToGridX(pixels: number, canvasId: string): number {\n  // Use cached grid size for better performance\n  const gridSize = getGridSizeHorizontal(canvasId);\n  if (gridSize === 0) {\n    return 0;\n  }\n  return Math.round(pixels / gridSize);\n}\n\n/**\n * Convert pixel coordinates to grid units for vertical values\n *\n * **Use cases**:\n * - Converting mouse Y position to grid coordinates\n * - Snapping vertical positions to grid\n * - Calculating vertical offsets\n *\n * **Rounding**:\n * Implements automatic grid snapping via `Math.round()`\n *\n * @param pixels - Pixel value to convert\n * @returns Number of grid units (rounded)\n *\n * @example\n * ```typescript\n * // Mouse at 127px vertically\n * const gridY = pixelsToGridY(127); // → 6 (rounded from 6.35)\n *\n * // Element height 165px\n * const gridHeight = pixelsToGridY(165); // → 8 (rounded from 8.25)\n * ```\n */\nexport function pixelsToGridY(pixels: number): number {\n  return Math.round(pixels / GRID_SIZE_VERTICAL);\n}\n"],"version":3}