{"file":"grid-item-wrapper.entry.esm.js","mappings":"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","names":["getTransformPosition","gridState"],"sources":["src/services/virtual-renderer.ts","src/utils/drag-handler.ts","src/utils/resize-handler.ts","src/components/grid-item-wrapper/grid-item-wrapper.scss?tag=grid-item-wrapper","src/components/grid-item-wrapper/grid-item-wrapper.tsx"],"sourcesContent":["/**\n * Virtual Renderer Service - Lazy Loading System\n * ===============================================\n *\n * Performance optimization using IntersectionObserver to lazy-load component content\n * only when visible in the viewport. Reduces initial render time, memory usage, and\n * improves page load performance for pages with 100+ grid items.\n *\n * ## Problem\n *\n * Grid builders with many items face performance challenges:\n * - **Initial render cost**: Rendering 100+ components at page load is expensive\n * - **Memory overhead**: All components in memory even if off-screen\n * - **Slow page load**: Long time to interactive (TTI)\n * - **Poor scrolling**: Heavy DOM operations during scroll\n * - **Wasted rendering**: Complex components rendered but never seen\n *\n * **Example scenario**:\n * - Page with 100 grid items\n * - 10 items visible initially\n * - 90 items rendered but off-screen (wasted work)\n * - Each complex component: ~5-50ms to render\n * - Total wasted: 450-4500ms (almost 5 seconds!)\n *\n * ## Solution\n *\n * IntersectionObserver pattern providing:\n * 1. **Lazy initialization**: Items start with placeholder content\n * 2. **Viewport detection**: Observe when items enter viewport\n * 3. **Callback notification**: Notify components when visible\n * 4. **Component rendering**: Replace placeholder with actual content\n * 5. **Pre-rendering**: Start loading 200px before entering viewport\n * 6. **Memory cleanup**: Unobserve removed components\n *\n * ## Architecture: IntersectionObserver Pattern\n *\n * **Observer setup**:\n * ```typescript\n * // In grid-builder-app.tsx componentDidLoad:\n * (window as any).virtualRenderer = new VirtualRendererService();\n *\n * // In grid-item-wrapper.tsx componentDidLoad:\n * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *   this.isVisible = isVisible;  // Triggers re-render\n * });\n * ```\n *\n * **Flow**:\n * ```\n * 1. Grid item mounts → observe(element, callback)\n * 2. Item scrolls into viewport (200px before visible)\n * 3. IntersectionObserver fires → callback(true)\n * 4. Component sets isVisible = true → re-renders\n * 5. Placeholder replaced with actual component\n * 6. User sees smooth transition\n * ```\n *\n * **Cleanup**:\n * ```\n * 1. Grid item unmounts → disconnectedCallback()\n * 2. unobserve(element, id) → stop watching\n * 3. Remove callback from map → allow GC\n * 4. Observer continues for other elements\n * ```\n *\n * ## IntersectionObserver Configuration\n *\n * **Root margin strategy** (`rootMargin: '200px'`):\n * - Pre-render items 200px before they enter viewport\n * - Ensures content ready when user scrolls\n * - Prevents \"pop-in\" effect (flash of placeholder)\n * - Balance between performance and UX\n *\n * **Why 200px**:\n * - Typical scroll speed: ~100-300px per second\n * - 200px gives ~1 second to render before visible\n * - Complex component: ~50-200ms to render\n * - Comfortable buffer for smooth loading\n *\n * **Threshold setting** (`threshold: 0.01`):\n * - Trigger when even 1% of element is visible\n * - Very early detection (as soon as edge appears)\n * - Maximizes pre-render time\n * - Prevents late loading\n *\n * **Why 0.01 not 0**:\n * - 0 = fully outside viewport\n * - 0.01 = edge just entering\n * - Better cross-browser behavior\n * - More reliable than 0\n *\n * ## Observer Callback Pattern\n *\n * **Callback signature**:\n * ```typescript\n * type VisibilityCallback = (isVisible: boolean) => void;\n * ```\n *\n * **Callback invocation**:\n * ```typescript\n * entries.forEach((entry) => {\n *   const callback = this.observedElements.get(elementId);\n *   if (callback) {\n *     callback(entry.isIntersecting);  // true when entering, false when exiting\n *   }\n * });\n * ```\n *\n * **Component handler**:\n * ```typescript\n * // In grid-item-wrapper.tsx:\n * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *   this.isVisible = isVisible;  // @State update triggers re-render\n * });\n * ```\n *\n * **Render method**:\n * ```typescript\n * renderComponent() {\n *   if (!this.isVisible) {\n *     return <div class=\"component-placeholder\">Loading...</div>;\n *   }\n *   // Render actual component (expensive)\n *   return <component-image-gallery itemId={this.item.id} />;\n * }\n * ```\n *\n * ## Memory Management\n *\n * **Callback storage**:\n * ```typescript\n * private observedElements: Map<string, VisibilityCallback> = new Map();\n * ```\n *\n * **Why Map**:\n * - O(1) lookup by element ID\n * - Easy cleanup (delete)\n * - Prevents memory leaks\n * - Standard pattern\n *\n * **Cleanup strategy**:\n * 1. Component unmounts → unobserve(element, id)\n * 2. Delete callback from map → allow GC\n * 3. Observer stops watching element\n * 4. Element can be garbage collected\n *\n * **Memory impact**:\n * - Each callback: ~100 bytes\n * - 100 items: ~10KB total\n * - Negligible overhead\n *\n * ## Performance Characteristics\n *\n * **Initial page load** (100 items, 10 visible):\n * - Without virtual rendering: ~500-5000ms (render all)\n * - With virtual rendering: ~50-500ms (render 10)\n * - **10× faster initial load**\n *\n * **Scroll performance**:\n * - Observer overhead: ~1-2ms per event\n * - Component render: ~5-50ms (varies by type)\n * - Pre-render buffer: Items ready when visible\n * - Smooth 60fps scrolling maintained\n *\n * **Memory usage** (100 items):\n * - Without virtual rendering: ~50-500MB (all components)\n * - With virtual rendering: ~5-50MB (visible + buffered)\n * - **10× lower memory usage**\n *\n * ## Complex Component Targeting\n *\n * **Simple components** (always render):\n * - header, text, button (fast ~1-5ms)\n * - No lazy loading needed\n * - Always visible immediately\n *\n * **Complex components** (lazy load):\n * - image-gallery: Multiple images to load (~50-200ms)\n * - dashboard-widget: Chart rendering (~100-500ms)\n * - live-data: API calls + updates (~100ms+)\n *\n * **How wrapper decides**:\n * ```typescript\n * // In grid-item-wrapper.tsx:\n * componentDidLoad() {\n *   // Always observe, component decides if needed\n *   virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *     this.isVisible = isVisible;\n *   });\n * }\n *\n * renderComponent() {\n *   // Simple components ignore isVisible flag\n *   if (!this.isVisible && this.item.type === 'imageGallery') {\n *     return <div class=\"component-placeholder\">Loading...</div>;\n *   }\n *   // Complex types use isVisible guard\n * }\n * ```\n *\n * ## Browser Compatibility\n *\n * **IntersectionObserver support**:\n * - Chrome 51+ (2016)\n * - Firefox 55+ (2017)\n * - Safari 12.1+ (2019)\n * - Edge 15+ (2017)\n * - ~97% global browser coverage (2024)\n *\n * **Polyfill option**:\n * ```typescript\n * // If needed for older browsers:\n * import 'intersection-observer'; // polyfill\n * ```\n *\n * **Graceful degradation**:\n * - If IntersectionObserver unavailable\n * - Could fallback to immediate rendering\n * - Or use scroll event listener (less efficient)\n *\n * ## Extracting This Pattern\n *\n * To adapt virtual rendering for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * // 1. Create observer service\n * class VirtualRenderer {\n *   private observer: IntersectionObserver;\n *   private callbacks = new Map<string, (visible: boolean) => void>();\n *\n *   constructor() {\n *     this.observer = new IntersectionObserver(\n *       (entries) => entries.forEach(e =>\n *         this.callbacks.get(e.target.id)?.(e.isIntersecting)\n *       ),\n *       { rootMargin: '200px', threshold: 0.01 }\n *     );\n *   }\n *\n *   observe(el: Element, id: string, cb: (visible: boolean) => void) {\n *     this.callbacks.set(id, cb);\n *     this.observer.observe(el);\n *   }\n *\n *   unobserve(el: Element, id: string) {\n *     this.callbacks.delete(id);\n *     this.observer.unobserve(el);\n *   }\n * }\n *\n * // 2. Create singleton\n * export const virtualRenderer = new VirtualRenderer();\n *\n * // 3. Use in component\n * useEffect(() => {\n *   virtualRenderer.observe(ref.current, id, setIsVisible);\n *   return () => virtualRenderer.unobserve(ref.current, id);\n * }, []);\n *\n * return isVisible ? <ComplexComponent /> : <Placeholder />;\n * ```\n *\n * **For different frameworks**:\n * - **React**: Use useEffect for lifecycle, useState for visibility\n * - **Vue**: Use onMounted/onUnmounted, ref() for visibility\n * - **Angular**: Use ngAfterViewInit/ngOnDestroy, signals for visibility\n * - **Svelte**: Use onMount/onDestroy, stores for visibility\n *\n * **Key patterns to preserve**:\n * 1. Singleton service (one observer for all components)\n * 2. Callback map for O(1) lookups\n * 3. 200px root margin for pre-rendering\n * 4. 0.01 threshold for early detection\n * 5. Cleanup on component unmount\n *\n * **Customization options**:\n * ```typescript\n * // Adjust root margin based on needs\n * rootMargin: '200px'  // Standard (1 second buffer)\n * rootMargin: '400px'  // Aggressive (2 second buffer, more memory)\n * rootMargin: '100px'  // Conservative (less memory, might see pop-in)\n *\n * // Adjust threshold based on needs\n * threshold: 0.01      // Trigger immediately\n * threshold: 0.1       // Trigger when 10% visible\n * threshold: 0.5       // Trigger when 50% visible (not recommended)\n * ```\n *\n * @module virtual-renderer\n */\n\n/**\n * Visibility callback function type\n *\n * **Signature**: `(isVisible: boolean) => void`\n * **Called when**: Element enters or exits viewport\n * **Parameter**: `isVisible` - true when entering, false when exiting\n *\n * **Usage**:\n * ```typescript\n * virtualRenderer.observe(element, id, (isVisible) => {\n *   this.isVisible = isVisible;  // Update component state\n * });\n * ```\n */\nexport type VisibilityCallback = (isVisible: boolean) => void;\n\n/**\n * VirtualRendererService Class\n * ==============================\n *\n * Singleton service managing IntersectionObserver for all grid items.\n *\n * **Lifecycle**:\n * 1. Created once in grid-builder-app.tsx componentDidLoad\n * 2. Shared across all grid-item-wrapper components\n * 3. Lives for entire application lifetime\n * 4. Destroyed only on page unload\n *\n * **Properties**:\n * - `observer`: IntersectionObserver instance (null during initialization)\n * - `observedElements`: Map of element IDs to visibility callbacks\n *\n * **Methods**:\n * - `constructor()`: Initialize observer with configuration\n * - `initialize()`: Create IntersectionObserver with rootMargin and threshold\n * - `observe(element, id, callback)`: Start observing element\n * - `unobserve(element, id)`: Stop observing element\n * - `destroy()`: Cleanup all observations\n */\nexport class VirtualRendererService {\n  /**\n   * IntersectionObserver instance\n   *\n   * **Lifecycle**: Created in initialize(), destroyed in destroy()\n   * **Configuration**: rootMargin: '200px', threshold: 0.01\n   * **Purpose**: Watch all grid items for viewport intersection\n   *\n   * **Null during**:\n   * - Before initialize() completes\n   * - After destroy() called\n   * - Error during initialization\n   */\n  private observer: IntersectionObserver | null = null;\n\n  /**\n   * Map of element IDs to visibility callbacks\n   *\n   * **Structure**: `Map<elementId: string, callback: VisibilityCallback>`\n   * **Lookup**: O(1) by element ID\n   * **Cleanup**: Entries deleted in unobserve()\n   *\n   * **Memory**: ~100 bytes per entry, ~10KB for 100 items\n   *\n   * **Why Map**:\n   * - Fast lookups in observer callback\n   * - Easy cleanup (delete by key)\n   * - Prevents memory leaks\n   * - Standard pattern for observer registries\n   */\n  private observedElements: Map<string, VisibilityCallback> = new Map();\n\n  /**\n   * Constructor - Initialize virtual renderer\n   *\n   * **Called**: Once when VirtualRendererService instantiated\n   * **Purpose**: Create IntersectionObserver with configuration\n   *\n   * **Delegates to**: initialize()\n   * - Sets up observer with rootMargin and threshold\n   * - Registers callback handler for intersection events\n   *\n   * **Usage**:\n   * ```typescript\n   * // In grid-builder-app.tsx componentDidLoad:\n   * (window as any).virtualRenderer = new VirtualRendererService();\n   * ```\n   */\n  constructor() {\n    this.initialize();\n  }\n\n  /**\n   * Initialize IntersectionObserver\n   *\n   * **Called by**: constructor (once)\n   * **Purpose**: Create and configure IntersectionObserver instance\n   *\n   * ## Observer Configuration\n   *\n   * **Observer callback**:\n   * ```typescript\n   * (entries) => {\n   *   entries.forEach((entry) => {\n   *     const elementId = entry.target.id;\n   *     const callback = this.observedElements.get(elementId);\n   *     if (callback) {\n   *       callback(entry.isIntersecting);  // true = entering, false = exiting\n   *     }\n   *   });\n   * }\n   * ```\n   *\n   * **Why forEach entries**:\n   * - IntersectionObserver can fire for multiple elements at once\n   * - Batch processing is more efficient\n   * - Each element gets independent callback\n   *\n   * **Element ID lookup**:\n   * ```typescript\n   * const elementId = entry.target.id;  // From element.id attribute\n   * const callback = this.observedElements.get(elementId);  // O(1) lookup\n   * ```\n   *\n   * **Why use element ID**:\n   * - Direct mapping to callback\n   * - No need to store element references\n   * - Simpler memory management\n   * - Works across DOM mutations\n   *\n   * ## Observer Options\n   *\n   * **Root margin** (`rootMargin: '200px'`):\n   * - Expand viewport bounds by 200px in all directions\n   * - Items render 200px before actually visible\n   * - 1 second buffer at typical scroll speed\n   * - Prevents \"pop-in\" effect\n   *\n   * **Threshold** (`threshold: 0.01`):\n   * - Fire when 1% of element visible\n   * - Very early detection\n   * - Maximizes pre-render time\n   * - More reliable than 0 across browsers\n   *\n   * **Why these specific values**:\n   * - 200px root margin: Balance between performance and UX\n   * - 0.01 threshold: As early as possible without false positives\n   * - Tested with 100+ items for optimal performance\n   *\n   * ## Callback Execution\n   *\n   * **entry.isIntersecting**:\n   * - `true`: Element entering viewport (or 200px buffer)\n   * - `false`: Element exiting viewport\n   * - Component can show/hide content accordingly\n   *\n   * **Callback guard** (`if (callback)`):\n   * - Handles race conditions\n   * - Element may have been unobserved but event still fires\n   * - Prevents errors from missing callbacks\n   * - Graceful degradation\n   *\n   * ## Performance Impact\n   *\n   * **Observer overhead**: ~1-2ms per intersection event\n   * **Callback execution**: ~0.1ms per callback\n   * **Total overhead**: Negligible compared to component rendering\n   *\n   * **Scalability**:\n   * - Single observer for all elements (efficient)\n   * - Map lookups O(1)\n   * - No DOM queries needed\n   * - Works well with 100+ elements\n   *\n   * @private\n   */\n  private initialize() {\n    // Create observer with 200px margin (pre-render before entering viewport)\n    this.observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          const elementId = entry.target.id;\n          const callback = this.observedElements.get(elementId);\n\n          if (callback) {\n            // Call callback with visibility state\n            callback(entry.isIntersecting);\n          }\n        });\n      },\n      {\n        rootMargin: '200px', // Start loading 200px before entering viewport\n        threshold: 0.01, // Trigger when even 1% is visible\n      }\n    );\n  }\n\n  /**\n   * Observe element for visibility changes\n   *\n   * **Called from**: grid-item-wrapper.tsx componentDidLoad\n   * **Purpose**: Register element for lazy loading when it enters viewport\n   *\n   * ## Registration Process\n   *\n   * **Validation**:\n   * ```typescript\n   * if (!this.observer || !element) return;  // Guard against invalid state\n   * ```\n   *\n   * **Why validation needed**:\n   * - Observer may not be initialized (edge case)\n   * - Element may be null if ref not set\n   * - Fail gracefully without errors\n   * - Defensive programming\n   *\n   * **Store callback**:\n   * ```typescript\n   * this.observedElements.set(elementId, callback);  // Map: id → callback\n   * ```\n   *\n   * **Why store before observing**:\n   * - Callback ready when first intersection fires\n   * - No race condition between observe and callback\n   * - Guaranteed handler availability\n   *\n   * **Start observing**:\n   * ```typescript\n   * this.observer.observe(element);  // Add to observer's watch list\n   * ```\n   *\n   * ## Callback Invocation\n   *\n   * **When callback fires**:\n   * 1. Element enters viewport (or 200px buffer)\n   * 2. Observer callback runs\n   * 3. Looks up callback by elementId\n   * 4. Calls callback(true)\n   * 5. Component updates isVisible state\n   * 6. Component re-renders with actual content\n   *\n   * **Callback signature**:\n   * ```typescript\n   * (isVisible: boolean) => void\n   * ```\n   *\n   * **Typical usage**:\n   * ```typescript\n   * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n   *   this.isVisible = isVisible;  // @State update → re-render\n   * });\n   * ```\n   *\n   * ## Multiple Observations\n   *\n   * **Same element, different callback**:\n   * - New callback replaces old one\n   * - Map key is elementId (unique)\n   * - No duplicate observations\n   * - Latest callback wins\n   *\n   * **Multiple elements**:\n   * - Each gets own callback\n   * - All share single observer\n   * - Efficient batch processing\n   * - Scalable to 100+ items\n   *\n   * ## Memory Impact\n   *\n   * **Per observation**:\n   * - Map entry: ~100 bytes\n   * - Observer tracking: ~50 bytes\n   * - Total: ~150 bytes per item\n   *\n   * **100 items**:\n   * - Map overhead: ~10KB\n   * - Observer overhead: ~5KB\n   * - Total: ~15KB (negligible)\n   *\n   * ## Edge Cases\n   *\n   * **Element already observed**:\n   * - IntersectionObserver handles gracefully\n   * - No duplicate tracking\n   * - Callback map updated\n   *\n   * **Element without ID**:\n   * - Callback stored with undefined key\n   * - Lookups will fail\n   * - Element won't lazy load\n   * - Should ensure ID set\n   *\n   * **Observer not initialized**:\n   * - Guard returns early\n   * - No error thrown\n   * - Element renders immediately\n   * - Graceful degradation\n   *\n   * @param element - DOM element to observe (must have id attribute)\n   * @param elementId - Unique ID for callback lookup (should match element.id)\n   * @param callback - Function called when visibility changes\n   *\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper.tsx componentDidLoad:\n   * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n   *   this.isVisible = isVisible;  // Trigger re-render\n   * });\n   * // → Element now monitored\n   * // → Callback fires when scrolled into view\n   * // → Component renders content instead of placeholder\n   * ```\n   */\n  observe(element: HTMLElement, elementId: string, callback: VisibilityCallback) {\n    if (!this.observer || !element) {\n      return;\n    }\n\n    // Store callback\n    this.observedElements.set(elementId, callback);\n\n    // Start observing\n    this.observer.observe(element);\n  }\n\n  /**\n   * Stop observing element (cleanup)\n   *\n   * **Called from**: grid-item-wrapper.tsx disconnectedCallback\n   * **Purpose**: Remove element from observation and free callback memory\n   *\n   * ## Cleanup Process\n   *\n   * **Validation**:\n   * ```typescript\n   * if (!this.observer || !element) return;  // Guard against invalid state\n   * ```\n   *\n   * **Why validation needed**:\n   * - Observer may be destroyed\n   * - Element may be null during unmount\n   * - Fail gracefully without errors\n   * - Safe cleanup pattern\n   *\n   * **Remove callback**:\n   * ```typescript\n   * this.observedElements.delete(elementId);  // Free callback from map\n   * ```\n   *\n   * **Why delete first**:\n   * - Prevents callback from firing during unobserve\n   * - Immediate cleanup of memory\n   * - No race conditions\n   * - Clean separation\n   *\n   * **Stop observing**:\n   * ```typescript\n   * this.observer.unobserve(element);  // Remove from observer's watch list\n   * ```\n   *\n   * ## Memory Management\n   *\n   * **Callback deletion**:\n   * - Removes Map entry\n   * - Allows callback garbage collection\n   * - Frees ~100 bytes per element\n   * - Critical for long-running apps\n   *\n   * **Observer cleanup**:\n   * - Removes element from internal list\n   * - Stops firing intersection events\n   * - Frees ~50 bytes per element\n   * - Reduces observer overhead\n   *\n   * **What if not called**:\n   * - Callback remains in memory (leak)\n   * - Observer still tracks element (leak)\n   * - ~150 bytes leaked per unmounted item\n   * - Adds up with many mount/unmount cycles\n   *\n   * ## Cleanup Timing\n   *\n   * **Component lifecycle**:\n   * ```\n   * 1. Component mounts → componentDidLoad → observe()\n   * 2. Component unmounts → disconnectedCallback → unobserve()\n   * 3. Element removed from DOM\n   * 4. Callback deleted from map\n   * 5. Observer stops watching\n   * 6. Garbage collector can free memory\n   * ```\n   *\n   * **Why in disconnectedCallback**:\n   * - Called when component removed from DOM\n   * - Guaranteed cleanup point\n   * - Standard web component lifecycle\n   * - No memory leaks\n   *\n   * ## Edge Cases\n   *\n   * **Element not observed**:\n   * - IntersectionObserver handles gracefully\n   * - No error thrown\n   * - Map.delete() returns false but safe\n   * - Idempotent operation\n   *\n   * **Called multiple times**:\n   * - First call removes callback and stops observing\n   * - Subsequent calls are no-ops\n   * - Safe to call multiple times\n   * - Defensive cleanup\n   *\n   * **Observer already destroyed**:\n   * - Guard returns early\n   * - No error thrown\n   * - Map cleanup still happens\n   * - Graceful degradation\n   *\n   * ## Performance Impact\n   *\n   * **Per unobserve**:\n   * - Map.delete(): ~0.01ms\n   * - observer.unobserve(): ~0.1ms\n   * - Total: ~0.11ms (negligible)\n   *\n   * **Batch cleanup** (100 items):\n   * - Sequential unobserve: ~11ms\n   * - Observer.disconnect() + Map.clear(): ~1ms\n   * - destroy() method more efficient for bulk\n   *\n   * @param element - DOM element to stop observing\n   * @param elementId - Element's ID for callback removal\n   *\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper.tsx disconnectedCallback:\n   * disconnectedCallback() {\n   *   if (this.itemRef) {\n   *     virtualRenderer.unobserve(this.itemRef, this.item.id);\n   *   }\n   * }\n   * // → Callback removed from map\n   * // → Observer stops watching element\n   * // → Memory freed for garbage collection\n   * ```\n   */\n  unobserve(element: HTMLElement, elementId: string) {\n    if (!this.observer || !element) {\n      return;\n    }\n\n    // Remove callback\n    this.observedElements.delete(elementId);\n\n    // Stop observing\n    this.observer.unobserve(element);\n  }\n\n  /**\n   * Cleanup all observations (bulk cleanup)\n   *\n   * **Called**: Manually when destroying service (rare, typically page unload)\n   * **Purpose**: Completely tear down observer and free all memory\n   *\n   * ## Cleanup Operations\n   *\n   * **Disconnect observer**:\n   * ```typescript\n   * if (this.observer) {\n   *   this.observer.disconnect();  // Stop watching all elements\n   *   this.observer = null;         // Allow GC\n   * }\n   * ```\n   *\n   * **Why disconnect**:\n   * - Stops all intersection callbacks\n   * - Removes all elements from watch list\n   * - More efficient than unobserve for each element\n   * - Single operation vs N operations\n   *\n   * **Why set to null**:\n   * - Signals observer destroyed\n   * - Guards in other methods will return early\n   * - Allows IntersectionObserver GC\n   * - Clean state reset\n   *\n   * **Clear callbacks**:\n   * ```typescript\n   * this.observedElements.clear();  // Remove all Map entries\n   * ```\n   *\n   * **Why clear**:\n   * - Frees all callback references\n   * - Allows callback GC\n   * - Prevents memory leaks\n   * - Complete cleanup\n   *\n   * ## Performance Comparison\n   *\n   * **destroy() vs unobserve all** (100 items):\n   * - destroy(): disconnect + clear = ~1ms\n   * - unobserve × 100: ~11ms\n   * - **11× faster for bulk cleanup**\n   *\n   * **Memory freed** (100 items):\n   * - Callbacks: ~10KB\n   * - Observer tracking: ~5KB\n   * - Observer instance: ~1KB\n   * - Total: ~16KB\n   *\n   * ## When to Use\n   *\n   * **Appropriate scenarios**:\n   * - Page unload / navigation away\n   * - Application teardown\n   * - Test cleanup (afterEach)\n   * - Hot module reload (HMR)\n   *\n   * **Not appropriate**:\n   * - Individual component unmount (use unobserve)\n   * - Removing some items (use unobserve per item)\n   * - Temporary pause (no such feature needed)\n   *\n   * ## State After Destroy\n   *\n   * **Observer state**:\n   * - `this.observer = null`\n   * - All observe/unobserve calls become no-ops\n   * - Guards prevent errors\n   *\n   * **Callbacks state**:\n   * - `this.observedElements` empty\n   * - All callbacks freed\n   * - No memory leaks\n   *\n   * **Service unusable**:\n   * - Must create new instance to use again\n   * - Or call initialize() if made public\n   * - Current design: create new service\n   *\n   * ## Edge Cases\n   *\n   * **Observer not initialized**:\n   * - Guard skips disconnect\n   * - Only clears callbacks\n   * - Safe even if never initialized\n   *\n   * **Called multiple times**:\n   * - First call destroys everything\n   * - Subsequent calls are no-ops\n   * - Idempotent operation\n   * - Safe defensive cleanup\n   *\n   * **Active intersections**:\n   * - disconnect() cancels all pending callbacks\n   * - No callbacks fire after destroy\n   * - Clean shutdown\n   *\n   * ## Memory Leak Prevention\n   *\n   * **Without destroy**:\n   * - Observer remains in memory\n   * - All callbacks remain referenced\n   * - Elements can't be GC'd\n   * - ~16KB leak per 100 items\n   *\n   * **With destroy**:\n   * - Observer freed\n   * - Callbacks freed\n   * - Elements can be GC'd\n   * - No memory leaks\n   *\n   * @example\n   * ```typescript\n   * // On page unload:\n   * window.addEventListener('beforeunload', () => {\n   *   virtualRenderer.destroy();\n   * });\n   *\n   * // In tests:\n   * afterEach(() => {\n   *   virtualRenderer.destroy();\n   * });\n   *\n   * // Hot module reload:\n   * if (module.hot) {\n   *   module.hot.dispose(() => {\n   *     virtualRenderer.destroy();\n   *   });\n   * }\n   * ```\n   */\n  destroy() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n    this.observedElements.clear();\n  }\n}\n\n/**\n * Singleton VirtualRenderer instance\n * ====================================\n *\n * Global singleton instance shared across all grid components.\n *\n * ## Singleton Pattern\n *\n * **Why singleton**:\n * - Single IntersectionObserver for all items (efficient)\n * - Shared callback registry (O(1) lookups)\n * - Consistent configuration across app\n * - Easier to use (no prop drilling)\n * - Standard service pattern\n *\n * **Instantiation**:\n * ```typescript\n * export const virtualRenderer = new VirtualRendererService();\n * ```\n * - Created at module load time\n * - Immediately available to all components\n * - Initializes IntersectionObserver\n * - Ready for observe() calls\n *\n * ## Usage Pattern\n *\n * **In grid-builder-app.tsx** (optional, for visibility):\n * ```typescript\n * componentDidLoad() {\n *   // Expose globally for debugging (optional)\n *   (window as any).virtualRenderer = virtualRenderer;\n * }\n * ```\n *\n * **In grid-item-wrapper.tsx**:\n * ```typescript\n * import { virtualRenderer } from '../../services/virtual-renderer';\n *\n * componentDidLoad() {\n *   virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *     this.isVisible = isVisible;\n * });\n * }\n *\n * disconnectedCallback() {\n *   virtualRenderer.unobserve(this.itemRef, this.item.id);\n * }\n * ```\n *\n * ## Global State\n *\n * **Observer shared across**:\n * - All grid-item-wrapper components\n * - All canvas sections\n * - Entire application\n *\n * **Benefits**:\n * - Single observer instance (low overhead)\n * - Batch intersection processing\n * - Consistent behavior\n * - Simple API\n *\n * ## Alternative Patterns\n *\n * **Could use React Context** (not needed):\n * ```typescript\n * const VirtualRendererContext = createContext(virtualRenderer);\n * // More boilerplate, no real benefit\n * ```\n *\n * **Could use dependency injection** (overkill):\n * ```typescript\n * @Inject() virtualRenderer: VirtualRendererService\n * // Complex setup, no benefit for this use case\n * ```\n *\n * **Singleton is simplest**:\n * - Direct import\n * - No context setup\n * - No DI container\n * - Works across frameworks\n *\n * @example\n * ```typescript\n * // Import and use directly:\n * import { virtualRenderer } from './virtual-renderer';\n *\n * virtualRenderer.observe(element, id, callback);\n * ```\n */\nexport const virtualRenderer = new VirtualRendererService();\n","/**\n * Drag Handler\n * ============\n *\n * High-performance drag-and-drop system for grid items using interact.js and direct DOM\n * manipulation. This module handles smooth 60fps dragging while avoiding framework\n * re-render overhead.\n *\n * ## Problem\n *\n * Dragging UI elements at 60fps requires updating positions ~16ms per frame. Using\n * framework state updates would cause:\n * - Full component re-renders on every mousemove event\n * - Virtual DOM diffing overhead\n * - Layout thrashing from read/write cycles\n * - Janky, stuttering drag experience\n *\n * ## Solution\n *\n * Hybrid approach combining interact.js events with direct DOM manipulation:\n *\n * 1. **During drag** (60fps): Direct DOM updates via `element.style.transform`\n * - No state updates\n * - No re-renders\n * - Smooth visual feedback\n *\n * 2. **After drag** (single operation): Update StencilJS state once\n * - Trigger single re-render\n * - Persist final position\n * - Emit undo/redo commands\n *\n * ## Key Architecture Decisions\n *\n * ### Transform vs Top/Left Positioning\n *\n * **Using**: `transform: translate(x, y)`\n * **Not using**: `top: y; left: x;`\n *\n * **Why transforms**:\n * - GPU-accelerated (composited layer)\n * - Doesn't trigger layout/reflow\n * - Subpixel precision for smooth animations\n * - Better performance on low-end devices\n *\n * **Why not top/left**:\n * - Triggers layout recalculation\n * - CPU-bound rendering\n * - Causes reflows affecting other elements\n * - Stuttery on complex layouts\n *\n * ### Grid Snapping Strategy\n *\n * **When**: Only at drag end\n * **How**: `Math.round(position / gridSize) * gridSize`\n * **Why**: Allows free-form dragging during operation, snaps to grid on release\n *\n * ### Cross-Canvas Dragging\n *\n * Detects when item is dragged over different canvas by:\n * 1. Tracking drag start canvas ID\n * 2. Finding element center point at drag end\n * 3. Hit-testing against all canvas bounding boxes\n * 4. Delegating to dropzone handler if canvas changed\n *\n * ## Performance Characteristics\n *\n * **During drag** (per frame):\n * - 1 style update (transform)\n * - 2 data attribute updates\n * - No layout/reflow\n * - ~0.5ms per frame\n *\n * **At drag end**:\n * - Grid snapping calculations\n * - Edge snapping checks\n * - State update + single re-render\n * - ~5-10ms total\n *\n * **Performance gain over state-based approach**:\n * - State-based: ~16ms+ per frame (re-render overhead)\n * - This approach: ~0.5ms per frame\n * - **~30x faster during drag**\n *\n * ## Edge Cases Handled\n *\n * - Cross-canvas drag detection\n * - Boundary constraints (can't drag outside canvas)\n * - Edge snapping (auto-snap to canvas edges within 20px)\n * - Mobile vs desktop viewport layouts\n * - Dragging from non-drag handles prevented\n * - Clean state cleanup on component destruction\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n *\n * ```typescript\n * class MyDragHandler {\n * private basePos = { x: 0, y: 0 };\n *\n * handleDragStart(e) {\n * // Store starting position\n * this.basePos = getCurrentPosition(e.target);\n * }\n *\n * handleDragMove(e) {\n * // Direct DOM update (no framework state)\n * const newX = this.basePos.x + e.dx;\n * const newY = this.basePos.y + e.dy;\n * e.target.style.transform = `translate(${newX}px, ${newY}px)`;\n * }\n *\n * handleDragEnd(e) {\n * // Snap to grid/constraints\n * const snapped = snapToGrid(finalPosition);\n * e.target.style.transform = `translate(${snapped.x}px, ${snapped.y}px)`;\n *\n * // Single state update triggers framework re-render\n * this.updateState(snapped);\n * }\n * }\n * ```\n *\n * ## Integration with Other Systems\n *\n * - **grid-calculations**: Convert between pixels and grid units\n * - **dom-cache**: Fast canvas element lookup\n * - **state-manager**: Single state update at drag end\n * - **undo-redo**: Command pushed via onUpdate callback\n * - **interact.js**: Event source for drag lifecycle\n * @module drag-handler\n */\n\nimport { GridItem } from '../services/state-manager';\nimport { domCache } from './dom-cache';\nimport { getGridSizeHorizontal, getGridSizeVertical, pixelsToGridX, pixelsToGridY } from './grid-calculations';\n\n/**\n * Extract current transform position from element's inline style\n *\n * Parses the `transform: translate(Xpx, Ypx)` CSS property to get current position.\n * This is needed because drag deltas are cumulative - we need the base position\n * to add deltas to.\n *\n * **Why needed**:\n * - Drag uses cumulative deltas (dx, dy) from drag start\n * - Must add to initial position, not reset each frame\n * - Transform string is canonical source of truth during drag\n *\n * **Performance**:\n * - Regex parsing is fast (< 0.1ms)\n * - Only called once at drag start, not per frame\n *\n * **Regex explanation**:\n * - `([\\d.-]+)` matches numbers including decimals and negatives\n * - More specific than `[^,]+` to avoid ReDoS issues\n * - Matches: `translate(10.5px, -20.3px)`\n * @param element - Element with transform style\n * @returns Current x,y position in pixels, or {0,0} if no transform\n * @example\n * ```typescript\n * const el = document.getElementById('item-1');\n * el.style.transform = 'translate(150px, 200px)';\n * const pos = getTransformPosition(el); // → {x: 150, y: 200}\n * ```\n */\nfunction getTransformPosition(element: HTMLElement): { x: number; y: number } {\n  const transform = element.style.transform;\n  const match = transform.match(/translate\\(([\\d.-]+)px,\\s*([\\d.-]+)px\\)/);\n\n  if (match) {\n    return {\n      x: parseFloat(match[1]),\n      y: parseFloat(match[2]),\n    };\n  }\n\n  return { x: 0, y: 0 };\n}\n\n/**\n * Drag Handler Class\n * ===================\n *\n * Manages high-performance drag behavior for a single grid item. Each grid item\n * gets its own DragHandler instance that coordinates interact.js events with\n * DOM updates and state management.\n *\n * ## Instance Lifecycle\n *\n * 1. **Creation**: Instantiated by grid-item-wrapper when item mounts\n * 2. **Initialization**: Sets up interact.js draggable with event listeners\n * 3. **Active**: Handles drag events with direct DOM manipulation\n * 4. **Cleanup**: destroy() called when item unmounts to prevent memory leaks\n *\n * ## State Management\n *\n * **Private state** (not in framework):\n * - `basePosition`: Starting transform position at drag start\n * - `dragStartCanvasId`: Original canvas ID for cross-canvas detection\n * - `interactInstance`: interact.js draggable instance\n *\n * **Framework state**: Updated only once at drag end via `onUpdate` callback\n *\n * ## Performance Pattern\n *\n * This class implements the \"direct manipulation + deferred state\" pattern:\n * - High-frequency events (move): Direct DOM updates\n * - Low-frequency events (start/end): State updates + event tracking\n * @example\n * ```typescript\n * // In grid-item-wrapper.tsx\n * componentDidLoad() {\n *   this.dragHandler = new DragHandler(\n *     this.element,\n *     this.item,\n *     (updatedItem) => {\n *       // This callback runs ONCE at drag end\n *       gridState.updateItem(updatedItem);\n *       undoRedo.pushCommand(new MoveCommand(this.item, updatedItem));\n *     }\n *   );\n * }\n *\n * disconnectedCallback() {\n *   this.dragHandler?.destroy(); // Cleanup\n * }\n * ```\n */\nexport class DragHandler {\n  /** DOM element being dragged (grid-item-wrapper element) */\n  private element: HTMLElement;\n\n  /** Grid item data (position, size, layouts) */\n  private item: GridItem;\n\n  /** Callback to update parent state after drag ends */\n  private onUpdate: (item: GridItem) => void;\n\n  /** interact.js draggable instance for cleanup */\n  private interactInstance: any;\n\n  /** Position at drag start (from transform) - used to apply deltas */\n  private basePosition: { x: number; y: number } = { x: 0, y: 0 };\n\n  /** Canvas ID where drag started - for cross-canvas detection */\n  private dragStartCanvasId: string = '';\n\n  /**\n   * Create drag handler and initialize interact.js\n   *\n   * **Lifecycle**: Called when grid-item-wrapper mounts\n   *\n   * **Why auto-initialize in constructor**:\n   * - Ensures drag is ready immediately after creation\n   * - Simplifies component code (no separate setup call)\n   * - Matches StencilJS lifecycle (componentDidLoad)\n   *\n   * **Performance**: Initialization is cheap (~1ms), deferred to constructor is fine\n   * @param element - DOM element to make draggable (grid-item-wrapper)\n   * @param item - Grid item data for position/layout management\n   * @param onUpdate - Callback invoked with updated item after drag ends\n   * @example\n   * ```typescript\n   * // Typical usage in component\n   * private dragHandler: DragHandler;\n   *\n   * componentDidLoad() {\n   *   this.dragHandler = new DragHandler(\n   *     this.element,\n   *     this.item,\n   *     (item) => this.handleItemUpdate(item)\n   *   );\n   * }\n   * ```\n   */\n  constructor(element: HTMLElement, item: GridItem, onUpdate: (item: GridItem) => void) {\n    this.element = element;\n    this.item = item;\n    this.onUpdate = onUpdate;\n\n    this.initialize();\n  }\n\n  /**\n   * Cleanup interact.js instance to prevent memory leaks\n   *\n   * **When to call**: Component unmount (disconnectedCallback in StencilJS)\n   *\n   * **Why needed**:\n   * - interact.js attaches event listeners to elements\n   * - Without cleanup, listeners persist after element removal\n   * - Causes memory leaks and potential errors on removed elements\n   *\n   * **What it does**:\n   * - Calls `interactInstance.unset()` to remove all interact.js listeners\n   * - Safe to call multiple times (checks if instance exists)\n   *\n   * **Performance**: Very cheap operation (~0.1ms)\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper component\n   * disconnectedCallback() {\n   *   if (this.dragHandler) {\n   *     this.dragHandler.destroy();\n   *   }\n   * }\n   * ```\n   */\n  destroy(): void {\n    if (this.interactInstance) {\n      this.interactInstance.unset();\n    }\n  }\n\n  /**\n   * Initialize interact.js draggable on element\n   *\n   * **Configuration choices**:\n   *\n   * **allowFrom: '.drag-handle'**\n   * - Only allows drag from drag handle element\n   * - Prevents accidental drags when clicking buttons/inputs inside item\n   * - Improves UX by requiring intentional drag gesture\n   *\n   * **inertia: false**\n   * - Disables momentum/physics after drag release\n   * - Grid snapping works better without inertia\n   * - Provides more predictable, precise positioning\n   *\n   * **Event binding**:\n   * - Uses `.bind(this)` to preserve class context in event handlers\n   * - Without bind, `this` would be interact.js context, not DragHandler\n   * - Allows handlers to access instance properties (element, item, etc.)\n   *\n   * **Error handling**:\n   * - Checks if interact.js loaded (from CDN script tag)\n   * - Fails gracefully with console warning if missing\n   * - Prevents app crash if CDN fails to load\n   * @example\n   * ```typescript\n   * // interact.js setup with event handlers\n   * interact(element).draggable({\n   *   allowFrom: '.drag-handle',\n   *   inertia: false,\n   *   listeners: {\n   *     start: handleDragStart,\n   *     move: handleDragMove,\n   *     end: handleDragEnd,\n   *   }\n   * });\n   * ```\n   */\n  private initialize(): void {\n    const interact = (window as any).interact;\n    if (!interact) {\n      console.warn('interact.js not loaded');\n      return;\n    }\n\n    this.interactInstance = interact(this.element).draggable({\n      allowFrom: '.drag-handle', // Only allow drag from drag handle\n      inertia: false,\n      listeners: {\n        start: this.handleDragStart.bind(this),\n        move: this.handleDragMove.bind(this),\n        end: this.handleDragEnd.bind(this),\n      },\n    });\n  }\n\n  /**\n   * Handle drag start event\n   *\n   * **Responsibilities**:\n   * 1. Start performance monitoring (if perfMonitor available)\n   * 2. Add visual feedback (dragging class)\n   * 3. Capture initial state for cross-canvas detection\n   * 4. Extract base position from current transform\n   * 5. Reset delta accumulators\n   *\n   * **Why capture dragStartCanvasId**:\n   * - item.canvasId may be updated by dropzone during drag\n   * - Need original canvas to detect if item moved to different canvas\n   * - Enables cross-canvas drag detection at drag end\n   *\n   * **Why extract basePosition**:\n   * - interact.js provides cumulative deltas (dx, dy) from drag start\n   * - Must add deltas to starting position, not reset each frame\n   * - Transform string is canonical position source during drag\n   *\n   * **Data attributes usage**:\n   * - `data-x`, `data-y`: Store cumulative deltas from drag start\n   * - Reset to 0 at drag start\n   * - Updated on every move event\n   * - Used to calculate final position at drag end\n   *\n   * **Performance tracking**:\n   * - Optional perfMonitor integration for debugging\n   * - Measures total drag duration (start → end)\n   * - Helps identify performance regressions\n   * @param event - interact.js drag start event\n   * @example\n   * ```typescript\n   * // Event data structure\n   * {\n   *   target: HTMLElement,        // Element being dragged\n   *   dx: 0,                      // Delta X (always 0 at start)\n   *   dy: 0,                      // Delta Y (always 0 at start)\n   *   // ... other interact.js properties\n   * }\n   * ```\n   */\n  private handleDragStart(event: any): void {\n    // Start performance tracking\n    if ((window as any).perfMonitor) {\n      (window as any).perfMonitor.startOperation('drag');\n    }\n\n    event.target.classList.add('dragging');\n\n    // Store the original canvas ID at drag start\n    this.dragStartCanvasId = this.item.canvasId;\n\n    // Store the base position from transform\n    this.basePosition = getTransformPosition(event.target);\n\n    // Reset accumulation\n    event.target.setAttribute('data-x', '0');\n    event.target.setAttribute('data-y', '0');\n  }\n\n  /**\n   * Handle drag move event (high-frequency, ~60fps)\n   *\n   * **Critical Performance Path**: This runs ~60 times per second during drag\n   *\n   * **Direct DOM Manipulation**:\n   * - Updates `element.style.transform` directly\n   * - No StencilJS state updates\n   * - No component re-renders\n   * - No virtual DOM diffing\n   * - Result: Smooth 60fps drag performance\n   *\n   * **Why this approach**:\n   * - State-based: Update state → trigger render → diff vdom → update DOM (~16ms+)\n   * - Direct DOM: Update transform property directly (~0.5ms)\n   * - **30x faster** than state-based approach\n   *\n   * **Delta accumulation**:\n   * - interact.js provides cumulative deltas since drag start\n   * - Read current delta from data attributes\n   * - Add new delta from event\n   * - Store back to data attributes\n   * - Apply to base position for final transform\n   *\n   * **Formula**:\n   * ```\n   * newX = basePosition.x + totalDeltaX\n   * newY = basePosition.y + totalDeltaY\n   * ```\n   *\n   * **Why data attributes**:\n   * - Persist state across events without class properties\n   * - Can be read/written during event without this context\n   * - Survive potential element re-renders (though we avoid those)\n   *\n   * **Performance per frame**:\n   * - 1 transform style update\n   * - 2 data attribute updates\n   * - No layout/reflow (transform is composited)\n   * - Total: ~0.5ms\n   * @param event - interact.js drag move event\n   * @example\n   * ```typescript\n   * // Event provides cumulative deltas\n   * {\n   *   target: HTMLElement,\n   *   dx: 5,    // 5px moved horizontally since drag start\n   *   dy: 3,    // 3px moved vertically since drag start\n   * }\n   *\n   * // Applied as:\n   * // transform = translate(baseX + 5px, baseY + 3px)\n   * ```\n   */\n  private handleDragMove(event: any): void {\n    const x = (parseFloat(event.target.getAttribute('data-x')) || 0) + event.dx;\n    const y = (parseFloat(event.target.getAttribute('data-y')) || 0) + event.dy;\n\n    // Apply drag delta to base position\n    // Direct DOM manipulation - no StencilJS re-render during drag\n    event.target.style.transform = `translate(${this.basePosition.x + x}px, ${this.basePosition.y + y}px)`;\n    event.target.setAttribute('data-x', x.toString());\n    event.target.setAttribute('data-y', y.toString());\n  }\n\n  /**\n   * Handle drag end event - finalize position and update state\n   *\n   * **Most Complex Method**: Handles grid snapping, boundary constraints, cross-canvas\n   * detection, mobile layout handling, and state persistence.\n   *\n   * ## Processing Steps\n   *\n   * ### 1. Cross-Canvas Detection\n   * - Calculate item center point in viewport coordinates\n   * - Hit-test against all canvas bounding boxes\n   * - Detect if dragged to different canvas\n   * - **Early exit**: Let dropzone handler manage cross-canvas moves\n   *\n   * **Why check center point**:\n   * - More intuitive than checking any corner\n   * - Prevents accidental canvas switches when edge crosses boundary\n   * - Matches user mental model (\"where did I drop it?\")\n   *\n   * **Why delegate to dropzone**:\n   * - Dropzone has specialized logic for cross-canvas moves\n   * - Handles state transfer between canvases\n   * - Emits proper undo/redo commands\n   * - This handler focuses on same-canvas repositioning\n   *\n   * ### 2. Grid Snapping\n   * Formula: `Math.round(position / gridSize) * gridSize`\n   * - Rounds to nearest grid unit\n   * - Separate X and Y snapping (different grid sizes)\n   * - Applied before boundary constraints\n   *\n   * **Why snap before constraints**:\n   * - Ensures snapped position respects grid\n   * - Constraints then clip to canvas bounds\n   * - Prevents off-grid positions at edges\n   *\n   * ### 3. Boundary Constraints\n   * - Prevents item from extending outside canvas\n   * - Uses `Math.max(0, Math.min(pos, maxPos))` clamp pattern\n   * - Considers item width/height (full item must be visible)\n   *\n   * ### 4. Edge Snapping\n   * - Auto-snap to canvas edges within 20px threshold\n   * - Provides \"magnetic\" edges for precise alignment\n   * - Applied after grid snapping (takes precedence)\n   *\n   * **UX benefit**:\n   * - Easy to align items to canvas edges\n   * - No need for pixel-perfect dragging\n   * - Common layout pattern (full-width headers, etc.)\n   *\n   * ### 5. Mobile Layout Handling\n   * - Detects current viewport (desktop vs mobile)\n   * - Updates appropriate layout object\n   * - Marks mobile layout as \"customized\" when modified\n   * - Initializes mobile width/height from desktop if not set\n   *\n   * **Why \"customized\" flag**:\n   * - Mobile layouts default to desktop layout\n   * - Flag indicates user explicitly modified mobile layout\n   * - Prevents future desktop changes from overwriting mobile\n   *\n   * ### 6. State Persistence\n   * - Converts final pixel position to grid units\n   * - Updates item.layouts with new position\n   * - Calls `onUpdate(item)` callback\n   * - Triggers single StencilJS re-render\n   * - Parent component pushes undo/redo command\n   *\n   * ## Performance Characteristics\n   *\n   * **Total execution time**: ~5-10ms\n   * - Cross-canvas detection: ~1-2ms (querySelectorAll + getBoundingClientRect)\n   * - Grid calculations: ~1ms\n   * - Boundary checks: ~0.5ms\n   * - State update: ~3-5ms (single re-render)\n   *\n   * **Why this is acceptable**:\n   * - Only runs once at drag end (not 60fps)\n   * - User expects slight delay when releasing drag\n   * - Grid snapping provides visual feedback justifying delay\n   *\n   * ## Edge Cases Handled\n   *\n   * - Item dragged outside canvas bounds → clamped to canvas\n   * - Item dragged to different canvas → delegated to dropzone\n   * - Canvas container not found → early exit (safety)\n   * - Mobile view with no mobile layout → initialized from desktop\n   * - Item near edge → snapped to edge for alignment\n   * @param event - interact.js drag end event\n   * @example\n   * ```typescript\n   * // Example drag sequence:\n   * // 1. handleDragStart: Store basePosition (100, 200)\n   * // 2. handleDragMove (60 times): Update transform with deltas\n   * // 3. handleDragEnd: deltaX=150, deltaY=75\n   * //    - finalX = 100 + 150 = 250px\n   * //    - snappedX = Math.round(250 / 20) * 20 = 260px\n   * //    - gridX = 260 / 20 = 13 grid units\n   * //    - item.layouts.desktop.x = 13\n   * //    - onUpdate(item) → re-render + undo command\n   * ```\n   */\n  private handleDragEnd(event: any): void {\n    event.target.classList.remove('dragging');\n\n    const deltaX = parseFloat(event.target.getAttribute('data-x')) || 0;\n    const deltaY = parseFloat(event.target.getAttribute('data-y')) || 0;\n\n    // Get the element's current position in viewport\n    const rect = event.target.getBoundingClientRect();\n    const centerX = rect.left + rect.width / 2;\n    const centerY = rect.top + rect.height / 2;\n\n    // Find which canvas the center of the item is over\n    let targetCanvasId = this.item.canvasId;\n\n    const gridContainers = document.querySelectorAll('.grid-container');\n    gridContainers.forEach((container: HTMLElement) => {\n      const containerRect = container.getBoundingClientRect();\n      if (\n        centerX >= containerRect.left &&\n        centerX <= containerRect.right &&\n        centerY >= containerRect.top &&\n        centerY <= containerRect.bottom\n      ) {\n        targetCanvasId = container.getAttribute('data-canvas-id') || this.item.canvasId;\n      }\n    });\n\n    // If canvas changed from drag start, let the dropzone handle it\n    // (Use dragStartCanvasId since item.canvasId may have been updated by dropzone already)\n    if (targetCanvasId !== this.dragStartCanvasId) {\n      // Clean up drag state\n      event.target.classList.remove('dragging');\n      event.target.setAttribute('data-x', '0');\n      event.target.setAttribute('data-y', '0');\n\n      // End performance tracking\n      if ((window as any).perfMonitor) {\n        (window as any).perfMonitor.endOperation('drag');\n      }\n      return;\n    }\n\n    // Calculate new position relative to current canvas (same-canvas drag only)\n    const targetContainer = domCache.getCanvas(targetCanvasId);\n    if (!targetContainer) {\n      return;\n    }\n\n    const gridSizeX = getGridSizeHorizontal(targetCanvasId);\n    const gridSizeY = getGridSizeVertical();\n\n    // Final position is base position + drag delta\n    let newX = this.basePosition.x + deltaX;\n    let newY = this.basePosition.y + deltaY;\n\n    // Snap to grid (separate X and Y)\n    newX = Math.round(newX / gridSizeX) * gridSizeX;\n    newY = Math.round(newY / gridSizeY) * gridSizeY;\n\n    // Ensure item stays fully within target canvas\n    const itemWidth = parseFloat(event.target.style.width) || 0;\n    const itemHeight = parseFloat(event.target.style.height) || 0;\n    newX = Math.max(0, Math.min(newX, targetContainer.clientWidth - itemWidth));\n    newY = Math.max(0, Math.min(newY, targetContainer.clientHeight - itemHeight));\n\n    // Snap to canvas edges if within threshold (20px)\n    const EDGE_SNAP_THRESHOLD = 20;\n    if (newX < EDGE_SNAP_THRESHOLD) {\n      newX = 0; // Snap to left edge\n    } else if (newX > targetContainer.clientWidth - itemWidth - EDGE_SNAP_THRESHOLD) {\n      newX = targetContainer.clientWidth - itemWidth; // Snap to right edge\n    }\n    if (newY < EDGE_SNAP_THRESHOLD) {\n      newY = 0; // Snap to top edge\n    } else if (newY > targetContainer.clientHeight - itemHeight - EDGE_SNAP_THRESHOLD) {\n      newY = targetContainer.clientHeight - itemHeight; // Snap to bottom edge\n    }\n\n    // Update item position in current viewport's layout (convert to grid units)\n    const currentViewport = (window as any).gridState?.currentViewport || 'desktop';\n    const layout = this.item.layouts[currentViewport as 'desktop' | 'mobile'];\n\n    layout.x = pixelsToGridX(newX, targetCanvasId);\n    layout.y = pixelsToGridY(newY);\n\n    // If in mobile view, mark as customized\n    if (currentViewport === 'mobile') {\n      this.item.layouts.mobile.customized = true;\n      // Set width/height if not already set (copy from desktop)\n      if (this.item.layouts.mobile.width === null) {\n        this.item.layouts.mobile.width = this.item.layouts.desktop.width;\n      }\n      if (this.item.layouts.mobile.height === null) {\n        this.item.layouts.mobile.height = this.item.layouts.desktop.height;\n      }\n    }\n\n    // Apply final snapped position to DOM\n    event.target.style.transform = `translate(${newX}px, ${newY}px)`;\n    event.target.setAttribute('data-x', '0');\n    event.target.setAttribute('data-y', '0');\n\n    // End performance tracking\n    if ((window as any).perfMonitor) {\n      (window as any).perfMonitor.endOperation('drag');\n    }\n\n    // Trigger StencilJS update (single re-render at end)\n    this.onUpdate(this.item);\n  }\n}\n","/**\n * Resize Handler\n * ===============\n *\n * High-performance resize system for grid items using interact.js with direct DOM\n * manipulation and requestAnimationFrame batching. Enables smooth 60fps resizing\n * with 8-point handles while avoiding framework re-render overhead.\n *\n * ## Problem\n *\n * Resizing UI elements at 60fps requires updating dimensions and position ~16ms per frame.\n * Using framework state updates would cause:\n * - Full component re-renders on every mousemove event during resize\n * - Virtual DOM diffing overhead\n * - Layout thrashing from repeated read/write cycles\n * - Janky, stuttering resize experience\n * - Position jumping on certain resize handles (bottom/right edges)\n *\n * ## Solution\n *\n * Hybrid approach combining interact.js resize events with RAF-batched DOM updates:\n *\n * 1. **During resize** (60fps): Direct DOM updates via RAF batching\n *    - No state updates\n *    - No re-renders\n *    - Smooth visual feedback\n *    - Batched with requestAnimationFrame\n *\n * 2. **After resize** (single operation): Update StencilJS state once\n *    - Trigger single re-render\n *    - Persist final dimensions\n *    - Emit undo/redo commands\n *\n * ## Key Architecture Decisions\n *\n * ### 8-Point Resize Handles\n *\n * **Configuration**: `edges: { left: true, right: true, bottom: true, top: true }`\n *\n * Provides 8 resize handles:\n * - 4 corners: top-left, top-right, bottom-left, bottom-right\n * - 4 edges: top, right, bottom, left\n *\n * **Why all 8 handles**:\n * - Maximum flexibility for users\n * - Matches familiar UI patterns (Figma, Photoshop, etc.)\n * - Enables precise positioning and sizing\n *\n * ### RequestAnimationFrame Batching\n *\n * **Pattern**:\n * ```typescript\n * handleResizeMove(event) {\n *   cancelAnimationFrame(this.rafId);\n *   this.rafId = requestAnimationFrame(() => {\n *     // Apply DOM updates once per frame\n *   });\n * }\n * ```\n *\n * **Why RAF batching**:\n * - Mousemove events fire faster than display refresh (60fps)\n * - Without batching: multiple DOM updates per frame (wasted work)\n * - With batching: exactly 1 DOM update per frame (aligned with browser paint)\n * - Prevents layout thrashing\n * - Smoother visual updates\n *\n * **Performance impact**:\n * - Without RAF: ~200 updates/sec, many dropped frames\n * - With RAF: ~60 updates/sec, no dropped frames\n * - **3-4x fewer DOM operations**\n *\n * ### Grid Snapping Strategy\n *\n * **When**: Only at resize end (endOnly: true)\n * **Why**: Allows free-form resizing during operation, snaps to grid on release\n *\n * **interact.js modifier**:\n * ```typescript\n * interact.modifiers.snap({\n *   targets: [interact.snappers.grid({ x: gridSizeX, y: gridSizeY })],\n *   endOnly: true  // Critical: prevents mid-resize jumps\n * })\n * ```\n *\n * **Alternative approaches and why they fail**:\n * - Snap during resize: Causes visual jumping, poor UX\n * - Manual snapping in handleResizeEnd: Works, but duplicates logic\n * - endOnly modifier: Clean, performant, built into interact.js\n *\n * ### DeltaRect Position Preservation\n *\n * **Problem**: Resizing from left/top edges changes element position\n * **Solution**: Track accumulated deltas and update transform\n *\n * **Example**:\n * - Resize from left edge: width increases, x position decreases\n * - deltaRect.left = -50 (element moved left 50px)\n * - deltaRect.width = 50 (element grew 50px wider)\n * - Apply both: new x = startX + (-50), new width = startWidth + 50\n *\n * **Why this is tricky**:\n * - Bottom/right resizes only change dimensions\n * - Top/left resizes change BOTH position and dimensions\n * - Must update transform AND width/height simultaneously\n * - interact.js provides deltaRect to handle this automatically\n *\n * ### Minimum Size Constraints\n *\n * **Configuration**:\n * ```typescript\n * interact.modifiers.restrictSize({ min: { width: 100, height: 80 } })\n * ```\n *\n * **Why these minimums**:\n * - width: 100px → ~5 grid units (enough for readable text/UI)\n * - height: 80px → ~4 grid units (matches common component heights)\n * - Prevents accidentally collapsing items to unusable sizes\n * - No maximum (items can grow to fill canvas)\n *\n * ## Performance Characteristics\n *\n * **During resize** (per frame):\n * - 1 RAF batch (~60fps max)\n * - 3 style updates (transform, width, height)\n * - No layout/reflow (transform is composited)\n * - ~0.5-1ms per frame\n *\n * **At resize end**:\n * - Grid snapping calculations\n * - Boundary constraint checks\n * - State update + single re-render\n * - ~5-10ms total\n *\n * **Performance gain over state-based approach**:\n * - State-based: ~16ms+ per frame (re-render overhead)\n * - This approach: ~0.5-1ms per frame\n * - **~16-30x faster during resize**\n *\n * ## Edge Cases Handled\n *\n * - Resize from any of 8 handles\n * - Position preservation during top/left resize\n * - Boundary constraints (can't resize outside canvas)\n * - Minimum size enforcement (100×80px)\n * - Grid snapping without mid-resize jumps\n * - Mobile vs desktop viewport layouts\n * - Element styles not yet applied (RAF delay in constructor)\n * - Clean RAF cancellation on destroy\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n *\n * ```typescript\n * class MyResizeHandler {\n *   private rafId: number | null = null;\n *   private startRect = { x: 0, y: 0, width: 0, height: 0 };\n *\n *   handleResizeMove(e) {\n *     // Cancel previous frame\n *     if (this.rafId) cancelAnimationFrame(this.rafId);\n *\n *     // Batch with RAF\n *     this.rafId = requestAnimationFrame(() => {\n *       // Accumulate deltas\n *       this.startRect.x += e.deltaRect.left;\n *       this.startRect.y += e.deltaRect.top;\n *       this.startRect.width += e.deltaRect.width;\n *       this.startRect.height += e.deltaRect.height;\n *\n *       // Direct DOM update\n *       e.target.style.transform = `translate(${this.startRect.x}px, ${this.startRect.y}px)`;\n *       e.target.style.width = this.startRect.width + 'px';\n *       e.target.style.height = this.startRect.height + 'px';\n *     });\n *   }\n *\n *   handleResizeEnd(e) {\n *     cancelAnimationFrame(this.rafId);\n *     // Single state update\n *     this.updateState(this.startRect);\n *   }\n * }\n * ```\n *\n * ## Integration with Other Systems\n *\n * - **grid-calculations**: Convert between pixels and grid units\n * - **dom-cache**: Fast canvas element lookup\n * - **state-manager**: Single state update at resize end\n * - **undo-redo**: Command pushed via onUpdate callback\n * - **interact.js**: Event source for resize lifecycle + modifiers\n *\n * @module resize-handler\n */\n\nimport { GridItem } from '../services/state-manager';\nimport { domCache } from './dom-cache';\nimport { getGridSizeHorizontal, getGridSizeVertical, pixelsToGridX, pixelsToGridY } from './grid-calculations';\n\n/**\n * Extract current transform position from element's inline style\n *\n * **Purpose**: Get element's current position for resize start position tracking\n *\n * **Why needed**: Resize operations must preserve position when resizing from\n * top/left handles. The transform is the canonical position source during operations.\n *\n * **Pattern shared with drag-handler**: Both drag and resize need base position\n * extraction, so this function is duplicated (could be extracted to shared utility).\n *\n * @param element - Element with transform style\n * @returns Current x,y position in pixels, or {0,0} if no transform\n *\n * @example\n * ```typescript\n * const el = document.getElementById('item-1');\n * el.style.transform = 'translate(100px, 150px)';\n * const pos = getTransformPosition(el); // → {x: 100, y: 150}\n * ```\n */\nfunction getTransformPosition(element: HTMLElement): { x: number; y: number } {\n  const transform = element.style.transform;\n  const match = transform.match(/translate\\(([\\d.-]+)px,\\s*([\\d.-]+)px\\)/);\n\n  if (match) {\n    return {\n      x: parseFloat(match[1]),\n      y: parseFloat(match[2]),\n    };\n  }\n\n  return { x: 0, y: 0 };\n}\n\n/**\n * Resize Handler Class\n * =====================\n *\n * Manages high-performance resize behavior for a single grid item. Each grid item\n * gets its own ResizeHandler instance that coordinates interact.js resize events\n * with RAF-batched DOM updates and state management.\n *\n * ## Instance Lifecycle\n *\n * 1. **Creation**: Instantiated by grid-item-wrapper when item mounts\n * 2. **Initialization**: Sets up interact.js resizable with 8 handles + modifiers\n * 3. **Active**: Handles resize events with RAF-batched DOM manipulation\n * 4. **Cleanup**: destroy() called when item unmounts to prevent RAF/memory leaks\n *\n * ## State Management\n *\n * **Private state** (not in framework):\n * - `startRect`: Position and size at resize start\n * - `resizeRafId`: RAF handle for batching updates\n * - `interactInstance`: interact.js resizable instance\n *\n * **Framework state**: Updated only once at resize end via `onUpdate` callback\n *\n * ## Performance Pattern\n *\n * RAF batching + direct manipulation:\n * - High-frequency events (move): RAF-batched DOM updates\n * - Low-frequency events (start/end): State updates + event tracking\n * - Cancel pending RAF on each move (only last frame executes)\n *\n * @example\n * ```typescript\n * // In grid-item-wrapper.tsx\n * componentDidLoad() {\n *   this.resizeHandler = new ResizeHandler(\n *     this.element,\n *     this.item,\n *     (updatedItem) => {\n *       // This callback runs ONCE at resize end\n *       gridState.updateItem(updatedItem);\n *       undoRedo.pushCommand(new ResizeCommand(this.item, updatedItem));\n *     }\n *   );\n * }\n *\n * disconnectedCallback() {\n *   this.resizeHandler?.destroy(); // Critical: prevents RAF leak\n * }\n * ```\n */\nexport class ResizeHandler {\n  /** DOM element being resized (grid-item-wrapper element) */\n  private element: HTMLElement;\n\n  /** Grid item data (position, size, layouts) */\n  private item: GridItem;\n\n  /** Callback to update parent state after resize ends */\n  private onUpdate: (item: GridItem) => void;\n\n  /** interact.js resizable instance for cleanup */\n  private interactInstance: any;\n\n  /** RAF ID for cancelling pending frame updates */\n  private resizeRafId: number | null = null;\n\n  /** Accumulated position and size during resize (deltaRect tracking) */\n  private startRect: { x: number; y: number; width: number; height: number } = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /**\n   * Create resize handler and initialize interact.js\n   *\n   * **Lifecycle**: Called when grid-item-wrapper mounts\n   *\n   * **RAF delay pattern**:\n   * If element doesn't have width/height styles yet, defers initialization to next frame.\n   * This handles race condition where StencilJS hasn't applied computed styles yet.\n   *\n   * **Why RAF delay is needed**:\n   * - interact.js reads element dimensions during setup\n   * - If dimensions are 0, resize handles won't work correctly\n   * - RAF ensures browser has completed style application\n   * - Only happens on initial mount, not on subsequent operations\n   *\n   * **Error handling**:\n   * Warns but continues if styles missing (won't break app, just logs issue)\n   *\n   * @param element - DOM element to make resizable (grid-item-wrapper)\n   * @param item - Grid item data for dimension/position management\n   * @param onUpdate - Callback invoked with updated item after resize ends\n   *\n   * @example\n   * ```typescript\n   * // Typical usage in component\n   * private resizeHandler: ResizeHandler;\n   *\n   * componentDidLoad() {\n   *   this.resizeHandler = new ResizeHandler(\n   *     this.element,\n   *     this.item,\n   *     (item) => this.handleItemUpdate(item)\n   *   );\n   * }\n   * ```\n   */\n  constructor(element: HTMLElement, item: GridItem, onUpdate: (item: GridItem) => void) {\n    this.element = element;\n    this.item = item;\n    this.onUpdate = onUpdate;\n\n    // Ensure element has width/height before initializing interact.js\n    // StencilJS might not have applied styles yet\n    if (!element.style.width || !element.style.height) {\n      console.warn('Element missing width/height styles, waiting for next frame');\n      requestAnimationFrame(() => this.initialize());\n    } else {\n      this.initialize();\n    }\n  }\n\n  /**\n   * Cleanup interact.js instance and cancel pending RAF\n   *\n   * **When to call**: Component unmount (disconnectedCallback in StencilJS)\n   *\n   * **Critical for RAF cleanup**:\n   * Unlike drag-handler, resize-handler uses RAF batching. Must cancel\n   * pending RAF to prevent:\n   * - Memory leaks from closures\n   * - Errors from updating removed elements\n   * - RAF callbacks firing after component destruction\n   *\n   * **What it does**:\n   * 1. Cancels any pending requestAnimationFrame\n   * 2. Calls `interactInstance.unset()` to remove event listeners\n   * 3. Safe to call multiple times (checks if instances exist)\n   *\n   * **Performance**: Very cheap operation (~0.1ms)\n   *\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper component\n   * disconnectedCallback() {\n   *   if (this.resizeHandler) {\n   *     this.resizeHandler.destroy(); // MUST call to prevent RAF leak\n   *   }\n   * }\n   * ```\n   */\n  destroy(): void {\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n      this.resizeRafId = null;\n    }\n\n    if (this.interactInstance) {\n      this.interactInstance.unset();\n    }\n  }\n\n  /**\n   * Initialize interact.js resizable on element\n   *\n   * **Configuration choices explained**:\n   *\n   * **edges: all true**\n   * - Enables 8 resize handles (4 corners + 4 edges)\n   * - Provides maximum flexibility for users\n   * - Matches familiar design tool patterns\n   *\n   * **modifiers array**:\n   * Order matters! Modifiers are applied in sequence:\n   *\n   * 1. **restrictSize modifier**: Enforces minimum dimensions\n   *    - min width: 100px (~5 grid units)\n   *    - min height: 80px (~4 grid units)\n   *    - Prevents unusably small items\n   *    - No maximum (items can grow to canvas bounds)\n   *\n   * 2. **snap modifier with endOnly: true**:\n   *    - Snaps to grid ONLY at resize end\n   *    - **Critical**: endOnly prevents mid-resize jumping\n   *    - Uses function callbacks for dynamic grid sizes\n   *    - range: Infinity means always snap (no distance limit)\n   *\n   * **Why function callbacks for grid sizes**:\n   * ```typescript\n   * x: () => getGridSizeHorizontal(this.item.canvasId)\n   * ```\n   * - Grid sizes can change (viewport switch, canvas resize)\n   * - Function ensures fresh value on each snap\n   * - Without callback, would cache stale grid size\n   *\n   * **Event binding**:\n   * - Uses `.bind(this)` to preserve class context\n   * - Without bind, `this` would be interact.js context\n   * - Allows handlers to access instance properties\n   *\n   * **Error handling**:\n   * - Checks if interact.js loaded (from CDN)\n   * - Fails gracefully with console warning\n   * - Prevents app crash if CDN fails\n   *\n   * @private\n   *\n   * @example\n   * ```typescript\n   * // interact.js resizable configuration\n   * interact(element).resizable({\n   *   edges: { left: true, right: true, bottom: true, top: true },\n   *   modifiers: [\n   *     interact.modifiers.restrictSize({ min: { width: 100, height: 80 } }),\n   *     interact.modifiers.snap({\n   *       targets: [interact.snappers.grid({ x: 20, y: 20 })],\n   *       endOnly: true  // Key: prevents visual jumping during resize\n   *     })\n   *   ]\n   * });\n   * ```\n   */\n  private initialize(): void {\n    const interact = (window as any).interact;\n    if (!interact) {\n      console.warn('interact.js not loaded');\n      return;\n    }\n\n    this.interactInstance = interact(this.element).resizable({\n      edges: { left: true, right: true, bottom: true, top: true },\n\n      modifiers: [\n        // Enforce minimum size\n        interact.modifiers.restrictSize({\n          min: { width: 100, height: 80 },\n        }),\n        // Snap to grid only when resize ends (prevents jump during resize)\n        interact.modifiers.snap({\n          targets: [\n            interact.snappers.grid({\n              x: () => getGridSizeHorizontal(this.item.canvasId),\n              y: () => getGridSizeVertical(),\n            }),\n          ],\n          range: Infinity,\n          endOnly: true,\n        }),\n      ],\n\n      listeners: {\n        start: this.handleResizeStart.bind(this),\n        move: this.handleResizeMove.bind(this),\n        end: this.handleResizeEnd.bind(this),\n      },\n    });\n  }\n\n  /**\n   * Handle resize start event\n   *\n   * **Responsibilities**:\n   * 1. Start performance monitoring (if perfMonitor available)\n   * 2. Add visual feedback (resizing class)\n   * 3. Capture starting position and dimensions\n   * 4. Initialize startRect for deltaRect accumulation\n   *\n   * **Why capture startRect**:\n   * - interact.js provides deltaRect (cumulative changes)\n   * - Must apply deltas to starting values\n   * - Position can change during resize (top/left handles)\n   * - Dimensions always change during resize\n   *\n   * **startRect structure**:\n   * ```typescript\n   * {\n   *   x: 100,      // Starting transform X\n   *   y: 150,      // Starting transform Y\n   *   width: 300,  // Starting width in pixels\n   *   height: 200  // Starting height in pixels\n   * }\n   * ```\n   *\n   * **Performance tracking**:\n   * - Optional perfMonitor integration\n   * - Measures total resize duration (start → end)\n   * - Helps identify performance regressions\n   *\n   * @private\n   * @param event - interact.js resize start event\n   *\n   * @example\n   * ```typescript\n   * // Event provides element reference\n   * {\n   *   target: HTMLElement,\n   *   rect: {width, height, left, top, ...},\n   *   // ... other interact.js properties\n   * }\n   * ```\n   */\n  private handleResizeStart(event: any): void {\n    // Start performance tracking\n    if ((window as any).perfMonitor) {\n      (window as any).perfMonitor.startOperation('resize');\n    }\n\n    event.target.classList.add('resizing');\n\n    // Store the starting position and size\n    const position = getTransformPosition(event.target);\n    this.startRect.x = position.x;\n    this.startRect.y = position.y;\n    this.startRect.width = parseFloat(event.target.style.width) || 0;\n    this.startRect.height = parseFloat(event.target.style.height) || 0;\n  }\n\n  /**\n   * Handle resize move event with RAF batching (high-frequency, ~60fps)\n   *\n   * **Critical Performance Path**: This runs ~200 times/sec during resize (mousemove),\n   * but RAF batching limits actual DOM updates to ~60fps.\n   *\n   * **RAF Batching Pattern**:\n   * ```\n   * cancelAnimationFrame(oldId);  // Cancel previous pending frame\n   * newId = requestAnimationFrame(() => {\n   *   // DOM updates execute once per browser paint\n   * });\n   * ```\n   *\n   * **Why RAF batching is critical**:\n   * - Mousemove fires ~200x/sec (faster than 60fps display)\n   * - Without batching: 200 DOM updates/sec, many wasted (can't paint that fast)\n   * - With batching: ~60 DOM updates/sec, aligned with browser paint\n   * - **3-4x fewer DOM operations**\n   * - Prevents frame drops and stuttering\n   *\n   * **DeltaRect Accumulation**:\n   * interact.js provides cumulative changes since resize start:\n   * - `deltaRect.left`: X position change (negative = moved left)\n   * - `deltaRect.top`: Y position change (negative = moved up)\n   * - `deltaRect.width`: Width change\n   * - `deltaRect.height`: Height change\n   *\n   * **Why accumulate into startRect**:\n   * - Maintains single source of truth for current state\n   * - Allows direct application to DOM\n   * - Simplifies final position calculation\n   *\n   * **Example resize from top-left handle**:\n   * ```\n   * Start: x=100, y=150, width=300, height=200\n   * User drags top-left handle up-left by 50px\n   * deltaRect: {left: -50, top: -50, width: 50, height: 50}\n   * Result: x=50, y=100, width=350, height=250\n   * ```\n   *\n   * **Performance per frame**:\n   * - Cancel previous RAF: ~0.01ms\n   * - Schedule new RAF: ~0.01ms\n   * - Actual DOM update (in RAF callback):\n   *   - 3 style updates (transform, width, height)\n   *   - No layout/reflow (transform is composited)\n   *   - ~0.5-1ms total\n   *\n   * **Without RAF batching**:\n   * - 200 updates/sec × 1ms = 200ms/sec wasted\n   * - Dropped frames, stuttering\n   *\n   * **With RAF batching**:\n   * - 60 updates/sec × 1ms = 60ms/sec\n   * - Smooth, no dropped frames\n   *\n   * @private\n   * @param event - interact.js resize move event\n   *\n   * @example\n   * ```typescript\n   * // Event provides deltaRect (cumulative changes)\n   * {\n   *   target: HTMLElement,\n   *   deltaRect: {\n   *     left: -10,   // Element moved left 10px\n   *     top: 0,      // No vertical movement\n   *     width: 10,   // Grew 10px wider\n   *     height: 0    // Height unchanged\n   *   }\n   * }\n   *\n   * // Applied as:\n   * // newX = startX + (-10)\n   * // newWidth = startWidth + 10\n   * ```\n   */\n  private handleResizeMove(event: any): void {\n    // Cancel any pending frame\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n\n    // Batch DOM updates with requestAnimationFrame for 60fps\n    this.resizeRafId = requestAnimationFrame(() => {\n      // Use deltaRect to accumulate changes\n      const dx = event.deltaRect.left;\n      const dy = event.deltaRect.top;\n      const dw = event.deltaRect.width;\n      const dh = event.deltaRect.height;\n\n      // Update stored rect\n      this.startRect.x += dx;\n      this.startRect.y += dy;\n      this.startRect.width += dw;\n      this.startRect.height += dh;\n\n      // Apply styles\n      event.target.style.transform = `translate(${this.startRect.x}px, ${this.startRect.y}px)`;\n      event.target.style.width = this.startRect.width + 'px';\n      event.target.style.height = this.startRect.height + 'px';\n\n      this.resizeRafId = null;\n    });\n  }\n\n  /**\n   * Handle resize end event - finalize dimensions and update state\n   *\n   * **Critical responsibilities**:\n   * - Cancel pending RAF (prevent stale updates)\n   * - Grid snap position AND dimensions\n   * - Enforce boundary constraints\n   * - Convert viewport coordinates to container-relative\n   * - Update state (triggers single re-render)\n   *\n   * ## Processing Steps\n   *\n   * ### 1. RAF Cleanup\n   * Cancel any pending requestAnimationFrame to prevent stale updates after\n   * resize completes. Critical to avoid errors and ensure clean state.\n   *\n   * ### 2. Coordinate Conversion\n   * interact.js provides viewport coordinates (event.rect.left/top).\n   * Must convert to container-relative coordinates:\n   * ```\n   * containerRelativeX = viewportX - containerRect.left\n   * ```\n   *\n   * **Why conversion needed**:\n   * - CSS transform uses container-relative coordinates\n   * - event.rect uses viewport coordinates\n   * - Scrolled pages have different viewport vs container positions\n   *\n   * ### 3. Grid Snapping (Position AND Dimensions)\n   * Unlike drag, resize snaps BOTH position and dimensions:\n   * ```\n   * newX = Math.round(newX / gridSizeX) * gridSizeX\n   * newWidth = Math.round(newWidth / gridSizeX) * gridSizeX\n   * ```\n   *\n   * **Why snap dimensions**:\n   * - Ensures items align to grid cells\n   * - Prevents items spanning fractional grid units\n   * - Makes layouts predictable and clean\n   *\n   * ### 4. Boundary Constraints\n   * **Manual implementation** (interact.js restrictEdges breaks with deltaRect):\n   * ```\n   * newX = Math.max(0, newX);  // Left edge\n   * newX = Math.min(newX, containerWidth - itemWidth);  // Right edge\n   * ```\n   *\n   * **Why manual constraints**:\n   * - interact.js restrictEdges modifier conflicts with deltaRect\n   * - Manual constraints applied after grid snapping\n   * - Ensures final position respects canvas bounds\n   *\n   * ### 5. Mobile Layout Handling\n   * - Detects current viewport (desktop vs mobile)\n   * - Updates appropriate layout object\n   * - Marks mobile as \"customized\" when modified\n   * - Ensures mobile layouts don't auto-sync from desktop\n   *\n   * ### 6. State Persistence\n   * - Converts pixels to grid units\n   * - Updates item.layouts with new position and dimensions\n   * - Calls `onUpdate(item)` callback\n   * - Triggers single StencilJS re-render\n   * - Parent pushes undo/redo command\n   *\n   * ## Performance Characteristics\n   *\n   * **Total execution time**: ~5-10ms\n   * - RAF cancellation: ~0.01ms\n   * - Coordinate conversion: ~0.5ms\n   * - Grid snapping: ~1ms\n   * - Boundary checks: ~0.5ms\n   * - State update: ~3-5ms (single re-render)\n   *\n   * **Why this is acceptable**:\n   * - Only runs once at resize end (not 60fps)\n   * - User expects slight delay when releasing resize\n   * - Grid snapping provides visual feedback justifying delay\n   *\n   * ## Edge Cases Handled\n   *\n   * - Resize extending outside canvas → clamped to bounds\n   * - Minimum size violations → prevented by modifier\n   * - Position changes during resize (top/left handles) → preserved via deltaRect\n   * - Container not found → early exit (safety)\n   * - Mobile view → mark as customized\n   * - Pending RAF → cancelled before state update\n   *\n   * @private\n   * @param event - interact.js resize end event\n   *\n   * @example\n   * ```typescript\n   * // Example resize sequence (top-left handle):\n   * // 1. handleResizeStart: Store startRect (x=100, y=150, w=300, h=200)\n   * // 2. handleResizeMove (RAF batched): Apply deltaRect changes\n   * // 3. handleResizeEnd:\n   * //    - event.rect: {left: 525, top: 375, width: 350, height: 250} (viewport coords)\n   * //    - containerRect: {left: 475, top: 275} (viewport offset)\n   * //    - relativeX = 525 - 475 = 50px\n   * //    - relativeY = 375 - 275 = 100px\n   * //    - snappedX = round(50/20)*20 = 60px\n   * //    - gridX = 60/20 = 3 grid units\n   * //    - item.layouts.desktop.x = 3\n   * //    - onUpdate(item) → re-render + undo command\n   * ```\n   */\n  private handleResizeEnd(event: any): void {\n    // Cancel any pending frame\n    if (this.resizeRafId) {\n      cancelAnimationFrame(this.resizeRafId);\n      this.resizeRafId = null;\n    }\n\n    event.target.classList.remove('resizing');\n\n    // Clean up data attributes\n    event.target.removeAttribute('data-x');\n    event.target.removeAttribute('data-y');\n    event.target.removeAttribute('data-width');\n    event.target.removeAttribute('data-height');\n\n    // Get the container to calculate relative position\n    const container = domCache.getCanvas(this.item.canvasId);\n    if (!container) {\n      return;\n    }\n\n    const containerRect = container.getBoundingClientRect();\n    const gridSizeX = getGridSizeHorizontal(this.item.canvasId);\n    const gridSizeY = getGridSizeVertical();\n\n    // Convert absolute event.rect to container-relative coordinates\n    let newX = event.rect.left - containerRect.left;\n    let newY = event.rect.top - containerRect.top;\n    let newWidth = event.rect.width;\n    let newHeight = event.rect.height;\n\n    // Snap position to grid\n    newX = Math.round(newX / gridSizeX) * gridSizeX;\n    newY = Math.round(newY / gridSizeY) * gridSizeY;\n\n    // Snap dimensions to grid\n    newWidth = Math.round(newWidth / gridSizeX) * gridSizeX;\n    newHeight = Math.round(newHeight / gridSizeY) * gridSizeY;\n\n    // Keep within parent boundaries (manual implementation since interact.js restrictEdges breaks deltaRect)\n    newX = Math.max(0, newX); // Don't go past left edge\n    newY = Math.max(0, newY); // Don't go past top edge\n    newX = Math.min(newX, container.clientWidth - newWidth); // Don't go past right edge\n    newY = Math.min(newY, container.clientHeight - newHeight); // Don't go past bottom edge\n\n    // Apply snapped final position\n    event.target.style.transform = `translate(${newX}px, ${newY}px)`;\n    event.target.style.width = newWidth + 'px';\n    event.target.style.height = newHeight + 'px';\n\n    // Update item size and position in current viewport's layout (convert to grid units)\n    const currentViewport = (window as any).gridState?.currentViewport || 'desktop';\n    const layout = this.item.layouts[currentViewport as 'desktop' | 'mobile'];\n\n    layout.width = pixelsToGridX(newWidth, this.item.canvasId);\n    layout.height = pixelsToGridY(newHeight);\n    layout.x = pixelsToGridX(newX, this.item.canvasId);\n    layout.y = pixelsToGridY(newY);\n\n    // If in mobile view, mark as customized\n    if (currentViewport === 'mobile') {\n      this.item.layouts.mobile.customized = true;\n    }\n\n    // End performance tracking\n    if ((window as any).perfMonitor) {\n      (window as any).perfMonitor.endOperation('resize');\n    }\n\n    // Trigger StencilJS update (single re-render at end)\n    this.onUpdate(this.item);\n  }\n}\n","@import '../../global/variables';\n\n/* Grid Item */\n.grid-item {\n  position: absolute;\n  min-width: 100px;\n  min-height: 80px;\n  padding: 20px 20px 20px 44px; /* Extra left padding for drag handle */\n  border: 2px solid transparent;\n  border-radius: 4px;\n  background: white;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 10%);\n  cursor: default;\n  transition: border-color 0.2s, box-shadow 0.2s;\n  will-change: transform; /* GPU acceleration hint */\n}\n\n.grid-item:hover {\n  border-color: #4a90e2;\n}\n\n.grid-item.selected {\n  z-index: 1000;\n  border: 3px solid #2563eb; /* Thicker border with darker blue */\n  padding: 19px 19px 19px 43px; /* Compensate for thicker border to prevent content shift */\n  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2), 0 4px 12px rgba(74, 144, 226, 0.4);\n  /* Add outer glow ring + shadow for clear visual distinction */\n}\n\n.grid-item.dragging {\n  cursor: move;\n  opacity: 0.7;\n}\n\n.grid-item.resizing {\n  user-select: none;\n}\n\n/* Item Header */\n.grid-item-header {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  margin: -20px -20px 12px -44px;\n  padding: 10px 16px 10px 50px;\n  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);\n  border-bottom: 1px solid #dee2e6;\n  border-radius: 4px 4px 0 0;\n  color: #495057;\n  font-size: 13px;\n  font-weight: 600;\n  letter-spacing: 0.3px;\n  text-transform: uppercase;\n}\n\n.grid-item.selected .grid-item-header {\n  margin: -19px -19px 12px -43px; /* Compensate for adjusted padding */\n  padding: 10px 16px 10px 49px; /* Compensate for adjusted padding */\n}\n\n/* Item Content */\n.grid-item-content {\n  overflow: hidden;\n  max-width: 100%;\n  color: #666;\n  font-size: 13px;\n}\n\n.loading-placeholder {\n  display: flex;\n  height: 100%;\n  align-items: center;\n  justify-content: center;\n  color: #999;\n  font-size: 12px;\n}\n\n/* Item Controls */\n.grid-item-controls {\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  display: flex;\n  gap: 4px;\n  opacity: 0;\n  transition: opacity 0.2s;\n}\n\n.grid-item.selected .grid-item-controls,\n.grid-item:hover .grid-item-controls {\n  opacity: 1;\n}\n\n.grid-item.selected .grid-item-controls {\n  top: 7px; /* Compensate for thicker border */\n  right: 7px; /* Compensate for thicker border */\n}\n\n.grid-item-control-btn {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  border-radius: 4px;\n  background: #4a90e2;\n  color: white;\n  cursor: pointer;\n  font-size: 12px;\n  line-height: 1;\n  transition: background 0.2s;\n}\n\n.grid-item-control-btn:hover {\n  background: #357abd;\n}\n\n.grid-item-delete {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  border-radius: 50%;\n  background: #f44;\n  color: white;\n  cursor: pointer;\n  font-size: 14px;\n  line-height: 1;\n  transition: background 0.2s;\n}\n\n.grid-item-delete:hover {\n  background: #c00;\n}\n\n/* Drag Handle */\n.drag-handle {\n  position: absolute;\n  top: 8px;\n  left: 8px;\n  display: flex;\n  width: 28px;\n  height: 28px;\n  align-items: center;\n  justify-content: center;\n  border: 1px solid rgba(74, 144, 226, 30%);\n  border-radius: 4px;\n  background: rgba(74, 144, 226, 10%);\n  cursor: move;\n  opacity: 0.7;\n  transition: all 0.2s;\n}\n\n.drag-handle::before {\n  color: #4a90e2;\n  content: '⋮⋮';\n  font-size: 14px;\n  font-weight: bold;\n  letter-spacing: -2px;\n}\n\n.drag-handle:hover {\n  background: rgba(74, 144, 226, 25%);\n  transform: scale(1.1);\n}\n\n.grid-item:hover .drag-handle {\n  background: rgba(74, 144, 226, 15%);\n  opacity: 1;\n}\n\n.grid-item.selected .drag-handle {\n  top: 7px; /* Compensate for thicker border */\n  left: 7px; /* Compensate for thicker border */\n}\n\n/* Resize Handles */\n.resize-handle {\n  position: absolute;\n  width: 10px;\n  height: 10px;\n  border: 2px solid white;\n  border-radius: 50%;\n  background: #4a90e2;\n  box-shadow: 0 0 3px rgba(0, 0, 0, 30%);\n  opacity: 0;\n  transition: opacity 0.2s;\n}\n\n.grid-item.selected .resize-handle,\n.grid-item:hover .resize-handle {\n  opacity: 1;\n}\n\n.resize-handle.nw {\n  top: -5px;\n  left: -5px;\n  cursor: nw-resize;\n}\n\n.resize-handle.ne {\n  top: -5px;\n  right: -5px;\n  cursor: ne-resize;\n}\n\n.resize-handle.sw {\n  bottom: -5px;\n  left: -5px;\n  cursor: sw-resize;\n}\n\n.resize-handle.se {\n  right: -5px;\n  bottom: -5px;\n  cursor: se-resize;\n}\n\n.resize-handle.n {\n  top: -5px;\n  left: 50%;\n  cursor: n-resize;\n  transform: translateX(-50%);\n}\n\n.resize-handle.s {\n  bottom: -5px;\n  left: 50%;\n  cursor: s-resize;\n  transform: translateX(-50%);\n}\n\n.resize-handle.e {\n  top: 50%;\n  right: -5px;\n  cursor: e-resize;\n  transform: translateY(-50%);\n}\n\n.resize-handle.w {\n  top: 50%;\n  left: -5px;\n  cursor: w-resize;\n  transform: translateY(-50%);\n}\n\n/* Compensate resize handles for thicker border when selected */\n.grid-item.selected .resize-handle.nw,\n.grid-item.selected .resize-handle.n,\n.grid-item.selected .resize-handle.ne {\n  top: -6px; /* -5px - 1px for thicker border */\n}\n\n.grid-item.selected .resize-handle.sw,\n.grid-item.selected .resize-handle.s,\n.grid-item.selected .resize-handle.se {\n  bottom: -6px; /* -5px - 1px for thicker border */\n}\n\n.grid-item.selected .resize-handle.nw,\n.grid-item.selected .resize-handle.w,\n.grid-item.selected .resize-handle.sw {\n  left: -6px; /* -5px - 1px for thicker border */\n}\n\n.grid-item.selected .resize-handle.ne,\n.grid-item.selected .resize-handle.e,\n.grid-item.selected .resize-handle.se {\n  right: -6px; /* -5px - 1px for thicker border */\n}\n","/**\n * Grid Item Wrapper Component\n * ============================\n *\n * Individual grid item container managing positioning, drag/resize interactions,\n * virtual rendering, and component lifecycle. Each GridItemWrapper instance\n * represents a single draggable, resizable component on the canvas with full\n * undo/redo support and viewport-aware layout.\n *\n * ## Problem\n *\n * Grid-based builders need individual item components that:\n * - Position themselves using grid coordinates (not absolute pixels)\n * - Support drag and resize with interact.js\n * - Track changes for undo/redo\n * - Render different layouts for desktop/mobile\n * - Handle selection state visually\n * - Support z-index layering (bring to front/send to back)\n * - Lazy load complex components for performance\n * - Clean up resources on unmount\n *\n * **Without wrappers**:\n * - Duplicate positioning logic per component type\n * - No consistent drag/resize behavior\n * - Manual undo/redo tracking everywhere\n * - Complex lifecycle management\n * - Performance issues with many items\n *\n * ## Solution\n *\n * Unified wrapper component providing:\n * 1. **Transform-based positioning**: GPU-accelerated positioning with translate()\n * 2. **Grid unit conversion**: Automatic pixel calculation from grid units\n * 3. **Drag/resize handlers**: Consistent interact.js integration\n * 4. **Undo/redo tracking**: Automatic snapshot and command creation\n * 5. **Virtual rendering**: Lazy load components only when visible\n * 6. **Viewport switching**: Auto-layout for mobile or custom positioning\n * 7. **Selection management**: Visual feedback and state tracking\n * 8. **Z-index controls**: Bring to front / send to back\n * 9. **Dynamic component rendering**: Switch statement for component types\n *\n * ## Architecture: Wrapper Pattern\n *\n * **Component structure**:\n * ```\n * <grid-item-wrapper>\n *   └── .grid-item (positioned container)\n *       ├── .drag-handle (for dragging)\n *       ├── .grid-item-header (icon + title)\n *       ├── .grid-item-content (actual component)\n *       ├── .grid-item-controls (z-index + delete)\n *       └── .resize-handle × 8 (corners + edges)\n * ```\n *\n * **Wrapper benefits**:\n * - Consistent container for all component types\n * - Isolates positioning from component logic\n * - Reusable drag/resize behavior\n * - Centralized undo/redo tracking\n * - Single point for virtual rendering\n *\n * ## Transform-Based Positioning\n *\n * **GPU acceleration with translate()**:\n * ```typescript\n * const xPixels = gridToPixelsX(layout.x, canvasId);\n * const yPixels = gridToPixelsY(layout.y);\n * const style = {\n *   transform: `translate(${xPixels}px, ${yPixels}px)`,\n *   width: `${widthPixels}px`,\n *   height: `${heightPixels}px`\n * };\n * ```\n *\n * **Why transform over top/left**:\n * - ✅ GPU-accelerated (compositing layer)\n * - ✅ No layout recalculation (60fps dragging)\n * - ✅ Sub-pixel positioning accuracy\n * - ✅ Better performance with many items\n * - ❌ Slightly more complex coordinates (relative to static position)\n *\n * **Performance comparison**:\n * - `transform: translate()`: ~0.5ms per item move\n * - `top/left`: ~3-5ms per item move (triggers layout)\n * - 6-10× faster with transforms\n *\n * ## Grid Unit to Pixel Conversion\n *\n * **Responsive width (2% per unit)**:\n * ```typescript\n * gridToPixelsX(10, 'canvas1')  // Container width × 0.02 × 10\n * // → 1000px container = 200px width\n * ```\n *\n * **Fixed height (20px per unit)**:\n * ```typescript\n * gridToPixelsY(6)  // 6 × 20 = 120px\n * ```\n *\n * **Why hybrid grid**:\n * - Horizontal: Responsive to container width (fluid layouts)\n * - Vertical: Fixed spacing (consistent vertical rhythm)\n * - Balance between flexibility and predictability\n *\n * **Canvas-specific width**:\n * - Pass canvasId to gridToPixelsX()\n * - Each canvas can have different width\n * - Grid calculations cached per canvas\n *\n * ## Drag and Resize Handler Integration\n *\n * **Handler initialization**:\n * ```typescript\n * componentDidLoad() {\n *   this.dragHandler = new DragHandler(\n *     this.itemRef,           // Element to make draggable\n *     this.item,              // Grid item data\n *     this.handleItemUpdate   // Callback on drag end\n *   );\n *\n *   this.resizeHandler = new ResizeHandler(\n *     this.itemRef,           // Element to make resizable\n *     this.item,              // Grid item data\n *     this.handleItemUpdate   // Callback on resize end\n *   );\n * }\n * ```\n *\n * **Callback pattern**:\n * - Handlers call `handleItemUpdate()` when operation completes\n * - Wrapper creates undo command and updates state\n * - Decouples interaction from state management\n * - Allows handlers to be framework-agnostic\n *\n * **Cleanup on unmount**:\n * ```typescript\n * disconnectedCallback() {\n *   this.dragHandler.destroy();   // Remove interact.js listeners\n *   this.resizeHandler.destroy(); // Remove interact.js listeners\n * }\n * ```\n *\n * ## Item Snapshot for Undo/Redo\n *\n * **Snapshot pattern**:\n * ```typescript\n * // Before interaction\n * componentWillLoad() {\n *   this.captureItemSnapshot();  // Deep clone item state\n * }\n *\n * // After interaction\n * handleItemUpdate(updatedItem) {\n *   const positionChanged = compare(snapshot, updatedItem);\n *   if (positionChanged) {\n *     pushCommand(new MoveItemCommand(\n *       itemId,\n *       snapshot.canvasId,     // Source\n *       updatedItem.canvasId,  // Target\n *       { x: snapshot.x, y: snapshot.y },      // Before\n *       { x: updatedItem.x, y: updatedItem.y } // After\n *     ));\n *   }\n * }\n * ```\n *\n * **Why snapshot before operation**:\n * - Captures original position/size\n * - Enables accurate undo\n * - Detects actual changes (drag without movement = no command)\n * - Supports cross-canvas moves\n *\n * **Deep cloning**:\n * ```typescript\n * this.itemSnapshot = JSON.parse(JSON.stringify(this.item));\n * ```\n * - Prevents mutations from affecting snapshot\n * - Simple and reliable\n * - ~0.1-0.5ms per snapshot (acceptable)\n *\n * ## Desktop vs Mobile Layout Rendering\n *\n * **Layout selection**:\n * ```typescript\n * const currentViewport = gridState.currentViewport; // 'desktop' | 'mobile'\n * const layout = this.item.layouts[currentViewport];\n * ```\n *\n * **Mobile auto-layout** (when not customized):\n * ```typescript\n * if (currentViewport === 'mobile' && !item.layouts.mobile.customized) {\n *   // Calculate stacked position\n *   const itemIndex = canvas.items.findIndex(i => i.id === item.id);\n *   let yPosition = 0;\n *   for (let i = 0; i < itemIndex; i++) {\n *     yPosition += canvas.items[i].layouts.desktop.height;\n *   }\n *\n *   actualLayout = {\n *     x: 0,                                  // Full left\n *     y: yPosition,                          // Stacked vertically\n *     width: 50,                             // Full width (50 units)\n *     height: item.layouts.desktop.height    // Keep desktop height\n *   };\n * }\n * ```\n *\n * **Auto-layout strategy**:\n * - Full width (50 units = 100% of mobile viewport)\n * - Stacked vertically (sum heights of previous items)\n * - Maintains desktop height (preserves aspect ratio)\n * - No horizontal scrolling (mobile-friendly)\n *\n * **Custom mobile layout**:\n * - If `layouts.mobile.customized = true`\n * - Use explicit mobile x/y/width/height\n * - Ignore desktop layout\n * - User has manually positioned in mobile view\n *\n * ## Selection State Management\n *\n * **Reactive selection**:\n * ```typescript\n * updateComponentState() {\n *   this.isSelected = gridState.selectedItemId === this.item.id;\n * }\n *\n * render() {\n *   const isSelected = gridState.selectedItemId === this.item.id;\n *   const itemClasses = {\n *     'grid-item': true,\n *     selected: isSelected\n *   };\n * }\n * ```\n *\n * **Visual feedback**:\n * - `.selected` class adds border/shadow (CSS)\n * - Resize handles visible when selected\n * - Z-index controls visible when selected\n * - Drag handle highlighted when selected\n *\n * **Click handling**:\n * ```typescript\n * handleClick(e) {\n *   // Ignore clicks on handles/controls\n *   if (target.isHandle || target.isControl) return;\n *\n *   // Set selection immediately\n *   gridState.selectedItemId = this.item.id;\n *   gridState.selectedCanvasId = this.item.canvasId;\n *\n *   // Dispatch event for config panel\n *   dispatchEvent(new CustomEvent('item-click', { ... }));\n * }\n * ```\n *\n * ## Z-Index Handling\n *\n * **Bring to front**:\n * ```typescript\n * handleBringToFront() {\n *   const canvas = gridState.canvases[item.canvasId];\n *   const maxZ = Math.max(...canvas.items.map(i => i.zIndex));\n *   this.item.zIndex = maxZ + 1;\n *   gridState.canvases = { ...gridState.canvases };\n * }\n * ```\n *\n * **Send to back**:\n * ```typescript\n * handleSendToBack() {\n *   const minZ = Math.min(...canvas.items.map(i => i.zIndex));\n *   this.item.zIndex = minZ - 1;\n *   gridState.canvases = { ...gridState.canvases };\n * }\n * ```\n *\n * **Why monotonic z-index**:\n * - Never reuse z-index values\n * - Always increment/decrement\n * - No conflicts with existing items\n * - Simple and reliable ordering\n *\n * **Z-index in render**:\n * ```typescript\n * style={{ zIndex: item.zIndex.toString() }}\n * ```\n *\n * ## Dynamic Component Rendering\n *\n * **Switch statement pattern**:\n * ```typescript\n * renderComponent() {\n *   if (!this.isVisible) {\n *     return <div class=\"component-placeholder\">Loading...</div>;\n *   }\n *\n *   switch (this.item.type) {\n *     case 'header': return <component-header itemId={item.id} />;\n *     case 'text': return <component-text-block itemId={item.id} />;\n *     case 'image': return <component-image itemId={item.id} />;\n *     // ...\n *     default: return <div>Unknown component type: {item.type}</div>;\n *   }\n * }\n * ```\n *\n * **Why pass itemId**:\n * - Child component can look up data in state\n * - Avoids prop drilling\n * - Components can update themselves\n * - Simpler wrapper interface\n *\n * **Virtual rendering guard**:\n * - Only render when `isVisible = true`\n * - Show placeholder while loading\n * - Reduces initial render cost\n * - Complex components loaded on scroll\n *\n * ## Virtual Rendering Integration\n *\n * **Observer setup**:\n * ```typescript\n * componentDidLoad() {\n *   virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *     this.isVisible = isVisible;  // Triggers re-render\n *   });\n * }\n * ```\n *\n * **Cleanup**:\n * ```typescript\n * disconnectedCallback() {\n *   virtualRenderer.unobserve(this.itemRef, this.item.id);\n * }\n * ```\n *\n * **How it works**:\n * - IntersectionObserver watches item visibility\n * - Items start with `isVisible = false`\n * - When scrolled into view → `isVisible = true`\n * - Triggers re-render with actual component\n * - Complex components only render when needed\n *\n * **Performance benefit**:\n * - Initial render: Only visible items rendered\n * - 100 items on page, 10 visible → 10× faster load\n * - Smooth scrolling (items render as they appear)\n *\n * ## Component Lifecycle Pattern\n *\n * **componentWillLoad**: Capture initial state\n * - Update selection state\n * - Capture item snapshot for undo\n * - Runs before first render\n *\n * **componentWillUpdate**: Update state before re-render\n * - Refresh selection state\n * - Re-capture snapshot (item may have changed)\n * - Ensures render has latest data\n *\n * **componentDidLoad**: Initialize interactions\n * - Create DragHandler\n * - Create ResizeHandler\n * - Setup virtual rendering observer\n * - Runs after DOM available\n *\n * **disconnectedCallback**: Cleanup\n * - Destroy drag handler\n * - Destroy resize handler\n * - Unobserve virtual renderer\n * - Prevent memory leaks\n *\n * **render**: Reactive template\n * - Convert grid units to pixels\n * - Apply transform positioning\n * - Render drag/resize handles\n * - Render component content\n * - Render controls (z-index, delete)\n *\n * ## Performance Characteristics\n *\n * **Transform positioning**: ~0.5ms per item\n * **Grid unit conversion**: ~0.1ms (cached)\n * **Virtual rendering**: ~10× faster initial load (100 items)\n * **Re-render on renderVersion change**: ~2-5ms\n * **Snapshot capture**: ~0.1-0.5ms (JSON clone)\n * **Undo command creation**: ~0.2ms\n *\n * **Optimization**: renderVersion prop forces re-renders only when\n * grid calculations change (on resize), not on every state update.\n *\n * ## StencilJS Props and State\n *\n * **@Prop() item**: GridItem data\n * - Position, size, type, zIndex\n * - Passed from parent canvas-section\n * - Changes trigger re-render\n *\n * **@Prop() renderVersion**: Force re-render trigger\n * - Incremented by parent on resize\n * - Forces grid calculation refresh\n * - Optional (defaults to undefined)\n *\n * **@State() isSelected**: Selection state\n * - Managed by wrapper\n * - Updates on state changes\n * - Triggers visual feedback\n *\n * **@State() isVisible**: Virtual rendering state\n * - Managed by IntersectionObserver\n * - Controls component content rendering\n * - Starts false, becomes true when scrolled into view\n *\n * ## Extracting This Pattern\n *\n * To adapt grid item wrapper for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * export function GridItem({ item, onUpdate }) {\n *   const ref = useRef();\n *   const [snapshot, setSnapshot] = useState(null);\n *\n *   useEffect(() => {\n *     // Capture snapshot before interactions\n *     setSnapshot(JSON.parse(JSON.stringify(item)));\n *\n *     // Initialize drag/resize\n *     const dragHandler = new DragHandler(ref.current, item, (updated) => {\n *       if (hasChanged(snapshot, updated)) {\n *         pushUndoCommand(snapshot, updated);\n *       }\n *       onUpdate(updated);\n *     });\n *\n *     return () => dragHandler.destroy();\n *   }, [item.id]);\n *\n *   const x = gridToPixelsX(item.layout.x, item.canvasId);\n *   const y = gridToPixelsY(item.layout.y);\n *   const width = gridToPixelsX(item.layout.width, item.canvasId);\n *   const height = gridToPixelsY(item.layout.height);\n *\n *   return (\n *     <div\n *       ref={ref}\n *       style={{\n *         transform: `translate(${x}px, ${y}px)`,\n *         width: `${width}px`,\n *         height: `${height}px`,\n *         zIndex: item.zIndex\n *       }}\n *     >\n *       <DragHandle />\n *       <ComponentContent type={item.type} />\n *       <ResizeHandles />\n *     </div>\n *   );\n * }\n * ```\n *\n * **For different frameworks**:\n * - **React**: Use useRef, useEffect, useState\n * - **Vue**: Use ref(), onMounted, reactive\n * - **Angular**: Use ViewChild, ngAfterViewInit, signals\n *\n * **Key patterns to preserve**:\n * 1. Transform-based positioning (GPU acceleration)\n * 2. Grid unit to pixel conversion\n * 3. Snapshot before/after comparison\n * 4. Callback pattern for state updates\n * 5. Cleanup on unmount\n *\n * @module grid-item-wrapper\n */\n\n// External libraries (alphabetical)\nimport { Component, h, Prop, State } from '@stencil/core';\n\n// Internal imports (alphabetical)\nimport { componentTemplates } from '../../data/component-templates';\nimport { GridItem, gridState } from '../../services/state-manager';\nimport { pushCommand } from '../../services/undo-redo';\nimport { MoveItemCommand } from '../../services/undo-redo-commands';\nimport { virtualRenderer } from '../../services/virtual-renderer';\nimport { DragHandler } from '../../utils/drag-handler';\nimport { gridToPixelsX, gridToPixelsY } from '../../utils/grid-calculations';\nimport { ResizeHandler } from '../../utils/resize-handler';\n\n/**\n * GridItemWrapper Component\n * ==========================\n *\n * StencilJS component wrapping individual grid items with drag/resize/selection.\n *\n * **Tag**: `<grid-item-wrapper>`\n * **Shadow DOM**: Disabled (required for interact.js compatibility)\n * **Lifecycle**: Standard StencilJS (componentWillLoad → componentDidLoad → render → disconnectedCallback)\n */\n@Component({\n  tag: 'grid-item-wrapper',\n  styleUrl: 'grid-item-wrapper.scss',\n  shadow: false, // Use light DOM for compatibility with interact.js\n})\nexport class GridItemWrapper {\n  /**\n   * Grid item data (position, size, type, etc.)\n   *\n   * **Source**: Parent canvas-section component\n   * **Contains**: id, canvasId, type, name, layouts (desktop/mobile), zIndex\n   * **Updates**: Trigger re-render and grid calculations\n   */\n  @Prop() item!: GridItem;\n\n  /**\n   * Render version (force re-render trigger)\n   *\n   * **Source**: Parent canvas-section (incremented on resize)\n   * **Purpose**: Force grid calculation refresh when container resizes\n   * **Optional**: Defaults to undefined\n   *\n   * **Why needed**:\n   * - Grid calculations cached based on container width\n   * - Container resize invalidates cache\n   * - Parent increments renderVersion → wrapper recalculates\n   */\n  @Prop() renderVersion?: number;\n\n  /**\n   * Selection state (reactive)\n   *\n   * **Managed by**: updateComponentState()\n   * **Updated on**: componentWillLoad, componentWillUpdate\n   * **Triggers**: Visual selection styles (.selected class)\n   */\n  @State() isSelected: boolean = false;\n\n  /**\n   * Visibility state (virtual rendering)\n   *\n   * **Managed by**: IntersectionObserver callback\n   * **Initial value**: false (item not visible)\n   * **Becomes true**: When scrolled into viewport\n   * **Controls**: Whether component content renders or placeholder shows\n   */\n  @State() isVisible: boolean = false;\n\n  /**\n   * Item DOM element reference\n   *\n   * **Used for**:\n   * - DragHandler initialization\n   * - ResizeHandler initialization\n   * - VirtualRenderer observation\n   * - Custom event dispatching\n   */\n  private itemRef: HTMLElement;\n\n  /**\n   * Drag handler instance\n   *\n   * **Lifecycle**: Created in componentDidLoad, destroyed in disconnectedCallback\n   * **Purpose**: Manage drag interactions with interact.js\n   * **Callback**: Calls handleItemUpdate on drag end\n   */\n  private dragHandler: DragHandler;\n\n  /**\n   * Resize handler instance\n   *\n   * **Lifecycle**: Created in componentDidLoad, destroyed in disconnectedCallback\n   * **Purpose**: Manage resize interactions with interact.js\n   * **Callback**: Calls handleItemUpdate on resize end\n   */\n  private resizeHandler: ResizeHandler;\n\n  /**\n   * Item snapshot (for undo/redo)\n   *\n   * **Captured**: componentWillLoad, componentWillUpdate\n   * **Purpose**: Store item state before interactions\n   * **Used by**: handleItemUpdate to detect changes and create undo commands\n   * **Deep clone**: JSON.parse(JSON.stringify(item))\n   */\n  private itemSnapshot: GridItem | null = null;\n\n  /**\n   * Component will load lifecycle hook\n   *\n   * **Called**: Before first render\n   * **Purpose**: Update component state before initial render\n   *\n   * **Delegates to**: updateComponentState()\n   * - Updates selection state\n   * - Captures item snapshot for undo\n   */\n  componentWillLoad() {\n    this.updateComponentState();\n  }\n\n  /**\n   * Component will update lifecycle hook\n   *\n   * **Called**: Before each re-render\n   * **Purpose**: Refresh component state before re-render\n   *\n   * **Delegates to**: updateComponentState()\n   * - Re-checks selection state (may have changed)\n   * - Re-captures snapshot (item may have been modified)\n   *\n   * **Why needed**:\n   * - Selection can change between renders\n   * - Item data can be updated externally\n   * - Ensures render has latest state\n   */\n  componentWillUpdate() {\n    this.updateComponentState();\n  }\n\n  /**\n   * Update component state (selection and snapshot)\n   *\n   * **Called from**: componentWillLoad, componentWillUpdate\n   * **Purpose**: Sync local state with global state before render\n   *\n   * **Operations**:\n   * 1. Update selection state from gridState\n   * 2. Capture item snapshot for undo/redo\n   *\n   * **Selection check**:\n   * ```typescript\n   * this.isSelected = gridState.selectedItemId === this.item.id;\n   * ```\n   *\n   * **Snapshot capture**:\n   * ```typescript\n   * this.captureItemSnapshot();  // Deep clone item\n   * ```\n   *\n   * **Why in separate method**:\n   * - DRY principle (called from 2 places)\n   * - Easier to test\n   * - Clearer lifecycle flow\n   *\n   * @private\n   */\n  private updateComponentState() {\n    // Update selection state\n    this.isSelected = gridState.selectedItemId === this.item.id;\n\n    // Capture item snapshot for undo/redo\n    this.captureItemSnapshot();\n  }\n\n  /**\n   * Component did load lifecycle hook\n   *\n   * **Called**: After first render (DOM available)\n   * **Purpose**: Initialize drag/resize handlers and virtual rendering\n   *\n   * **Operations**:\n   * 1. Create DragHandler instance\n   * 2. Create ResizeHandler instance\n   * 3. Setup virtual rendering observer\n   *\n   * **Handler initialization**:\n   * ```typescript\n   * this.dragHandler = new DragHandler(\n   *   this.itemRef,           // Element to make draggable\n   *   this.item,              // Grid item data\n   *   this.handleItemUpdate   // Callback on drag end\n   * );\n   * ```\n   *\n   * **Virtual rendering setup**:\n   * ```typescript\n   * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n   *   this.isVisible = isVisible;  // State update triggers re-render\n   * });\n   * ```\n   *\n   * **Why after render**:\n   * - Needs itemRef to be assigned (happens during render)\n   * - interact.js requires actual DOM element\n   * - IntersectionObserver requires element to observe\n   *\n   * **One-time setup**:\n   * - Only runs once after mount\n   * - Handlers persist across re-renders\n   * - Cleanup in disconnectedCallback\n   */\n  componentDidLoad() {\n    // Initialize drag and resize handlers\n    this.dragHandler = new DragHandler(this.itemRef, this.item, this.handleItemUpdate);\n    this.resizeHandler = new ResizeHandler(this.itemRef, this.item, this.handleItemUpdate);\n\n    // Set up virtual rendering observer\n    virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n      this.isVisible = isVisible;\n    });\n  }\n\n  /**\n   * Disconnected callback (cleanup)\n   *\n   * **Called**: When component removed from DOM\n   * **Purpose**: Clean up handlers and observers\n   *\n   * **Cleanup operations**:\n   * 1. Destroy drag handler (remove interact.js listeners)\n   * 2. Destroy resize handler (remove interact.js listeners)\n   * 3. Unobserve virtual renderer (remove IntersectionObserver)\n   *\n   * **Why important**:\n   * - Prevents memory leaks\n   * - Removes event listeners\n   * - Stops observation of removed elements\n   * - Standard web component lifecycle pattern\n   *\n   * **Safety checks**:\n   * - Verifies handlers exist before destroying\n   * - Verifies itemRef exists before unobserving\n   *\n   * **Memory impact**:\n   * - Without cleanup: ~50-100KB per item leaked\n   * - With cleanup: Proper garbage collection\n   */\n  disconnectedCallback() {\n    // Cleanup handlers\n    if (this.dragHandler) {\n      this.dragHandler.destroy();\n    }\n    if (this.resizeHandler) {\n      this.resizeHandler.destroy();\n    }\n\n    // Cleanup virtual renderer\n    if (this.itemRef) {\n      virtualRenderer.unobserve(this.itemRef, this.item.id);\n    }\n  }\n\n  /**\n   * Render component content (dynamic component switching)\n   *\n   * **Called from**: render() method\n   * **Purpose**: Render appropriate component based on item type\n   *\n   * ## Virtual Rendering Guard\n   *\n   * **Placeholder when not visible**:\n   * ```typescript\n   * if (!this.isVisible) {\n   *   return <div class=\"component-placeholder\">Loading...</div>;\n   * }\n   * ```\n   *\n   * **Why needed**:\n   * - Complex components expensive to render\n   * - Initial page load renders only visible items\n   * - Placeholder shows while scrolling\n   * - Actual component renders when visible\n   *\n   * **Performance benefit**:\n   * - 100 items, 10 visible → 90 placeholders\n   * - Placeholder: ~0.5ms, Component: ~5-50ms\n   * - 10× faster initial render\n   *\n   * ## Component Type Switching\n   *\n   * **Switch statement pattern**:\n   * ```typescript\n   * switch (this.item.type) {\n   *   case 'header': return <component-header itemId={item.id} />;\n   *   case 'text': return <component-text-block itemId={item.id} />;\n   *   // ...\n   *   default: return <div>Unknown component type</div>;\n   * }\n   * ```\n   *\n   * **Why itemId prop**:\n   * - Child component can look up data in gridState\n   * - Avoids prop drilling full GridItem\n   * - Components can update themselves\n   * - Simpler wrapper interface\n   *\n   * **Component types**:\n   * - Simple: header, text, image, button, video\n   * - Complex: imageGallery, dashboardWidget, liveData\n   * - Complex components benefit most from virtual rendering\n   *\n   * **Error handling**:\n   * - Default case shows \"Unknown component type\"\n   * - Prevents crash if invalid type\n   * - Helps debugging\n   *\n   * @returns JSX for component content or placeholder\n   *\n   * @example\n   * ```typescript\n   * // Visible header item\n   * renderComponent()\n   * // → <component-header itemId=\"item-1\" />\n   *\n   * // Not visible gallery\n   * renderComponent()\n   * // → <div class=\"component-placeholder\">Loading...</div>\n   * ```\n   *\n   * @private\n   */\n  private renderComponent() {\n    // Virtual rendering: only render component content when visible\n    if (!this.isVisible) {\n      return <div class=\"component-placeholder\">Loading...</div>;\n    }\n\n    switch (this.item.type) {\n      case 'header':\n        return <component-header itemId={this.item.id} />;\n      case 'text':\n        return <component-text-block itemId={this.item.id} />;\n      case 'image':\n        return <component-image itemId={this.item.id} />;\n      case 'button':\n        return <component-button itemId={this.item.id} />;\n      case 'video':\n        return <component-video itemId={this.item.id} />;\n      case 'imageGallery':\n        return <component-image-gallery itemId={this.item.id} />;\n      case 'dashboardWidget':\n        return <component-dashboard-widget itemId={this.item.id} />;\n      case 'liveData':\n        return <component-live-data itemId={this.item.id} />;\n      default:\n        return <div>Unknown component type: {this.item.type}</div>;\n    }\n  }\n\n  /**\n   * Render component template\n   *\n   * **Reactive**: Re-runs when item, renderVersion, or state changes\n   * **Pure**: No side effects, only returns JSX\n   *\n   * ## Layout Selection and Auto-Layout\n   *\n   * **Viewport-based layout**:\n   * ```typescript\n   * const currentViewport = gridState.currentViewport; // 'desktop' | 'mobile'\n   * const layout = this.item.layouts[currentViewport];\n   * ```\n   *\n   * **Mobile auto-layout**:\n   * When `currentViewport === 'mobile'` AND `!item.layouts.mobile.customized`:\n   * ```typescript\n   * // Calculate stacked vertical position\n   * const itemIndex = canvas.items.findIndex(i => i.id === item.id);\n   * let yPosition = 0;\n   * for (let i = 0; i < itemIndex; i++) {\n   *   yPosition += canvas.items[i].layouts.desktop.height || 6;\n   * }\n   *\n   * actualLayout = {\n   *   x: 0,                                  // Full left\n   *   y: yPosition,                          // Stacked\n   *   width: 50,                             // Full width (50 units = 100%)\n   *   height: item.layouts.desktop.height    // Keep height\n   * };\n   * ```\n   *\n   * **Auto-layout strategy**:\n   * - Full-width items (no horizontal scroll)\n   * - Stacked vertically (reading flow)\n   * - Maintains aspect ratio (desktop height)\n   * - Mobile-friendly UX\n   *\n   * ## Grid to Pixel Conversion\n   *\n   * **Convert layout to pixels**:\n   * ```typescript\n   * const xPixels = gridToPixelsX(actualLayout.x, item.canvasId);\n   * const yPixels = gridToPixelsY(actualLayout.y);\n   * const widthPixels = gridToPixelsX(actualLayout.width, item.canvasId);\n   * const heightPixels = gridToPixelsY(actualLayout.height);\n   * ```\n   *\n   * **Responsive width**: 2% per unit × container width\n   * **Fixed height**: 20px per unit\n   * **Canvas-specific**: Width varies by canvas\n   *\n   * ## Transform-Based Positioning\n   *\n   * **Style object**:\n   * ```typescript\n   * const itemStyle = {\n   *   transform: `translate(${xPixels}px, ${yPixels}px)`,\n   *   width: `${widthPixels}px`,\n   *   height: `${heightPixels}px`,\n   *   zIndex: this.item.zIndex.toString()\n   * };\n   * ```\n   *\n   * **Why transform**:\n   * - GPU-accelerated compositing\n   * - No layout recalculation\n   * - 60fps dragging performance\n   * - Sub-pixel accuracy\n   *\n   * ## Template Structure\n   *\n   * **Wrapper div** (`.grid-item`):\n   * - Positioned with transform\n   * - Sized with width/height\n   * - Layered with z-index\n   * - Contains all child elements\n   *\n   * **Child elements**:\n   * 1. **Drag handle** - For dragging entire item\n   * 2. **Item header** - Icon + title display\n   * 3. **Item content** - Actual component (renderComponent())\n   * 4. **Item controls** - Bring to front, send to back, delete\n   * 5. **Resize handles** - 8 points (corners + edges)\n   *\n   * ## Selection State\n   *\n   * **Dynamic classes**:\n   * ```typescript\n   * const itemClasses = {\n   *   'grid-item': true,           // Always present\n   *   selected: isSelected         // Conditional\n   * };\n   * ```\n   *\n   * **CSS effects** (when selected):\n   * - Border and shadow visible\n   * - Resize handles visible\n   * - Z-index controls visible\n   * - Drag handle highlighted\n   *\n   * ## Event Handlers\n   *\n   * **onClick**: handleClick (selection and config panel)\n   * **Bring to front button**: handleBringToFront\n   * **Send to back button**: handleSendToBack\n   * **Delete button**: handleDelete\n   *\n   * ## Data Attributes\n   *\n   * - `id={item.id}` - For DOM queries and drag detection\n   * - `data-canvas-id={item.canvasId}` - For cross-canvas drag detection\n   * - `data-component-name={item.name}` - For debugging\n   *\n   * ## Ref Assignment\n   *\n   * **Item ref**:\n   * ```typescript\n   * ref={(el) => (this.itemRef = el)}\n   * ```\n   *\n   * **Used for**:\n   * - Drag handler initialization\n   * - Resize handler initialization\n   * - Virtual renderer observation\n   * - Event dispatching\n   *\n   * @returns JSX template for grid item wrapper\n   *\n   * @example\n   * ```tsx\n   * // Rendered output for selected header item:\n   * <div\n   *   class=\"grid-item selected\"\n   *   id=\"item-1\"\n   *   style={{\n   *     transform: \"translate(100px, 40px)\",\n   *     width: \"200px\",\n   *     height: \"120px\",\n   *     zIndex: \"1\"\n   *   }}\n   * >\n   *   <div class=\"drag-handle\" />\n   *   <div class=\"grid-item-header\">📝 Header</div>\n   *   <div class=\"grid-item-content\">\n   *     <component-header itemId=\"item-1\" />\n   *   </div>\n   *   <div class=\"grid-item-controls\">\n   *     <button>⬆️</button>\n   *     <button>⬇️</button>\n   *     <button>×</button>\n   *   </div>\n   *   <div class=\"resize-handle nw\" />\n   *   <!-- ... 7 more resize handles ... -->\n   * </div>\n   * ```\n   */\n  render() {\n    const template = componentTemplates[this.item.type];\n    const currentViewport = gridState.currentViewport;\n    const layout = this.item.layouts[currentViewport];\n\n    // For mobile viewport, calculate auto-layout if not customized\n    let actualLayout = layout;\n    if (currentViewport === 'mobile' && !this.item.layouts.mobile.customized) {\n      // Auto-layout for mobile: stack components vertically at full width\n      const canvas = gridState.canvases[this.item.canvasId];\n      const itemIndex = canvas?.items.findIndex((i) => i.id === this.item.id) ?? 0;\n\n      // Calculate Y position by summing heights of all previous items\n      let yPosition = 0;\n      if (canvas && itemIndex > 0) {\n        for (let i = 0; i < itemIndex; i++) {\n          const prevItem = canvas.items[i];\n          // Use desktop height or default to 6 units\n          yPosition += prevItem.layouts.desktop.height || 6;\n        }\n      }\n\n      actualLayout = {\n        x: 0, // Full left\n        y: yPosition,\n        width: 50, // Full width (50 units = 100%)\n        height: this.item.layouts.desktop.height || 6, // Keep desktop height\n      };\n    }\n\n    // Compute selection directly from gridState (not cached state)\n    const isSelected = gridState.selectedItemId === this.item.id;\n\n    const itemClasses = {\n      'grid-item': true,\n      selected: isSelected,\n    };\n\n    // Convert grid units to pixels\n    const xPixels = gridToPixelsX(actualLayout.x, this.item.canvasId);\n    const yPixels = gridToPixelsY(actualLayout.y);\n    const widthPixels = gridToPixelsX(actualLayout.width, this.item.canvasId);\n    const heightPixels = gridToPixelsY(actualLayout.height);\n\n    const itemStyle = {\n      transform: `translate(${xPixels}px, ${yPixels}px)`,\n      width: `${widthPixels}px`,\n      height: `${heightPixels}px`,\n      zIndex: this.item.zIndex.toString(),\n    };\n\n    return (\n      <div\n        class={itemClasses}\n        id={this.item.id}\n        data-canvas-id={this.item.canvasId}\n        data-component-name={this.item.name || template.title}\n        style={itemStyle}\n        onClick={(e) => this.handleClick(e)}\n        ref={(el) => (this.itemRef = el)}\n      >\n        {/* Drag Handle */}\n        <div class=\"drag-handle\" />\n\n        {/* Item Header */}\n        <div class=\"grid-item-header\">\n          {template.icon} {this.item.name || template.title}\n        </div>\n\n        {/* Item Content */}\n        <div class=\"grid-item-content\" id={`${this.item.id}-content`}>\n          {this.renderComponent()}\n        </div>\n\n        {/* Item Controls */}\n        <div class=\"grid-item-controls\">\n          <button class=\"grid-item-control-btn\" onClick={() => this.handleBringToFront()} title=\"Bring to Front\">\n            ⬆️\n          </button>\n          <button class=\"grid-item-control-btn\" onClick={() => this.handleSendToBack()} title=\"Send to Back\">\n            ⬇️\n          </button>\n          <button class=\"grid-item-delete\" onClick={() => this.handleDelete()}>\n            ×\n          </button>\n        </div>\n\n        {/* Resize Handles (8 points) */}\n        <div class=\"resize-handle nw\" />\n        <div class=\"resize-handle ne\" />\n        <div class=\"resize-handle sw\" />\n        <div class=\"resize-handle se\" />\n        <div class=\"resize-handle n\" />\n        <div class=\"resize-handle s\" />\n        <div class=\"resize-handle e\" />\n        <div class=\"resize-handle w\" />\n      </div>\n    );\n  }\n\n  /**\n   * Capture item snapshot for undo/redo\n   *\n   * **Called from**: updateComponentState (before interactions)\n   * **Purpose**: Deep clone item state for change detection\n   *\n   * **Deep cloning**:\n   * ```typescript\n   * this.itemSnapshot = JSON.parse(JSON.stringify(this.item));\n   * ```\n   *\n   * **Why deep clone**:\n   * - Prevents mutations from affecting snapshot\n   * - Independent copy of item state\n   * - Simple and reliable (no reference tracking)\n   *\n   * **Performance**:\n   * - ~0.1-0.5ms per snapshot\n   * - Acceptable for pre-interaction capture\n   * - Could optimize with structured cloning if needed\n   *\n   * **Used by**: handleItemUpdate to compare before/after state\n   *\n   * @private\n   */\n  private captureItemSnapshot = () => {\n    // Deep clone the item to capture its state before drag/resize\n    this.itemSnapshot = JSON.parse(JSON.stringify(this.item));\n  };\n\n  /**\n   * Handle item update (called by drag/resize handlers)\n   *\n   * **Triggered by**: DragHandler.onUpdate, ResizeHandler.onUpdate\n   * **Purpose**: Create undo command and update state\n   *\n   * ## Change Detection\n   *\n   * **Compare snapshot with updated item**:\n   * ```typescript\n   * const positionChanged =\n   *   snapshot.layouts.desktop.x !== updated.layouts.desktop.x ||\n   *   snapshot.layouts.desktop.y !== updated.layouts.desktop.y ||\n   *   snapshot.layouts.desktop.width !== updated.layouts.desktop.width ||\n   *   snapshot.layouts.desktop.height !== updated.layouts.desktop.height;\n   *\n   * const canvasChanged = snapshot.canvasId !== updated.canvasId;\n   * ```\n   *\n   * **Why check for changes**:\n   * - Drag without movement shouldn't create undo command\n   * - Resize without size change shouldn't create undo command\n   * - Prevents undo history pollution\n   * - Only track meaningful operations\n   *\n   * ## Undo Command Creation\n   *\n   * **Create MoveItemCommand**:\n   * ```typescript\n   * pushCommand(new MoveItemCommand(\n   *   itemId,\n   *   snapshot.canvasId,     // Source canvas\n   *   updated.canvasId,      // Target canvas (may be same)\n   *   { x: snapshot.x, y: snapshot.y },        // Before position\n   *   { x: updated.x, y: updated.y },          // After position\n   *   sourceIndex            // Original array index\n   * ));\n   * ```\n   *\n   * **Why MoveItemCommand for resize**:\n   * - MoveItemCommand tracks position changes\n   * - Resize changes position AND size\n   * - Position comparison includes width/height\n   * - Single command type for all transformations\n   *\n   * **Source index capture**:\n   * ```typescript\n   * const sourceIndex = sourceCanvas.items.findIndex(i => i.id === item.id);\n   * ```\n   * - Needed for undo to restore at original position\n   * - Critical for z-index order preservation\n   *\n   * ## State Update\n   *\n   * **Update item in canvas**:\n   * ```typescript\n   * const canvas = gridState.canvases[this.item.canvasId];\n   * const itemIndex = canvas.items.findIndex(i => i.id === this.item.id);\n   * canvas.items[itemIndex] = updatedItem;\n   * gridState.canvases = { ...gridState.canvases };  // Trigger reactivity\n   * ```\n   *\n   * **Why spread pattern**:\n   * - Object reference change triggers StencilJS reactivity\n   * - Components automatically re-render\n   * - Standard reactive state pattern\n   *\n   * **Order of operations**:\n   * 1. Compare snapshot with updated item\n   * 2. Create undo command if changed\n   * 3. Push command to history\n   * 4. Update item in state\n   * 5. Trigger re-render\n   *\n   * **Edge cases**:\n   * - No snapshot: Skip undo command creation\n   * - Canvas not found: Skip state update\n   * - Item not found: Skip state update\n   *\n   * @param updatedItem - Item with new position/size from drag/resize handler\n   *\n   * @example\n   * ```typescript\n   * // After drag operation\n   * handleItemUpdate({\n   *   ...item,\n   *   layouts: {\n   *     desktop: { x: 15, y: 10, width: 20, height: 8 }\n   *   }\n   * })\n   * // → Compares with snapshot: { x: 10, y: 5, ... }\n   * // → Position changed: true\n   * // → Creates MoveItemCommand(before: {10,5}, after: {15,10})\n   * // → Updates state\n   * // → Undo available\n   * ```\n   *\n   * @private\n   */\n  private handleItemUpdate = (updatedItem: GridItem) => {\n    // Called by drag/resize handlers at end of operation\n\n    // Check if position or canvas changed (for undo/redo)\n    if (this.itemSnapshot) {\n      const snapshot = this.itemSnapshot;\n      const positionChanged =\n        snapshot.layouts.desktop.x !== updatedItem.layouts.desktop.x ||\n        snapshot.layouts.desktop.y !== updatedItem.layouts.desktop.y ||\n        snapshot.layouts.desktop.width !== updatedItem.layouts.desktop.width ||\n        snapshot.layouts.desktop.height !== updatedItem.layouts.desktop.height;\n      const canvasChanged = snapshot.canvasId !== updatedItem.canvasId;\n\n      if (positionChanged || canvasChanged) {\n        // Find source canvas and index\n        const sourceCanvas = gridState.canvases[snapshot.canvasId];\n        const sourceIndex = sourceCanvas?.items.findIndex((i) => i.id === this.item.id) || 0;\n\n        // Push undo command before updating state\n        pushCommand(\n          new MoveItemCommand(\n            updatedItem.id,\n            snapshot.canvasId,\n            updatedItem.canvasId,\n            {\n              x: snapshot.layouts.desktop.x,\n              y: snapshot.layouts.desktop.y,\n            },\n            {\n              x: updatedItem.layouts.desktop.x,\n              y: updatedItem.layouts.desktop.y,\n            },\n            sourceIndex\n          )\n        );\n      }\n    }\n\n    // Update item in state (triggers re-render)\n    const canvas = gridState.canvases[this.item.canvasId];\n    const itemIndex = canvas.items.findIndex((i) => i.id === this.item.id);\n    if (itemIndex !== -1) {\n      canvas.items[itemIndex] = updatedItem;\n      gridState.canvases = { ...gridState.canvases }; // Trigger update\n    }\n  };\n\n  /**\n   * Handle click event (selection and config panel)\n   *\n   * **Triggered by**: User clicks anywhere on grid item\n   * **Purpose**: Select item and optionally open config panel\n   *\n   * ## Click Filtering\n   *\n   * **Ignore clicks on interactive elements**:\n   * ```typescript\n   * if (\n   *   target.classList.contains('drag-handle') ||\n   *   target.classList.contains('resize-handle') ||\n   *   target.classList.contains('grid-item-delete') ||\n   *   target.classList.contains('grid-item-control-btn')\n   * ) {\n   *   return;  // Don't select/open config\n   * }\n   * ```\n   *\n   * **Why filter**:\n   * - Drag handle should only drag (not select)\n   * - Resize handles should only resize (not select)\n   * - Control buttons have their own actions\n   * - Prevents conflicting interactions\n   *\n   * **Uses closest() for nested elements**:\n   * ```typescript\n   * target.closest('.drag-handle')\n   * ```\n   * - Handles clicks on child elements of handle\n   * - Bubbling through handle children\n   * - More robust than classList alone\n   *\n   * ## Selection Update\n   *\n   * **Set selection immediately**:\n   * ```typescript\n   * gridState.selectedItemId = this.item.id;\n   * gridState.selectedCanvasId = this.item.canvasId;\n   * ```\n   *\n   * **Why immediate**:\n   * - Keyboard shortcuts check selection (Delete key)\n   * - Visual feedback needs to be instant\n   * - Other components react to selection\n   * - No need to wait for event handling\n   *\n   * ## Custom Event Dispatch\n   *\n   * **Dispatch 'item-click' event**:\n   * ```typescript\n   * dispatchEvent(new CustomEvent('item-click', {\n   *   detail: { itemId: item.id, canvasId: item.canvasId },\n   *   bubbles: true,    // Event reaches parent (grid-builder-app)\n   *   composed: true    // Event crosses shadow DOM\n   * }));\n   * ```\n   *\n   * **Purpose**: Open config panel in parent app\n   * - App listens for item-click events\n   * - Opens config panel for selected item\n   * - Decouples wrapper from app logic\n   *\n   * **Event details**:\n   * - `itemId`: Which item was clicked\n   * - `canvasId`: Which canvas contains item\n   * - Both needed for state lookup\n   *\n   * @param e - Mouse click event\n   *\n   * @example\n   * ```typescript\n   * // User clicks item header\n   * handleClick(event)\n   * // → target is header, not a handle\n   * // → Selection updated: selectedItemId = 'item-3'\n   * // → Event dispatched to app\n   * // → Config panel opens\n   *\n   * // User clicks drag handle\n   * handleClick(event)\n   * // → target is drag-handle\n   * // → Early return, no selection change\n   * // → Drag operation can proceed\n   * ```\n   *\n   * @private\n   */\n  private handleClick = (e: MouseEvent) => {\n    // Don't open config panel if clicking on drag handle, resize handle, or control buttons\n    const target = e.target as HTMLElement;\n    if (\n      target.classList.contains('drag-handle') ||\n      target.closest('.drag-handle') ||\n      target.classList.contains('resize-handle') ||\n      target.closest('.resize-handle') ||\n      target.classList.contains('grid-item-delete') ||\n      target.classList.contains('grid-item-control-btn')\n    ) {\n      return;\n    }\n\n    // Set selection state immediately (so keyboard shortcuts work)\n    gridState.selectedItemId = this.item.id;\n    gridState.selectedCanvasId = this.item.canvasId;\n\n    // Dispatch event to open config panel\n    const event = new CustomEvent('item-click', {\n      detail: { itemId: this.item.id, canvasId: this.item.canvasId },\n      bubbles: true,\n      composed: true,\n    });\n    this.itemRef.dispatchEvent(event);\n  };\n\n  /**\n   * Handle bring to front (increase z-index)\n   *\n   * **Triggered by**: User clicks \"Bring to Front\" button (⬆️)\n   * **Purpose**: Move item to top of stacking order\n   *\n   * ## Z-Index Calculation\n   *\n   * **Find maximum z-index in canvas**:\n   * ```typescript\n   * const canvas = gridState.canvases[item.canvasId];\n   * const maxZ = Math.max(...canvas.items.map(i => i.zIndex));\n   * ```\n   *\n   * **Set item z-index to max + 1**:\n   * ```typescript\n   * this.item.zIndex = maxZ + 1;\n   * ```\n   *\n   * **Why max + 1**:\n   * - Guarantees item is on top\n   * - Monotonic z-index (never reuse values)\n   * - Simple and reliable\n   * - No conflicts with existing items\n   *\n   * ## State Update\n   *\n   * **Trigger reactivity**:\n   * ```typescript\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   *\n   * **Side effects**:\n   * - Component re-renders with new z-index\n   * - Item visually moves to front\n   * - CSS z-index applied: `style={{ zIndex: newValue }}`\n   *\n   * ## No Undo Support\n   *\n   * **Note**: Z-index changes NOT tracked in undo history\n   * - Would clutter history with minor operations\n   * - Less critical than position/size changes\n   * - Could be added if needed\n   *\n   * **Alternative approach**:\n   * - Track in separate z-index command type\n   * - Or bundle with next position change\n   *\n   * @example\n   * ```typescript\n   * // Canvas has items with z-index: 1, 3, 5\n   * handleBringToFront()\n   * // → maxZ = 5\n   * // → item.zIndex = 6\n   * // → Item now on top\n   * ```\n   *\n   * @private\n   */\n  private handleBringToFront = () => {\n    const canvas = gridState.canvases[this.item.canvasId];\n    const maxZ = Math.max(...canvas.items.map((i) => i.zIndex));\n    this.item.zIndex = maxZ + 1;\n    gridState.canvases = { ...gridState.canvases }; // Trigger update\n  };\n\n  /**\n   * Handle send to back (decrease z-index)\n   *\n   * **Triggered by**: User clicks \"Send to Back\" button (⬇️)\n   * **Purpose**: Move item to bottom of stacking order\n   *\n   * ## Z-Index Calculation\n   *\n   * **Find minimum z-index in canvas**:\n   * ```typescript\n   * const canvas = gridState.canvases[item.canvasId];\n   * const minZ = Math.min(...canvas.items.map(i => i.zIndex));\n   * ```\n   *\n   * **Set item z-index to min - 1**:\n   * ```typescript\n   * this.item.zIndex = minZ - 1;\n   * ```\n   *\n   * **Why min - 1**:\n   * - Guarantees item is behind all others\n   * - Allows negative z-index (CSS allows it)\n   * - Monotonic z-index (never conflicts)\n   * - Simple and reliable\n   *\n   * ## State Update\n   *\n   * **Trigger reactivity**:\n   * ```typescript\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   *\n   * **Side effects**:\n   * - Component re-renders with new z-index\n   * - Item visually moves to back\n   * - Other items appear in front\n   *\n   * ## Z-Index Range\n   *\n   * **No limits enforced**:\n   * - Can go negative (valid CSS)\n   * - Can grow arbitrarily high\n   * - In practice: -100 to +100 range\n   * - Could add normalization if needed\n   *\n   * @example\n   * ```typescript\n   * // Canvas has items with z-index: 1, 3, 5\n   * handleSendToBack()\n   * // → minZ = 1\n   * // → item.zIndex = 0\n   * // → Item now behind all others\n   * ```\n   *\n   * @private\n   */\n  private handleSendToBack = () => {\n    const canvas = gridState.canvases[this.item.canvasId];\n    const minZ = Math.min(...canvas.items.map((i) => i.zIndex));\n    this.item.zIndex = minZ - 1;\n    gridState.canvases = { ...gridState.canvases }; // Trigger update\n  };\n\n  /**\n   * Handle delete (dispatch event to app)\n   *\n   * **Triggered by**: User clicks delete button (×)\n   * **Purpose**: Request item deletion from parent app\n   *\n   * ## Custom Event Dispatch\n   *\n   * **Pattern**:\n   * ```typescript\n   * dispatchEvent(new CustomEvent('item-delete', {\n   *   detail: { itemId: item.id, canvasId: item.canvasId },\n   *   bubbles: true,\n   *   composed: true\n   * }));\n   * ```\n   *\n   * **Why custom event**:\n   * - Wrapper doesn't manage global state\n   * - App coordinates deletion with undo command\n   * - Decouples wrapper from app logic\n   * - Testable (can spy on events)\n   *\n   * **Event details**:\n   * - `itemId`: Which item to delete\n   * - `canvasId`: Which canvas contains item\n   * - Both needed for state lookup\n   *\n   * ## App Coordination\n   *\n   * **grid-builder-app.tsx handles**:\n   * 1. Receives 'item-delete' event\n   * 2. Gets item and index for undo command\n   * 3. Creates DeleteItemCommand\n   * 4. Removes item from state\n   * 5. Pushes command for undo\n   * 6. Clears selection if this item selected\n   *\n   * **Why delegate to app**:\n   * - App owns item collection state\n   * - App manages undo history\n   * - Single responsibility (wrapper = UI, app = state)\n   * - Easier to test and maintain\n   *\n   * ## No Direct State Mutation\n   *\n   * **Wrapper does NOT**:\n   * - Remove item from state\n   * - Create undo command\n   * - Clear selection\n   *\n   * **Only dispatches event**:\n   * - App decides how to handle\n   * - Could show confirmation dialog\n   * - Could enforce business rules\n   * - Flexible architecture\n   *\n   * @example\n   * ```typescript\n   * // User clicks delete button\n   * handleDelete()\n   * // → Event dispatched: { itemId: 'item-3', canvasId: 'canvas1' }\n   * // → App receives event\n   * // → App creates DeleteItemCommand\n   * // → App removes item from state\n   * // → Item disappears from DOM\n   * // → Undo available\n   * ```\n   *\n   * @private\n   */\n  private handleDelete = () => {\n    // Dispatch event to grid-builder-app to handle\n    const event = new CustomEvent('item-delete', {\n      detail: { itemId: this.item.id, canvasId: this.item.canvasId },\n      bubbles: true,\n      composed: true,\n    });\n    this.itemRef.dispatchEvent(event);\n  };\n}\n"],"version":3}