{"version":3,"file":"api.js","sourceRoot":"","sources":["../../src/types/api.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/**\n * Grid Builder API Types\n * =======================\n *\n * API interface exposed to plugins and external code for interacting with the grid builder.\n * Provides methods for event subscriptions, state access, and programmatic operations.\n */\n\nimport { GridItem, GridState } from '../services/state-manager';\nimport { UndoRedoState } from '../services/undo-redo';\n\n/**\n * Event callback type for grid builder events\n *\n * **Generic event structure**: All events pass an object with relevant data\n * **Unsubscribe pattern**: Store callback reference to unsubscribe later\n */\nexport type EventCallback<T = any> = (data: T) => void;\n\n/**\n * Grid Builder API Interface\n * ============================\n *\n * Main API exposed to plugins and external code for interacting with the grid builder.\n * Provides full access to state, operations, and events.\n *\n * **Typical usage**: Plugins receive API in init() method\n * ```typescript\n * class MyPlugin implements GridBuilderPlugin {\n *   private api: GridBuilderAPI;\n *\n *   init(api: GridBuilderAPI) {\n *     this.api = api;\n *\n *     // Subscribe to events\n *     api.on('componentAdded', this.handleComponentAdded);\n *\n *     // Programmatic operations\n *     const state = api.getState();\n *     console.log(`Currently ${state.canvases.canvas1.items.length} items`);\n *   }\n *\n *   destroy() {\n *     // Unsubscribe from events\n *     this.api.off('componentAdded', this.handleComponentAdded);\n *   }\n * }\n * ```\n *\n * **Example: Analytics Plugin**\n * ```typescript\n * export class AnalyticsPlugin implements GridBuilderPlugin {\n *   name = 'analytics';\n *   private api: GridBuilderAPI;\n *\n *   init(api: GridBuilderAPI) {\n *     this.api = api;\n *\n *     // Track component additions\n *     api.on('componentAdded', (e) => {\n *       analytics.track('Component Added', {\n *         type: e.item.type,\n *         canvasId: e.canvasId\n *       });\n *     });\n *\n *     // Track component deletes\n *     api.on('componentDeleted', (e) => {\n *       analytics.track('Component Deleted', {\n *         itemId: e.itemId\n *       });\n *     });\n *   }\n *\n *   destroy() {\n *     // Cleanup if needed\n *   }\n * }\n * ```\n */\nexport interface GridBuilderAPI {\n  // ======================\n  // Event Subscriptions\n  // ======================\n\n  /**\n   * Subscribe to grid builder event\n   *\n   * **Use cases**:\n   * - Track user actions (analytics)\n   * - Sync with external systems\n   * - Custom validation/workflows\n   * - Performance monitoring\n   *\n   * **Event types**: See events.ts for full list\n   * - 'componentAdded' - When component dropped on canvas\n   * - 'componentDeleted' - When component removed\n   * - 'componentDragged' - After drag completes\n   * - 'componentResized' - After resize completes\n   * - 'componentSelected' - When component selected\n   * - 'componentDeselected' - When selection cleared\n   * - 'configChanged' - After config panel save\n   * - 'dragStart' - When drag begins\n   * - 'dragEnd' - When drag ends\n   * - 'resizeStart' - When resize begins\n   * - 'resizeEnd' - When resize ends\n   * - 'viewportChanged' - When desktop/mobile toggle\n   * - 'undo' - When undo performed\n   * - 'redo' - When redo performed\n   *\n   * **Unsubscribe pattern**: Must unsubscribe in plugin.destroy()\n   * ```typescript\n   * // Subscribe\n   * const callback = (e) => console.log('Added:', e);\n   * api.on('componentAdded', callback);\n   *\n   * // Unsubscribe (in destroy)\n   * api.off('componentAdded', callback);\n   * ```\n   *\n   * @param eventName - Event to subscribe to\n   * @param callback - Function called when event fires\n   *\n   * @example\n   * ```typescript\n   * // Track all component additions\n   * api.on('componentAdded', (event) => {\n   *   console.log(`Added ${event.item.type} to ${event.canvasId}`);\n   * });\n   *\n   * // Monitor performance of drag operations\n   * let dragStartTime: number;\n   * api.on('dragStart', () => {\n   *   dragStartTime = Date.now();\n   * });\n   * api.on('dragEnd', () => {\n   *   const duration = Date.now() - dragStartTime;\n   *   console.log(`Drag took ${duration}ms`);\n   * });\n   * ```\n   */\n  on<T = any>(eventName: string, callback: EventCallback<T>): void;\n\n  /**\n   * Unsubscribe from grid builder event\n   *\n   * **CRITICAL**: Must unsubscribe in plugin.destroy() to prevent memory leaks\n   *\n   * **Requirements**:\n   * - Must pass EXACT same callback reference used in on()\n   * - Callback stored as property or bound method\n   *\n   * **Common mistake**:\n   * ```typescript\n   * // ❌ Wrong: Different callback reference\n   * api.on('componentAdded', (e) => console.log(e));\n   * api.off('componentAdded', (e) => console.log(e)); // Won't unsubscribe!\n   *\n   * // ✅ Correct: Same callback reference\n   * const callback = (e) => console.log(e);\n   * api.on('componentAdded', callback);\n   * api.off('componentAdded', callback); // Unsubscribes successfully\n   * ```\n   *\n   * @param eventName - Event to unsubscribe from\n   * @param callback - Exact callback reference used in on()\n   *\n   * @example\n   * ```typescript\n   * class MyPlugin implements GridBuilderPlugin {\n   *   private api: GridBuilderAPI;\n   *   private handleAdd = (e) => console.log('Added:', e);\n   *\n   *   init(api: GridBuilderAPI) {\n   *     this.api = api;\n   *     api.on('componentAdded', this.handleAdd);\n   *   }\n   *\n   *   destroy() {\n   *     // Unsubscribe using same reference\n   *     this.api.off('componentAdded', this.handleAdd);\n   *   }\n   * }\n   * ```\n   */\n  off<T = any>(eventName: string, callback: EventCallback<T>): void;\n\n  // ======================\n  // State Access (Read)\n  // ======================\n\n  /**\n   * Get current grid builder state\n   *\n   * **Returns**: Full GridState object (canvases, selection, viewport, etc.)\n   * **Read-only**: For reading state. Use API methods to mutate.\n   *\n   * **Use cases**:\n   * - Save/export layout to JSON\n   * - Check current viewport mode\n   * - Count items per canvas\n   * - Custom validation logic\n   *\n   * @returns Current grid state\n   *\n   * @example\n   * ```typescript\n   * // Save state to localStorage\n   * const state = api.getState();\n   * localStorage.setItem('grid-state', JSON.stringify(state));\n   *\n   * // Count total items\n   * const state = api.getState();\n   * const totalItems = Object.values(state.canvases)\n   *   .reduce((sum, canvas) => sum + canvas.items.length, 0);\n   * console.log(`Total items: ${totalItems}`);\n   * ```\n   */\n  getState(): GridState;\n\n  /**\n   * Get all items in specific canvas\n   *\n   * **Returns**: Array of GridItem objects in canvas\n   * **Sorted**: Items in DOM render order\n   *\n   * **Use cases**:\n   * - Iterate over canvas items\n   * - Count items per canvas\n   * - Filter items by type\n   * - Export canvas layout\n   *\n   * @param canvasId - Canvas to get items from\n   * @returns Array of items or empty array if canvas not found\n   *\n   * @example\n   * ```typescript\n   * // Count headers in canvas1\n   * const items = api.getItems('canvas1');\n   * const headerCount = items.filter(item => item.type === 'header').length;\n   * console.log(`${headerCount} headers in canvas1`);\n   *\n   * // Export canvas to JSON\n   * const items = api.getItems('canvas2');\n   * const exportData = items.map(item => ({\n   *   type: item.type,\n   *   position: item.layouts.desktop\n   * }));\n   * ```\n   */\n  getItems(canvasId: string): GridItem[];\n\n  /**\n   * Get specific item by ID\n   *\n   * **Returns**: GridItem or null if not found\n   * **Note**: Searches across ALL canvases (item IDs are globally unique)\n   *\n   * **Use cases**:\n   * - Check if item exists\n   * - Get item before operation\n   * - Read item properties\n   * - Validation checks\n   *\n   * @param itemId - Item ID to find\n   * @returns GridItem or null if not found\n   *\n   * @example\n   * ```typescript\n   * // Check item exists before operation\n   * const item = api.getItem('item-5');\n   * if (item) {\n   *   console.log(`Item at (${item.layouts.desktop.x}, ${item.layouts.desktop.y})`);\n   * } else {\n   *   console.error('Item not found');\n   * }\n   *\n   * // Validate item type\n   * const item = api.getItem('item-3');\n   * if (item?.type === 'video') {\n   *   console.log('This is a video component');\n   * }\n   * ```\n   */\n  getItem(itemId: string): GridItem | null;\n\n  // ======================\n  // Programmatic Operations\n  // ======================\n\n  /**\n   * Add component programmatically\n   *\n   * **Use cases**:\n   * - Add component via plugin\n   * - Template/preset loading\n   * - Import from saved layout\n   * - Programmatic page building\n   *\n   * **Coordinates**: x/y in grid units (not pixels)\n   * **Auto-generates**:\n   * - Unique item ID\n   * - z-index assignment\n   * - Mobile layout (if not provided)\n   *\n   * **Events triggered**: 'componentAdded'\n   *\n   * @param canvasId - Target canvas\n   * @param componentType - Component type (must match registered definition)\n   * @param position - Position in grid units\n   * @param config - Optional initial configuration\n   * @returns Created item ID or null if failed\n   *\n   * @example\n   * ```typescript\n   * // Add header to canvas1\n   * const itemId = api.addComponent('canvas1', 'header', {\n   *   x: 5,\n   *   y: 2,\n   *   width: 20,\n   *   height: 8\n   * }, {\n   *   text: 'Welcome!',\n   *   level: 'H1',\n   *   color: '#000000'\n   * });\n   *\n   * if (itemId) {\n   *   console.log(`Created ${itemId}`);\n   * }\n   * ```\n   */\n  addComponent(\n    canvasId: string,\n    componentType: string,\n    position: { x: number; y: number; width: number; height: number },\n    config?: Record<string, any>\n  ): string | null;\n\n  /**\n   * Delete component programmatically\n   *\n   * **Use cases**:\n   * - Delete via plugin\n   * - Cleanup operations\n   * - Conditional deletions\n   * - Undo add operation\n   *\n   * **Events triggered**: 'componentDeleted'\n   * **Deselects**: If deleting selected item\n   *\n   * @param itemId - Item to delete\n   * @returns true if deleted, false if item not found\n   *\n   * @example\n   * ```typescript\n   * // Delete all headers in canvas1\n   * const items = api.getItems('canvas1');\n   * const headers = items.filter(item => item.type === 'header');\n   * headers.forEach(item => {\n   *   api.deleteComponent(item.id);\n   * });\n   * ```\n   */\n  deleteComponent(itemId: string): boolean;\n\n  /**\n   * Update component configuration\n   *\n   * **Use cases**:\n   * - Change config via plugin\n   * - Bulk property updates\n   * - Theme changes\n   * - Programmatic editing\n   *\n   * **Triggers**: Component re-render with new config\n   * **Events triggered**: 'configChanged'\n   *\n   * @param itemId - Item to update\n   * @param config - New configuration (merged with existing)\n   * @returns true if updated, false if item not found\n   *\n   * @example\n   * ```typescript\n   * // Change all header colors to blue\n   * const items = api.getItems('canvas1');\n   * const headers = items.filter(item => item.type === 'header');\n   * headers.forEach(item => {\n   *   api.updateConfig(item.id, { color: 'blue' });\n   * });\n   * ```\n   */\n  updateConfig(itemId: string, config: Record<string, any>): boolean;\n\n  // ======================\n  // Batch Operations\n  // ======================\n\n  /**\n   * Add multiple components in single operation\n   *\n   * **Performance**: 1000 items in ~10ms with 1 re-render\n   * **Atomicity**: All-or-nothing operation (single undo/redo)\n   *\n   * **Use cases**:\n   * - Template loading (many components at once)\n   * - Import saved layouts\n   * - Stress testing\n   * - Bulk operations\n   *\n   * **Events triggered**: Single 'componentsBatchAdded' event with all items\n   *\n   * @param components - Array of component specs (without id/zIndex)\n   * @returns Array of created item IDs\n   *\n   * @example\n   * ```typescript\n   * // Load template with 50 components\n   * const template = [\n   *   {\n   *     canvasId: 'canvas1',\n   *     type: 'header',\n   *     position: { x: 0, y: 0, width: 50, height: 10 },\n   *     config: { text: 'Hero Header' }\n   *   },\n   *   {\n   *     canvasId: 'canvas1',\n   *     type: 'text',\n   *     position: { x: 0, y: 12, width: 25, height: 15 },\n   *     config: { text: 'Lorem ipsum...' }\n   *   },\n   *   // ... 48 more components\n   * ];\n   *\n   * const itemIds = api.addComponentsBatch(template);\n   * console.log(`Added ${itemIds.length} components in single operation`);\n   * ```\n   */\n  addComponentsBatch(\n    components: Array<{\n      canvasId: string;\n      type: string;\n      position: { x: number; y: number; width: number; height: number };\n      config?: Record<string, any>;\n    }>\n  ): string[];\n\n  /**\n   * Delete multiple components in single operation\n   *\n   * **Performance**: 1000 items in ~5ms with 1 re-render\n   * **Atomicity**: All-or-nothing operation (single undo/redo)\n   *\n   * **Use cases**:\n   * - Clear entire canvas\n   * - Delete selection group\n   * - Bulk cleanup\n   * - Undo batch add\n   *\n   * **Events triggered**: Single 'componentsBatchDeleted' event with all item IDs\n   *\n   * @param itemIds - Array of item IDs to delete\n   *\n   * @example\n   * ```typescript\n   * // Clear entire canvas1\n   * const items = api.getItems('canvas1');\n   * const itemIds = items.map(item => item.id);\n   * api.deleteComponentsBatch(itemIds);\n   * console.log('Canvas1 cleared');\n   * ```\n   */\n  deleteComponentsBatch(itemIds: string[]): void;\n\n  /**\n   * Update multiple component configs in single operation\n   *\n   * **Performance**: 1000 items in ~8ms with 1 re-render\n   * **Atomicity**: All-or-nothing operation (single undo/redo)\n   *\n   * **Use cases**:\n   * - Theme changes (update all component colors)\n   * - Bulk property updates\n   * - Template application\n   * - Undo batch config change\n   *\n   * **Events triggered**: Single 'configsBatchChanged' event with all updates\n   *\n   * @param updates - Array of { itemId, config } objects\n   *\n   * @example\n   * ```typescript\n   * // Change all headers to dark theme\n   * const items = api.getItems('canvas1');\n   * const headerUpdates = items\n   *   .filter(item => item.type === 'header')\n   *   .map(item => ({\n   *     itemId: item.id,\n   *     config: {\n   *       color: '#ffffff',\n   *       backgroundColor: '#000000'\n   *     }\n   *   }));\n   *\n   * api.updateConfigsBatch(headerUpdates);\n   * console.log(`Updated ${headerUpdates.length} headers to dark theme`);\n   * ```\n   */\n  updateConfigsBatch(updates: Array<{ itemId: string; config: Record<string, any> }>): void;\n\n  // ======================\n  // Canvas Access\n  // ======================\n\n  /**\n   * Get canvas DOM element reference\n   *\n   * **Use cases**:\n   * - Measure canvas dimensions\n   * - Add custom overlays\n   * - Custom drag/drop implementations\n   * - Direct DOM manipulation (use cautiously)\n   *\n   * **Warning**: Avoid direct DOM manipulation when possible.\n   * Prefer API methods to maintain reactivity.\n   *\n   * @param canvasId - Canvas to get element for\n   * @returns HTMLElement or null if not found\n   *\n   * @example\n   * ```typescript\n   * // Measure canvas dimensions\n   * const canvas = api.getCanvasElement('canvas1');\n   * if (canvas) {\n   *   const rect = canvas.getBoundingClientRect();\n   *   console.log(`Canvas is ${rect.width}px × ${rect.height}px`);\n   * }\n   *\n   * // Add custom overlay\n   * const canvas = api.getCanvasElement('canvas2');\n   * if (canvas) {\n   *   const overlay = document.createElement('div');\n   *   overlay.className = 'custom-overlay';\n   *   canvas.appendChild(overlay);\n   * }\n   * ```\n   */\n  getCanvasElement(canvasId: string): HTMLElement | null;\n\n  // ======================\n  // Undo/Redo Operations\n  // ======================\n\n  /**\n   * Undo last operation\n   *\n   * **Use cases**:\n   * - Implement undo button\n   * - Keyboard shortcut (Ctrl+Z)\n   * - Programmatic undo\n   *\n   * **Undoable operations**:\n   * - Add/delete components\n   * - Move/resize components\n   * - Config changes\n   * - Add/remove canvases\n   *\n   * @example\n   * ```typescript\n   * // Undo button handler\n   * handleUndo() {\n   *   api.undo();\n   * }\n   * ```\n   */\n  undo(): void;\n\n  /**\n   * Redo last undone operation\n   *\n   * **Use cases**:\n   * - Implement redo button\n   * - Keyboard shortcut (Ctrl+Y)\n   * - Programmatic redo\n   *\n   * @example\n   * ```typescript\n   * // Redo button handler\n   * handleRedo() {\n   *   api.redo();\n   * }\n   * ```\n   */\n  redo(): void;\n\n  /**\n   * Check if undo is available\n   *\n   * **Use cases**:\n   * - Enable/disable undo button\n   * - Check before undo operation\n   *\n   * @returns true if undo stack has operations\n   *\n   * @example\n   * ```typescript\n   * // Enable/disable undo button\n   * <button disabled={!api.canUndo()} onClick={() => api.undo()}>\n   *   Undo\n   * </button>\n   * ```\n   */\n  canUndo(): boolean;\n\n  /**\n   * Check if redo is available\n   *\n   * **Use cases**:\n   * - Enable/disable redo button\n   * - Check before redo operation\n   *\n   * @returns true if redo stack has operations\n   *\n   * @example\n   * ```typescript\n   * // Enable/disable redo button\n   * <button disabled={!api.canRedo()} onClick={() => api.redo()}>\n   *   Redo\n   * </button>\n   * ```\n   */\n  canRedo(): boolean;\n\n  /**\n   * Reactive undo/redo state for button updates\n   *\n   * **Reactive**: StencilJS components automatically re-render when state changes\n   * **Use instead of**: canUndo() and canRedo() functions for reactive UIs\n   *\n   * **Use cases**:\n   * - Enable/disable undo/redo buttons reactively\n   * - Show/hide undo/redo UI based on availability\n   * - Display in status bars\n   *\n   * **Properties**:\n   * - canUndo: boolean - Whether undo is available\n   * - canRedo: boolean - Whether redo is available\n   *\n   * @example\n   * ```typescript\n   * // Reactive undo/redo buttons (updates automatically)\n   * <button\n   *   disabled={!api.undoRedoState.canUndo}\n   *   onClick={() => api.undo()}>\n   *   Undo\n   * </button>\n   * <button\n   *   disabled={!api.undoRedoState.canRedo}\n   *   onClick={() => api.redo()}>\n   *   Redo\n   * </button>\n   * ```\n   */\n  undoRedoState: UndoRedoState;\n\n  // ======================\n  // Canvas Management\n  // ======================\n\n  /**\n   * Add new canvas programmatically\n   *\n   * **Use cases**:\n   * - Dynamic canvas creation\n   * - Template loading\n   * - User adds section via UI\n   *\n   * **Library responsibility**:\n   * - Create canvas in gridState with empty items array\n   * - Initialize zIndexCounter\n   * - Track operation in undo/redo\n   *\n   * **Host app responsibility**:\n   * - Listen to 'canvasAdded' event\n   * - Add canvas metadata (title, backgroundColor, etc.)\n   *\n   * **Events triggered**: 'canvasAdded'\n   *\n   * @param canvasId - Unique canvas identifier\n   *\n   * @example\n   * ```typescript\n   * // Add new section\n   * api.addCanvas('hero-section-2');\n   *\n   * // Host app syncs metadata\n   * api.on('canvasAdded', (event) => {\n   *   canvasMetadata[event.canvasId] = {\n   *     title: 'New Section',\n   *     backgroundColor: '#f5f5f5'\n   *   };\n   * });\n   * ```\n   */\n  addCanvas(canvasId: string): void;\n\n  /**\n   * Remove canvas programmatically\n   *\n   * **Use cases**:\n   * - Delete section via UI\n   * - Template cleanup\n   * - Conditional canvas removal\n   *\n   * **Library responsibility**:\n   * - Snapshot canvas items and zIndexCounter\n   * - Remove canvas from gridState\n   * - Track operation in undo/redo (restores items on undo)\n   *\n   * **Host app responsibility**:\n   * - Listen to 'canvasRemoved' event\n   * - Remove canvas metadata\n   * - Clean up any dynamically injected headers/UI\n   *\n   * **Events triggered**: 'canvasRemoved'\n   *\n   * @param canvasId - Canvas to remove\n   *\n   * @example\n   * ```typescript\n   * // Remove section\n   * api.removeCanvas('hero-section-2');\n   *\n   * // Host app syncs metadata\n   * api.on('canvasRemoved', (event) => {\n   *   delete canvasMetadata[event.canvasId];\n   *   removeCanvasHeader(event.canvasId);\n   * });\n   * ```\n   */\n  removeCanvas(canvasId: string): void;\n\n  /**\n   * Set active canvas programmatically\n   *\n   * **Use cases**:\n   * - Focus specific section for editing\n   * - Programmatic navigation between sections\n   * - Highlight canvas after adding items\n   * - Show canvas-specific settings panel\n   *\n   * **Library responsibility**:\n   * - Update gridState.activeCanvasId\n   * - Pass isActive prop to canvas-section components\n   * - Apply 'active' CSS class to active canvas\n   * - Emit 'canvasActivated' event\n   *\n   * **Host app responsibility**:\n   * - Listen to 'canvasActivated' event (optional)\n   * - Update canvas-specific UI (settings panel, etc.)\n   * - Apply custom styling via CSS (title opacity, etc.)\n   *\n   * **Automatic activation**: Canvas automatically activates when user:\n   * - Clicks item on canvas\n   * - Clicks canvas background\n   * - Starts dragging item\n   * - Starts resizing item\n   *\n   * **Events triggered**: 'canvasActivated'\n   *\n   * @param canvasId - Canvas to activate\n   *\n   * @example\n   * ```typescript\n   * // Activate canvas after adding item\n   * const itemId = api.addComponent('canvas2', 'header', { x: 1, y: 1, width: 20, height: 6 });\n   * api.setActiveCanvas('canvas2');\n   *\n   * // Listen to activation events\n   * api.on('canvasActivated', ({ canvasId }) => {\n   *   showCanvasSettings(canvasId);\n   * });\n   * ```\n   */\n  setActiveCanvas(canvasId: string): void;\n\n  /**\n   * Get currently active canvas ID\n   *\n   * **Use cases**:\n   * - Check which canvas is currently active\n   * - Conditional UI rendering based on active canvas\n   * - State synchronization\n   *\n   * **Returns**:\n   * - Canvas ID string if a canvas is active\n   * - `null` if no canvas is active\n   *\n   * @returns Canvas ID or null if none active\n   *\n   * @example\n   * ```typescript\n   * const activeId = api.getActiveCanvas();\n   * if (activeId === 'canvas1') {\n   *   // Show canvas1-specific settings\n   * }\n   * ```\n   */\n  getActiveCanvas(): string | null;\n}\n"]}