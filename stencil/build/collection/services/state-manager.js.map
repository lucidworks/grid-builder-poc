{"version":3,"file":"state-manager.js","sourceRoot":"","sources":["../../src/services/state-manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * State Manager\n * ==============\n *\n * Centralized reactive state management for the grid builder using StencilJS Store.\n * Manages grid items, canvases, layouts, selection state, and viewport configuration\n * with automatic component re-renders on state changes.\n *\n * ## Problem\n *\n * Complex interactive applications need:\n * - Centralized state accessible across all components\n * - Automatic UI updates when state changes\n * - Type-safe state mutations\n * - Undo/redo support (requires state snapshots)\n * - Desktop + mobile layout management\n * - Selection tracking across multiple canvases\n *\n * Without centralized state:\n * - Props drilling through component hierarchies\n * - Manual event subscriptions and cleanup\n * - Synchronization issues between components\n * - Difficult undo/redo implementation\n *\n * ## Solution\n *\n * Use @stencil/store for reactive state management with:\n * 1. **Single source of truth**: All state in one store\n * 2. **Automatic reactivity**: Components re-render on state changes\n * 3. **Type safety**: Full TypeScript support\n * 4. **Simple API**: Direct property access (no actions/reducers)\n * 5. **Lightweight**: ~1KB, built into StencilJS\n *\n * ## Architecture Decisions\n *\n * ### Why @stencil/store vs Redux/Zustand?\n *\n * **@stencil/store chosen because**:\n * - ✅ Native StencilJS integration (zero setup)\n * - ✅ Automatic component subscriptions (no manual connect/subscribe)\n * - ✅ Simple mutation API (direct property assignment)\n * - ✅ Tiny bundle size (~1KB)\n * - ✅ Full TypeScript support\n * - ✅ Perfect for component-scoped state\n *\n * **Redux would add**:\n * - ❌ Boilerplate (actions, reducers, dispatch)\n * - ❌ Bundle size (~15KB min)\n * - ❌ Learning curve (middleware, selectors)\n * - ❌ Manual component subscriptions\n *\n * **Zustand would work but**:\n * - ⚠️ External dependency (not StencilJS native)\n * - ⚠️ Manual subscriptions in StencilJS\n * - ⚠️ Less TypeScript integration\n *\n * ### Dual Layout System (Desktop + Mobile)\n *\n * Each grid item has TWO layout configurations:\n *\n * **Desktop Layout** (always present):\n * - Primary layout with full positioning data\n * - x, y, width, height in grid units\n * - Never null, always has values\n *\n * **Mobile Layout** (optional/auto-generated):\n * - x, y, width, height can be null\n * - `customized: false` → auto-generated from desktop layout\n * - `customized: true` → user manually positioned in mobile view\n *\n * **Why dual layouts**:\n * - Different screen sizes need different layouts\n * - Mobile can auto-adapt OR be manually customized\n * - Single item definition works across viewports\n *\n * **Auto-generation strategy**:\n * ```typescript\n * // When mobile layout is null (not customized):\n * // - Full width items (span entire mobile viewport)\n * // - Stacked vertically\n * // - Responsive heights\n *\n * // When mobile.customized = true:\n * // - Use explicit mobile.x, mobile.y, mobile.width, mobile.height\n * // - Ignore desktop layout\n * ```\n *\n * ### State Mutation Pattern\n *\n * **Immutable spread pattern** for reactivity:\n * ```typescript\n * // ❌ Wrong: Direct mutation doesn't trigger updates\n * canvas.items.push(newItem);\n *\n * // ✅ Correct: Spread triggers reactivity\n * canvas.items.push(newItem);\n * state.canvases = { ...state.canvases };\n * ```\n *\n * **Why this pattern**:\n * - StencilJS store detects reference changes\n * - Object spread creates new reference\n * - Components automatically re-render\n * - Simple and performant\n *\n * ### Z-Index Management\n *\n * **Per-canvas z-index tracking**:\n * - Each canvas has `zIndexCounter` (monotonically increasing)\n * - New items get `zIndexCounter++`\n * - Ensures unique z-index per canvas\n * - Higher z-index = rendered on top\n *\n * **Why per-canvas**:\n * - Items in different canvases don't overlap\n * - Simplifies z-index calculations\n * - Prevents z-index conflicts\n * - Independent stacking contexts\n *\n * **Bringing to front**:\n * ```typescript\n * item.zIndex = canvas.zIndexCounter++;\n * state.canvases = { ...state.canvases }; // Trigger update\n * ```\n *\n * ## State Structure\n *\n * ```typescript\n * {\n *   canvases: {\n *     'canvas1': {\n *       items: [GridItem, GridItem, ...],\n *       zIndexCounter: 5,\n *       backgroundColor: '#ffffff'\n *     },\n *     'canvas2': { ... },\n *     ...\n *   },\n *   selectedItemId: 'item-3' | null,\n *   selectedCanvasId: 'canvas1' | null,\n *   currentViewport: 'desktop' | 'mobile',\n *   showGrid: true | false\n * }\n * ```\n *\n * ## Performance Characteristics\n *\n * **State access**: O(1) - direct property access\n * **State updates**: O(n) - spread operation copies references\n * **Component re-renders**: Only components consuming changed state\n * **Memory**: Lightweight (~1KB store + actual state data)\n *\n * **Optimization**: Immutable updates only copy top-level references,\n * not deep clones. Child objects remain same reference if unchanged.\n *\n * ## Integration with Undo/Redo\n *\n * State structure supports undo/redo via snapshots:\n * ```typescript\n * // Save snapshot\n * const snapshot = JSON.parse(JSON.stringify(state.canvases));\n *\n * // Restore snapshot\n * state.canvases = JSON.parse(JSON.stringify(snapshot));\n * ```\n *\n * Deep cloning required because:\n * - Prevents mutations from affecting history\n * - Ensures independent state snapshots\n * - Simple and reliable (no ref tracking)\n *\n * ## Extracting This Pattern\n *\n * To adapt for other frameworks:\n *\n * **React + Zustand**:\n * ```typescript\n * import create from 'zustand';\n *\n * const useStore = create<GridState>((set) => ({\n *   ...initialState,\n *   addItem: (canvasId, item) => set((state) => ({\n *     canvases: {\n *       ...state.canvases,\n *       [canvasId]: {\n *         ...state.canvases[canvasId],\n *         items: [...state.canvases[canvasId].items, item]\n *       }\n *     }\n *   }))\n * }));\n * ```\n *\n * **Vue + Pinia**:\n * ```typescript\n * import { defineStore } from 'pinia';\n *\n * export const useGridStore = defineStore('grid', {\n *   state: () => initialState,\n *   actions: {\n *     addItem(canvasId, item) {\n *       this.canvases[canvasId].items.push(item);\n *     }\n *   }\n * });\n * ```\n *\n * **Angular + NgRx**:\n * ```typescript\n * export const addItem = createAction(\n *   '[Grid] Add Item',\n *   props<{ canvasId: string; item: GridItem }>()\n * );\n *\n * export const gridReducer = createReducer(\n *   initialState,\n *   on(addItem, (state, { canvasId, item }) => ({\n *     ...state,\n *     canvases: {\n *       ...state.canvases,\n *       [canvasId]: {\n *         ...state.canvases[canvasId],\n *         items: [...state.canvases[canvasId].items, item]\n *       }\n *     }\n *   }))\n * );\n * ```\n *\n * @module state-manager\n */\n\nimport { createStore } from '@stencil/store';\n\n/**\n * Grid Item Interface\n * ====================\n *\n * Core data structure representing a single component instance in the grid.\n * Each item has dual layouts (desktop + mobile) and positioning metadata.\n *\n * **Lifecycle**:\n * 1. Created when dropped from palette or added programmatically\n * 2. Updated during drag/resize operations\n * 3. Persisted in state for undo/redo\n * 4. Removed when deleted\n *\n * **Key Properties**:\n * - `id`: Unique identifier (generated via generateItemId)\n * - `canvasId`: Which canvas owns this item\n * - `type`: Component type ('header', 'text', 'button', etc.)\n * - `name`: Display name (shown in UI)\n * - `layouts`: Desktop and mobile positioning\n * - `zIndex`: Stacking order within canvas\n *\n * **Type System Integration**:\n * The `type` field determines which component renders via dynamic imports:\n * ```typescript\n * switch (item.type) {\n *   case 'header': return <component-header />;\n *   case 'text': return <component-text-block />;\n *   case 'button': return <component-button />;\n *   // ...\n * }\n * ```\n */\nexport interface GridItem {\n  /** Unique item identifier (e.g., 'item-1', 'item-2') */\n  id: string;\n\n  /** Canvas ID this item belongs to (e.g., 'canvas1', 'canvas2') */\n  canvasId: string;\n\n  /** Component type determining which component renders ('header', 'text', 'button', etc.) */\n  type: string;\n\n  /** Display name shown in UI */\n  name: string;\n\n  /**\n   * Dual layout system for responsive design\n   *\n   * **Desktop Layout** (required, never null):\n   * - Primary layout used in desktop viewport\n   * - All properties (x, y, width, height) always have numeric values\n   * - Coordinates in grid units (not pixels)\n   *\n   * **Mobile Layout** (optional/auto-generated):\n   * - Properties can be null when not customized\n   * - `customized: false` → Auto-generated layout (full-width, stacked)\n   * - `customized: true` → User manually positioned in mobile view\n   *\n   * **Auto-generation behavior** (when mobile.customized = false):\n   * ```typescript\n   * // grid-item-wrapper.tsx calculates:\n   * x: 0 (left edge)\n   * y: calculatedFromStackOrder\n   * width: 50 (full width = 100% of viewport)\n   * height: desktop.height (maintain aspect ratio)\n   * ```\n   *\n   * **Example usage**:\n   * ```typescript\n   * const item: GridItem = {\n   *   id: 'item-1',\n   *   canvasId: 'canvas1',\n   *   type: 'header',\n   *   name: 'Hero Header',\n   *   layouts: {\n   *     desktop: { x: 5, y: 2, width: 20, height: 8 },\n   *     mobile: {\n   *       x: null, y: null, width: null, height: null,\n   *       customized: false // Will auto-generate\n   *     }\n   *   },\n   *   zIndex: 1\n   * };\n   * ```\n   */\n  layouts: {\n    /** Desktop layout (always fully defined) */\n    desktop: {\n      /** Horizontal position in grid units (0 = left edge) */\n      x: number;\n\n      /** Vertical position in grid units (0 = top edge) */\n      y: number;\n\n      /** Width in grid units (e.g., 20 units at 2% = 40% of container) */\n      width: number;\n\n      /** Height in grid units (e.g., 8 units × 20px = 160px) */\n      height: number;\n    };\n\n    /** Mobile layout (optional/auto-generated) */\n    mobile: {\n      /** Horizontal position or null for auto-generation */\n      x: number | null;\n\n      /** Vertical position or null for auto-generation */\n      y: number | null;\n\n      /** Width or null for auto-generation (typically full-width) */\n      width: number | null;\n\n      /** Height or null for auto-generation */\n      height: number | null;\n\n      /**\n       * Whether user manually customized mobile layout\n       *\n       * **false**: Auto-generate from desktop layout\n       * - Full width (50 grid units)\n       * - Stacked vertically\n       * - Maintains desktop height\n       *\n       * **true**: Use explicit mobile x/y/width/height\n       * - User dragged/resized in mobile view\n       * - Ignore desktop layout\n       * - Persist custom positioning\n       */\n      customized: boolean;\n    };\n  };\n\n  /**\n   * Stacking order within canvas (higher = on top)\n   *\n   * **Assignment**: New items get `canvas.zIndexCounter++`\n   * **Bringing to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Per-canvas**: Z-indexes only compete within same canvas\n   */\n  zIndex: number;\n\n  /**\n   * Component configuration data\n   *\n   * **Purpose**: Store component-specific settings (text, color, etc.)\n   * **Structure**: Record<string, any> matching ComponentDefinition.configSchema\n   * **Default**: Empty object {} when component created\n   *\n   * **Example**:\n   * ```typescript\n   * // Header component config\n   * config: {\n   *   text: 'Welcome!',\n   *   level: 'H1',\n   *   color: '#000000',\n   *   alignment: 'center'\n   * }\n   * ```\n   */\n  config?: Record<string, any>;\n}\n\n/**\n * Canvas Interface\n * =================\n *\n * Represents a single canvas container (section) in the grid builder.\n * Each canvas is an independent dropzone with its own items and z-index tracking.\n *\n * **Typical usage**: Multi-section landing pages\n * - canvas1 = Hero section\n * - canvas2 = Content section\n * - canvas3 = Footer section\n *\n * **Why multiple canvases**:\n * - Logical content sections\n * - Independent z-index contexts\n * - Different background colors per section\n * - Easier content organization\n *\n * **Example**:\n * ```typescript\n * const heroCanvas: Canvas = {\n *   items: [headerItem, textItem, buttonItem, imageItem],\n *   zIndexCounter: 5, // Next item gets zIndex: 5\n *   backgroundColor: '#ffffff'\n * };\n * ```\n */\n/**\n * Canvas Interface\n * ==================\n *\n * Minimal canvas structure focused purely on item placement management.\n *\n * **Library responsibilities** (what IS in this interface):\n * - Item placement and layouts\n * - Z-index management for stacking\n *\n * **Host app responsibilities** (what is NOT in this interface):\n * - Canvas styling (backgroundColor, themes, etc.)\n * - Canvas metadata (title, description, etc.)\n * - Presentation concerns (how canvases look)\n *\n * **Why this separation**:\n * - Different apps have different styling needs\n * - Library focuses on layout, not presentation\n * - Host app owns the complete data model\n * - Enables library to be used in any context\n *\n * **Host app pattern**:\n * ```typescript\n * // Host app maintains its own canvas metadata\n * const canvasMetadata = {\n *   'canvas1': { title: 'Hero Section', backgroundColor: '#f0f4f8', ... },\n *   'canvas2': { title: 'Footer', backgroundColor: '#e8f0f2', ... }\n * };\n *\n * // Library only knows about item placement\n * const gridState = {\n *   canvases: {\n *     'canvas1': { items: [...], zIndexCounter: 5 },\n *     'canvas2': { items: [...], zIndexCounter: 3 }\n *   }\n * };\n * ```\n */\nexport interface Canvas {\n  /**\n   * Array of grid items in this canvas\n   *\n   * **Rendering**: Items render in DOM order, styled with z-index for stacking\n   * **Mutation**: Always use spread pattern to trigger reactivity\n   */\n  items: GridItem[];\n\n  /**\n   * Monotonically increasing counter for z-index assignment\n   *\n   * **New items**: `item.zIndex = canvas.zIndexCounter++`\n   * **Bring to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Never decreases**: Only increments to prevent conflicts\n   */\n  zIndexCounter: number;\n}\n\n/**\n * Grid State Interface\n * =====================\n *\n * Root state structure for entire grid builder application.\n * Manages all canvases, selection state, and viewport configuration.\n *\n * **Single source of truth**: All app state in this one object\n * **Reactivity**: Changes trigger automatic component re-renders\n * **Persistence**: Can be serialized to JSON for save/export\n *\n * **Access pattern**:\n * ```typescript\n * import { gridState } from './state-manager';\n *\n * // Read state\n * const items = gridState.canvases['canvas1'].items;\n *\n * // Mutate state (triggers reactivity)\n * gridState.selectedItemId = 'item-5';\n * gridState.canvases = { ...gridState.canvases }; // After mutations\n * ```\n */\nexport interface GridState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': Canvas, 'canvas2': Canvas, ... }`\n   * **Access**: `gridState.canvases['canvas1']`\n   * **Dynamic canvases**: Can add/remove canvases at runtime\n   */\n  canvases: Record<string, Canvas>;\n\n  /**\n   * Currently selected item ID or null if no selection\n   *\n   * **Selection flow**:\n   * 1. User clicks item → `selectItem(itemId, canvasId)`\n   * 2. State updates → `selectedItemId = 'item-3'`\n   * 3. Components re-render with visual selection indicators\n   *\n   * **Deselection**: Click canvas background → `deselectItem()` → `null`\n   */\n  selectedItemId: string | null;\n\n  /**\n   * Canvas ID containing currently selected item\n   *\n   * **Why needed**: Item IDs are unique across canvases, but need canvas\n   * for operations like delete, move, etc.\n   *\n   * **Always paired**: When `selectedItemId` is set, `selectedCanvasId` must be set\n   */\n  selectedCanvasId: string | null;\n\n  /**\n   * Currently active/focused canvas ID or null if none active\n   *\n   * **Selection flow**:\n   * 1. User interacts with canvas (click, drag, resize) → `setActiveCanvas(canvasId)`\n   * 2. State updates → `activeCanvasId = 'canvas1'`\n   * 3. Canvas section component receives isActive prop\n   * 4. Visual feedback applied (title opacity, border, etc.)\n   *\n   * **Activation triggers**:\n   * - Clicking item on canvas\n   * - Clicking canvas background\n   * - Starting drag operation on item\n   * - Starting resize operation on item\n   *\n   * **Use cases**:\n   * - Highlight which section user is working on\n   * - Show canvas-specific settings panel\n   * - Provide visual context in multi-section layouts\n   *\n   * **Difference from selectedCanvasId**:\n   * - `selectedCanvasId`: Canvas containing selected **item** (editing focus)\n   * - `activeCanvasId`: Canvas that is **active** for interaction (section focus)\n   */\n  activeCanvasId: string | null;\n\n  /**\n   * Current viewport mode (desktop or mobile)\n   *\n   * **Affects**:\n   * - Which layout is rendered (item.layouts.desktop vs item.layouts.mobile)\n   * - Grid calculations (responsive vs fixed)\n   * - Canvas width (full vs mobile viewport)\n   *\n   * **Toggle**: User clicks viewport switcher button\n   */\n  currentViewport: 'desktop' | 'mobile';\n\n  /**\n   * Whether to show grid lines on canvases\n   *\n   * **Visual aid**: Helps users align items to grid\n   * **Toggle**: User clicks grid visibility button\n   * **Rendering**: CSS background-image with grid pattern\n   */\n  showGrid: boolean;\n}\n\n/**\n * Viewer-Only State Interfaces\n * ==============================\n *\n * Minimal state types for grid-viewer component (rendering-only mode).\n * These are subsets of the full editing state, excluding editing-specific properties.\n *\n * ## Separation of Concerns\n *\n * **Builder App** (grid-builder):\n * - Full GridState with selection, z-index tracking, etc.\n * - Includes interact.js for drag-and-drop (~45KB)\n * - Bundle size: ~150KB\n *\n * **Viewer App** (grid-viewer):\n * - Minimal ViewerState without editing features\n * - No interact.js dependency\n * - Bundle size: ~30KB (80% reduction)\n *\n * ## Export/Import Workflow\n *\n * ```typescript\n * // Builder App → Export layout\n * const builder = document.querySelector('grid-builder');\n * const exportData = await builder.exportState();\n * await fetch('/api/layouts', {\n *   method: 'POST',\n *   body: JSON.stringify(exportData)\n * });\n *\n * // Viewer App → Import layout\n * const layout = await fetch('/api/layouts/123').then(r => r.json());\n * const viewer = document.querySelector('grid-viewer');\n * viewer.initialState = layout;\n * ```\n *\n * ## What's Excluded from Viewer\n *\n * **Canvas.zIndexCounter** - Editing-only state:\n * - Tracks next z-index for new items\n * - Not needed in viewer (items already have zIndex)\n * - Viewer reads item.zIndex directly\n *\n * **GridState.selectedItemId/selectedCanvasId** - Editing-only state:\n * - Tracks which item is selected for editing\n * - Not needed in viewer (no selection UI)\n * - Viewer only renders, never selects\n *\n * **GridState.showGrid** - Editing-only state:\n * - Visual aid for aligning items during editing\n * - Not needed in viewer (no editing)\n * - Viewer renders clean output without grid lines\n *\n * ## Type Compatibility\n *\n * ViewerState is intentionally compatible with GridExport format:\n * ```typescript\n * // GridExport can be used as ViewerState\n * const exportData: GridExport = await builder.exportState();\n * viewer.initialState = exportData; // Type-safe!\n * ```\n */\n\n/**\n * Viewer Canvas Interface\n * ========================\n *\n * Minimal canvas structure for viewer mode (rendering-only).\n * Excludes editing-specific properties like zIndexCounter.\n *\n * **Differences from Canvas**:\n * - ✅ items: Array of ViewerItem (same as GridItem)\n * - ❌ zIndexCounter: Not needed (items already have zIndex)\n *\n * **Use in viewer**:\n * ```typescript\n * const canvas: ViewerCanvas = {\n *   items: [\n *     { id: 'item-1', type: 'header', zIndex: 1, ... },\n *     { id: 'item-2', type: 'text', zIndex: 2, ... }\n *   ]\n * };\n *\n * // Render items in z-index order\n * const sortedItems = canvas.items.sort((a, b) => a.zIndex - b.zIndex);\n * ```\n */\nexport interface ViewerCanvas {\n  /** Grid items in this canvas (rendering-only, no editing state) */\n  items: GridItem[]; // Reuse GridItem - it's already clean and serializable\n}\n\n/**\n * Viewer State Interface\n * =======================\n *\n * Minimal state structure for grid-viewer component (rendering-only mode).\n * Subset of GridState excluding all editing-specific properties.\n *\n * **Differences from GridState**:\n * - ✅ canvases: Record<string, ViewerCanvas>\n * - ✅ currentViewport: 'desktop' | 'mobile'\n * - ❌ selectedItemId: Not needed (no selection in viewer)\n * - ❌ selectedCanvasId: Not needed (no selection in viewer)\n * - ❌ showGrid: Not needed (no grid lines in viewer)\n *\n * **Why minimal state**:\n * - Smaller bundle size (no editing logic)\n * - Simpler component tree (no interact.js)\n * - Faster initialization (no drag/drop setup)\n * - Clean separation of concerns\n *\n * **Use in viewer**:\n * ```typescript\n * // Initialize viewer from exported layout\n * const viewerState: ViewerState = {\n *   canvases: {\n *     'hero-section': {\n *       items: [\n *         {\n *           id: 'header-1',\n *           canvasId: 'hero-section',\n *           type: 'header',\n *           name: 'Hero Header',\n *           layouts: {\n *             desktop: { x: 0, y: 0, width: 50, height: 6 },\n *             mobile: { x: null, y: null, width: null, height: null, customized: false }\n *           },\n *           zIndex: 1,\n *           config: { title: 'Welcome!' }\n *         }\n *       ]\n *     }\n *   },\n *   currentViewport: 'desktop'\n * };\n * ```\n *\n * **Type-safe import from GridExport**:\n * ```typescript\n * import { GridExport } from '../types/grid-export';\n *\n * function convertExportToViewerState(exportData: GridExport): ViewerState {\n *   return {\n *     canvases: exportData.canvases,\n *     currentViewport: exportData.viewport\n *   };\n * }\n * ```\n */\nexport interface ViewerState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': ViewerCanvas, 'canvas2': ViewerCanvas, ... }`\n   * **Rendering**: Each canvas section renders its items in z-index order\n   * **Responsive**: Switches between desktop/mobile layouts based on currentViewport\n   */\n  canvases: Record<string, ViewerCanvas>;\n\n  /**\n   * Current viewport mode (desktop or mobile)\n   *\n   * **Affects**:\n   * - Which layout is rendered (item.layouts.desktop vs item.layouts.mobile)\n   * - Responsive layout calculations\n   * - Canvas width and item positioning\n   *\n   * **Auto-switching**: Can use ResizeObserver for container-based switching\n   * **Manual override**: Can be set via props or API\n   */\n  currentViewport: 'desktop' | 'mobile';\n}\n\n/**\n * Initial State (empty canvases for library)\n *\n * Library starts with empty canvases by default.\n * Consumers can add their own initial items programmatically.\n */\nconst initialState: GridState = {\n  canvases: {\n    canvas1: {\n      items: [],\n      zIndexCounter: 1,\n    },\n    canvas2: {\n      items: [],\n      zIndexCounter: 1,\n    },\n    canvas3: {\n      items: [],\n      zIndexCounter: 1,\n    },\n  },\n  selectedItemId: null,\n  selectedCanvasId: null,\n  activeCanvasId: null,\n  currentViewport: 'desktop',\n  showGrid: true,\n};\n\n/**\n * Global Grid State Store\n * ========================\n *\n * StencilJS store instance providing reactive state management.\n *\n * **Exports**:\n * - `state`: Reactive state proxy (mutate to trigger updates)\n * - `onChange`: Subscribe to state changes\n * - `dispose`: Cleanup subscriptions (typically not needed)\n *\n * **Usage in components**:\n * ```typescript\n * import { gridState } from './state-manager';\n *\n * // Component automatically re-renders when state changes\n * render() {\n *   const items = gridState.canvases['canvas1'].items;\n *   return items.map(item => <div>{item.name}</div>);\n * }\n * ```\n */\nconst { state, onChange, dispose } = createStore<GridState>(initialState);\n\n/**\n * Reset state to initial empty configuration\n *\n * **When to call**:\n * - User clicks \"Reset\" button\n * - Starting fresh\n * - Test cleanup (afterEach hooks)\n *\n * **What it resets**:\n * - Clears all items from all canvases\n * - Resets z-index counters\n * - Clears selection state\n * - Resets viewport to desktop\n * - Shows grid\n * - Resets item ID counter to 0\n *\n * **Deep clone pattern**:\n * Uses `JSON.parse(JSON.stringify())` to create independent copy\n * of initial state. Prevents mutations from affecting initialState.\n *\n * @example\n * ```typescript\n * // Reset button handler\n * handleReset() {\n *   if (confirm('Reset to initial state?')) {\n *     reset();\n *     console.log('State reset to empty');\n *   }\n * }\n * ```\n */\nexport function reset() {\n  itemIdCounter = 0; // Reset to 0 (library starts empty)\n\n  // Restore initial state (empty canvases)\n  state.canvases = JSON.parse(JSON.stringify(initialState.canvases));\n  state.selectedItemId = null;\n  state.selectedCanvasId = null;\n  state.activeCanvasId = null;\n  state.currentViewport = 'desktop';\n  state.showGrid = true;\n}\n\nexport { state as gridState, onChange, dispose };\n\n/**\n * Helper Functions\n * ================\n *\n * CRUD operations for managing grid items and canvases.\n * All mutations use spread pattern to trigger reactivity.\n */\n\n/**\n * Add item to canvas\n *\n * **Use cases**:\n * - Dropping component from palette\n * - Undo delete operation\n * - Duplicating existing item\n * - Programmatic item creation\n *\n * **Reactivity pattern**:\n * 1. Push item to canvas.items array\n * 2. Spread canvases object to trigger update\n * 3. Components automatically re-render\n *\n * **Z-index assignment**:\n * Item should have `zIndex: canvas.zIndexCounter++` before calling.\n * This function doesn't assign z-index automatically.\n *\n * **Safety**: No-op if canvas doesn't exist\n *\n * @param canvasId - Target canvas ID\n * @param item - GridItem to add (should have zIndex assigned)\n *\n * @example\n * ```typescript\n * // Add new item from palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(),\n *   canvasId: 'canvas1',\n *   type: 'header',\n *   name: 'Header',\n *   layouts: {\n *     desktop: { x: 5, y: 5, width: 20, height: 8 },\n *     mobile: { x: null, y: null, width: null, height: null, customized: false }\n *   },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n * addItemToCanvas('canvas1', newItem);\n * ```\n */\nexport function addItemToCanvas(canvasId: string, item: GridItem) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items.push(item);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Remove item from canvas\n *\n * **Use cases**:\n * - User deletes item (Delete key or button)\n * - Undo add operation\n * - Clearing canvas\n *\n * **Filter pattern**:\n * Creates new array without the item, preserving array order.\n * Reassignment triggers reactivity.\n *\n * **Index preservation**:\n * Array order maintained for z-index rendering.\n * Other items' indexes shift down by 1.\n *\n * **Safety**: No-op if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to remove\n *\n * @example\n * ```typescript\n * // Delete selected item\n * if (gridState.selectedItemId && gridState.selectedCanvasId) {\n *   removeItemFromCanvas(\n *     gridState.selectedCanvasId,\n *     gridState.selectedItemId\n *   );\n *   deselectItem(); // Clear selection\n * }\n * ```\n */\nexport function removeItemFromCanvas(canvasId: string, itemId: string) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((item) => item.id !== itemId);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Update item properties in canvas\n *\n * **Use cases**:\n * - After drag operation (update position)\n * - After resize operation (update dimensions)\n * - Changing item name or type\n * - Bringing item to front (update zIndex)\n *\n * **Partial updates**:\n * Uses `Partial<GridItem>` to allow updating subset of properties.\n * Object.assign merges updates into existing item.\n *\n * **Typical update patterns**:\n * ```typescript\n * // Update position after drag\n * updateItem(canvasId, itemId, {\n *   layouts: { ...item.layouts, desktop: { x: 10, y: 5, width: 20, height: 8 } }\n * });\n *\n * // Bring to front\n * updateItem(canvasId, itemId, {\n *   zIndex: gridState.canvases[canvasId].zIndexCounter++\n * });\n * ```\n *\n * **Safety**: No-op if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to update\n * @param updates - Partial GridItem with properties to update\n *\n * @example\n * ```typescript\n * // After drag end\n * const item = getItem('canvas1', 'item-3');\n * if (item) {\n *   item.layouts.desktop.x = newX;\n *   item.layouts.desktop.y = newY;\n *   updateItem('canvas1', 'item-3', item);\n * }\n * ```\n */\nexport function updateItem(canvasId: string, itemId: string, updates: Partial<GridItem>) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  const item = canvas.items.find((i) => i.id === itemId);\n  if (!item) {\n    return;\n  }\n\n  Object.assign(item, updates);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Get item by ID\n *\n * **Use cases**:\n * - Reading item data before update\n * - Validation checks\n * - Getting item for undo/redo snapshots\n * - Checking if item exists\n *\n * **Read-only**: Returns reference to item in state.\n * To modify, use `updateItem()` to trigger reactivity.\n *\n * **Safety**: Returns null if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to retrieve\n * @returns GridItem or null if not found\n *\n * @example\n * ```typescript\n * // Check item before operation\n * const item = getItem('canvas1', 'item-3');\n * if (item) {\n *   console.log(`Item at (${item.layouts.desktop.x}, ${item.layouts.desktop.y})`);\n * }\n *\n * // Create snapshot for undo\n * const snapshot = JSON.parse(JSON.stringify(getItem(canvasId, itemId)));\n * ```\n */\nexport function getItem(canvasId: string, itemId: string): GridItem | null {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return null;\n  }\n\n  return canvas.items.find((i) => i.id === itemId) || null;\n}\n\n/**\n * Move item to different canvas\n *\n * **Use cases**:\n * - Dragging item across canvas boundaries\n * - Reorganizing multi-section layouts\n * - Undo move operation\n *\n * **Operation flow**:\n * 1. Find item in source canvas\n * 2. Remove from source canvas items array\n * 3. Update item's canvasId property\n * 4. Add to destination canvas items array\n * 5. Trigger reactivity with spread\n *\n * **Important**: Item keeps its existing zIndex.\n * May want to update with destination canvas's zIndexCounter.\n *\n * **Position handling**:\n * Item keeps its grid coordinates. Caller should validate/adjust\n * position fits within destination canvas bounds.\n *\n * **Safety**: No-op if either canvas doesn't exist or item not found\n *\n * @param fromCanvasId - Source canvas ID\n * @param toCanvasId - Destination canvas ID\n * @param itemId - Item to move\n *\n * @example\n * ```typescript\n * // Move item on cross-canvas drag\n * handleDragEnd(event) {\n *   const targetCanvasId = event.dropTarget.id;\n *   if (targetCanvasId !== item.canvasId) {\n *     moveItemToCanvas(item.canvasId, targetCanvasId, item.id);\n *\n *     // Optionally update z-index for new canvas\n *     const canvas = gridState.canvases[targetCanvasId];\n *     updateItem(targetCanvasId, item.id, {\n *       zIndex: canvas.zIndexCounter++\n *     });\n *   }\n * }\n * ```\n */\nexport function moveItemToCanvas(fromCanvasId: string, toCanvasId: string, itemId: string) {\n  const fromCanvas = state.canvases[fromCanvasId];\n  const toCanvas = state.canvases[toCanvasId];\n\n  if (!fromCanvas || !toCanvas) {\n    return;\n  }\n\n  const item = fromCanvas.items.find((i) => i.id === itemId);\n  if (!item) {\n    return;\n  }\n\n  // Remove from old canvas\n  fromCanvas.items = fromCanvas.items.filter((i) => i.id !== itemId);\n\n  // Update item's canvasId\n  item.canvasId = toCanvasId;\n\n  // Add to new canvas\n  toCanvas.items.push(item);\n\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * ID counter for generating unique item IDs\n *\n * **Starts at 0**: Library starts with empty canvases\n * **Increments**: Each call to generateItemId() returns next ID\n * **Format**: 'item-N' where N is the counter value\n */\nexport let itemIdCounter = 0; // Start at 0 (library starts empty)\n\n/**\n * Generate unique item ID\n *\n * **Use cases**:\n * - Creating new item from palette drop\n * - Duplicating existing item\n * - Any programmatic item creation\n *\n * **Uniqueness guarantee**:\n * Monotonically increasing counter ensures no collisions.\n * Even after delete, IDs never reused.\n *\n * **Format**: Returns 'item-N' (e.g., 'item-11', 'item-12')\n *\n * **Thread safety**: Not thread-safe, but not an issue in\n * single-threaded JavaScript environment.\n *\n * @returns Unique item ID string\n *\n * @example\n * ```typescript\n * // Create new item from palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(), // 'item-11'\n *   canvasId: 'canvas1',\n *   type: 'button',\n *   name: 'Button',\n *   layouts: { ... },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n * ```\n */\nexport function generateItemId(): string {\n  return `item-${++itemIdCounter}`;\n}\n\n/**\n * Select item and set active canvas\n *\n * **Use cases**:\n * - User clicks item\n * - After creating new item (auto-select)\n * - Keyboard navigation\n *\n * **Visual effects**:\n * - Selected item gets visual highlight (via CSS)\n * - Resize/drag handles appear\n * - Item can be deleted with Delete key\n *\n * **State changes**:\n * - `selectedItemId` = itemId\n * - `selectedCanvasId` = canvasId\n * - Components re-render with selection styles\n *\n * **Single selection**: Selecting new item automatically deselects previous\n *\n * @param itemId - Item to select\n * @param canvasId - Canvas containing the item\n *\n * @example\n * ```typescript\n * // Handle item click\n * handleItemClick(item: GridItem) {\n *   selectItem(item.id, item.canvasId);\n * }\n *\n * // Auto-select after creating item\n * const newItem = createNewItem();\n * addItemToCanvas('canvas1', newItem);\n * selectItem(newItem.id, 'canvas1');\n * ```\n */\nexport function selectItem(itemId: string, canvasId: string) {\n  state.selectedItemId = itemId;\n  state.selectedCanvasId = canvasId;\n}\n\n/**\n * Deselect currently selected item\n *\n * **Use cases**:\n * - User clicks canvas background\n * - After deleting selected item\n * - Escape key pressed\n * - Starting drag operation\n *\n * **Visual effects**:\n * - Selection highlight removed\n * - Resize/drag handles hidden\n * - Item no longer delete-able with Delete key\n *\n * **State changes**:\n * - `selectedItemId` = null\n * - `selectedCanvasId` = null\n * - Components re-render without selection styles\n *\n * **Safety**: Safe to call even if nothing selected\n *\n * @example\n * ```typescript\n * // Handle canvas click (deselect)\n * handleCanvasClick(event) {\n *   if (event.target === canvasElement) {\n *     deselectItem();\n *   }\n * }\n *\n * // After deleting item\n * removeItemFromCanvas(canvasId, itemId);\n * deselectItem();\n * ```\n */\nexport function deselectItem() {\n  state.selectedItemId = null;\n  state.selectedCanvasId = null;\n}\n\n/**\n * Set active canvas\n *\n * **Use cases**:\n * - User clicks item on canvas → activate that canvas\n * - User clicks canvas background → activate that canvas\n * - User starts dragging item → activate canvas containing item\n * - User starts resizing item → activate canvas containing item\n * - Programmatic canvas focus (e.g., after adding item)\n *\n * **Visual effects**:\n * - Canvas title opacity changes (consumer-controlled CSS)\n * - Canvas border/highlight applied\n * - Canvas-specific settings panel shown\n *\n * **State changes**:\n * - `activeCanvasId` = canvasId\n * - Components re-render with isActive prop\n * - 'canvasActivated' event emitted\n *\n * **Reactivity**: Direct assignment (no spread needed for primitive)\n *\n * @param canvasId - Canvas ID to activate\n *\n * @example\n * ```typescript\n * // Handle item click (activate canvas)\n * handleItemClick(itemId, canvasId) {\n *   setActiveCanvas(canvasId);\n *   selectItem(itemId, canvasId);\n * }\n *\n * // Handle canvas background click\n * handleCanvasClick(canvasId) {\n *   setActiveCanvas(canvasId);\n *   deselectItem();\n * }\n * ```\n */\nexport function setActiveCanvas(canvasId: string) {\n  state.activeCanvasId = canvasId;\n}\n\n/**\n * Clear active canvas\n *\n * **Use cases**:\n * - Reset application state\n * - Close all panels\n * - Deactivate all canvases\n *\n * **Visual effects**:\n * - All canvas titles return to inactive state\n * - No canvas highlighted\n * - Canvas settings panel hidden\n *\n * **State changes**:\n * - `activeCanvasId` = null\n * - Components re-render without active state\n *\n * **Safety**: Safe to call even if no canvas active\n *\n * @example\n * ```typescript\n * // Reset button handler\n * handleReset() {\n *   clearActiveCanvas();\n *   deselectItem();\n *   reset();\n * }\n * ```\n */\nexport function clearActiveCanvas() {\n  state.activeCanvasId = null;\n}\n\n/**\n * Batch Operations\n * =================\n *\n * Performance-optimized functions for bulk operations.\n * Single state update = single re-render (vs N updates = N re-renders).\n */\n\n/**\n * Add multiple items in a single batch\n *\n * **Performance benefit**: 1000 items added in ~10ms with single re-render\n * vs ~200-500ms with 1000 individual add calls and 1000 re-renders.\n *\n * **Use cases**:\n * - Stress testing (adding 100-1000 items)\n * - Template/preset loading (page templates with many components)\n * - Undo batch delete\n * - Import from saved layout\n *\n * **Reactivity pattern**:\n * 1. Clone canvases object\n * 2. Add all items to cloned canvases\n * 3. Single state assignment triggers single re-render\n * 4. Single undo/redo command for entire batch\n *\n * @param items - Array of partial GridItem specs (missing id, zIndex auto-assigned)\n * @returns Array of created item IDs\n *\n * @example\n * ```typescript\n * // Add 100 items in stress test\n * const items = Array.from({ length: 100 }, (_, i) => ({\n *   canvasId: 'canvas1',\n *   type: i % 2 === 0 ? 'header' : 'text',\n *   name: `Item ${i}`,\n *   layouts: {\n *     desktop: { x: (i % 10) * 5, y: Math.floor(i / 10) * 5, width: 20, height: 5 },\n *     mobile: { x: null, y: null, width: null, height: null, customized: false }\n *   }\n * }));\n *\n * const itemIds = addItemsBatch(items);\n * // ✅ 1 state update, 1 re-render, 1 undo command\n * ```\n */\nexport function addItemsBatch(items: Partial<GridItem>[]): string[] {\n  const itemIds: string[] = [];\n  const updatedCanvases = { ...state.canvases };\n\n  for (const itemData of items) {\n    const id = generateItemId();\n    const canvasId = itemData.canvasId!;\n    const canvas = updatedCanvases[canvasId];\n\n    if (!canvas) {\n      console.warn(`Canvas ${canvasId} not found, skipping item`);\n      continue;\n    }\n\n    const newItem: GridItem = {\n      id,\n      canvasId,\n      type: itemData.type || 'unknown',\n      name: itemData.name || 'Unnamed',\n      layouts: itemData.layouts || {\n        desktop: { x: 0, y: 0, width: 20, height: 10 },\n        mobile: { x: null, y: null, width: null, height: null, customized: false },\n      },\n      zIndex: canvas.zIndexCounter++,\n      config: itemData.config || {},\n    };\n\n    canvas.items.push(newItem);\n    itemIds.push(id);\n  }\n\n  // Single state update triggers single re-render\n  state.canvases = updatedCanvases;\n\n  return itemIds;\n}\n\n/**\n * Delete multiple items in a single batch\n *\n * **Performance benefit**: 1000 items deleted in ~5ms with single re-render\n * vs ~100-200ms with 1000 individual delete calls and 1000 re-renders.\n *\n * **Use cases**:\n * - Clear canvas (delete all)\n * - Delete selection group\n * - Undo batch add\n * - Cleanup operations\n *\n * **Reactivity pattern**:\n * 1. Clone canvases object\n * 2. Filter out all items from cloned canvases\n * 3. Single state assignment triggers single re-render\n * 4. Single undo/redo command for entire batch\n *\n * @param itemIds - Array of item IDs to delete\n *\n * @example\n * ```typescript\n * // Clear entire canvas\n * const canvas = gridState.canvases['canvas1'];\n * const allItemIds = canvas.items.map(item => item.id);\n * deleteItemsBatch(allItemIds);\n * // ✅ 1 state update, 1 re-render, 1 undo command\n * ```\n */\nexport function deleteItemsBatch(itemIds: string[]): void {\n  const itemIdSet = new Set(itemIds);\n  const updatedCanvases = { ...state.canvases };\n\n  // Filter out items from all canvases\n  for (const canvasId in updatedCanvases) {\n    updatedCanvases[canvasId] = {\n      ...updatedCanvases[canvasId],\n      items: updatedCanvases[canvasId].items.filter((item) => !itemIdSet.has(item.id)),\n    };\n  }\n\n  // Single state update triggers single re-render\n  state.canvases = updatedCanvases;\n}\n\n/**\n * Update multiple item configs in a single batch\n *\n * **Performance benefit**: 1000 items updated in ~8ms with single re-render\n * vs ~150-300ms with 1000 individual update calls and 1000 re-renders.\n *\n * **Use cases**:\n * - Theme changes (update colors for all items)\n * - Bulk property changes\n * - Undo batch config change\n * - Template application\n *\n * **Reactivity pattern**:\n * 1. Clone canvases object\n * 2. Apply all updates to cloned canvases\n * 3. Single state assignment triggers single re-render\n * 4. Single undo/redo command for entire batch\n *\n * @param updates - Array of { itemId, canvasId, updates } objects\n *\n * @example\n * ```typescript\n * // Change all headers to blue\n * const headerUpdates = Object.values(gridState.canvases)\n *   .flatMap(canvas => canvas.items)\n *   .filter(item => item.type === 'header')\n *   .map(item => ({\n *     itemId: item.id,\n *     canvasId: item.canvasId,\n *     updates: { config: { ...item.config, color: 'blue' } }\n *   }));\n *\n * updateItemsBatch(headerUpdates);\n * // ✅ 1 state update, 1 re-render, 1 undo command\n * ```\n */\nexport function updateItemsBatch(\n  updates: Array<{ itemId: string; canvasId: string; updates: Partial<GridItem> }>\n): void {\n  const updatedCanvases = { ...state.canvases };\n\n  for (const { itemId, canvasId, updates: itemUpdates } of updates) {\n    const canvas = updatedCanvases[canvasId];\n    if (!canvas) {\n      console.warn(`Canvas ${canvasId} not found, skipping item ${itemId}`);\n      continue;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      console.warn(`Item ${itemId} not found in canvas ${canvasId}`);\n      continue;\n    }\n\n    Object.assign(item, itemUpdates);\n  }\n\n  // Single state update triggers single re-render\n  state.canvases = updatedCanvases;\n}\n"]}