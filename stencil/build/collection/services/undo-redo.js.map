{"version":3,"file":"undo-redo.js","sourceRoot":"","sources":["../../src/services/undo-redo.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Undo/Redo Service\n * ==================\n *\n * Command pattern implementation for undo/redo functionality in the grid builder.\n * Provides stack-based history management with keyboard shortcuts and UI state tracking.\n *\n * ## Problem\n *\n * Interactive applications need undo/redo capabilities for:\n * - Recovering from mistakes (accidental delete)\n * - Experimenting with layouts (try different arrangements)\n * - Learning the interface (undo to see what changed)\n * - Building confidence (knowing you can undo)\n *\n * **Without undo/redo**:\n * - Users hesitant to experiment\n * - Mistakes are permanent\n * - No way to review history\n * - Poor user experience\n *\n * ## Solution\n *\n * Implement **Command Pattern** with stack-based history:\n *\n * 1. **Command Interface**: Each undoable action implements undo() and redo()\n * 2. **History Stack**: Array of command objects\n * 3. **Position Pointer**: Tracks current position in history\n * 4. **Bounded History**: Limited to 50 commands to prevent memory bloat\n * 5. **Branching**: New actions after undo discard \"future\" history\n *\n * ## Architecture: Command Pattern\n *\n * **Classic Gang of Four pattern** for undo/redo:\n *\n * **Key Components**:\n * - **Command Interface**: Defines undo() and redo() methods\n * - **Concrete Commands**: AddItemCommand, DeleteItemCommand, MoveItemCommand, ResizeCommand\n * - **Invoker**: undo-redo.ts (this file) manages command execution\n * - **Receiver**: state-manager.ts (receives state mutations)\n *\n * **Flow**:\n * ```\n * User Action ‚Üí Create Command ‚Üí pushCommand() ‚Üí Execute & Store\n * Undo (Ctrl+Z) ‚Üí Get command at position ‚Üí command.undo() ‚Üí Update position\n * Redo (Ctrl+Y) ‚Üí Advance position ‚Üí command.redo() ‚Üí Execute\n * ```\n *\n * **Why Command Pattern**:\n * - ‚úÖ Encapsulates actions as objects\n * - ‚úÖ Enables undo/redo without coupling to specific operations\n * - ‚úÖ Supports macro commands (batch operations)\n * - ‚úÖ Easy to extend with new command types\n * - ‚úÖ History can be serialized/persisted\n *\n * ## History Management\n *\n * **Stack-based with position pointer**:\n * ```\n * commandHistory = [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                                  ‚Üë\n *                            historyPosition = 2\n * ```\n *\n * **Operations**:\n * - **Push new command**: Discard commands after position, append new command\n * - **Undo**: Execute command.undo() at position, decrement position\n * - **Redo**: Increment position, execute command.redo() at new position\n *\n * **Branching behavior** (discarding future on new action):\n * ```\n * Initial:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                         ‚Üë position = 2\n *\n * Undo 2x:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                  ‚Üë position = 0\n *\n * New cmd:  [cmd1, cmd6]  ‚Üê cmd2-cmd5 discarded!\n *                  ‚Üë position = 1\n * ```\n *\n * **Why branching (not tree)**:\n * - Simpler mental model for users\n * - No UI complexity for branch navigation\n * - Standard undo/redo UX pattern\n *\n * ## Memory Management\n *\n * **Bounded history** (MAX_HISTORY = 50):\n * - Prevents unbounded memory growth\n * - Removes oldest command when limit reached\n * - 50 commands ‚âà typical user session\n *\n * **Memory per command**:\n * - Command object: ~200-500 bytes\n * - State snapshots: ~1-5 KB (JSON serialized GridItem)\n * - Total for 50 commands: ~50-250 KB (acceptable)\n *\n * **Sliding window approach**:\n * ```\n * When history full:\n * [cmd1, cmd2, ..., cmd50]  ‚Üê At capacity\n * Push cmd51:\n * [cmd2, cmd3, ..., cmd51]  ‚Üê cmd1 removed\n * ```\n *\n * ## State Snapshot Strategy\n *\n * Each command stores **before/after snapshots**:\n * ```typescript\n * class MoveItemCommand implements Command {\n *   beforeState = JSON.parse(JSON.stringify(item));  // Deep clone\n *   afterState = JSON.parse(JSON.stringify(updatedItem));\n *\n *   undo() { restoreState(beforeState); }\n *   redo() { restoreState(afterState); }\n * }\n * ```\n *\n * **Deep cloning required because**:\n * - Prevents mutations from affecting snapshots\n * - Ensures independent state copies\n * - Simple and reliable (no reference tracking needed)\n *\n * **Trade-off**:\n * - ‚úÖ Simple implementation\n * - ‚úÖ No reference bugs\n * - ‚ùå Higher memory usage than delta-based\n * - ‚ùå Slower than structural sharing (acceptable for this use case)\n *\n * ## Keyboard Shortcuts\n *\n * Implemented in grid-builder-app.tsx:\n * - **Ctrl+Z** (Cmd+Z on Mac): Undo last command\n * - **Ctrl+Y** (Cmd+Y on Mac): Redo next command\n * - **Ctrl+Shift+Z**: Alternative redo (common in design tools)\n *\n * ## UI Integration\n *\n * **Reactive state for buttons**:\n * ```typescript\n * undoRedoState = {\n *   canUndo: boolean,  // Enable/disable undo button\n *   canRedo: boolean   // Enable/disable redo button\n * }\n * ```\n *\n * **Updates on**:\n * - New command pushed\n * - Undo executed\n * - Redo executed\n * - History cleared\n *\n * **Button rendering**:\n * ```tsx\n * <button disabled={!undoRedoState.canUndo} onClick={undo}>\n *   Undo\n * </button>\n * ```\n *\n * ## Extracting This Pattern\n *\n * To adapt Command pattern for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * interface Command {\n *   undo(): void;\n *   redo(): void;\n * }\n *\n * class UndoRedoManager {\n *   private history: Command[] = [];\n *   private position = -1;\n *\n *   push(command: Command) {\n *     this.history.splice(this.position + 1);  // Discard future\n *     this.history.push(command);\n *     this.position++;\n *   }\n *\n *   undo() {\n *     if (this.position >= 0) {\n *       this.history[this.position].undo();\n *       this.position--;\n *     }\n *   }\n *\n *   redo() {\n *     if (this.position < this.history.length - 1) {\n *       this.position++;\n *       this.history[this.position].redo();\n *     }\n *   }\n * }\n * ```\n *\n * **Example commands**:\n * ```typescript\n * class AddItemCommand implements Command {\n *   constructor(\n *     private canvasId: string,\n *     private item: GridItem\n *   ) {}\n *\n *   undo() { removeItemFromCanvas(this.canvasId, this.item.id); }\n *   redo() { addItemToCanvas(this.canvasId, this.item); }\n * }\n * ```\n *\n * **For different frameworks**:\n * - React: Use useReducer or Zustand middleware\n * - Vue: Use Pinia plugin or custom composable\n * - Angular: Use NgRx effects or service\n *\n * @module undo-redo\n */\n\nimport { createStore } from '@stencil/store';\nimport { createDebugLogger } from '../utils/debug';\n\nconst debug = createDebugLogger('undo-redo');\n\n/**\n * Command Interface\n * =================\n *\n * Core abstraction for undoable operations. All commands must implement\n * both undo() and redo() methods to reverse and reapply their effects.\n *\n * **Design principle**: Commands are **self-contained** - they store all\n * data needed to both undo and redo without external dependencies.\n *\n * **Typical implementation**:\n * ```typescript\n * class MyCommand implements Command {\n *   private beforeState: any;\n *   private afterState: any;\n *\n *   constructor(initialState) {\n *     this.beforeState = JSON.parse(JSON.stringify(initialState));\n *     // ... perform operation ...\n *     this.afterState = JSON.parse(JSON.stringify(finalState));\n *   }\n *\n *   undo() { restoreState(this.beforeState); }\n *   redo() { restoreState(this.afterState); }\n * }\n * ```\n *\n * **Why separate undo/redo methods**:\n * - ‚ùå Not: Single execute(reverse: boolean) method\n * - ‚úÖ Yes: Separate undo() and redo() methods\n * - Reason: Clearer intent, easier to implement, matches user mental model\n *\n * **Concrete implementations**:\n * - AddItemCommand: Add/remove grid item\n * - DeleteItemCommand: Remove/restore grid item with index preservation\n * - MoveItemCommand: Update item position (cross-canvas support)\n * - ResizeCommand: Update item dimensions\n *\n * @example\n * ```typescript\n * class DeleteItemCommand implements Command {\n *   constructor(\n *     private canvasId: string,\n *     private item: GridItem,\n *     private itemIndex: number\n *   ) {}\n *\n *   undo() {\n *     // Restore item at original index\n *     const canvas = gridState.canvases[this.canvasId];\n *     canvas.items.splice(this.itemIndex, 0, this.item);\n *     gridState.canvases = { ...gridState.canvases };\n *   }\n *\n *   redo() {\n *     // Remove item again\n *     removeItemFromCanvas(this.canvasId, this.item.id);\n *   }\n * }\n * ```\n */\nexport interface Command {\n  /**\n   * Reverse the effect of this command\n   *\n   * **Idempotent**: Calling undo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  undo(): void;\n\n  /**\n   * Reapply the effect of this command\n   *\n   * **Idempotent**: Calling redo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  redo(): void;\n}\n\n/**\n * Undo/Redo State\n * ================\n *\n * Reactive state for UI button enable/disable logic.\n * Components subscribe to this state to update undo/redo button states.\n *\n * **Why reactive**:\n * - Automatic button state updates (no manual DOM manipulation)\n * - Components re-render when canUndo/canRedo changes\n * - Declarative UI logic\n *\n * **Usage in components**:\n * ```tsx\n * import { undoRedoState } from './undo-redo';\n *\n * render() {\n *   return (\n *     <div>\n *       <button\n *         disabled={!undoRedoState.canUndo}\n *         onClick={() => undo()}>\n *         Undo\n *       </button>\n *       <button\n *         disabled={!undoRedoState.canRedo}\n *         onClick={() => redo()}>\n *         Redo\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n */\nexport interface UndoRedoState {\n  /** Whether undo operation is available (historyPosition >= 0) */\n  canUndo: boolean;\n\n  /** Whether redo operation is available (historyPosition < commandHistory.length - 1) */\n  canRedo: boolean;\n}\n\n/**\n * Reactive state store for undo/redo button states\n *\n * **StencilJS integration**: Components automatically subscribe when accessing properties\n * **Updates**: Modified by updateButtonStates() after each operation\n */\nconst { state: undoRedoState } = createStore<UndoRedoState>({\n  canUndo: false,\n  canRedo: false,\n});\n\nexport { undoRedoState };\n\n/**\n * Undo/Redo Service API\n * =====================\n *\n * Provides a clear, namespaced API for undo/redo operations.\n * Use this instead of individual function imports for better clarity.\n *\n * @example\n * ```typescript\n * import { undoRedo } from './services/undo-redo';\n *\n * // Add command to history\n * undoRedo.push(new AddItemCommand(canvasId, item));\n *\n * // Undo/redo\n * undoRedo.undo();\n * undoRedo.redo();\n *\n * // Check availability\n * if (undoRedo.canUndo()) {\n *   undoRedo.undo();\n * }\n * ```\n */\nexport const undoRedo = {\n  /** Add command to undo/redo history */\n  push: pushCommand,\n\n  /** Undo last command */\n  undo,\n\n  /** Redo previously undone command */\n  redo,\n\n  /** Check if undo is available */\n  canUndo,\n\n  /** Check if redo is available */\n  canRedo,\n\n  /** Clear entire history */\n  clearHistory,\n};\n\n/**\n * Internal Command History State\n * ===============================\n *\n * Private state managing command stack and position.\n * Not exported - accessed only through public functions.\n */\n\n/**\n * Command history stack\n *\n * **Structure**: Array of Command objects in chronological order\n * **Growth**: Appends new commands to end\n * **Bounded**: Limited to MAX_HISTORY commands (50)\n * **Branching**: Discards commands after current position on new push\n *\n * @example\n * ```\n * [AddItemCommand, DeleteItemCommand, MoveItemCommand]\n *  ‚Üë                ‚Üë                  ‚Üë\n *  0                1                  2 (historyPosition)\n * ```\n */\nconst commandHistory: Command[] = [];\n\n/**\n * Current position in command history\n *\n * **Range**: -1 (empty history) to commandHistory.length - 1\n * **Meaning**:\n * - -1: No commands or all undone\n * - 0: First command is current state\n * - N: Command at index N is current state\n *\n * **Operations**:\n * - Push command: position++\n * - Undo: position--\n * - Redo: position++\n *\n * **Invariant**: position < commandHistory.length\n */\nlet historyPosition: number = -1;\n\n/**\n * Maximum number of commands in history\n *\n * **Why 50**: Balance between:\n * - ‚úÖ Enough for typical user session\n * - ‚úÖ Reasonable memory usage (~50-250 KB)\n * - ‚ùå Not unlimited (prevents memory bloat)\n *\n * **Behavior when exceeded**: Oldest command removed (sliding window)\n */\nconst MAX_HISTORY = 50;\n\n/**\n * Update reactive state for undo/redo button enablement\n *\n * **Called after**:\n * - pushCommand() - New command added\n * - undo() - Position moved backward\n * - redo() - Position moved forward\n * - clearHistory() - History reset\n *\n * **Updates**:\n * - `canUndo`: true if historyPosition >= 0 (commands available to undo)\n * - `canRedo`: true if historyPosition < commandHistory.length - 1 (commands available to redo)\n *\n * **Triggers**:\n * - Component re-renders (via StencilJS Store reactivity)\n * - Button enable/disable state changes\n *\n * **Why not inline**:\n * - DRY principle (called from 4 places)\n * - Single responsibility (updating button states)\n * - Easier to extend (e.g., add logging, analytics)\n *\n * @private\n */\nfunction updateButtonStates(): void {\n  undoRedoState.canUndo = historyPosition >= 0;\n  undoRedoState.canRedo = historyPosition < commandHistory.length - 1;\n}\n\n/**\n * Push a new command to the history stack\n *\n * **Use cases**:\n * - After drag operation completes\n * - After resize operation completes\n * - After adding new item\n * - After deleting item\n *\n * **Branching behavior** (discards future):\n * ```\n * Before: [cmd1, cmd2, cmd3, cmd4]\n *                  ‚Üë position = 1 (undid twice)\n *\n * Push cmd5: [cmd1, cmd2, cmd5]\n *                        ‚Üë position = 2\n *\n * Note: cmd3 and cmd4 discarded!\n * ```\n *\n * **Why discard future**:\n * - Matches user mental model (new action erases \"undone\" history)\n * - Simpler implementation than tree-based history\n * - Standard undo/redo UX pattern\n *\n * **Memory management**:\n * - If history exceeds MAX_HISTORY (50), oldest command removed\n * - Position adjusted to maintain integrity\n *\n * **Operation sequence**:\n * 1. Discard commands after current position (splice)\n * 2. Append new command to history\n * 3. If over limit, remove oldest (shift)\n * 4. Update position pointer\n * 5. Update button states (triggers UI)\n *\n * **Typical usage**:\n * ```typescript\n * // After drag end\n * const command = new MoveItemCommand(item, oldPos, newPos);\n * pushCommand(command);\n * ```\n *\n * **Important**: Command should be fully constructed (with snapshots taken)\n * before being pushed. This function does NOT execute the command - it's\n * assumed the operation already happened.\n *\n * @param command - Fully constructed command with before/after snapshots\n *\n * @example\n * ```typescript\n * // Delete item example\n * handleDelete(itemId: string, canvasId: string) {\n *   const item = getItem(canvasId, itemId);\n *   const index = gridState.canvases[canvasId].items.indexOf(item);\n *\n *   // Perform the delete\n *   removeItemFromCanvas(canvasId, itemId);\n *\n *   // Push command for undo (AFTER operation)\n *   const command = new DeleteItemCommand(canvasId, item, index);\n *   pushCommand(command);\n * }\n * ```\n */\nexport function pushCommand(command: Command): void {\n  debug.log('‚ûï PUSH: Adding command to history:', (command as any).description || command);\n\n  // Remove any commands after current position\n  commandHistory.splice(historyPosition + 1);\n\n  // Add new command\n  commandHistory.push(command);\n\n  // Limit history size\n  if (commandHistory.length > MAX_HISTORY) {\n    commandHistory.shift();\n  } else {\n    historyPosition++;\n  }\n\n  debug.log('  History position now:', historyPosition, ', Total commands:', commandHistory.length);\n\n  // Update button states\n  updateButtonStates();\n}\n\n/**\n * Undo the last command in history\n *\n * **Triggered by**:\n * - Ctrl+Z / Cmd+Z keyboard shortcut\n * - Undo button click\n * - Programmatic undo (rare)\n *\n * **Operation sequence**:\n * 1. Check if undo available (historyPosition >= 0)\n * 2. Get command at current position\n * 3. Execute command.undo() (reverses operation)\n * 4. Decrement position pointer\n * 5. Update button states (triggers UI)\n *\n * **Side effects**:\n * - Mutates global state (via command.undo())\n * - Triggers component re-renders\n * - Updates undo/redo button states\n * - May deselect items (depending on command)\n *\n * **Position before/after**:\n * ```\n * Before: [cmd1, cmd2, cmd3]\n *                      ‚Üë position = 2\n *\n * After:  [cmd1, cmd2, cmd3]\n *                ‚Üë position = 1\n * ```\n *\n * **Safety**: No-op if historyPosition < 0 (nothing to undo)\n *\n * **Multiple undo**: Can be called repeatedly to undo multiple commands\n *\n * @example\n * ```typescript\n * // Keyboard shortcut handler\n * window.addEventListener('keydown', (e) => {\n *   if ((e.ctrlKey || e.metaKey) && e.key === 'z') {\n *     undo();\n *     e.preventDefault();\n *   }\n * });\n * ```\n */\nexport function undo(): void {\n  if (historyPosition < 0) {\n    return;\n  }\n\n  const command = commandHistory[historyPosition];\n  debug.log('üîô UNDO: Executing command at position', historyPosition, ':', command);\n  debug.log('  Command description:', (command as any).description);\n  command.undo();\n  historyPosition--;\n  debug.log('  New position after undo:', historyPosition);\n\n  updateButtonStates();\n}\n\n/**\n * Redo the next command in history\n *\n * **Triggered by**:\n * - Ctrl+Y / Cmd+Y keyboard shortcut\n * - Ctrl+Shift+Z / Cmd+Shift+Z (alternative)\n * - Redo button click\n * - Programmatic redo (rare)\n *\n * **Operation sequence**:\n * 1. Check if redo available (historyPosition < commandHistory.length - 1)\n * 2. Increment position pointer\n * 3. Get command at new position\n * 4. Execute command.redo() (reapplies operation)\n * 5. Update button states (triggers UI)\n *\n * **Side effects**:\n * - Mutates global state (via command.redo())\n * - Triggers component re-renders\n * - Updates undo/redo button states\n * - May select items (depending on command)\n *\n * **Position before/after**:\n * ```\n * Before: [cmd1, cmd2, cmd3]\n *                ‚Üë position = 1\n *\n * After:  [cmd1, cmd2, cmd3]\n *                      ‚Üë position = 2\n * ```\n *\n * **Safety**: No-op if no commands to redo (position at end)\n *\n * **Multiple redo**: Can be called repeatedly to redo multiple commands\n *\n * **Redo after new action**: Redo becomes unavailable after new command\n * pushed (future history discarded)\n *\n * @example\n * ```typescript\n * // Keyboard shortcut handler\n * window.addEventListener('keydown', (e) => {\n *   if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\n *     redo();\n *     e.preventDefault();\n *   }\n * });\n * ```\n */\nexport function redo(): void {\n  if (historyPosition >= commandHistory.length - 1) {\n    return;\n  }\n\n  historyPosition++;\n  const command = commandHistory[historyPosition];\n  command.redo();\n\n  updateButtonStates();\n}\n\n/**\n * Check if undo operation is available\n *\n * **Use cases**:\n * - Enabling/disabling undo button\n * - Showing undo keyboard hint\n * - Programmatic checks before undo\n *\n * **Returns true when**: historyPosition >= 0 (commands in history)\n * **Returns false when**: historyPosition = -1 (no history or all undone)\n *\n * **Note**: Prefer using `undoRedoState.canUndo` in UI components\n * for automatic reactivity. This function is for imperative checks.\n *\n * @returns true if undo() can be called, false otherwise\n *\n * @example\n * ```typescript\n * // Imperative check\n * if (canUndo()) {\n *   debug.log('Undo available');\n *   undo();\n * }\n *\n * // Prefer reactive state in UI\n * <button disabled={!undoRedoState.canUndo}>Undo</button>\n * ```\n */\nexport function canUndo(): boolean {\n  return historyPosition >= 0;\n}\n\n/**\n * Check if redo operation is available\n *\n * **Use cases**:\n * - Enabling/disabling redo button\n * - Showing redo keyboard hint\n * - Programmatic checks before redo\n *\n * **Returns true when**: historyPosition < commandHistory.length - 1\n * **Returns false when**: At end of history or history empty\n *\n * **Becomes false after**: New command pushed (future discarded)\n *\n * **Note**: Prefer using `undoRedoState.canRedo` in UI components\n * for automatic reactivity. This function is for imperative checks.\n *\n * @returns true if redo() can be called, false otherwise\n *\n * @example\n * ```typescript\n * // Imperative check\n * if (canRedo()) {\n *   debug.log('Redo available');\n *   redo();\n * }\n *\n * // Prefer reactive state in UI\n * <button disabled={!undoRedoState.canRedo}>Redo</button>\n * ```\n */\nexport function canRedo(): boolean {\n  return historyPosition < commandHistory.length - 1;\n}\n\n/**\n * Clear all command history\n *\n * **Use cases**:\n * - Application reset\n * - Loading new project\n * - Test cleanup\n * - Memory management (rare)\n *\n * **Effects**:\n * - Empties command history array\n * - Resets position to -1\n * - Disables both undo and redo buttons\n * - Does NOT affect current state (only history)\n *\n * **Memory**: Allows garbage collection of command objects and snapshots\n *\n * **Cannot be undone**: This operation itself is not undoable\n *\n * **Safety**: Safe to call even if history already empty\n *\n * @example\n * ```typescript\n * // Reset application\n * function resetApp() {\n *   clearHistory();\n *   reset(); // Reset state\n *   debug.log('Application reset');\n * }\n *\n * // Test cleanup\n * afterEach(() => {\n *   clearHistory();\n * });\n * ```\n */\nexport function clearHistory(): void {\n  commandHistory.length = 0;\n  historyPosition = -1;\n  updateButtonStates();\n}\n"]}