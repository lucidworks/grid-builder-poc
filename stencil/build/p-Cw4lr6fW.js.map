{"version":3,"file":"p-Cw4lr6fW.js","sources":["src/services/undo-redo-commands.ts","src/utils/error-handler.ts","src/utils/breakpoint-utils.ts","src/utils/boundary-constraints.ts"],"sourcesContent":["/**\n * Undo/Redo Commands\n * ===================\n *\n * Concrete Command implementations for grid operations. Each command class\n * encapsulates a specific user action with the ability to undo and redo.\n *\n * ## Problem\n *\n * The Command pattern requires concrete implementations for each undoable operation.\n * Each command must:\n * - Capture enough state to reverse the operation (undo)\n * - Capture enough state to reapply the operation (redo)\n * - Be self-contained (no external dependencies)\n * - Handle edge cases (canvas switching, index preservation)\n *\n * ## Solution\n *\n * Four concrete command classes covering all grid operations:\n *\n * 1. **AddItemCommand**: Adding new items to canvas\n * 2. **DeleteItemCommand**: Removing items with index preservation\n * 3. **MoveItemCommand**: Dragging items (same or different canvas)\n * 4. **ResizeCommand**: (Not yet implemented - resize operations not tracked)\n *\n * ## Key Design Patterns\n *\n * ### Deep Cloning Strategy\n *\n * **Why deep clone**: Prevent mutations from affecting command snapshots\n *\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **When to clone**:\n * - ‚úÖ Constructor: Capture initial state\n * - ‚úÖ redo(): Create fresh copy for state mutation\n * - ‚ùå undo(): Usually work with existing state references\n *\n * **Trade-offs**:\n * - ‚úÖ Simple and reliable\n * - ‚úÖ No reference bugs\n * - ‚ùå Higher memory usage (~1-5 KB per command)\n * - ‚ùå Slower than structural sharing\n *\n * ### Index Preservation Pattern\n *\n * **Why preserve index**: Undo delete should restore item at original position\n *\n * ```typescript\n * class DeleteItemCommand {\n * private itemIndex: number;  // Capture index before deletion\n *\n * undo() {\n * canvas.items.splice(this.itemIndex, 0, item);  // Restore at index\n * }\n * }\n * ```\n *\n * **Important for**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * ### Selection State Management\n *\n * **Pattern**: Clear selection when deleting selected item\n *\n * ```typescript\n * if (gridState.selectedItemId === itemId) {\n * gridState.selectedItemId = null;\n * gridState.selectedCanvasId = null;\n * }\n * ```\n *\n * **Why needed**:\n * - Prevents dangling references to deleted items\n * - Avoids errors when accessing selectedItemId\n * - Matches user expectations (deleted item can't be selected)\n *\n * ### Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between canvases\n *\n * **Solution**: Track source and target canvas IDs\n *\n * ```typescript\n * class MoveItemCommand {\n * sourceCanvasId: string;\n * targetCanvasId: string;\n *\n * undo() {\n * // Move from target back to source\n * removeFrom(targetCanvasId);\n * addTo(sourceCanvasId, sourceIndex);  // Restore position\n * }\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Typical flow**:\n * ```\n * 1. User performs action (drag, delete, etc.)\n * 2. Operation completes (state already updated)\n * 3. Create command with before/after snapshots\n * 4. pushCommand(command) ‚Üí adds to history\n * 5. User presses Ctrl+Z\n * 6. command.undo() ‚Üí reverses operation\n * 7. User presses Ctrl+Y\n * 8. command.redo() ‚Üí reapplies operation\n * ```\n *\n * **Important**: Commands are created AFTER the operation completes,\n * not before. The constructor captures the final state.\n *\n * ## Extracting These Patterns\n *\n * To create new command types:\n *\n * ```typescript\n * export class MyCommand implements Command {\n * // Capture state needed for undo/redo\n * private beforeState: any;\n * private afterState: any;\n *\n * constructor(params) {\n * // Deep clone to prevent mutations\n * this.beforeState = JSON.parse(JSON.stringify(before));\n * this.afterState = JSON.parse(JSON.stringify(after));\n * }\n *\n * undo(): void {\n * // Restore before state\n * restoreState(this.beforeState);\n * gridState.canvases = { ...gridState.canvases };  // Trigger reactivity\n * }\n *\n * redo(): void {\n * // Apply after state\n * restoreState(this.afterState);\n * gridState.canvases = { ...gridState.canvases };\n * }\n * }\n * ```\n *\n * **Guidelines**:\n * - Always deep clone state in constructor\n * - Always trigger reactivity (`gridState.canvases = { ...gridState.canvases }`)\n * - Handle null cases (canvas/item not found)\n * - Clear selection if needed\n * - Preserve array indices for positional restore\n * @module undo-redo-commands\n */\n\nimport { GridItem } from \"./state-manager\";\nimport { Command } from \"./undo-redo\";\nimport { EventManager } from \"./event-manager\";\nimport { createDebugLogger } from \"../utils/debug\";\n\nconst debug = createDebugLogger(\"undo-redo-commands\");\n\n/**\n * Helper function to remove an item from a canvas and clear selection\n *\n * **Responsibilities**:\n * - Remove item from canvas items array\n * - Trigger state reactivity (spread pattern)\n * - Clear selection if deleted item was selected\n *\n * **Used by**:\n * - AddItemCommand.undo() - Remove just-added item\n * - DeleteItemCommand.redo() - Remove item again\n * - MoveItemCommand (implicitly via filter)\n *\n * **Why helper function**:\n * - DRY principle (used in multiple commands)\n * - Encapsulates selection clearing logic\n * - Consistent behavior across commands\n *\n * **Selection clearing**:\n * Prevents dangling references and UI errors when selected item deleted.\n *\n * **Instance-based architecture**:\n * - Requires state parameter for multi-instance support\n * @param canvasId - Canvas containing the item\n * @param itemId - Item to remove\n * @param state - GridState instance\n * @example\n * ```typescript\n * // Used internally by commands\n * undo() {\n *   removeItemFromCanvas(this.canvasId, this.item.id, this.stateInstance);\n * }\n * ```\n */\nfunction removeItemFromCanvas(\n  canvasId: string,\n  itemId: string,\n  state: any,\n): void {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((i) => i.id !== itemId);\n  state.canvases = { ...state.canvases };\n\n  // NOTE: Selection clearing removed - view state should not be modified by commands\n  // Selection is instance-specific view state, not shared data state\n  // Selection clearing should happen at the API/component level when needed\n}\n\n/**\n * AddItemCommand\n * ==============\n *\n * Captures the addition of a new grid item to a canvas, enabling undo/redo\n * for create operations.\n *\n * ## Use Cases\n *\n * - User drops component from palette onto canvas\n * - Programmatic item creation (stress tests, templates)\n * - Duplicating existing items\n *\n * ## Command Lifecycle\n *\n * **Creation**: After item already added to canvas\n * ```typescript\n * // 1. Add item to canvas (operation completes)\n * addItemToCanvas('canvas1', newItem);\n *\n * // 2. Create command for undo (captures final state)\n * const command = new AddItemCommand('canvas1', newItem);\n * pushCommand(command);\n * ```\n *\n * **Undo**: Remove the item from canvas\n * ```typescript\n * command.undo(); // Item disappears from canvas\n * ```\n *\n * **Redo**: Re-add the item to canvas\n * ```typescript\n * command.redo(); // Item reappears in canvas\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures item state with deep clone\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Prevents mutations from affecting command's snapshot\n * - Item might be modified after command creation\n * - Ensures redo restores exact original state\n *\n * **Redo cloning**: Creates fresh copy for state mutation\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.push(itemCopy);\n * ```\n *\n * **Why redo also clones**:\n * - Multiple redo calls shouldn't share references\n * - Prevents undo/redo from affecting each other\n * - Safe state isolation\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: redo() returns early if canvas not found\n * - **Item modified**: Command stores original state, not current\n * - **Selection**: undo() automatically clears selection via helper\n * @example\n * ```typescript\n * // After palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(),\n *   canvasId: 'canvas1',\n *   type: 'header',\n *   name: 'Header',\n *   layouts: { desktop: { x: 5, y: 5, width: 20, height: 8 }, ... },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n *\n * addItemToCanvas('canvas1', newItem);\n * pushCommand(new AddItemCommand('canvas1', newItem));\n * ```\n */\nexport class AddItemCommand implements Command {\n  /** Deep clone of item at creation time */\n  private item: GridItem;\n\n  /** Canvas ID where item was added */\n  private canvasId: string;\n\n  /** GridState instance for multi-instance support */\n  private stateInstance: any;\n\n  /**\n   * Capture item addition operation\n   *\n   * **Important**: Call AFTER item added to canvas (not before)\n   *\n   * **Deep clones item**: Prevents future mutations from affecting snapshot\n   *\n   * **Instance-based architecture**:\n   * - Requires stateInstance parameter for multi-instance support\n   * @param canvasId - Canvas where item was added\n   * @param item - Item that was added (will be deep cloned)\n   * @param stateInstance - GridState instance\n   */\n  constructor(canvasId: string, item: GridItem, stateInstance: any) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state at time of creation\n    this.item = JSON.parse(JSON.stringify(item));\n    this.stateInstance = stateInstance;\n  }\n\n  /**\n   * Undo: Remove the item from canvas\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  undo(): void {\n    // Remove the item from the canvas\n    removeItemFromCanvas(this.canvasId, this.item.id, this.stateInstance);\n  }\n\n  /**\n   * Redo: Re-add the item to canvas\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Appends to end**: Doesn't preserve original index (acceptable for add)\n   *\n   * **Side effects**:\n   * - Item added to end of canvas.items array\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found (e.g., canvas was deleted)\n   */\n  redo(): void {\n    // Re-add the item to the canvas\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Use the cloned item state\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    canvas.items.push(itemCopy);\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n  }\n\n  /**\n   * Get description of this command\n   * @returns Object with action type, position, and item details\n   */\n  getDescription() {\n    const { x, y, width, height } = this.item.layouts.desktop;\n    return {\n      action: \"add\",\n      type: this.item.type,\n      position: { x, y },\n      size: { width, height },\n    };\n  }\n}\n\n/**\n * DeleteItemCommand\n * ==================\n *\n * Captures the deletion of a grid item from a canvas, enabling undo/redo\n * for delete operations with index preservation.\n *\n * ## Use Cases\n *\n * - User deletes item with Delete key\n * - Delete button clicked\n * - Programmatic item removal\n * - Clearing canvas sections\n *\n * ## Index Preservation Pattern\n *\n * **Critical feature**: Restores deleted item at its ORIGINAL array position\n *\n * **Why important**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * **Implementation**:\n * ```typescript\n * constructor(canvasId, item, itemIndex) {\n * this.itemIndex = itemIndex;  // Capture before deletion!\n * }\n *\n * undo() {\n * canvas.items.splice(this.itemIndex, 0, itemCopy);  // Restore at index\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE deleting item (to capture index)\n * ```typescript\n * // 1. Get item and its index BEFORE deletion\n * const item = getItem('canvas1', 'item-5');\n * const index = gridState.canvases['canvas1'].items.indexOf(item);\n *\n * // 2. Create command (captures item and index)\n * const command = new DeleteItemCommand('canvas1', item, index);\n *\n * // 3. Perform deletion\n * removeItemFromCanvas('canvas1', 'item-5');\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Restore item at original position\n * ```typescript\n * command.undo(); // Item reappears at exact original position\n * ```\n *\n * **Redo**: Delete item again\n * ```typescript\n * command.redo(); // Item disappears (and selection cleared if selected)\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures complete item state before deletion\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Item will be deleted from state immediately after\n * - Reference would become invalid after deletion\n * - Must preserve complete state for restoration\n *\n * **Undo cloning**: Creates fresh copy for state insertion\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.splice(this.itemIndex, 0, itemCopy);\n * ```\n *\n * ## Selection State Handling\n *\n * **Redo behavior**: Delegates to removeItemFromCanvas helper\n *\n * **Helper automatically**:\n * - Clears selectedItemId if this item was selected\n * - Clears selectedCanvasId\n * - Prevents dangling references\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: undo() returns early if canvas not found\n * - **Invalid index**: Falls back to push() if index out of bounds\n * - **Item modified before delete**: Command stores pre-deletion state\n * - **Multiple deletes**: Each command independently tracks its item\n * @example\n * ```typescript\n * // Handle Delete key press\n * handleDeleteKey() {\n *   if (!gridState.selectedItemId || !gridState.selectedCanvasId) {\n *     return;\n *   }\n *\n *   const item = getItem(gridState.selectedCanvasId, gridState.selectedItemId);\n *   const canvas = gridState.canvases[gridState.selectedCanvasId];\n *   const index = canvas.items.indexOf(item);\n *\n *   // Create command before deleting\n *   const command = new DeleteItemCommand(\n *     gridState.selectedCanvasId,\n *     item,\n *     index\n *   );\n *\n *   // Perform deletion\n *   removeItemFromCanvas(gridState.selectedCanvasId, gridState.selectedItemId);\n *\n *   // Enable undo\n *   pushCommand(command);\n * }\n * ```\n */\nexport class DeleteItemCommand implements Command {\n  /** Deep clone of item before deletion */\n  private item: GridItem;\n\n  /** Canvas ID where item was deleted from */\n  private canvasId: string;\n\n  /** Original array index for position restoration */\n  private itemIndex: number;\n\n  /** GridState instance for multi-instance support */\n  private stateInstance: any;\n\n  /**\n   * Capture item deletion operation\n   *\n   * **Important**: Call BEFORE deleting item (to capture index)\n   *\n   * **Deep clones item**: Preserves state before deletion\n   *\n   * **Captures index**: Critical for restoring at original position\n   *\n   * **Instance-based architecture**:\n   * - Requires stateInstance parameter for multi-instance support\n   * @param canvasId - Canvas containing the item\n   * @param item - Item being deleted (will be deep cloned)\n   * @param itemIndex - Original array index (call indexOf before deletion!)\n   * @param stateInstance - GridState instance\n   */\n  constructor(\n    canvasId: string,\n    item: GridItem,\n    itemIndex: number,\n    stateInstance: any,\n  ) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state before deletion\n    this.item = JSON.parse(JSON.stringify(item));\n    this.itemIndex = itemIndex;\n    this.stateInstance = stateInstance;\n  }\n\n  /**\n   * Undo: Restore item at original position\n   *\n   * **Index preservation**: Uses splice to insert at exact original position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive coding)\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Side effects**:\n   * - Item restored to canvas.items array at original index\n   * - Other items shift to make room\n   * - Z-index order maintained (items render in array order)\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found\n   */\n  undo(): void {\n    // Re-add the item to its original position\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    // Insert at original index if possible, otherwise push to end\n    if (this.itemIndex >= 0 && this.itemIndex <= canvas.items.length) {\n      canvas.items.splice(this.itemIndex, 0, itemCopy);\n    } else {\n      canvas.items.push(itemCopy);\n    }\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n  }\n\n  /**\n   * Redo: Delete item again\n   *\n   * **Delegates to helper**: Uses removeItemFromCanvas for consistency\n   *\n   * **Automatic selection clearing**: Helper clears selection if this item selected\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  redo(): void {\n    // Remove the item again\n    removeItemFromCanvas(this.canvasId, this.item.id, this.stateInstance);\n  }\n\n  /**\n   * Get description of this command\n   * @returns Object with action type, position, and item details\n   */\n  getDescription() {\n    const { x, y, width, height } = this.item.layouts.desktop;\n    return {\n      action: \"delete\",\n      type: this.item.type,\n      position: { x, y },\n      size: { width, height },\n    };\n  }\n}\n\n/**\n * MoveItemCommand\n * ===============\n *\n * Captures the movement of a grid item within the same canvas or across canvases,\n * enabling undo/redo for drag operations with position and index preservation.\n *\n * ## Use Cases\n *\n * - User drags item to new position in same canvas\n * - User drags item across canvas boundaries (cross-canvas move)\n * - Programmatic item repositioning\n * - Layout reorganization\n *\n * ## Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between different canvases\n *\n * **Solution**: Track both source and target canvas IDs\n *\n * **Same-canvas move**:\n * ```typescript\n * sourceCanvasId === targetCanvasId\n * // Only position changes, no canvas transfer\n * ```\n *\n * **Cross-canvas move**:\n * ```typescript\n * sourceCanvasId !== targetCanvasId\n * // Item removed from source, added to target\n * // Position updated to target coordinates\n * ```\n *\n * ## Position Tracking\n *\n * **Dual position capture**:\n * - `sourcePosition`: { x, y } before drag\n * - `targetPosition`: { x, y } after drag\n *\n * **Why both needed**:\n * - Undo must restore original position\n * - Redo must restore final position\n * - Positions are in grid coordinates (not pixels)\n *\n * ## Index Preservation Pattern\n *\n * **Critical for undo**: Restore item at original array position in source canvas\n *\n * **Why important**:\n * - Maintains visual z-order consistency\n * - Restores exact pre-drag state\n * - Items render in array order\n *\n * **Implementation**:\n * ```typescript\n * // Capture source index before move\n * const sourceIndex = sourceCanvas.items.indexOf(item);\n *\n * // Restore at index on undo\n * sourceCanvas.items.splice(sourceIndex, 0, item);\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE drag operation (capture source state)\n * ```typescript\n * // 1. Capture state before drag starts\n * const sourceIndex = canvas.items.indexOf(item);\n * const sourcePos = { x: item.layouts.desktop.x, y: item.layouts.desktop.y };\n *\n * // 2. Drag completes (position updated in DOM)\n * // ...\n *\n * // 3. Create command with before/after state\n * const command = new MoveItemCommand(\n * item.id,\n * sourceCanvasId,\n * targetCanvasId,  // May be same as source\n * sourcePos,\n * targetPos,       // New position after drag\n * sourceIndex\n * );\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Move back to source at original position\n * ```typescript\n * command.undo();\n * // Item returns to source canvas at original index\n * // Position restored to sourcePosition\n * ```\n *\n * **Redo**: Move to target at new position\n * ```typescript\n * command.redo();\n * // Item moves to target canvas (appended to end)\n * // Position updated to targetPosition\n * ```\n *\n * ## State Mutation Pattern\n *\n * **Unlike Add/Delete**: Does NOT deep clone item\n *\n * **Why reference-based**:\n * - Same item object moves between canvases\n * - Only position properties mutated\n * - Efficient (no serialization overhead)\n * - Item identity preserved (same ID, zIndex, etc.)\n *\n * **What gets cloned**:\n * ```typescript\n * // Only position objects cloned (shallow)\n * this.sourcePosition = { ...sourcePosition };\n * this.targetPosition = { ...targetPosition };\n * ```\n *\n * ## Position Coordinates\n *\n * **Uses desktop layout**: `item.layouts.desktop.x/y`\n *\n * **Why desktop**:\n * - Drag handler operates on desktop coordinates\n * - Mobile layout auto-generated or separately customized\n * - Single source of truth for command\n *\n * **Grid units**: Positions stored in grid units (not pixels)\n *\n * ## Canvas Mutation Flow\n *\n * **Undo sequence** (target ‚Üí source):\n * 1. Find item in target canvas\n * 2. Remove from target.items array\n * 3. Update item.canvasId to source\n * 4. Update item position to sourcePosition\n * 5. Insert at sourceIndex in source.items\n * 6. Trigger reactivity\n *\n * **Redo sequence** (source ‚Üí target):\n * 1. Find item in source canvas\n * 2. Remove from source.items array\n * 3. Update item.canvasId to target\n * 4. Update item position to targetPosition\n * 5. Append to target.items (no index preservation for redo)\n * 6. Trigger reactivity\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: Both undo/redo return early if canvas not found\n * - **Item not found**: Returns early (defensive coding)\n * - **Same position move**: Creates valid command (user expectation)\n * - **Invalid source index**: Fallback to append (defensive)\n * @example\n * ```typescript\n * // After drag end event\n * handleDragEnd(event) {\n *   const item = getItem(sourceCanvasId, itemId);\n *   const sourceIndex = gridState.canvases[sourceCanvasId].items.indexOf(item);\n *\n *   const command = new MoveItemCommand(\n *     itemId,\n *     sourceCanvasId,\n *     targetCanvasId,  // Detected from drop target\n *     { x: oldX, y: oldY },  // Captured on drag start\n *     { x: newX, y: newY },  // Calculated from drop position\n *     sourceIndex\n *   );\n *\n *   pushCommand(command);\n * }\n * ```\n */\nexport class MoveItemCommand implements Command {\n  /** Item ID (reference to item, not deep clone) */\n  private itemId: string;\n\n  /** Canvas ID where item started */\n  private sourceCanvasId: string;\n\n  /** Canvas ID where item ended (may equal source for same-canvas move) */\n  private targetCanvasId: string;\n\n  /** Position before drag (grid coordinates) */\n  private sourcePosition: { x: number; y: number };\n\n  /** Position after drag (grid coordinates) */\n  private targetPosition: { x: number; y: number };\n\n  /** Size before operation (grid units) - optional for resize tracking */\n  private sourceSize?: { width: number; height: number };\n\n  /** Size after operation (grid units) - optional for resize tracking */\n  private targetSize?: { width: number; height: number };\n\n  /** Mobile layout before operation - captures full mobile state including customized flag */\n  private sourceMobileLayout?: {\n    x: number | null;\n    y: number | null;\n    width: number | null;\n    height: number | null;\n    customized: boolean;\n  };\n\n  /** Mobile layout after operation - captures full mobile state including customized flag */\n  private targetMobileLayout?: {\n    x: number | null;\n    y: number | null;\n    width: number | null;\n    height: number | null;\n    customized: boolean;\n  };\n\n  /** Z-index in source canvas (for undo restoration) */\n  private sourceZIndex: number;\n\n  /**\n   * Z-index in target canvas (assigned during cross-canvas move)\n   *\n   * **Cross-canvas behavior**:\n   * - Same canvas move: sourceZIndex === targetZIndex (no change)\n   * - Cross-canvas move: targetZIndex = targetCanvas.zIndexCounter++ (new z-index)\n   *\n   * **Why needed**:\n   * - Prevents z-index conflicts between canvases\n   * - Each canvas has independent z-index space\n   * - Undo must restore original z-index in source canvas\n   */\n  private targetZIndex: number;\n\n  /** Original array index in source canvas (for undo restoration) */\n  private sourceIndex: number;\n\n  /** GridState instance for multi-instance support */\n  private stateInstance: any;\n\n  /** Active viewport during operation - determines which layout to restore on undo/redo */\n  private activeViewport: string;\n\n  /**\n   * Capture item move operation\n   *\n   * **Important**: Item should already be at target position\n   *\n   * **Shallow position clone**: Prevents mutation of passed objects\n   *\n   * **No item clone**: Uses reference-based approach (item ID tracking)\n   *\n   * **Resize support**: Optional size parameters track width/height changes\n   *\n   * **Z-index handling**:\n   * - Same canvas: sourceZIndex === targetZIndex (no change)\n   * - Cross-canvas: targetZIndex assigned from targetCanvas.zIndexCounter++\n   *\n   * **Instance-based architecture**:\n   * - Requires stateInstance parameter for multi-instance support\n   *\n   * **Viewport isolation**:\n   * - activeViewport parameter determines which layout (desktop/mobile) to restore on undo/redo\n   * - Only the specified viewport's layout is modified, the other viewport remains untouched\n   * @param itemId - ID of moved item\n   * @param sourceCanvasId - Canvas where item started\n   * @param targetCanvasId - Canvas where item ended\n   * @param sourcePosition - Position before drag (will be shallow cloned)\n   * @param targetPosition - Position after drag (will be shallow cloned)\n   * @param sourceIndex - Original array index in source canvas\n   * @param sourceZIndex - Z-index in source canvas (for undo restoration)\n   * @param targetZIndex - Z-index in target canvas (assigned during move)\n   * @param sourceSize - Optional: Size before operation (for resize tracking)\n   * @param targetSize - Optional: Size after operation (for resize tracking)\n   * @param stateInstance - GridState instance\n   * @param activeViewport - Which viewport was active during operation ('desktop' | 'mobile')\n   * @param sourceMobileLayout - Optional: Mobile layout before operation (for complete state tracking)\n   * @param targetMobileLayout - Optional: Mobile layout after operation (for complete state tracking)\n   */\n  constructor(\n    itemId: string,\n    sourceCanvasId: string,\n    targetCanvasId: string,\n    sourcePosition: { x: number; y: number },\n    targetPosition: { x: number; y: number },\n    sourceIndex: number,\n    sourceZIndex: number,\n    targetZIndex: number,\n    sourceSize: { width: number; height: number } | undefined,\n    targetSize: { width: number; height: number } | undefined,\n    stateInstance: any,\n    activeViewport: string,\n    sourceMobileLayout?: {\n      x: number | null;\n      y: number | null;\n      width: number | null;\n      height: number | null;\n      customized: boolean;\n    },\n    targetMobileLayout?: {\n      x: number | null;\n      y: number | null;\n      width: number | null;\n      height: number | null;\n      customized: boolean;\n    },\n  ) {\n    this.itemId = itemId;\n    this.sourceCanvasId = sourceCanvasId;\n    this.targetCanvasId = targetCanvasId;\n    this.sourcePosition = { ...sourcePosition };\n    this.targetPosition = { ...targetPosition };\n    this.sourceIndex = sourceIndex;\n    this.sourceZIndex = sourceZIndex;\n    this.targetZIndex = targetZIndex;\n    this.sourceSize = sourceSize ? { ...sourceSize } : undefined;\n    this.targetSize = targetSize ? { ...targetSize } : undefined;\n    this.stateInstance = stateInstance;\n    this.activeViewport = activeViewport;\n    this.sourceMobileLayout = sourceMobileLayout\n      ? { ...sourceMobileLayout }\n      : undefined;\n    this.targetMobileLayout = targetMobileLayout\n      ? { ...targetMobileLayout }\n      : undefined;\n  }\n\n  /**\n   * Undo: Move item back to source canvas at original position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from target canvas\n   * - Updates canvasId back to source\n   * - Restores source position\n   * - Inserts at original index in source\n   *\n   * **Index preservation**: Uses splice to restore exact array position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive)\n   *\n   * **Side effects**:\n   * - Item removed from target canvas\n   * - Item added to source canvas at original index\n   * - Item position updated to sourcePosition\n   * - Item canvasId updated to sourceCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  undo(): void {\n    debug.log(\"üîô MoveItemCommand.undo()\", {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in target canvas first\n    let targetCanvas = this.stateInstance.canvases[this.targetCanvasId];\n    let item = targetCanvas?.items.find((i) => i.id === this.itemId);\n\n    // If target canvas doesn't exist or item not found there, search all canvases\n    // This handles the case where the target canvas was deleted\n    if (!item) {\n      for (const canvasId in this.stateInstance.canvases) {\n        const canvas = this.stateInstance.canvases[canvasId];\n        item = canvas.items.find((i) => i.id === this.itemId);\n        if (item) {\n          targetCanvas = canvas;\n          break;\n        }\n      }\n    }\n\n    if (!item || !targetCanvas) {\n      console.warn(\"  ‚ùå Item or canvas not found, aborting undo\");\n      return;\n    }\n\n    debug.log(\"  üìç Found item, current position:\", {\n      viewport: this.activeViewport,\n      x: item.layouts[this.activeViewport].x,\n      y: item.layouts[this.activeViewport].y,\n    });\n\n    // Remove from current canvas (wherever it is)\n    targetCanvas.items = targetCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's canvasId and z-index back to source\n    item.canvasId = this.sourceCanvasId;\n    item.zIndex = this.sourceZIndex;\n\n    // Restore position for the active viewport only (viewport isolation)\n    item.layouts[this.activeViewport].x = this.sourcePosition.x;\n    item.layouts[this.activeViewport].y = this.sourcePosition.y;\n\n    debug.log(\"  ‚úÖ Updated item position and z-index to:\", {\n      viewport: this.activeViewport,\n      x: item.layouts[this.activeViewport].x,\n      y: item.layouts[this.activeViewport].y,\n      zIndex: item.zIndex,\n    });\n\n    // Restore size for the active viewport only (for resize operations)\n    if (this.sourceSize) {\n      item.layouts[this.activeViewport].width = this.sourceSize.width;\n      item.layouts[this.activeViewport].height = this.sourceSize.height;\n    }\n\n    // Restore full mobile layout ONLY if we're undoing a desktop operation\n    // (Mobile operations already restored mobile via activeViewport logic above)\n    if (this.activeViewport === \"desktop\" && this.sourceMobileLayout) {\n      item.layouts.mobile = { ...this.sourceMobileLayout };\n    }\n\n    // Add back to source canvas at original index\n    const sourceCanvas = this.stateInstance.canvases[this.sourceCanvasId];\n    if (!sourceCanvas) {\n      console.warn(\"  ‚ùå Source canvas not found, aborting undo\");\n      return;\n    }\n\n    if (\n      this.sourceIndex >= 0 &&\n      this.sourceIndex <= sourceCanvas.items.length\n    ) {\n      sourceCanvas.items.splice(this.sourceIndex, 0, item);\n    } else {\n      sourceCanvas.items.push(item);\n    }\n\n    // Trigger state update\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log(\"  üé® Clearing inline transform style\");\n      element.style.transform = \"\";\n    }\n\n    debug.log(\"  ‚úÖ Undo complete\");\n  }\n\n  /**\n   * Redo: Move item to target canvas at final position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from source canvas\n   * - Updates canvasId to target\n   * - Restores target position\n   * - Appends to target canvas (no index preservation for redo)\n   *\n   * **No index preservation for redo**: Appends to end of target array\n   * (undo needs original index, redo doesn't)\n   *\n   * **Side effects**:\n   * - Item removed from source canvas\n   * - Item added to end of target canvas\n   * - Item position updated to targetPosition\n   * - Item canvasId updated to targetCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  redo(): void {\n    debug.log(\"üîú MoveItemCommand.redo()\", {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in source canvas\n    const sourceCanvas = this.stateInstance.canvases[this.sourceCanvasId];\n    const item = sourceCanvas?.items.find((i) => i.id === this.itemId);\n    if (!item) {\n      console.warn(\"  ‚ùå Item not found, aborting redo\");\n      return;\n    }\n\n    debug.log(\"  üìç Found item, current position:\", {\n      viewport: this.activeViewport,\n      x: item.layouts[this.activeViewport].x,\n      y: item.layouts[this.activeViewport].y,\n    });\n\n    // Remove from source canvas\n    sourceCanvas.items = sourceCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's canvasId and z-index to target\n    item.canvasId = this.targetCanvasId;\n    item.zIndex = this.targetZIndex;\n\n    // Restore position for the active viewport only (viewport isolation)\n    item.layouts[this.activeViewport].x = this.targetPosition.x;\n    item.layouts[this.activeViewport].y = this.targetPosition.y;\n\n    debug.log(\"  ‚úÖ Updated item position and z-index to:\", {\n      viewport: this.activeViewport,\n      x: item.layouts[this.activeViewport].x,\n      y: item.layouts[this.activeViewport].y,\n      zIndex: item.zIndex,\n    });\n\n    // Restore size for the active viewport only (for resize operations)\n    if (this.targetSize) {\n      item.layouts[this.activeViewport].width = this.targetSize.width;\n      item.layouts[this.activeViewport].height = this.targetSize.height;\n    }\n\n    // Restore full mobile layout ONLY if we're redoing a desktop operation\n    // (Mobile operations already restored mobile via activeViewport logic above)\n    if (this.activeViewport === \"desktop\" && this.targetMobileLayout) {\n      item.layouts.mobile = { ...this.targetMobileLayout };\n    }\n\n    // Add to target canvas\n    const targetCanvas = this.stateInstance.canvases[this.targetCanvasId];\n    if (!targetCanvas) {\n      console.warn(\"  ‚ùå Target canvas not found, aborting redo\");\n      return;\n    }\n\n    targetCanvas.items.push(item);\n\n    // Trigger state update\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log(\"  üé® Clearing inline transform style\");\n      element.style.transform = \"\";\n    }\n\n    debug.log(\"  ‚úÖ Redo complete\");\n  }\n\n  /**\n   * Get description of this command\n   *\n   * **Detects resize vs move**: Returns different action based on whether size changed\n   * @returns Object with action type, source/target positions and sizes\n   */\n  getDescription() {\n    // Check if this is a resize operation (size changed)\n    const isResize =\n      this.sourceSize &&\n      this.targetSize &&\n      (this.sourceSize.width !== this.targetSize.width ||\n        this.sourceSize.height !== this.targetSize.height);\n\n    return {\n      action: isResize ? \"resize\" : \"move\",\n      source: {\n        position: this.sourcePosition,\n        size: this.sourceSize,\n      },\n      target: {\n        position: this.targetPosition,\n        size: this.targetSize,\n      },\n    };\n  }\n}\n\n/**\n * UpdateItemCommand - Update item properties\n *\n * Records old item state and applies updates\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n */\nexport class UpdateItemCommand implements Command {\n  private stateInstance: any;\n\n  constructor(\n    private canvasId: string,\n    private itemId: string,\n    private oldItem: GridItem,\n    private updates: Partial<GridItem>,\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n  }\n\n  undo(): void {\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    const item = canvas?.items.find((i) => i.id === this.itemId);\n    if (item) {\n      Object.assign(item, this.oldItem);\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n    }\n  }\n\n  redo(): void {\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    const item = canvas?.items.find((i) => i.id === this.itemId);\n    if (item) {\n      Object.assign(item, this.updates);\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n    }\n  }\n\n  getDescription() {\n    return {\n      action: \"update\",\n      itemId: this.itemId,\n      updates: this.updates,\n    };\n  }\n}\n\n/**\n * RemoveItemCommand - Remove item from canvas\n *\n * Stores removed item for restoration\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n */\nexport class RemoveItemCommand implements Command {\n  private stateInstance: any;\n\n  constructor(\n    private canvasId: string,\n    private item: GridItem,\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n  }\n\n  undo(): void {\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    if (canvas) {\n      canvas.items.push(this.item);\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n    }\n  }\n\n  redo(): void {\n    removeItemFromCanvas(this.canvasId, this.item.id, this.stateInstance);\n  }\n\n  getDescription() {\n    const { x, y, width, height } = this.item.layouts.desktop;\n    return {\n      action: \"remove\",\n      type: this.item.type,\n      position: { x, y },\n      size: { width, height },\n    };\n  }\n}\n\n/**\n * SetViewportCommand - Change current viewport\n *\n * Stores old and new viewport states\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n */\nexport class SetViewportCommand implements Command {\n  private stateInstance: any;\n\n  constructor(\n    private oldViewport: string,\n    private newViewport: string,\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n  }\n\n  undo(): void {\n    this.stateInstance.currentViewport = this.oldViewport;\n  }\n\n  redo(): void {\n    this.stateInstance.currentViewport = this.newViewport;\n  }\n\n  getDescription() {\n    return {\n      action: \"setViewport\",\n      oldViewport: this.oldViewport,\n      newViewport: this.newViewport,\n    };\n  }\n}\n\n/**\n * ToggleGridCommand - Toggle grid visibility\n *\n * Stores old and new visibility states\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n */\nexport class ToggleGridCommand implements Command {\n  private stateInstance: any;\n\n  constructor(\n    private oldValue: boolean,\n    private newValue: boolean,\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n  }\n\n  undo(): void {\n    this.stateInstance.showGrid = this.oldValue;\n  }\n\n  redo(): void {\n    this.stateInstance.showGrid = this.newValue;\n  }\n\n  getDescription() {\n    return {\n      action: \"toggleGrid\",\n      oldValue: this.oldValue,\n      newValue: this.newValue,\n    };\n  }\n}\n\n/**\n * BatchAddCommand - Add multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n * Reduces undo stack size and provides atomic undo/redo for batch operations.\n *\n * **Use cases**:\n * - Stress test (add 100+ items at once)\n * - Template application (add multiple pre-configured items)\n * - Undo batch delete operation\n * - Import from file (restore multiple items)\n *\n * **Undo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Re-adds all items with original IDs and properties\n * - Maintains z-index and positioning\n * - Single state update, single re-render\n */\nexport class BatchAddCommand implements Command {\n  private itemsData: GridItem[];\n  private stateInstance: any;\n\n  constructor(itemIds: string[], stateInstance: any) {\n    this.stateInstance = stateInstance;\n    // Store full item data for redo (deep clone to prevent mutations)\n    this.itemsData = itemIds\n      .map((id) => {\n        const item = Object.values(this.stateInstance.canvases)\n          .flatMap((canvas: any) => canvas.items)\n          .find((i: any) => i.id === id);\n        return item ? JSON.parse(JSON.stringify(item)) : null;\n      })\n      .filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n\n    // Manual delete logic for instance-based state\n    const updatedCanvases = { ...this.stateInstance.canvases };\n    for (const canvasId in updatedCanvases) {\n      const canvas = updatedCanvases[canvasId];\n      canvas.items = canvas.items.filter((item) => !itemIds.includes(item.id));\n    }\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Re-add all items (addItemsBatch will generate new IDs, so we need custom logic)\n    const updatedCanvases = { ...this.stateInstance.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  getDescription() {\n    return {\n      action: \"batchAdd\",\n      itemCount: this.itemsData.length,\n      items: this.itemsData.map((item) => ({\n        id: item.id,\n        type: item.type,\n        position: { x: item.layouts.desktop.x, y: item.layouts.desktop.y },\n        size: {\n          width: item.layouts.desktop.width,\n          height: item.layouts.desktop.height,\n        },\n      })),\n    };\n  }\n}\n\n/**\n * BatchDeleteCommand - Delete multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n *\n * **Use cases**:\n * - Clear canvas (delete all items)\n * - Delete selection group\n * - Undo batch add operation\n * - Bulk cleanup operations\n *\n * **Undo behavior**:\n * - Re-adds all items with original properties and positions\n * - Maintains z-index and canvas placement\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchDeleteCommand implements Command {\n  private itemsData: GridItem[];\n  private stateInstance: any;\n\n  constructor(itemIds: string[], stateInstance: any) {\n    this.stateInstance = stateInstance;\n    // Store full item data for undo (deep clone to prevent mutations)\n    this.itemsData = itemIds\n      .map((id) => {\n        const item = Object.values(this.stateInstance.canvases)\n          .flatMap((canvas: any) => canvas.items)\n          .find((i: any) => i.id === id);\n        return item ? JSON.parse(JSON.stringify(item)) : null;\n      })\n      .filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Re-add all items (same logic as BatchAddCommand.redo)\n    const updatedCanvases = { ...this.stateInstance.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n\n    // Manual delete logic for instance-based state\n    const updatedCanvases = { ...this.stateInstance.canvases };\n    for (const canvasId in updatedCanvases) {\n      const canvas = updatedCanvases[canvasId];\n      canvas.items = canvas.items.filter((item) => !itemIds.includes(item.id));\n    }\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  getDescription() {\n    return {\n      action: \"batchDelete\",\n      itemCount: this.itemsData.length,\n      items: this.itemsData.map((item) => ({\n        id: item.id,\n        type: item.type,\n        position: { x: item.layouts.desktop.x, y: item.layouts.desktop.y },\n        size: {\n          width: item.layouts.desktop.width,\n          height: item.layouts.desktop.height,\n        },\n      })),\n    };\n  }\n}\n\n/**\n * BatchUpdateConfigCommand - Update multiple item configs in a single batch\n *\n * **Performance benefit**: 1 undo/redo command for N config updates instead of N commands.\n *\n * **Use cases**:\n * - Theme changes (update colors for all headers)\n * - Bulk property changes (set all text sizes to 16px)\n * - Template application (apply preset configs)\n * - Undo/redo bulk config changes\n *\n * **Undo behavior**:\n * - Restores all old configs in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Applies all new configs in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchUpdateConfigCommand implements Command {\n  private updates: {\n    itemId: string;\n    canvasId: string;\n    oldItem: GridItem;\n    newItem: GridItem;\n  }[];\n  private stateInstance: any;\n\n  constructor(\n    updates: {\n      itemId: string;\n      canvasId: string;\n      updates: Partial<GridItem>;\n    }[],\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n    // Store old and new state for each item (deep clone to prevent mutations)\n    this.updates = updates\n      .map(({ itemId, canvasId, updates: itemUpdates }) => {\n        const canvas = this.stateInstance.canvases[canvasId];\n        const item = canvas?.items.find((i) => i.id === itemId);\n\n        if (!item) {\n          return null;\n        }\n\n        return {\n          itemId,\n          canvasId,\n          oldItem: JSON.parse(JSON.stringify(item)),\n          newItem: JSON.parse(JSON.stringify({ ...item, ...itemUpdates })),\n        };\n      })\n      .filter(Boolean) as {\n      itemId: string;\n      canvasId: string;\n      oldItem: GridItem;\n      newItem: GridItem;\n    }[];\n  }\n\n  undo(): void {\n    // Restore old configs\n    const updatedCanvases = { ...this.stateInstance.canvases };\n    this.updates.forEach(({ itemId, canvasId, oldItem }) => {\n      const canvas = updatedCanvases[canvasId];\n      const item = canvas?.items.find((i) => i.id === itemId);\n      if (item) {\n        Object.assign(item, oldItem);\n      }\n    });\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Apply new configs\n    const updatedCanvases = { ...this.stateInstance.canvases };\n    this.updates.forEach(({ itemId, canvasId, newItem }) => {\n      const canvas = updatedCanvases[canvasId];\n      const item = canvas?.items.find((i) => i.id === itemId);\n      if (item) {\n        Object.assign(item, newItem);\n      }\n    });\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  getDescription() {\n    return {\n      action: \"batchUpdateConfig\",\n      updateCount: this.updates.length,\n      updates: this.updates.map(({ itemId, canvasId, oldItem, newItem }) => ({\n        itemId,\n        canvasId,\n        oldConfig: oldItem.config,\n        newConfig: newItem.config,\n      })),\n    };\n  }\n}\n\n/**\n * AddCanvasCommand\n * =================\n *\n * Undoable command for adding a canvas to the grid.\n *\n * **Pattern**: Host app owns canvas metadata, library manages item placement\n *\n * **Library responsibility** (what this command does):\n * - Create canvas in gridState.canvases with empty items array\n * - Initialize zIndexCounter for item stacking\n * - Track operation in undo/redo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or other metadata\n * - Host app maintains its own canvas metadata separately\n * - Host app listens to canvasAdded event to sync its state\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app maintains canvas metadata\n * const canvasMetadata = {\n * 'section-1': { title: 'Hero Section', backgroundColor: '#f0f4f8' }\n * };\n *\n * // Create canvas in library (just placement state)\n * const cmd = new AddCanvasCommand('section-1');\n * pushCommand(cmd); // Add to undo/redo stack\n * cmd.redo(); // Creates canvas with items: [], zIndexCounter: 1\n *\n * // Host app listens to event and syncs its own state\n * api.on('canvasAdded', (event) => {\n * // Host app can now add its own metadata\n * });\n * ```\n *\n * **Why this separation**:\n * - Library focuses on layout (items, positions, z-index)\n * - Host app owns presentation (styling, titles, metadata)\n * - Different apps can use library with different data models\n */\nexport class AddCanvasCommand implements Command {\n  description = \"Add Canvas\";\n  private canvasId: string;\n  private stateInstance: any; // GridState instance\n  private eventManagerInstance: any; // EventManager instance\n\n  constructor(canvasId: string, stateInstance: any, eventManagerInstance: any) {\n    this.canvasId = canvasId;\n    this.stateInstance = stateInstance;\n    this.eventManagerInstance = eventManagerInstance;\n  }\n\n  undo(): void {\n    debug.log(\"üîô AddCanvasCommand.undo() - removing canvas:\", this.canvasId);\n\n    // Remove canvas from instance state\n    delete this.stateInstance.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    debug.log(\"  üì¢ Emitting canvasRemoved event for:\", this.canvasId);\n    this.eventManagerInstance.emit(\"canvasRemoved\", {\n      canvasId: this.canvasId,\n    });\n  }\n\n  redo(): void {\n    // Add canvas to instance state (minimal - just item placement management)\n    this.stateInstance.canvases[this.canvasId] = {\n      zIndexCounter: 1,\n      items: [],\n    };\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    this.eventManagerInstance.emit(\"canvasAdded\", { canvasId: this.canvasId });\n  }\n\n  getDescription() {\n    return {\n      action: \"addCanvas\",\n      canvasId: this.canvasId,\n    };\n  }\n}\n\n/**\n * RemoveCanvasCommand\n * ====================\n *\n * Undoable command for removing a canvas from the grid.\n *\n * **Critical**: Snapshots canvas items and zIndexCounter before removal\n *\n * **Library responsibility** (what this command does):\n * - Snapshot canvas items array and zIndexCounter\n * - Remove canvas from gridState.canvases\n * - Restore canvas with all items on undo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or metadata\n * - Host app must listen to canvasRemoved event\n * - Host app must manage its own metadata undo/redo separately\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app listens to events and manages its own metadata\n * api.on('canvasRemoved', (event) => {\n * // Host app removes its own metadata\n * delete canvasMetadata[event.canvasId];\n * });\n *\n * api.on('canvasAdded', (event) => {\n * // On undo of remove, host app restores metadata\n * if (wasUndoOperation) {\n * canvasMetadata[event.canvasId] = savedMetadata;\n * }\n * });\n *\n * // Remove canvas\n * const cmd = new RemoveCanvasCommand('section-1');\n * pushCommand(cmd);\n * cmd.redo(); // Removes canvas from library\n * ```\n *\n * **Edge case handling**:\n * - Canvas doesn't exist: command becomes no-op\n * - Canvas has items: all items removed with canvas\n * - Undo restores items with original layouts and zIndex\n */\nexport class RemoveCanvasCommand implements Command {\n  description = \"Remove Canvas\";\n  private canvasId: string;\n  private stateInstance: any; // GridState instance\n  private eventManagerInstance: any; // EventManager instance\n  private canvasSnapshot: {\n    zIndexCounter: number;\n    items: GridItem[];\n  } | null = null;\n\n  constructor(canvasId: string, stateInstance: any, eventManagerInstance: any) {\n    this.canvasId = canvasId;\n    this.stateInstance = stateInstance;\n    this.eventManagerInstance = eventManagerInstance;\n\n    // Snapshot canvas state (deep clone to prevent mutations)\n    const canvas = this.stateInstance.canvases[canvasId];\n    if (canvas) {\n      this.canvasSnapshot = JSON.parse(JSON.stringify(canvas));\n    }\n  }\n\n  undo(): void {\n    // Restore canvas from snapshot (just layout state, no metadata)\n    if (this.canvasSnapshot) {\n      this.stateInstance.canvases[this.canvasId] = JSON.parse(\n        JSON.stringify(this.canvasSnapshot),\n      );\n\n      // Trigger state change for reactivity\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n      // Emit event so host app can sync its metadata\n      this.eventManagerInstance.emit(\"canvasAdded\", {\n        canvasId: this.canvasId,\n      });\n    }\n  }\n\n  redo(): void {\n    // Remove canvas from instance state\n    delete this.stateInstance.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    this.eventManagerInstance.emit(\"canvasRemoved\", {\n      canvasId: this.canvasId,\n    });\n  }\n\n  getDescription() {\n    return {\n      action: \"removeCanvas\",\n      canvasId: this.canvasId,\n      itemCount: this.canvasSnapshot?.items.length || 0,\n    };\n  }\n}\n\n/**\n * Change Z-Index Command\n * ======================\n *\n * Handles undo/redo for z-index changes (layer reordering).\n * Supports both single-item changes and multi-item swaps.\n *\n * **Use cases**:\n * - Layer panel drag-to-reorder (swap with other item)\n * - Bring to front / send to back (single item)\n * - Move forward / move backward (swap with adjacent item)\n * - Direct z-index assignment (single item)\n *\n * **What it captures**:\n * - Array of z-index changes (supports cascading/swap operations)\n * - Each change: { itemId, canvasId, oldZIndex, newZIndex }\n *\n * **Why array-based**:\n * - Move forward/backward swaps z-index with adjacent item (2 items affected)\n * - Drag-to-reorder can shuffle multiple items\n * - Undo must atomically restore all affected items\n *\n * **Operation**:\n * - Updates all items' zIndex properties in single undo/redo operation\n * - Maintains canvas zIndexCounter\n * - Triggers reactivity once for UI updates\n * - Emits events for layer panel to update\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n * - Operates on instance state\n *\n * **Example usage**:\n * ```typescript\n * // Instance-based (multi-grid support)\n * const cmd = new ChangeZIndexCommand(\n *   changes,\n *   eventManager,\n *   stateInstance\n * );\n * ```\n *\n * **Edge case handling**:\n * - Item doesn't exist: skips that item (doesn't fail entire command)\n * - Canvas doesn't exist: skips that item\n * - Undo restores exact z-index values for all items\n * - Maintains visual layer order across all affected items\n */\nexport class ChangeZIndexCommand implements Command {\n  description: string;\n  private changes: {\n    itemId: string;\n    canvasId: string;\n    oldZIndex: number;\n    newZIndex: number;\n  }[];\n  private eventManager: EventManager;\n  private stateInstance: any; // GridState instance\n\n  constructor(\n    changes: {\n      itemId: string;\n      canvasId: string;\n      oldZIndex: number;\n      newZIndex: number;\n    }[],\n    eventManager: EventManager,\n    stateInstance: any,\n  ) {\n    this.changes = changes;\n    this.eventManager = eventManager;\n    this.stateInstance = stateInstance;\n\n    // Descriptive message for command history\n    if (changes.length === 1) {\n      const change = changes[0];\n      this.description = `Change Z-Index (${change.oldZIndex} ‚Üí ${change.newZIndex})`;\n    } else {\n      this.description = `Reorder ${changes.length} Layers`;\n    }\n  }\n\n  undo(): void {\n    // Restore old z-index for all affected items\n    this.changes.forEach((change) => {\n      const canvas = this.stateInstance.canvases[change.canvasId];\n      const item = canvas?.items.find((i) => i.id === change.itemId);\n      if (item) {\n        item.zIndex = change.oldZIndex;\n        debug.log(\n          `Undo z-index change: ${change.itemId} from ${change.newZIndex} to ${change.oldZIndex}`,\n        );\n      }\n    });\n\n    // Trigger reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit single event (batch or individual based on change count)\n    if (this.changes.length === 1) {\n      const change = this.changes[0];\n      this.eventManager.emit(\"zIndexChanged\", {\n        itemId: change.itemId,\n        canvasId: change.canvasId,\n        oldZIndex: change.newZIndex, // Swapped for undo\n        newZIndex: change.oldZIndex,\n      });\n    } else {\n      // Emit batch event for atomic update\n      this.eventManager.emit(\"zIndexBatchChanged\", {\n        changes: this.changes.map((change) => ({\n          itemId: change.itemId,\n          canvasId: change.canvasId,\n          oldZIndex: change.newZIndex, // Swapped for undo\n          newZIndex: change.oldZIndex,\n        })),\n      });\n    }\n  }\n\n  redo(): void {\n    // Reapply new z-index for all affected items\n    this.changes.forEach((change) => {\n      const canvas = this.stateInstance.canvases[change.canvasId];\n      const item = canvas?.items.find((i) => i.id === change.itemId);\n      if (item) {\n        item.zIndex = change.newZIndex;\n        debug.log(\n          `Redo z-index change: ${change.itemId} from ${change.oldZIndex} to ${change.newZIndex}`,\n        );\n      }\n    });\n\n    // Trigger reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit single event (batch or individual based on change count)\n    if (this.changes.length === 1) {\n      const change = this.changes[0];\n      this.eventManager.emit(\"zIndexChanged\", {\n        itemId: change.itemId,\n        canvasId: change.canvasId,\n        oldZIndex: change.oldZIndex,\n        newZIndex: change.newZIndex,\n      });\n    } else {\n      // Emit batch event for atomic update\n      this.eventManager.emit(\"zIndexBatchChanged\", {\n        changes: this.changes.map((change) => ({\n          itemId: change.itemId,\n          canvasId: change.canvasId,\n          oldZIndex: change.oldZIndex,\n          newZIndex: change.newZIndex,\n        })),\n      });\n    }\n  }\n\n  getDescription() {\n    return {\n      action: \"changeZIndex\",\n      changeCount: this.changes.length,\n      changes: this.changes.map((change) => ({\n        itemId: change.itemId,\n        canvasId: change.canvasId,\n        oldZIndex: change.oldZIndex,\n        newZIndex: change.newZIndex,\n      })),\n    };\n  }\n}\n","/**\n * Error Handler Utilities (Generic - Extractable)\n * ================================================\n *\n * Generic error classification, formatting, and context extraction utilities.\n * Zero dependencies on grid-builder - can be extracted to standalone package.\n *\n * ## Design Principles\n *\n * **Pure Functions**:\n * - No side effects (no logging, no state mutation)\n * - Deterministic output for same input\n * - Composable and testable\n *\n * **Generic and Reusable**:\n * - Works with any Error subclass\n * - No assumptions about application structure\n * - Extensible classification rules\n *\n * **Browser Compatible**:\n * - Uses standard Error properties\n * - Handles browser differences gracefully\n * - Works in all modern browsers\n * @module error-handler\n */\n\nimport {\n  ErrorSeverity,\n  ErrorClassification,\n  BaseErrorInfo,\n  BaseErrorEventDetail,\n} from \"../types/error-types\";\n\n/**\n * Classify error by type and determine handling strategy\n *\n * **Purpose**: Categorize errors for appropriate handling\n * **Pure Function**: No side effects, deterministic\n *\n * **Classification Logic**:\n * 1. Check error name and message for known patterns\n * 2. Assign severity based on error type\n * 3. Determine if recoverable or critical\n * 4. Decide if should be reported to monitoring\n *\n * **Error Types**:\n * - `network`: Failed fetch, timeout, offline\n * - `validation`: Invalid input, constraint violation\n * - `permission`: Access denied, authentication failed\n * - `runtime`: TypeError, ReferenceError, null pointer\n * - `timeout`: Operation took too long\n * - `unknown`: Unrecognized error type\n *\n * **Example**:\n * ```typescript\n * const error = new TypeError('Cannot read property of undefined');\n * const classification = classifyError(error);\n * // {\n * //   type: 'runtime',\n * //   severity: 'error',\n * //   recoverable: true,\n * //   shouldReport: true,\n * //   userMessage: 'An unexpected error occurred. Please try again.'\n * // }\n * ```\n * @param error - Error object to classify\n * @returns Classification result with type, severity, and recovery info\n */\nexport function classifyError(error: Error): ErrorClassification {\n  const errorName = error.name.toLowerCase();\n  const errorMessage = error.message.toLowerCase();\n\n  // Network errors (recoverable, user should retry)\n  if (\n    errorName.includes(\"network\") ||\n    errorMessage.includes(\"network\") ||\n    errorMessage.includes(\"fetch\") ||\n    errorMessage.includes(\"timeout\") ||\n    errorMessage.includes(\"offline\")\n  ) {\n    return {\n      type: \"network\",\n      severity: \"error\",\n      recoverable: true,\n      shouldReport: true,\n      userMessage: \"Network error. Please check your connection and try again.\",\n    };\n  }\n\n  // Validation errors (recoverable, expected, don't spam logs)\n  if (\n    errorName.includes(\"validation\") ||\n    errorMessage.includes(\"invalid\") ||\n    errorMessage.includes(\"required\") ||\n    errorMessage.includes(\"must be\")\n  ) {\n    return {\n      type: \"validation\",\n      severity: \"warning\",\n      recoverable: true,\n      shouldReport: false, // Expected errors, don't spam monitoring\n      userMessage: \"Please check your input and try again.\",\n    };\n  }\n\n  // Permission/Auth errors (critical, user needs to login)\n  if (\n    errorName.includes(\"auth\") ||\n    errorName.includes(\"permission\") ||\n    errorMessage.includes(\"unauthorized\") ||\n    errorMessage.includes(\"forbidden\") ||\n    errorMessage.includes(\"access denied\")\n  ) {\n    return {\n      type: \"permission\",\n      severity: \"critical\",\n      recoverable: false,\n      shouldReport: true,\n      userMessage: \"You do not have permission to perform this action.\",\n    };\n  }\n\n  // Timeout errors (recoverable, user should retry)\n  if (errorMessage.includes(\"timeout\") || errorMessage.includes(\"timed out\")) {\n    return {\n      type: \"timeout\",\n      severity: \"warning\",\n      recoverable: true,\n      shouldReport: true,\n      userMessage: \"Operation timed out. Please try again.\",\n    };\n  }\n\n  // Runtime errors (recoverable, developer should fix)\n  if (\n    errorName === \"typeerror\" ||\n    errorName === \"referenceerror\" ||\n    errorName === \"rangeerror\" ||\n    errorMessage.includes(\"undefined\") ||\n    errorMessage.includes(\"null\")\n  ) {\n    return {\n      type: \"runtime\",\n      severity: \"error\",\n      recoverable: true,\n      shouldReport: true,\n      userMessage: \"An unexpected error occurred. Please try again.\",\n    };\n  }\n\n  // Unknown error type (assume recoverable, report for investigation)\n  return {\n    type: \"unknown\",\n    severity: \"error\",\n    recoverable: true,\n    shouldReport: true,\n    userMessage: \"Something went wrong. Please try again.\",\n  };\n}\n\n/**\n * Extract component stack from error\n *\n * **Purpose**: Build component hierarchy string for debugging\n * **Pure Function**: No side effects\n *\n * **Extraction Strategy**:\n * 1. Check error.stack for component names\n * 2. Parse stack frames for component identifiers\n * 3. Build hierarchy string (e.g., \"Parent > Child > GrandChild\")\n *\n * **Note**: StencilJS doesn't provide React-like componentStack,\n * so we extract what we can from error.stack\n *\n * **Example**:\n * ```typescript\n * const stack = extractComponentStack(error);\n * // \"grid-builder > canvas-section > grid-item-wrapper\"\n * ```\n * @param error - Error object with stack trace\n * @returns Component hierarchy string or undefined if not available\n */\nexport function extractComponentStack(error: Error): string | undefined {\n  if (!error.stack) {\n    return undefined;\n  }\n\n  // Extract component-like names from stack (web component tags)\n  const componentPattern = /(?:at )?([a-z]+-[a-z-]+)/gi;\n  const matches = error.stack.match(componentPattern);\n\n  if (!matches || matches.length === 0) {\n    return undefined;\n  }\n\n  // Remove duplicates and build hierarchy\n  const uniqueComponents = Array.from(\n    new Set(matches.map((m) => m.replace(/^at /, \"\"))),\n  );\n\n  return uniqueComponents.join(\" > \");\n}\n\n/**\n * Format error message for display\n *\n * **Purpose**: Create user-friendly error message\n * **Pure Function**: No side effects\n *\n * **Formatting Logic**:\n * 1. Use classification.userMessage if available\n * 2. Fall back to error.message if concise\n * 3. Use generic message for cryptic errors\n *\n * **Development vs Production**:\n * - Development: Include technical details\n * - Production: User-friendly messages only\n *\n * **Example**:\n * ```typescript\n * const message = formatErrorMessage(error, classification, true);\n * // Dev: \"TypeError: Cannot read property 'foo' of undefined\"\n * // Prod: \"An unexpected error occurred. Please try again.\"\n * ```\n * @param error - Error object\n * @param classification - Error classification result\n * @param isDevelopment - Whether in development mode (show technical details)\n * @returns Formatted error message\n */\nexport function formatErrorMessage(\n  error: Error,\n  classification: ErrorClassification,\n  isDevelopment: boolean = false,\n): string {\n  // Development: Show technical error message\n  if (isDevelopment) {\n    return `${error.name}: ${error.message}`;\n  }\n\n  // Production: Use user-friendly message from classification\n  if (classification.userMessage) {\n    return classification.userMessage;\n  }\n\n  // Fallback: Use error message if short and readable\n  if (error.message && error.message.length < 100) {\n    return error.message;\n  }\n\n  // Last resort: Generic message\n  return \"An error occurred. Please try again.\";\n}\n\n/**\n * Build error event detail\n *\n * **Purpose**: Create type-safe error event payload\n * **Pure Function**: No side effects\n *\n * **Event Structure**:\n * ```typescript\n * {\n * error: Error,\n * errorInfo: { errorBoundary, timestamp, componentStack, ...context },\n * severity: 'critical' | 'error' | 'warning' | 'info',\n * recoverable: boolean\n * }\n * ```\n *\n * **Usage**:\n * ```typescript\n * const detail = buildErrorEventDetail(\n * error,\n * 'my-component',\n * { userId: '123' }\n * );\n *\n * const event = new CustomEvent('error', { detail });\n * element.dispatchEvent(event);\n * ```\n * @param error - Error object\n * @param errorBoundary - Which boundary caught the error\n * @param additionalContext - Domain-specific context to merge\n * @returns Complete error event detail\n */\nexport function buildErrorEventDetail(\n  error: Error,\n  errorBoundary: string,\n  additionalContext?: Record<string, any>,\n): BaseErrorEventDetail {\n  const classification = classifyError(error);\n  const componentStack = extractComponentStack(error);\n\n  const errorInfo: BaseErrorInfo = {\n    errorBoundary,\n    timestamp: Date.now(),\n    userAgent:\n      typeof navigator !== \"undefined\" ? navigator.userAgent : undefined,\n    componentStack,\n    ...additionalContext,\n  };\n\n  return {\n    error,\n    errorInfo,\n    severity: classification.severity,\n    recoverable: classification.recoverable,\n  };\n}\n\n/**\n * Sanitize error for logging\n *\n * **Purpose**: Remove sensitive data before logging\n * **Pure Function**: Returns new object, doesn't mutate input\n *\n * **Sanitization**:\n * - Remove passwords, tokens, API keys from message\n * - Redact email addresses\n * - Strip query parameters from URLs\n * - Remove stack traces in production (optionally)\n *\n * **Example**:\n * ```typescript\n * const error = new Error('Auth failed for token=abc123');\n * const sanitized = sanitizeError(error);\n * // Error: 'Auth failed for token=REDACTED'\n * ```\n * @param error - Error object to sanitize\n * @param removeStack - Whether to remove stack trace (default: false)\n * @returns Sanitized error object (new instance)\n */\nexport function sanitizeError(\n  error: Error,\n  removeStack: boolean = false,\n): Error {\n  const sanitized = new Error(sanitizeString(error.message));\n  sanitized.name = error.name;\n\n  if (!removeStack && error.stack) {\n    sanitized.stack = sanitizeString(error.stack);\n  }\n\n  return sanitized;\n}\n\n/**\n * Sanitize string (remove sensitive data)\n *\n * **Purpose**: Strip sensitive information from strings\n * **Pure Function**: Returns new string\n *\n * **Patterns Redacted**:\n * - `password=xxx` ‚Üí `password=REDACTED`\n * - `token=xxx` ‚Üí `token=REDACTED`\n * - `key=xxx` ‚Üí `key=REDACTED`\n * - Email addresses ‚Üí `***@***.***`\n * @param str - String to sanitize\n * @returns Sanitized string\n */\nfunction sanitizeString(str: string): string {\n  return str\n    .replace(/password=([^&\\s]+)/gi, \"password=REDACTED\")\n    .replace(/token=([^&\\s]+)/gi, \"token=REDACTED\")\n    .replace(/key=([^&\\s]+)/gi, \"key=REDACTED\")\n    .replace(/api[-_]?key=([^&\\s]+)/gi, \"api_key=REDACTED\")\n    .replace(\n      /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g,\n      \"***@***.***\",\n    );\n}\n\n/**\n * Check if error should be reported to monitoring\n *\n * **Purpose**: Filter out noise from error monitoring (Sentry, etc.)\n * **Pure Function**: Deterministic boolean result\n *\n * **Don't Report**:\n * - Validation errors (expected)\n * - User-triggered errors (cancelled operations)\n * - Known browser quirks (ResizeObserver loop limit)\n *\n * **Always Report**:\n * - Runtime errors (TypeError, ReferenceError)\n * - Network errors (fetch failures)\n * - Unknown errors (need investigation)\n *\n * **Example**:\n * ```typescript\n * if (shouldReportError(error)) {\n * Sentry.captureException(error);\n * }\n * ```\n * @param error - Error object\n * @returns true if should be reported to monitoring\n */\nexport function shouldReportError(error: Error): boolean {\n  const classification = classifyError(error);\n\n  // Don't report validation errors (expected)\n  if (classification.type === \"validation\") {\n    return false;\n  }\n\n  // Don't report ResizeObserver loop limit (browser quirk)\n  if (error.message.includes(\"ResizeObserver loop\")) {\n    return false;\n  }\n\n  // Report based on classification\n  return classification.shouldReport;\n}\n\n/**\n * Get error severity icon (emoji)\n *\n * **Purpose**: Visual indicator for error severity\n * **Pure Function**: Maps severity ‚Üí emoji\n *\n * **Icons**:\n * - critical: üî¥ (red circle)\n * - error: ‚ö†Ô∏è (warning sign)\n * - warning: ‚ö° (lightning bolt)\n * - info: ‚ÑπÔ∏è (information)\n * @param severity - Error severity level\n * @returns Emoji icon\n */\nexport function getErrorIcon(severity: ErrorSeverity): string {\n  switch (severity) {\n    case \"critical\":\n      return \"üî¥\";\n    case \"error\":\n      return \"‚ö†Ô∏è\";\n    case \"warning\":\n      return \"‚ö°\";\n    case \"info\":\n      return \"‚ÑπÔ∏è\";\n    default:\n      return \"‚ùì\";\n  }\n}\n\n/**\n * Truncate error message for display\n *\n * **Purpose**: Prevent UI overflow from long error messages\n * **Pure Function**: Returns truncated string\n *\n * **Truncation**:\n * - Limit to maxLength characters\n * - Add ellipsis if truncated\n * - Keep full message in development mode\n * @param message - Error message to truncate\n * @param maxLength - Maximum length (default: 100)\n * @param isDevelopment - Whether in development mode (no truncation)\n * @returns Truncated message\n */\nexport function truncateErrorMessage(\n  message: string,\n  maxLength: number = 100,\n  isDevelopment: boolean = false,\n): string {\n  // Don't truncate in development mode\n  if (isDevelopment) {\n    return message;\n  }\n\n  if (message.length <= maxLength) {\n    return message;\n  }\n\n  return message.substring(0, maxLength - 3) + \"...\";\n}\n\n/**\n * Check if error is a development-only issue\n *\n * **Purpose**: Identify errors that only occur in development\n * **Pure Function**: Boolean result\n *\n * **Dev-Only Errors**:\n * - HMR (Hot Module Replacement) errors\n * - Source map warnings\n * - Stencil build warnings\n *\n * **Use Case**: Don't show dev-only errors in production UI\n * @param error - Error object\n * @returns true if dev-only error\n */\nexport function isDevelopmentOnlyError(error: Error): boolean {\n  const message = error.message.toLowerCase();\n\n  return (\n    message.includes(\"hmr\") ||\n    message.includes(\"hot reload\") ||\n    message.includes(\"source map\") ||\n    message.includes(\"[stencil]\")\n  );\n}\n","/**\n * Breakpoint Utilities\n * ======================\n *\n * Utilities for multi-breakpoint responsive layout management.\n * Handles viewport detection, layout resolution, auto-stacking, and inheritance.\n *\n * ## Core Functions\n *\n * 1. **getViewportForWidth()** - Determine which breakpoint matches container width\n * 2. **getEffectiveLayout()** - Resolve actual layout to render (with fallback/inheritance)\n * 3. **shouldAutoStack()** - Check if breakpoint uses auto-stacking\n * 4. **calculateAutoStackLayout()** - Calculate stacked y-position for items\n * 5. **initializeLayouts()** - Create default layouts for all breakpoints\n *\n * ## Layout Resolution Algorithm\n *\n * For any given breakpoint, determine which layout to render:\n *\n * 1. If item has layout for breakpoint AND `customized: true` ‚Üí use it\n * 2. If breakpoint has `layoutMode: 'inherit'` ‚Üí follow `inheritFrom` chain\n * 3. Otherwise ‚Üí find nearest customized breakpoint by width distance\n * 4. Ultimate fallback ‚Üí largest breakpoint (typically 'desktop')\n *\n * ## Performance\n *\n * - Viewport detection: O(n) where n = number of breakpoints (3-5 typically)\n * - Layout resolution: O(n log n) for sorting, ~10-15 comparisons worst case\n * - Auto-stack calculation: O(m) where m = number of items in canvas\n * @module breakpoint-utils\n */\n\nimport { BreakpointConfig, LayoutConfig } from \"../services/state-manager\";\n\n/**\n * Get viewport name for container width\n *\n * Determines which breakpoint applies based on container width using\n * mobile-first approach (largest matching minWidth wins).\n *\n * **Algorithm**:\n * 1. Sort breakpoints by minWidth (largest to smallest)\n * 2. Return first breakpoint where width >= minWidth\n * 3. If no match, return smallest breakpoint\n *\n * **Examples**:\n * ```typescript\n * const breakpoints = {\n * mobile: { minWidth: 0 },\n * tablet: { minWidth: 768 },\n * desktop: { minWidth: 1024 }\n * };\n *\n * getViewportForWidth(500, breakpoints);  // 'mobile'\n * getViewportForWidth(800, breakpoints);  // 'tablet'\n * getViewportForWidth(1200, breakpoints); // 'desktop'\n * ```\n * @param width - Container width in pixels\n * @param breakpoints - Breakpoint configuration\n * @returns Breakpoint name that matches width\n */\nexport function getViewportForWidth(\n  width: number,\n  breakpoints: BreakpointConfig,\n): string {\n  const sorted = Object.entries(breakpoints).sort(\n    ([, a], [, b]) => b.minWidth - a.minWidth,\n  ); // Largest to smallest\n\n  for (const [name, def] of sorted) {\n    if (width >= def.minWidth) return name;\n  }\n\n  // Fallback to smallest breakpoint (should never happen if 0px breakpoint exists)\n  return sorted[sorted.length - 1][0];\n}\n\n/**\n * Get effective layout with inheritance/fallback\n *\n * Resolves which layout to actually render for a given breakpoint,\n * handling customization, inheritance, and fallback logic.\n *\n * **Resolution Priority**:\n * 1. If layout exists and `customized: true` ‚Üí use it\n * 1.5. If `layoutMode: 'stack'` and layout has values ‚Üí use it, but sourceBreakpoint = nearest customized\n * 2. If `layoutMode: 'inherit'` and `inheritFrom` defined ‚Üí recursively resolve\n * 3. Otherwise ‚Üí find nearest customized breakpoint by width\n * 4. Ultimate fallback ‚Üí largest breakpoint\n *\n * **Example (inheritance)**:\n * ```typescript\n * const item = {\n * layouts: {\n * desktop: { x: 10, y: 10, width: 20, height: 10, customized: true },\n * tablet: { x: null, y: null, width: null, height: null, customized: false }\n * }\n * };\n *\n * const breakpoints = {\n * tablet: { minWidth: 768, layoutMode: 'inherit', inheritFrom: 'desktop' },\n * desktop: { minWidth: 1024, layoutMode: 'manual' }\n * };\n *\n * const result = getEffectiveLayout(item, 'tablet', breakpoints);\n * // Returns: { layout: desktop layout, sourceBreakpoint: 'desktop' }\n * ```\n *\n * **Example (stack mode with reference breakpoint)**:\n * ```typescript\n * const item = {\n * layouts: {\n * desktop: { x: 10, y: 20, width: 20, height: 10, customized: true },\n * mobile: { x: 0, y: 0, width: 50, height: 10, customized: false }\n * }\n * };\n *\n * const breakpoints = {\n * mobile: { minWidth: 0, layoutMode: 'stack' },\n * desktop: { minWidth: 768, layoutMode: 'manual' }\n * };\n *\n * const result = getEffectiveLayout(item, 'mobile', breakpoints);\n * // Returns: { layout: mobile layout, sourceBreakpoint: 'desktop' }\n * // sourceBreakpoint = 'desktop' so stacking order uses desktop's y-position\n * ```\n * @param item - Grid item with layouts\n * @param targetBreakpoint - Breakpoint name to get layout for\n * @param breakpoints - Breakpoint configuration\n * @returns Object with resolved layout and source breakpoint name\n */\nexport function getEffectiveLayout(\n  item: any, // GridItem type\n  targetBreakpoint: string,\n  breakpoints: BreakpointConfig,\n): { layout: LayoutConfig; sourceBreakpoint: string } {\n  const layout = item.layouts[targetBreakpoint];\n  const breakpointDef = breakpoints[targetBreakpoint];\n\n  // Priority 1: If customized, use it\n  if (layout?.customized) {\n    return { layout, sourceBreakpoint: targetBreakpoint };\n  }\n\n  // Priority 1.5: If layoutMode='stack' and layout has valid values, use it (for auto-stacking)\n  // This ensures stack-mode layouts with customized: false are returned so auto-stacking can be applied\n  // Only use it if layout has valid dimensions (not all null)\n  if (\n    breakpointDef?.layoutMode === \"stack\" &&\n    layout &&\n    (layout.x !== null ||\n      layout.y !== null ||\n      layout.width !== null ||\n      layout.height !== null)\n  ) {\n    // Find the reference breakpoint for visual ordering (nearest customized or largest manual)\n    const targetWidth = breakpointDef?.minWidth ?? 0;\n    const sorted = Object.keys(breakpoints)\n      .filter((name) => item.layouts[name]?.customized)\n      .sort(\n        (a, b) =>\n          Math.abs(breakpoints[a].minWidth - targetWidth) -\n          Math.abs(breakpoints[b].minWidth - targetWidth),\n      );\n\n    let referenceBreakpoint = targetBreakpoint;\n    if (sorted.length > 0) {\n      // Use nearest customized breakpoint as reference for visual ordering\n      referenceBreakpoint = sorted[0];\n    } else {\n      // Fallback to largest breakpoint\n      const largest = Object.entries(breakpoints).sort(\n        ([, a], [, b]) => b.minWidth - a.minWidth,\n      )[0][0];\n      referenceBreakpoint = largest;\n    }\n\n    return { layout, sourceBreakpoint: referenceBreakpoint };\n  }\n\n  // Priority 2: If layoutMode='inherit', follow inheritFrom chain\n  if (breakpointDef?.layoutMode === \"inherit\" && breakpointDef.inheritFrom) {\n    const inheritedFrom = breakpointDef.inheritFrom;\n    if (item.layouts[inheritedFrom]) {\n      return getEffectiveLayout(item, inheritedFrom, breakpoints);\n    }\n  }\n\n  // Priority 3: Find nearest customized breakpoint by width\n  const targetWidth = breakpointDef?.minWidth ?? 0;\n  const sorted = Object.keys(breakpoints)\n    .filter((name) => item.layouts[name]?.customized)\n    .sort(\n      (a, b) =>\n        Math.abs(breakpoints[a].minWidth - targetWidth) -\n        Math.abs(breakpoints[b].minWidth - targetWidth),\n    );\n\n  if (sorted.length > 0) {\n    return {\n      layout: item.layouts[sorted[0]],\n      sourceBreakpoint: sorted[0],\n    };\n  }\n\n  // Priority 4: Fallback to largest breakpoint\n  const largest = Object.entries(breakpoints).sort(\n    ([, a], [, b]) => b.minWidth - a.minWidth,\n  )[0][0];\n\n  return {\n    layout: item.layouts[largest],\n    sourceBreakpoint: largest,\n  };\n}\n\n/**\n * Check if breakpoint uses auto-stacking\n *\n * Determines whether items should stack vertically based on breakpoint's layoutMode.\n *\n * **Returns true when**:\n * - Breakpoint has `layoutMode: 'stack'`\n * - Example: Mobile breakpoints often use auto-stacking\n *\n * **Returns false when**:\n * - Breakpoint has `layoutMode: 'manual'` (default)\n * - Breakpoint has `layoutMode: 'inherit'`\n * - Breakpoint definition not found\n *\n * **Usage**:\n * ```typescript\n * if (shouldAutoStack(currentViewport, breakpoints) && !layout.customized) {\n * // Calculate stacked y-position\n * actualLayout = calculateAutoStackLayout(...);\n * }\n * ```\n * @param breakpoint - Breakpoint name to check\n * @param breakpoints - Breakpoint configuration\n * @returns true if breakpoint uses auto-stacking, false otherwise\n */\nexport function shouldAutoStack(\n  breakpoint: string,\n  breakpoints: BreakpointConfig,\n): boolean {\n  const def = breakpoints[breakpoint];\n  return def?.layoutMode === \"stack\";\n}\n\n/**\n * Calculate auto-stacked layout for an item\n *\n * Used when `layoutMode: 'stack'` and `customized: false`.\n * Calculates cumulative y-position by summing heights of all previous items\n * in visual order (sorted by y-position, then z-index of source breakpoint).\n *\n * **Stacking Algorithm**:\n * 1. Sort items by source breakpoint's y-position (ascending)\n * 2. For items with same y-position, sort by z-index (ascending)\n * 3. Calculate cumulative heights in that order\n * ```\n * item1.y = 0\n * item2.y = item1.height\n * item3.y = item1.height + item2.height\n * item4.y = item1.height + item2.height + item3.height\n * ```\n *\n * **Output Layout**:\n * - x: 0 (left edge)\n * - y: cumulative height of all previous items (in visual order)\n * - width: 50 (full width, 50 grid units = 100% of 50-unit canvas)\n * - height: source breakpoint's height (maintains aspect ratio)\n * - customized: false\n *\n * **Example**:\n * ```typescript\n * const items = [\n * { id: '1', zIndex: 1, layouts: { desktop: { y: 10, height: 10 } } },\n * { id: '2', zIndex: 2, layouts: { desktop: { y: 0, height: 15 } } },  // Stacks first (y=0)\n * { id: '3', zIndex: 3, layouts: { desktop: { y: 10, height: 8 } } }   // Stacks second (y=10, z=1)\n * ];\n *\n * // Visual order: item2 (y=0), item1 (y=10, z=1), item3 (y=10, z=3)\n * calculateAutoStackLayout(items[2], items, 'desktop');\n * // Returns: { x: 0, y: 25, width: 50, height: 8, customized: false }\n * //           (y = item2.height + item1.height = 15 + 10)\n * ```\n * @param item - Grid item to calculate layout for\n * @param canvasItems - All items in canvas (for cumulative height calculation)\n * @param sourceBreakpoint - Breakpoint to use for height reference and visual order\n * @returns Calculated auto-stack layout\n */\nexport function calculateAutoStackLayout(\n  item: any, // GridItem type\n  canvasItems: any[], // GridItem[] type\n  sourceBreakpoint: string,\n): LayoutConfig {\n  // Sort items by visual order in source breakpoint (y-position, then z-index)\n  const sortedItems = [...canvasItems].sort((a, b) => {\n    const aLayout = a.layouts[sourceBreakpoint];\n    const bLayout = b.layouts[sourceBreakpoint];\n    const aY = aLayout?.y ?? 0;\n    const bY = bLayout?.y ?? 0;\n\n    // Primary sort: y-position\n    if (aY !== bY) {\n      return aY - bY;\n    }\n\n    // Secondary sort: z-index (lower z-index stacks first)\n    const aZ = a.zIndex ?? 0;\n    const bZ = b.zIndex ?? 0;\n    return aZ - bZ;\n  });\n\n  const itemIndex = sortedItems.findIndex((i) => i.id === item.id);\n\n  // Calculate cumulative y-position from previous items (in visual order)\n  let yPosition = 0;\n  if (itemIndex > 0) {\n    for (let i = 0; i < itemIndex; i++) {\n      const prevItem = sortedItems[i];\n      const prevLayout = prevItem.layouts[sourceBreakpoint];\n      yPosition += prevLayout?.height ?? 6; // Fallback to 6 grid units\n    }\n  }\n\n  // Use source breakpoint's height\n  const sourceLayout = item.layouts[sourceBreakpoint];\n\n  return {\n    x: 0,\n    y: yPosition,\n    width: 50, // Full width (50 units = 100% of 50-unit canvas)\n    height: sourceLayout?.height ?? 6,\n    customized: false,\n  };\n}\n\n/**\n * Initialize layouts for new item across all breakpoints\n *\n * Creates initial layout configurations for all breakpoints when adding a new item.\n * Largest breakpoint gets the base layout with `customized: true`,\n * others get defaults based on their layoutMode.\n *\n * **Algorithm**:\n * 1. Sort breakpoints by minWidth (largest to smallest)\n * 2. Largest breakpoint = base layout with `customized: true`\n * 3. For each other breakpoint:\n * - `layoutMode: 'stack'` ‚Üí auto-stack defaults (x:0, y:0, width:50, height from base)\n * - `layoutMode: 'inherit'` ‚Üí null values (will inherit on render)\n * - `layoutMode: 'manual'` ‚Üí copy base layout with `customized: false`\n *\n * **Example (2-breakpoint)**:\n * ```typescript\n * const breakpoints = {\n * mobile: { minWidth: 0, layoutMode: 'stack' },\n * desktop: { minWidth: 768, layoutMode: 'manual' }\n * };\n *\n * const baseLayout = { x: 5, y: 2, width: 20, height: 8, customized: true };\n *\n * const layouts = initializeLayouts(breakpoints, baseLayout);\n * // Returns:\n * // {\n * //   desktop: { x: 5, y: 2, width: 20, height: 8, customized: true },\n * //   mobile: { x: 0, y: 0, width: 50, height: 8, customized: false }\n * // }\n * ```\n *\n * **Example (3-breakpoint with inheritance)**:\n * ```typescript\n * const breakpoints = {\n * mobile: { minWidth: 0, layoutMode: 'stack' },\n * tablet: { minWidth: 768, layoutMode: 'inherit', inheritFrom: 'desktop' },\n * desktop: { minWidth: 1024, layoutMode: 'manual' }\n * };\n *\n * const layouts = initializeLayouts(breakpoints, baseLayout);\n * // Returns:\n * // {\n * //   desktop: { x: 5, y: 2, width: 20, height: 8, customized: true },\n * //   tablet: { x: null, y: null, width: null, height: null, customized: false },\n * //   mobile: { x: 0, y: 0, width: 50, height: 8, customized: false }\n * // }\n * ```\n * @param breakpoints - Breakpoint configuration\n * @param baseLayout - Base layout to use for largest breakpoint\n * @returns Object mapping breakpoint names to LayoutConfig\n */\nexport function initializeLayouts(\n  breakpoints: BreakpointConfig,\n  baseLayout: LayoutConfig,\n): Record<string, LayoutConfig> {\n  const layouts: Record<string, LayoutConfig> = {};\n\n  // Find largest breakpoint (typically 'desktop')\n  const sortedNames = Object.entries(breakpoints)\n    .sort(([, a], [, b]) => b.minWidth - a.minWidth)\n    .map(([name]) => name);\n\n  const largestName = sortedNames[0];\n\n  // Largest = fully customized manual layout\n  layouts[largestName] = { ...baseLayout, customized: true };\n\n  // Others = default based on layoutMode\n  for (const name of sortedNames.slice(1)) {\n    const def = breakpoints[name];\n\n    if (def.layoutMode === \"stack\") {\n      // Stack mode: auto-calculate on render\n      layouts[name] = {\n        x: 0,\n        y: 0,\n        width: 50,\n        height: baseLayout.height,\n        customized: false,\n      };\n    } else if (def.layoutMode === \"inherit\") {\n      // Inherit mode: use null to trigger inheritance\n      layouts[name] = {\n        x: null,\n        y: null,\n        width: null,\n        height: null,\n        customized: false,\n      };\n    } else {\n      // Manual mode: copy from largest\n      layouts[name] = {\n        ...baseLayout,\n        customized: false,\n      };\n    }\n  }\n\n  return layouts;\n}\n","/**\n * Boundary Constraints Utility\n * =============================\n *\n * Utilities for constraining component placement and sizing within canvas boundaries.\n * Ensures components stay fully within canvas and handles size fitting when needed.\n *\n * ## Problem\n *\n * Components can be placed or dragged such that they extend beyond canvas boundaries:\n * - Dropped from palette outside canvas bounds\n * - Dragged beyond edges\n * - Default size larger than canvas\n *\n * ## Solution\n *\n * Provides constraint functions that:\n * 1. Validate component can fit within canvas (respecting minSize)\n * 2. Adjust size to fit canvas if needed (respecting minSize/maxSize)\n * 3. Constrain position to keep component fully within bounds\n * @module boundary-constraints\n */\n\nimport { ComponentDefinition } from \"../types/component-definition\";\n\n/**\n * Canvas dimensions in grid units\n *\n * **Standard canvas size**:\n * - Width: 50 units (100% width, 2% per unit)\n * - Height: Unlimited (grows with content)\n */\nexport const CANVAS_WIDTH_UNITS = 50;\n\n/**\n * Component size after constraint validation\n */\nexport interface ConstrainedSize {\n  /** Width in grid units (may be adjusted from default) */\n  width: number;\n  /** Height in grid units (may be adjusted from default) */\n  height: number;\n  /** Whether size was adjusted to fit */\n  wasAdjusted: boolean;\n}\n\n/**\n * Component position and size after boundary constraints\n */\nexport interface ConstrainedPlacement {\n  /** X position in grid units */\n  x: number;\n  /** Y position in grid units */\n  y: number;\n  /** Width in grid units */\n  width: number;\n  /** Height in grid units */\n  height: number;\n  /** Whether position was adjusted */\n  positionAdjusted: boolean;\n  /** Whether size was adjusted */\n  sizeAdjusted: boolean;\n}\n\n/**\n * Validate if component can fit within canvas\n *\n * Checks if component's minimum size is smaller than or equal to canvas size.\n * If component's minSize > canvas size, placement should be rejected.\n * @param definition - Component definition with min/max size constraints\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns true if component can fit, false if too large\n * @example\n * ```typescript\n * const hugeComponent = {\n *   type: 'huge-widget',\n *   minSize: { width: 60, height: 10 } // 60 > 50 canvas width\n * };\n *\n * if (!canComponentFitCanvas(hugeComponent)) {\n *   console.warn('Component too large for canvas');\n *   return; // Don't allow placement\n * }\n * ```\n */\nexport function canComponentFitCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): boolean {\n  // Get minimum size (or use default minimums if not specified)\n  const minWidth = definition.minSize?.width || 0;\n\n  // Check if minimum size fits within canvas\n  // Height is unlimited, so only check width\n  return minWidth <= canvasWidth;\n}\n\n/**\n * Constrain component size to fit within canvas\n *\n * Adjusts component size if default size exceeds canvas bounds,\n * while respecting min/max size constraints.\n *\n * **Size adjustment rules**:\n * 1. If defaultSize fits, use it\n * 2. If defaultSize > canvas, shrink to canvas size\n * 3. Never shrink below minSize\n * 4. Never grow beyond maxSize\n *\n * **Width constraint**: Canvas width (50 units)\n * **Height constraint**: None (canvas height grows with content)\n * @param definition - Component definition\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained size and adjustment flag\n * @example\n * ```typescript\n * const wideComponent = {\n *   type: 'banner',\n *   defaultSize: { width: 60, height: 10 }, // Too wide\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const size = constrainSizeToCanvas(wideComponent);\n * // { width: 50, height: 10, wasAdjusted: true }\n * ```\n */\nexport function constrainSizeToCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedSize {\n  const defaultWidth = definition.defaultSize.width;\n  const defaultHeight = definition.defaultSize.height;\n\n  const minWidth = definition.minSize?.width || 0;\n  const maxWidth = definition.maxSize?.width || Infinity;\n\n  let width = defaultWidth;\n  let height = defaultHeight;\n  let wasAdjusted = false;\n\n  // Constrain width to canvas\n  if (width > canvasWidth) {\n    width = canvasWidth;\n    wasAdjusted = true;\n  }\n\n  // Respect minSize\n  if (width < minWidth) {\n    width = minWidth;\n  }\n\n  // Respect maxSize\n  if (width > maxWidth) {\n    width = maxWidth;\n  }\n\n  // Height is not constrained by canvas (canvas grows vertically)\n  // but still respect min/max if specified\n  const minHeight = definition.minSize?.height || 0;\n  const maxHeight = definition.maxSize?.height || Infinity;\n\n  if (height < minHeight) {\n    height = minHeight;\n  }\n  if (height > maxHeight) {\n    height = maxHeight;\n  }\n\n  return { width, height, wasAdjusted };\n}\n\n/**\n * Constrain component position to keep it fully within canvas bounds\n *\n * Adjusts position so component stays completely inside canvas.\n * Snaps to edges if component would extend beyond boundaries.\n *\n * **Boundary rules**:\n * - Left edge: x >= 0\n * - Right edge: x + width <= canvasWidth\n * - Top edge: y >= 0\n * - Bottom edge: No constraint (canvas height grows)\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param width - Component width in grid units\n * @param height - Component height in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement\n * @example\n * ```typescript\n * // Component would extend beyond right edge\n * const placement = constrainPositionToCanvas(45, 10, 20, 10);\n * // { x: 30, y: 10, width: 20, height: 10, positionAdjusted: true, sizeAdjusted: false }\n * // Adjusted from 45 to 30 so (30 + 20 = 50) stays within canvas\n * ```\n */\nexport function constrainPositionToCanvas(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedPlacement {\n  let newX = x;\n  let newY = y;\n  let positionAdjusted = false;\n\n  // Constrain left edge\n  if (newX < 0) {\n    newX = 0;\n    positionAdjusted = true;\n  }\n\n  // Constrain right edge\n  if (newX + width > canvasWidth) {\n    newX = canvasWidth - width;\n    positionAdjusted = true;\n  }\n\n  // Constrain top edge\n  if (newY < 0) {\n    newY = 0;\n    positionAdjusted = true;\n  }\n\n  // No bottom edge constraint - canvas grows vertically\n\n  // Ensure position doesn't go negative after adjustment\n  newX = Math.max(0, newX);\n  newY = Math.max(0, newY);\n\n  return {\n    x: newX,\n    y: newY,\n    width,\n    height,\n    positionAdjusted,\n    sizeAdjusted: false,\n  };\n}\n\n/**\n * Apply full boundary constraints to component placement\n *\n * Complete constraint pipeline:\n * 1. Check if component can fit (validate minSize <= canvas)\n * 2. Adjust size to fit canvas (if needed)\n * 3. Constrain position to keep within bounds\n *\n * **Returns null if component cannot fit** (minSize > canvas)\n * @param definition - Component definition\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement, or null if component too large\n * @example\n * ```typescript\n * const definition = {\n *   type: 'widget',\n *   defaultSize: { width: 60, height: 10 },\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const placement = applyBoundaryConstraints(definition, 45, 10);\n * // {\n * //   x: 0,              // Adjusted from 45 to fit\n * //   y: 10,             // No Y adjustment needed\n * //   width: 50,         // Shrunk from 60 to fit canvas\n * //   height: 10,        // No height adjustment\n * //   positionAdjusted: true,\n * //   sizeAdjusted: true\n * // }\n * ```\n */\nexport function applyBoundaryConstraints(\n  definition: ComponentDefinition,\n  x: number,\n  y: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedPlacement | null {\n  // 1. Validate component can fit\n  if (!canComponentFitCanvas(definition, canvasWidth)) {\n    console.warn(\n      `Component \"${definition.name}\" minSize (${definition.minSize?.width}) ` +\n        `exceeds canvas width (${canvasWidth}). Placement rejected.`,\n    );\n    return null;\n  }\n\n  // 2. Adjust size to fit canvas\n  const constrainedSize = constrainSizeToCanvas(definition, canvasWidth);\n\n  // 3. Constrain position to keep within bounds\n  const constrainedPlacement = constrainPositionToCanvas(\n    x,\n    y,\n    constrainedSize.width,\n    constrainedSize.height,\n    canvasWidth,\n  );\n\n  // Combine size and position adjustments\n  return {\n    ...constrainedPlacement,\n    sizeAdjusted: constrainedSize.wasAdjusted,\n  };\n}\n"],"names":[],"mappings":"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"}