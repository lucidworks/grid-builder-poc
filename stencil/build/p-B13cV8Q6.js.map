{"version":3,"file":"p-B13cV8Q6.js","sources":["src/utils/dom-cache.ts","src/utils/grid-calculations.ts","node_modules/@stencil/store/dist/index.js","src/utils/debug.ts","src/utils/validation.ts","src/services/state-manager.ts"],"sourcesContent":["/**\n * DOM Cache Utility\n * =================\n *\n * Performance optimization layer that caches frequently accessed DOM elements to avoid\n * repeated `document.getElementById()` calls during drag/resize operations.\n *\n * ## Problem\n *\n * During interactive operations (drag, resize), we frequently need to access the same\n * DOM elements:\n * - Canvas containers for width calculations\n * - Grid items for position updates\n * - Parent elements for coordinate transforms\n *\n * Each `document.getElementById()` call:\n * - Traverses the DOM tree\n * - Can trigger layout calculations\n * - Becomes expensive when called hundreds of times per second during drag\n *\n * ## Solution\n *\n * Cache DOM references in memory after first lookup:\n * - **First access**: Query DOM once and store reference\n * - **Subsequent access**: Return cached reference (O(1) Map lookup)\n * - **Invalidation**: Clear cache when DOM structure changes\n *\n * ## Performance Impact\n *\n * **Without caching**:\n * - During drag: ~60 getElementById calls/second (60fps × multiple items)\n * - Each call traverses DOM tree\n * - Cumulative impact on frame budget\n *\n * **With caching**:\n * - First call: DOM query + cache store\n * - Subsequent: Map.get() (constant time)\n * - 90%+ reduction in DOM queries during operations\n *\n * ## When to Use This Pattern\n *\n * Apply DOM caching when:\n * ✅ Accessing same elements repeatedly in tight loops\n * ✅ During high-frequency events (mousemove, scroll, resize)\n * ✅ Elements are stable (not frequently added/removed)\n * ✅ Performance profiling shows getElementById as bottleneck\n *\n * Avoid when:\n * ❌ Elements change frequently (cache becomes stale)\n * ❌ Only accessing elements once\n * ❌ Using framework-managed refs (React useRef, Stencil @Element)\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n * ```typescript\n * class MyDOMCache {\n * private elements = new Map<string, HTMLElement>();\n *\n * get(id: string): HTMLElement | null {\n * if (this.elements.has(id)) return this.elements.get(id)!;\n * const el = document.getElementById(id);\n * if (el) this.elements.set(id, el);\n * return el;\n * }\n *\n * invalidate(id: string) { this.elements.delete(id); }\n * }\n * export const cache = new MyDOMCache();\n * ```\n *\n * ## Cache Invalidation Strategy\n *\n * Clear cache when:\n * - Canvas added/removed from DOM\n * - Component unmounts\n * - Major DOM restructuring\n * - Element IDs change\n * @module dom-cache\n */\n\n/**\n * DOM Cache for canvas containers and frequently accessed elements\n *\n * Singleton pattern ensures all code uses same cache instance\n */\nexport class DOMCache {\n  /** Canvas element cache - key: canvasId, value: HTMLElement */\n  private canvases: Map<string, HTMLElement> = new Map();\n\n  /**\n   * Get canvas element by ID with automatic caching\n   *\n   * **Caching behavior**:\n   * 1. Check Map cache first (O(1))\n   * 2. If miss, query DOM and cache result\n   * 3. Return cached or fresh element\n   *\n   * **Performance**:\n   * - Cached access: ~0.001ms (Map.get)\n   * - DOM query: ~0.1-1ms (getElementById + tree traversal)\n   * - Speedup: 100-1000x for cached access\n   *\n   * **Safety**:\n   * - Returns `null` if element doesn't exist\n   * - Safe to call before DOM ready (returns null, doesn't cache)\n   * - Cache automatically populated on first successful access\n   * @param canvasId - Canvas container element ID\n   * @returns HTMLElement or null if not found\n   * @example\n   * ```typescript\n   * // First call - queries DOM\n   * const canvas1 = domCache.getCanvas('canvas1'); // ~0.5ms\n   *\n   * // Subsequent calls - returns cached\n   * const canvas2 = domCache.getCanvas('canvas1'); // ~0.001ms\n   * const canvas3 = domCache.getCanvas('canvas1'); // ~0.001ms\n   *\n   * // Different canvas - new DOM query\n   * const canvas4 = domCache.getCanvas('canvas2'); // ~0.5ms\n   * ```\n   */\n  getCanvas(canvasId: string): HTMLElement | null {\n    // Check cache first\n    if (this.canvases.has(canvasId)) {\n      return this.canvases.get(canvasId)!;\n    }\n\n    // Query DOM and cache\n    const canvas = document.getElementById(canvasId);\n    if (canvas) {\n      this.canvases.set(canvasId, canvas);\n    }\n\n    return canvas;\n  }\n\n  /**\n   * Invalidate cache for a specific canvas\n   *\n   * **When to call**:\n   * - Canvas element removed from DOM\n   * - Canvas element replaced (same ID, different element)\n   * - Canvas component unmounts\n   * - Element ID changed\n   *\n   * **Why needed**:\n   * Cached references become stale when elements are removed or replaced.\n   * Invalidation ensures next access queries fresh element from DOM.\n   *\n   * **Performance**:\n   * Very cheap operation (Map.delete is O(1))\n   * @param canvasId - Canvas ID to remove from cache\n   * @example\n   * ```typescript\n   * // Component unmounting\n   * disconnectedCallback() {\n   *   domCache.invalidate(this.canvasId);\n   * }\n   *\n   * // Canvas removed from state\n   * delete gridState.canvases['canvas1'];\n   * domCache.invalidate('canvas1');\n   * ```\n   */\n  invalidate(canvasId: string): void {\n    this.canvases.delete(canvasId);\n  }\n\n  /**\n   * Clear entire DOM cache\n   *\n   * **When to call**:\n   * - Major DOM restructuring (e.g., navigation, full page reload)\n   * - All canvases removed/replaced\n   * - Test cleanup (afterEach hooks)\n   * - Memory cleanup when cache grows too large\n   *\n   * **Why needed**:\n   * Prevents memory leaks from cached references to removed elements\n   * and ensures clean slate after major DOM changes.\n   *\n   * **Performance**:\n   * Cheap operation - just clears Map references.\n   * Elements are garbage collected automatically.\n   * @example\n   * ```typescript\n   * // Test cleanup\n   * afterEach(() => {\n   *   domCache.clear();\n   * });\n   *\n   * // Navigation/route change\n   * router.beforeEach(() => {\n   *   domCache.clear();\n   * });\n   *\n   * // Memory management\n   * if (domCache.size() > 100) {\n   *   domCache.clear(); // Periodic cleanup\n   * }\n   * ```\n   */\n  clear(): void {\n    this.canvases.clear();\n  }\n}\n","/**\n * Grid Calculations Utility\n * ========================\n *\n * Core system for converting between pixel coordinates and grid units in the drag-and-drop\n * grid builder. This module provides pure functions with performance optimizations through\n * intelligent caching.\n *\n * ## Grid System Architecture\n *\n * The grid uses a hybrid approach combining responsive and fixed sizing:\n *\n * ### Horizontal Grid (Responsive)\n * - **Size**: 2% of container width (50 units across full width)\n * - **Behavior**: Scales proportionally with canvas width changes\n * - **Use case**: Enables responsive layouts that adapt to different screen sizes\n * - **Example**: At 1000px width, each grid unit = 20px (1000 * 0.02)\n *\n * ### Vertical Grid (Fixed)\n * - **Size**: Fixed 20px per grid unit\n * - **Behavior**: Remains constant regardless of viewport size\n * - **Use case**: Provides consistent vertical spacing and predictable heights\n * - **Rationale**: Vertical scrolling is unlimited, so fixed sizing provides better UX\n *\n * ## Performance Optimization Strategy\n *\n * ### Grid Size Caching\n * The horizontal grid size is calculated from DOM elements (container.clientWidth),\n * which is an expensive operation. To minimize performance impact:\n *\n * 1. **First access**: Calculate once per canvas and cache the result\n * 2. **Subsequent access**: Return cached value (no DOM reads)\n * 3. **Cache invalidation**: Clear when canvas resizes (via ResizeObserver)\n *\n * **Performance Impact**:\n * - Without caching: 100 items = 100+ DOM reads during viewport switch\n * - With caching: 100 items = 1 DOM read per canvas during viewport switch\n * - Prevents layout thrashing and reduces reflows\n *\n * ### DOM Caching Integration\n * Uses `domCache` utility to avoid repeated `getElementById` calls, providing\n * a second layer of performance optimization.\n *\n * ## Usage Examples\n *\n * ```typescript\n * // Convert grid position to pixels for rendering\n * const pixelX = gridToPixelsX(10, 'canvas1'); // Grid unit 10 → pixels\n * const pixelY = gridToPixelsY(5);              // Grid unit 5 → 100px\n *\n * // Convert mouse position to grid coordinates\n * const gridX = pixelsToGridX(250, 'canvas1');  // Pixels → grid units\n * const gridY = pixelsToGridY(120);             // 120px → 6 grid units\n *\n * // Clear cache on canvas resize\n * resizeObserver.observe(canvasContainer);\n * resizeObserver.addEventListener(() => clearGridSizeCache());\n * ```\n * @module grid-calculations\n */\n\nimport { DOMCache } from \"./dom-cache\";\nimport { GridConfig } from \"../types/grid-config\";\n\n/** Fixed vertical grid size in pixels - provides consistent vertical spacing */\nconst GRID_SIZE_VERTICAL = 20;\n\n/**\n * Horizontal grid size as percentage of container width\n * 0.02 = 2% = 50 grid units across full width\n */\nconst GRID_SIZE_HORIZONTAL_PERCENT = 0.02;\n\n/**\n * Default minimum grid size in pixels\n * Prevents grid from becoming too small on tiny screens\n */\nconst DEFAULT_MIN_GRID_SIZE = 10;\n\n/**\n * Default maximum grid size in pixels\n * Prevents grid from becoming too large on huge screens\n */\nconst DEFAULT_MAX_GRID_SIZE = 50;\n\n/**\n * Grid size cache to avoid repeated DOM queries\n *\n * **Cache key format**: `${instanceId}-${canvasId}-h` for horizontal grid sizes\n * **Instance isolation**: Each grid-builder instance gets its own cache namespace\n *\n * **Why instance-aware**:\n * - Multiple instances on same page can have different container widths for same canvasId\n * - Prevents cache collisions when instances share canvasIds\n * - Supports Storybook story switching (each story is a new instance)\n *\n * **Cleared on**:\n * - Canvas container resize (via ResizeObserver)\n * - Viewport changes (desktop ↔ mobile)\n * - Component unmount (disconnectedCallback)\n */\nconst gridSizeCache = new Map<string, number>();\n\n/**\n * Clear the grid size cache for all canvases or a specific instance\n *\n * **When to call**:\n * - Canvas container is resized (via ResizeObserver)\n * - Viewport changes (desktop ↔ mobile)\n * - Canvas is added/removed from DOM\n * - Component unmounts (clear only that instance's cache)\n *\n * **Instance-specific clearing**:\n * If instanceId provided, only clears cache entries for that instance.\n * Useful when unmounting a specific grid-builder instance.\n *\n * **Why needed**:\n * Cached grid sizes become stale when container widths change. This ensures\n * fresh calculations on next access.\n *\n * **Performance note**:\n * Clearing cache is cheap (O(1) for all, O(n) for instance-specific where n = cache size).\n * The cost is in recalculation, which happens lazily on next access.\n * @param instanceId - Optional instance ID to clear only that instance's cache\n * @example\n * ```typescript\n * // Clear all caches (all instances)\n * resizeObserver.observe(canvasElement);\n * resizeCallback = () => {\n *   clearGridSizeCache();\n *   // All instances will recalculate on next render\n * };\n *\n * // Clear only specific instance's cache (on unmount)\n * disconnectedCallback() {\n *   clearGridSizeCache(this.config?.instanceId);\n *   // Only this instance's cache is cleared\n * }\n * ```\n */\nexport function clearGridSizeCache(instanceId?: string) {\n  if (instanceId) {\n    // Clear only cache entries for this instance\n    const prefix = `${instanceId}-`;\n    for (const key of gridSizeCache.keys()) {\n      if (key.startsWith(prefix)) {\n        gridSizeCache.delete(key);\n      }\n    }\n  } else {\n    // Clear all (backward compatibility, window resize, etc.)\n    gridSizeCache.clear();\n  }\n}\n\n/**\n * Pre-populate grid size cache with known container width\n *\n * **Purpose**: Set cache value BEFORE triggering re-render to avoid reading DOM during transient state\n *\n * **Use case**: ResizeObserver gives us correct width via entry.contentRect.width.\n * By pre-calculating and caching this value before triggering re-render, we ensure\n * grid calculations never read clientWidth=0 during StencilJS re-render cycle.\n *\n * **Why needed**:\n * When ResizeObserver fires and we trigger re-render (renderVersion++), the DOM enters\n * a transient state where clientWidth returns 0. By pre-populating cache with the correct\n * value from ResizeObserver, we bypass DOM reads entirely during re-render.\n *\n * **Implementation**:\n * Uses same calculation logic as getGridSizeHorizontal() but accepts width parameter\n * instead of reading from DOM.\n * @param canvasId - Canvas element ID for cache key\n * @param containerWidth - Width from ResizeObserver entry.contentRect.width\n * @param config - Optional GridConfig for customization (gridSizePercent, min/max, instanceId)\n * @example\n * ```typescript\n * // In ResizeObserver callback\n * this.resizeObserver = new ResizeObserver((entries) => {\n *   for (const entry of entries) {\n *     const width = entry.contentRect.width;\n *\n *     // Pre-populate cache before triggering re-render\n *     setGridSizeCache(this.canvasId, width, this.config);\n *\n *     // Now trigger re-render - calculations will use cached value\n *     this.renderVersion++;\n *   }\n * });\n * ```\n */\nexport function setGridSizeCache(\n  canvasId: string,\n  containerWidth: number,\n  config?: GridConfig,\n): void {\n  // Build cache key (same logic as getGridSizeHorizontal)\n  const cacheKey = config?.instanceId\n    ? `${config.instanceId}-${canvasId}-h`\n    : `${canvasId}-h`;\n\n  // Get grid size percent from config or use default\n  const gridSizePercent = config?.gridSizePercent\n    ? config.gridSizePercent / 100\n    : GRID_SIZE_HORIZONTAL_PERCENT;\n\n  // Calculate raw grid size from provided width\n  const rawSize = containerWidth * gridSizePercent;\n\n  // Apply min/max constraints from config or use defaults\n  const minSize = config?.minGridSize ?? DEFAULT_MIN_GRID_SIZE;\n  const maxSize = config?.maxGridSize ?? DEFAULT_MAX_GRID_SIZE;\n  const size = Math.max(minSize, Math.min(maxSize, rawSize));\n\n  // Set in cache\n  gridSizeCache.set(cacheKey, size);\n}\n\n/**\n * Get the horizontal grid size for a specific canvas\n *\n * **Calculation**: `containerWidth * gridSizePercent` = size of one horizontal grid unit in pixels\n * **Min/Max constraints**: Applied from GridConfig (default: 10px-50px)\n *\n * **Caching behavior**:\n * - First call: Reads `container.clientWidth` from DOM and caches result\n * - Subsequent calls: Returns cached value (no DOM access)\n * - After resize: Cache cleared, recalculates on next call\n *\n * **Why responsive**:\n * Horizontal grid scales with container to support:\n * - Responsive layouts (desktop/mobile)\n * - Variable canvas widths\n * - Fluid grid-based designs\n *\n * **GridConfig customization**:\n * - `gridSizePercent`: Grid unit as % of width (default: 2% = 50 units per 100% width)\n * - `minGridSize`: Minimum size in pixels (default: 10px, prevents too small on mobile)\n * - `maxGridSize`: Maximum size in pixels (default: 50px, prevents too large on desktop)\n * @param canvasId - The canvas element ID to calculate grid size for\n * @param config - Optional GridConfig for customization\n * @param forceRecalc - Set true to bypass cache and force fresh calculation\n * @returns Size of one horizontal grid unit in pixels (constrained by min/max)\n * @example\n * ```typescript\n * // Default config (2% grid, 10px-50px)\n * const size1 = getGridSizeHorizontal('canvas1'); // → 20 (at 1000px width)\n *\n * // Custom config (3% grid, 15px-60px)\n * const size2 = getGridSizeHorizontal('canvas1', {\n *   gridSizePercent: 3,\n *   minGridSize: 15,\n *   maxGridSize: 60\n * }); // → 30 (at 1000px width)\n *\n * // Force recalculation\n * const size3 = getGridSizeHorizontal('canvas1', undefined, true);\n * ```\n */\nexport function getGridSizeHorizontal(\n  canvasId: string,\n  config?: GridConfig,\n  forceRecalc: boolean = false,\n  domCacheInstance?: DOMCache,\n): number {\n  // Instance-aware cache key: ${instanceId}-${canvasId}-h\n  // Fallback to ${canvasId}-h for backward compatibility if no instanceId\n  const cacheKey = config?.instanceId\n    ? `${config.instanceId}-${canvasId}-h`\n    : `${canvasId}-h`;\n\n  if (!forceRecalc && gridSizeCache.has(cacheKey)) {\n    return gridSizeCache.get(cacheKey)!;\n  }\n\n  // Use DOM cache instance if provided, otherwise create temporary instance\n  const cache = domCacheInstance || new DOMCache();\n  const container = cache.getCanvas(canvasId);\n  if (!container) {\n    console.warn(`Canvas container not found: ${canvasId}`);\n    return 0;\n  }\n\n  // Get grid size percent from config or use default\n  // Config gridSizePercent is whole number (2 = 2%), default is already decimal (0.02)\n  const gridSizePercent = config?.gridSizePercent\n    ? config.gridSizePercent / 100\n    : GRID_SIZE_HORIZONTAL_PERCENT;\n\n  // Calculate raw grid size\n  const rawSize = container.clientWidth * gridSizePercent;\n\n  // Apply min/max constraints from config or use defaults\n  const minSize = config?.minGridSize ?? DEFAULT_MIN_GRID_SIZE;\n  const maxSize = config?.maxGridSize ?? DEFAULT_MAX_GRID_SIZE;\n  const size = Math.max(minSize, Math.min(maxSize, rawSize));\n\n  // Don't cache if container not laid out yet (prevents caching 0-width or tiny containers)\n  // Critical for initial load: canvas element exists in DOM but CSS layout hasn't happened yet\n  // ResizeObserver will fire when layout completes, then we'll cache the correct value\n  if (container.clientWidth > 100) {\n    gridSizeCache.set(cacheKey, size);\n  }\n\n  return size;\n}\n\n/**\n * Get the vertical grid size\n *\n * **Configurable vertical grid**:\n * Unlike horizontal grid, vertical uses fixed sizing (default 20px) because:\n * - Vertical scrolling is infinite (no container height limit)\n * - Provides predictable, consistent heights across all viewports\n * - Simplifies calculations (no container dependency)\n * - Better UX for vertical spacing\n * @param config Optional GridConfig with verticalGridSize\n * @returns Vertical grid size in pixels (config.verticalGridSize || 20)\n * @example\n * ```typescript\n * const vSize = getGridSizeVertical(); // → 20 (default)\n * const vSize2 = getGridSizeVertical({ verticalGridSize: 25 }); // → 25\n * ```\n */\nexport function getGridSizeVertical(config?: GridConfig): number {\n  return config?.verticalGridSize ?? GRID_SIZE_VERTICAL;\n}\n\n/**\n * Convert grid units to pixels for horizontal positioning and sizing\n *\n * **Use cases**:\n * - Converting item `x` position from grid coordinates to CSS left/transform\n * - Converting item `width` from grid units to CSS width\n * - Rendering grid items at correct horizontal positions\n *\n * **Performance**:\n * Uses cached grid size via `getGridSizeHorizontal()` to avoid DOM reads\n *\n * **Rounding**:\n * Uses `Math.round()` to prevent subpixel rendering issues\n * @param gridUnits - Number of grid units\n * @param canvasId - Canvas ID for responsive grid size calculation\n * @param config - Optional GridConfig for customization\n * @returns Pixel value\n * @example\n * ```typescript\n * // Item at grid position x=10 (default 2% grid)\n * const leftPx = gridToPixelsX(10, 'canvas1'); // → 200px (at 1000px container)\n *\n * // Item with grid width=15 (custom 3% grid)\n * const widthPx = gridToPixelsX(15, 'canvas1', { gridSizePercent: 3 }); // → 450px\n * ```\n */\nexport function gridToPixelsX(\n  gridUnits: number,\n  canvasId: string,\n  config?: GridConfig,\n): number {\n  // Use cached grid size for better performance\n  const gridSize = getGridSizeHorizontal(canvasId, config);\n  return Math.round(gridUnits * gridSize);\n}\n\n/**\n * Convert grid units to pixels for vertical positioning and sizing\n *\n * **Use cases**:\n * - Converting item `y` position from grid coordinates to CSS top/transform\n * - Converting item `height` from grid units to CSS height\n * - Calculating vertical spacing\n *\n * **Configurable vertical grid**:\n * Uses config.verticalGridSize (default 20px) for calculation\n * @param gridUnits - Number of grid units\n * @param config - Optional GridConfig with verticalGridSize\n * @returns Pixel value (gridUnits * verticalGridSize)\n * @example\n * ```typescript\n * // Item at grid position y=5 (default 20px)\n * const topPx = gridToPixelsY(5); // → 100px\n *\n * // Item with grid height=8 (custom 25px)\n * const heightPx = gridToPixelsY(8, { verticalGridSize: 25 }); // → 200px\n * ```\n */\nexport function gridToPixelsY(gridUnits: number, config?: GridConfig): number {\n  return gridUnits * getGridSizeVertical(config);\n}\n\n/**\n * Convert pixel coordinates to grid units for horizontal values\n *\n * **Use cases**:\n * - Converting mouse/drop position to grid coordinates\n * - Snapping dragged items to grid\n * - Calculating item positions after drag\n *\n * **Rounding**:\n * Uses `Math.round()` to snap to nearest grid unit (implements grid snapping)\n *\n * **Safety**:\n * Returns 0 if grid size is 0 (container not found/initialized)\n * @param pixels - Pixel value to convert\n * @param canvasId - Canvas ID for responsive grid size calculation\n * @param config - Optional GridConfig for customization\n * @returns Number of grid units (rounded)\n * @example\n * ```typescript\n * // Mouse drop at 250px (default 2% grid)\n * const gridX = pixelsToGridX(250, 'canvas1'); // → 13 (at 1000px container)\n *\n * // After drag, element at 371px (custom 3% grid)\n * const snappedX = pixelsToGridX(371, 'canvas1', { gridSizePercent: 3 }); // → 12\n * ```\n */\nexport function pixelsToGridX(\n  pixels: number,\n  canvasId: string,\n  config?: GridConfig,\n): number {\n  // Use cached grid size for better performance\n  const gridSize = getGridSizeHorizontal(canvasId, config);\n  if (gridSize === 0) {\n    return 0;\n  }\n  return Math.round(pixels / gridSize);\n}\n\n/**\n * Convert pixel coordinates to grid units for vertical values\n *\n * **Use cases**:\n * - Converting mouse Y position to grid coordinates\n * - Snapping vertical positions to grid\n * - Calculating vertical offsets\n *\n * **Rounding**:\n * Implements automatic grid snapping via `Math.round()`\n * @param pixels - Pixel value to convert\n * @param config - Optional GridConfig with verticalGridSize\n * @returns Number of grid units (rounded)\n * @example\n * ```typescript\n * // Mouse at 127px vertically (default 20px grid)\n * const gridY = pixelsToGridY(127); // → 6 (rounded from 6.35)\n *\n * // Element height 165px (custom 25px grid)\n * const gridHeight = pixelsToGridY(165, { verticalGridSize: 25 }); // → 7 (rounded from 6.6)\n * ```\n */\nexport function pixelsToGridY(pixels: number, config?: GridConfig): number {\n  return Math.round(pixels / getGridSizeVertical(config));\n}\n","import { getRenderingRef, forceUpdate } from '@stencil/core';\n\nconst appendToMap = (map, propName, value) => {\n    const items = map.get(propName);\n    if (!items) {\n        map.set(propName, [value]);\n    }\n    else if (!items.includes(value)) {\n        items.push(value);\n    }\n};\nconst debounce = (fn, ms) => {\n    let timeoutId;\n    return (...args) => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = 0;\n            fn(...args);\n        }, ms);\n    };\n};\n\n/**\n * Check if a possible element isConnected.\n * The property might not be there, so we check for it.\n *\n * We want it to return true if isConnected is not a property,\n * otherwise we would remove these elements and would not update.\n *\n * Better leak in Edge than to be useless.\n */\nconst isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;\nconst cleanupElements = debounce((map) => {\n    for (let key of map.keys()) {\n        map.set(key, map.get(key).filter(isConnected));\n    }\n}, 2_000);\nconst stencilSubscription = () => {\n    if (typeof getRenderingRef !== 'function') {\n        // If we are not in a stencil project, we do nothing.\n        // This function is not really exported by @stencil/core.\n        return {};\n    }\n    const elmsToUpdate = new Map();\n    return {\n        dispose: () => elmsToUpdate.clear(),\n        get: (propName) => {\n            const elm = getRenderingRef();\n            if (elm) {\n                appendToMap(elmsToUpdate, propName, elm);\n            }\n        },\n        set: (propName) => {\n            const elements = elmsToUpdate.get(propName);\n            if (elements) {\n                elmsToUpdate.set(propName, elements.filter(forceUpdate));\n            }\n            cleanupElements(elmsToUpdate);\n        },\n        reset: () => {\n            elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));\n            cleanupElements(elmsToUpdate);\n        },\n    };\n};\n\nconst unwrap = (val) => (typeof val === 'function' ? val() : val);\nconst createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {\n    const unwrappedState = unwrap(defaultState);\n    let states = new Map(Object.entries(unwrappedState ?? {}));\n    const handlers = {\n        dispose: [],\n        get: [],\n        set: [],\n        reset: [],\n    };\n    // Track onChange listeners to enable removeListener functionality\n    const changeListeners = new Map();\n    const reset = () => {\n        // When resetting the state, the default state may be a function - unwrap it to invoke it.\n        // otherwise, the state won't be properly reset\n        states = new Map(Object.entries(unwrap(defaultState) ?? {}));\n        handlers.reset.forEach((cb) => cb());\n    };\n    const dispose = () => {\n        // Call first dispose as resetting the state would\n        // cause less updates ;)\n        handlers.dispose.forEach((cb) => cb());\n        reset();\n    };\n    const get = (propName) => {\n        handlers.get.forEach((cb) => cb(propName));\n        return states.get(propName);\n    };\n    const set = (propName, value) => {\n        const oldValue = states.get(propName);\n        if (shouldUpdate(value, oldValue, propName)) {\n            states.set(propName, value);\n            handlers.set.forEach((cb) => cb(propName, value, oldValue));\n        }\n    };\n    const state = (typeof Proxy === 'undefined'\n        ? {}\n        : new Proxy(unwrappedState, {\n            get(_, propName) {\n                return get(propName);\n            },\n            ownKeys(_) {\n                return Array.from(states.keys());\n            },\n            getOwnPropertyDescriptor() {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            },\n            has(_, propName) {\n                return states.has(propName);\n            },\n            set(_, propName, value) {\n                set(propName, value);\n                return true;\n            },\n        }));\n    const on = (eventName, callback) => {\n        handlers[eventName].push(callback);\n        return () => {\n            removeFromArray(handlers[eventName], callback);\n        };\n    };\n    const onChange = (propName, cb) => {\n        const setHandler = (key, newValue) => {\n            if (key === propName) {\n                cb(newValue);\n            }\n        };\n        const resetHandler = () => cb(unwrap(defaultState)[propName]);\n        // Register the handlers\n        const unSet = on('set', setHandler);\n        const unReset = on('reset', resetHandler);\n        // Track the relationship between the user callback and internal handlers\n        changeListeners.set(cb, { setHandler, resetHandler, propName });\n        return () => {\n            unSet();\n            unReset();\n            changeListeners.delete(cb);\n        };\n    };\n    const use = (...subscriptions) => {\n        const unsubs = subscriptions.reduce((unsubs, subscription) => {\n            if (subscription.set) {\n                unsubs.push(on('set', subscription.set));\n            }\n            if (subscription.get) {\n                unsubs.push(on('get', subscription.get));\n            }\n            if (subscription.reset) {\n                unsubs.push(on('reset', subscription.reset));\n            }\n            if (subscription.dispose) {\n                unsubs.push(on('dispose', subscription.dispose));\n            }\n            return unsubs;\n        }, []);\n        return () => unsubs.forEach((unsub) => unsub());\n    };\n    const forceUpdate = (key) => {\n        const oldValue = states.get(key);\n        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));\n    };\n    const removeListener = (propName, listener) => {\n        const listenerInfo = changeListeners.get(listener);\n        if (listenerInfo && listenerInfo.propName === propName) {\n            // Remove the specific handlers that were created for this listener\n            removeFromArray(handlers.set, listenerInfo.setHandler);\n            removeFromArray(handlers.reset, listenerInfo.resetHandler);\n            changeListeners.delete(listener);\n        }\n    };\n    return {\n        state,\n        get,\n        set,\n        on,\n        onChange,\n        use,\n        dispose,\n        reset,\n        forceUpdate,\n        removeListener,\n    };\n};\nconst removeFromArray = (array, item) => {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array[index] = array[array.length - 1];\n        array.length--;\n    }\n};\n\nconst createStore = (defaultState, shouldUpdate) => {\n    const map = createObservableMap(defaultState, shouldUpdate);\n    map.use(stencilSubscription());\n    return map;\n};\n\nexport { createObservableMap, createStore };\n","/**\n * Debug Utility\n * ==============\n *\n * Environment-aware logging utility for the grid-builder library. Provides conditional\n * logging that only outputs in development mode, keeping production console clean.\n *\n * ## Problem\n *\n * Development logging is helpful for debugging but pollutes production console:\n * - Performance tracking logs on every drag/resize\n * - Build timestamp logs on initialization\n * - State change debug messages\n * - Verbose interaction tracking\n *\n * ## Solution\n *\n * Centralized debug utility that checks environment before logging:\n * - Development: Full logging for debugging\n * - Production: Silent (no console pollution)\n * - Test: Configurable via `ENABLE_TEST_LOGS` flag\n *\n * ## Usage\n *\n * ```typescript\n * import { debug } from '../utils/debug';\n *\n * // Replace console.log with debug.log\n * debug.log('Component mounted', { itemId, canvasId });\n *\n * // Still use console.warn/error for actual issues\n * console.warn('Invalid configuration:', config);\n * ```\n *\n * ## Environment Detection\n *\n * **How it works**:\n * - Checks `process.env.NODE_ENV` at runtime\n * - StencilJS sets NODE_ENV during build\n * - Development builds: NODE_ENV = 'development'\n * - Production builds: NODE_ENV = 'production'\n * - Test builds: NODE_ENV = 'test'\n *\n * **Build-time optimization**:\n * - Production: debug.log() calls are no-ops (dead code elimination)\n * - Tree-shaking removes unused debug code\n * - Zero runtime overhead in production\n * @module debug\n */\n\n/**\n * Check if debug logging is enabled\n *\n * **Enabled when**:\n * - NODE_ENV === 'development'\n * - NODE_ENV === 'test' AND ENABLE_TEST_LOGS === true\n *\n * **Disabled when**:\n * - NODE_ENV === 'production'\n * - NODE_ENV === 'test' AND ENABLE_TEST_LOGS !== true\n * @returns true if debug logging should be enabled\n */\nfunction isDebugEnabled(): boolean {\n  // Check if we're in development mode\n  if (\n    typeof process !== \"undefined\" &&\n    process.env &&\n    process.env.NODE_ENV === \"development\"\n  ) {\n    return true;\n  }\n\n  // Allow test logs if explicitly enabled\n  if (\n    typeof process !== \"undefined\" &&\n    process.env &&\n    process.env.NODE_ENV === \"test\"\n  ) {\n    return process.env.ENABLE_TEST_LOGS === \"true\";\n  }\n\n  // Disable in production\n  return false;\n}\n\n/**\n * Debug logger instance\n *\n * Provides console.log-compatible methods that only log in development mode.\n * All methods are no-ops in production, allowing tree-shaking to remove them.\n */\nexport const debug = {\n  /**\n   * Log informational message\n   *\n   * **Use for**: General debugging, state changes, lifecycle events\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.log output\n   * @param args - Arguments to pass to console.log\n   * @example\n   * ```typescript\n   * debug.log('Item added:', item);\n   * debug.log('Grid size:', gridSize, 'for canvas:', canvasId);\n   * ```\n   */\n  log(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.log(...args);\n    }\n  },\n\n  /**\n   * Log warning message\n   *\n   * **Use for**: Recoverable issues, deprecation warnings, suspicious state\n   *\n   * **Note**: Consider using console.warn directly for warnings that should\n   * always be visible (even in production)\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.warn output\n   * @param args - Arguments to pass to console.warn\n   * @example\n   * ```typescript\n   * debug.warn('Deprecated API usage:', methodName);\n   * ```\n   */\n  warn(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.warn(...args);\n    }\n  },\n\n  /**\n   * Log error message\n   *\n   * **Use for**: Non-critical errors, caught exceptions, debugging errors\n   *\n   * **Note**: Use console.error directly for critical errors that should\n   * always be visible (even in production)\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.error output\n   * @param args - Arguments to pass to console.error\n   * @example\n   * ```typescript\n   * debug.error('Failed to initialize drag handler:', error);\n   * ```\n   */\n  error(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.error(...args);\n    }\n  },\n\n  /**\n   * Log grouped messages\n   *\n   * **Use for**: Complex debug output, nested data structures\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.group/groupEnd output\n   * @param label - Group label\n   * @param fn - Function to execute within group\n   * @example\n   * ```typescript\n   * debug.group('Drag operation', () => {\n   *   debug.log('Start position:', startPos);\n   *   debug.log('End position:', endPos);\n   *   debug.log('Delta:', delta);\n   * });\n   * ```\n   */\n  group(label: string, fn: () => void): void {\n    if (isDebugEnabled()) {\n      console.group(label);\n      fn();\n      console.groupEnd();\n    }\n  },\n\n  /**\n   * Check if debug mode is enabled\n   *\n   * **Use for**: Expensive debug operations that should be skipped in production\n   * @returns true if debug logging is enabled\n   * @example\n   * ```typescript\n   * if (debug.isEnabled()) {\n   *   // Expensive operation only in development\n   *   const stats = calculateDetailedStats();\n   *   debug.log('Stats:', stats);\n   * }\n   * ```\n   */\n  isEnabled(): boolean {\n    return isDebugEnabled();\n  },\n};\n\n/**\n * Create a namespaced debug logger\n *\n * **Use for**: Module-specific logging with consistent prefixes\n * @param namespace - Namespace for log messages (e.g., 'drag-handler', 'grid-calculations')\n * @returns Debug logger with namespace prefix\n * @example\n * ```typescript\n * // In drag-handler.ts\n * const debug = createDebugLogger('drag-handler');\n * debug.log('Drag started'); // → [drag-handler] Drag started\n * ```\n */\nexport function createDebugLogger(namespace: string) {\n  return {\n    log(...args: any[]): void {\n      debug.log(`[${namespace}]`, ...args);\n    },\n    warn(...args: any[]): void {\n      debug.warn(`[${namespace}]`, ...args);\n    },\n    error(...args: any[]): void {\n      debug.error(`[${namespace}]`, ...args);\n    },\n    group(label: string, fn: () => void): void {\n      debug.group(`[${namespace}] ${label}`, fn);\n    },\n    isEnabled(): boolean {\n      return debug.isEnabled();\n    },\n  };\n}\n","/**\n * Input Validation Utilities\n * ===========================\n *\n * Validates grid item data structure and bounds to prevent corrupt state.\n * Used for defensive programming in state-manager operations.\n *\n * ## Design Philosophy\n *\n * **Non-blocking validation**:\n * - All validation functions return results with warnings\n * - State operations proceed even if validation fails\n * - Warnings logged via debug utility (dev-only, tree-shaken in production)\n *\n * **What validation protects against**:\n * - State corruption (invalid layouts causing render errors)\n * - Layout integrity violations (out-of-bounds positions)\n * - Data persistence issues (malformed items in export)\n * - Undo/redo stack corruption (invalid snapshots)\n *\n * **What validation does NOT protect against**:\n * - XSS attacks (handled by API documentation in ComponentDefinition)\n * - Authentication/authorization (not library's responsibility)\n * - Network attacks (library is client-side only)\n *\n * ## Validation Rules\n *\n * **Desktop Layout**:\n * - x ≥ 0 (left boundary)\n * - y ≥ 0 (top boundary)\n * - width: 1-50 units (2%-100% of canvas)\n * - height: 1-100 units (20px-2000px typically)\n *\n * **Mobile Layout**:\n * - Same bounds as desktop if values present\n * - May be auto-generated (customized: false)\n *\n * **Item Properties**:\n * - id: non-empty string\n * - canvasId: non-empty string\n * - type: non-empty string\n * - zIndex: finite number\n * @module validation\n */\n\n/**\n * Validation result with success flag and error messages\n */\nexport interface ValidationResult {\n  /** True if validation passed, false if any errors */\n  valid: boolean;\n\n  /** Array of validation error messages */\n  errors: string[];\n}\n\n/**\n * Grid layout bounds configuration\n */\nconst LAYOUT_BOUNDS = {\n  x: { min: 0, max: Infinity },\n  y: { min: 0, max: Infinity },\n  width: { min: 1, max: 50 }, // 50 units = 100% canvas width\n  height: { min: 1, max: 100 }, // Reasonable maximum height\n};\n\n/**\n * Validate a single layout object (desktop or mobile)\n *\n * **Checks**:\n * - All required properties present (x, y, width, height)\n * - All values are finite numbers\n * - Values within valid bounds\n * @param layout - Layout object to validate\n * @param layoutType - 'desktop' or 'mobile' (for error messages)\n * @returns ValidationResult with errors if any\n */\nexport function validateLayout(\n  layout: any,\n  layoutType: string,\n): ValidationResult {\n  const errors: string[] = [];\n\n  // Check required properties\n  if (!layout) {\n    errors.push(`${layoutType} layout is missing or undefined`);\n    return { valid: false, errors };\n  }\n\n  // Check numeric properties\n  const numericProps = [\"x\", \"y\", \"width\", \"height\"];\n  for (const prop of numericProps) {\n    if (typeof layout[prop] !== \"number\" || !Number.isFinite(layout[prop])) {\n      errors.push(\n        `${layoutType} layout.${prop} must be a finite number, got: ${layout[prop]}`,\n      );\n    }\n  }\n\n  // Check bounds\n  if (Number.isFinite(layout.x) && layout.x < LAYOUT_BOUNDS.x.min) {\n    errors.push(\n      `${layoutType} layout.x must be >= ${LAYOUT_BOUNDS.x.min}, got: ${layout.x}`,\n    );\n  }\n\n  if (Number.isFinite(layout.y) && layout.y < LAYOUT_BOUNDS.y.min) {\n    errors.push(\n      `${layoutType} layout.y must be >= ${LAYOUT_BOUNDS.y.min}, got: ${layout.y}`,\n    );\n  }\n\n  if (\n    Number.isFinite(layout.width) &&\n    (layout.width < LAYOUT_BOUNDS.width.min ||\n      layout.width > LAYOUT_BOUNDS.width.max)\n  ) {\n    errors.push(\n      `${layoutType} layout.width must be between ${LAYOUT_BOUNDS.width.min}-${LAYOUT_BOUNDS.width.max}, got: ${layout.width}`,\n    );\n  }\n\n  if (\n    Number.isFinite(layout.height) &&\n    (layout.height < LAYOUT_BOUNDS.height.min ||\n      layout.height > LAYOUT_BOUNDS.height.max)\n  ) {\n    errors.push(\n      `${layoutType} layout.height must be between ${LAYOUT_BOUNDS.height.min}-${LAYOUT_BOUNDS.height.max}, got: ${layout.height}`,\n    );\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Validate a complete grid item structure\n *\n * **Checks**:\n * - Required properties: id, canvasId, type, zIndex, layouts\n * - String properties are non-empty\n * - zIndex is finite number\n * - Desktop layout is valid\n * - Mobile layout is valid (if present)\n *\n * **Usage**:\n * ```typescript\n * const result = validateGridItem(item);\n * if (!result.valid) {\n * debug.warn('Invalid item:', { itemId: item.id, errors: result.errors });\n * }\n * ```\n * @param item - Grid item to validate\n * @returns ValidationResult with errors if any\n */\nexport function validateGridItem(item: any): ValidationResult {\n  const errors: string[] = [];\n\n  // Check required properties exist\n  if (!item) {\n    errors.push(\"Item is null or undefined\");\n    return { valid: false, errors };\n  }\n\n  // Validate id\n  if (typeof item.id !== \"string\" || item.id.trim() === \"\") {\n    errors.push(`Item.id must be a non-empty string, got: ${item.id}`);\n  }\n\n  // Validate canvasId\n  if (typeof item.canvasId !== \"string\" || item.canvasId.trim() === \"\") {\n    errors.push(\n      `Item.canvasId must be a non-empty string, got: ${item.canvasId}`,\n    );\n  }\n\n  // Validate type\n  if (typeof item.type !== \"string\" || item.type.trim() === \"\") {\n    errors.push(`Item.type must be a non-empty string, got: ${item.type}`);\n  }\n\n  // Validate zIndex\n  if (typeof item.zIndex !== \"number\" || !Number.isFinite(item.zIndex)) {\n    errors.push(\n      `Item.zIndex must be a finite number, got: ${item.zIndex} (type: ${typeof item.zIndex})`,\n    );\n  }\n\n  // Validate layouts object\n  if (!item.layouts || typeof item.layouts !== \"object\") {\n    errors.push(\"Item.layouts must be an object\");\n    return { valid: false, errors };\n  }\n\n  // Validate desktop layout (required)\n  const desktopResult = validateLayout(item.layouts.desktop, \"desktop\");\n  if (!desktopResult.valid) {\n    errors.push(...desktopResult.errors);\n  }\n\n  // Validate mobile layout (optional, but if present must be valid)\n  if (item.layouts.mobile) {\n    const mobileResult = validateLayout(item.layouts.mobile, \"mobile\");\n    if (!mobileResult.valid) {\n      errors.push(...mobileResult.errors);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Validate item update object (partial updates)\n *\n * **Checks**:\n * - If layout updates present, validate layout structure\n * - If zIndex update present, validate it's a finite number\n * - If config update present, validate it's an object\n *\n * **Usage**:\n * ```typescript\n * const result = validateItemUpdates(updates);\n * if (!result.valid) {\n * debug.warn('Invalid updates:', { itemId, errors: result.errors });\n * }\n * ```\n * @param updates - Partial item updates to validate\n * @returns ValidationResult with errors if any\n */\nexport function validateItemUpdates(updates: any): ValidationResult {\n  const errors: string[] = [];\n\n  if (!updates || typeof updates !== \"object\") {\n    errors.push(\"Updates must be an object\");\n    return { valid: false, errors };\n  }\n\n  // Validate layouts if present\n  if (updates.layouts) {\n    if (typeof updates.layouts !== \"object\") {\n      errors.push(\"Updates.layouts must be an object\");\n    } else {\n      // Validate desktop layout if present\n      if (updates.layouts.desktop) {\n        const desktopResult = validateLayout(\n          updates.layouts.desktop,\n          \"desktop\",\n        );\n        if (!desktopResult.valid) {\n          errors.push(...desktopResult.errors);\n        }\n      }\n\n      // Validate mobile layout if present\n      if (updates.layouts.mobile) {\n        const mobileResult = validateLayout(updates.layouts.mobile, \"mobile\");\n        if (!mobileResult.valid) {\n          errors.push(...mobileResult.errors);\n        }\n      }\n    }\n  }\n\n  // Validate zIndex if present\n  if (\n    \"zIndex\" in updates &&\n    (typeof updates.zIndex !== \"number\" || !Number.isFinite(updates.zIndex))\n  ) {\n    errors.push(\n      `Updates.zIndex must be a finite number, got: ${updates.zIndex}`,\n    );\n  }\n\n  // Validate config if present (must be object, but any shape is allowed)\n  if (\"config\" in updates && typeof updates.config !== \"object\") {\n    errors.push(\n      `Updates.config must be an object, got: ${typeof updates.config}`,\n    );\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * State Manager\n * ==============\n *\n * Centralized reactive state management for the grid builder using StencilJS Store.\n * Manages grid items, canvases, layouts, selection state, and viewport configuration\n * with automatic component re-renders on state changes.\n *\n * ## Problem\n *\n * Complex interactive applications need:\n * - Centralized state accessible across all components\n * - Automatic UI updates when state changes\n * - Type-safe state mutations\n * - Undo/redo support (requires state snapshots)\n * - Desktop + mobile layout management\n * - Selection tracking across multiple canvases\n *\n * Without centralized state:\n * - Props drilling through component hierarchies\n * - Manual event subscriptions and cleanup\n * - Synchronization issues between components\n * - Difficult undo/redo implementation\n *\n * ## Solution\n *\n * Use @stencil/store for reactive state management with:\n * 1. **Single source of truth**: All state in one store\n * 2. **Automatic reactivity**: Components re-render on state changes\n * 3. **Type safety**: Full TypeScript support\n * 4. **Simple API**: Direct property access (no actions/reducers)\n * 5. **Lightweight**: ~1KB, built into StencilJS\n *\n * ## Architecture Decisions\n *\n * ### Why @stencil/store vs Redux/Zustand?\n *\n * **@stencil/store chosen because**:\n * - ✅ Native StencilJS integration (zero setup)\n * - ✅ Automatic component subscriptions (no manual connect/subscribe)\n * - ✅ Simple mutation API (direct property assignment)\n * - ✅ Tiny bundle size (~1KB)\n * - ✅ Full TypeScript support\n * - ✅ Perfect for component-scoped state\n *\n * **Redux would add**:\n * - ❌ Boilerplate (actions, reducers, dispatch)\n * - ❌ Bundle size (~15KB min)\n * - ❌ Learning curve (middleware, selectors)\n * - ❌ Manual component subscriptions\n *\n * **Zustand would work but**:\n * - ⚠️ External dependency (not StencilJS native)\n * - ⚠️ Manual subscriptions in StencilJS\n * - ⚠️ Less TypeScript integration\n *\n * ### Dual Layout System (Desktop + Mobile)\n *\n * Each grid item has TWO layout configurations:\n *\n * **Desktop Layout** (always present):\n * - Primary layout with full positioning data\n * - x, y, width, height in grid units\n * - Never null, always has values\n *\n * **Mobile Layout** (optional/auto-generated):\n * - x, y, width, height can be null\n * - `customized: false` → auto-generated from desktop layout\n * - `customized: true` → user manually positioned in mobile view\n *\n * **Why dual layouts**:\n * - Different screen sizes need different layouts\n * - Mobile can auto-adapt OR be manually customized\n * - Single item definition works across viewports\n *\n * **Auto-generation strategy**:\n * ```typescript\n * // When mobile layout is null (not customized):\n * // - Full width items (span entire mobile viewport)\n * // - Stacked vertically\n * // - Responsive heights\n *\n * // When mobile.customized = true:\n * // - Use explicit mobile.x, mobile.y, mobile.width, mobile.height\n * // - Ignore desktop layout\n * ```\n *\n * ### State Mutation Pattern\n *\n * **Immutable spread pattern** for reactivity:\n * ```typescript\n * // ❌ Wrong: Direct mutation doesn't trigger updates\n * canvas.items.push(newItem);\n *\n * // ✅ Correct: Spread triggers reactivity\n * canvas.items.push(newItem);\n * state.canvases = { ...state.canvases };\n * ```\n *\n * **Why this pattern**:\n * - StencilJS store detects reference changes\n * - Object spread creates new reference\n * - Components automatically re-render\n * - Simple and performant\n *\n * ### Z-Index Management\n *\n * **Per-canvas z-index tracking**:\n * - Each canvas has `zIndexCounter` (monotonically increasing)\n * - New items get `zIndexCounter++`\n * - Ensures unique z-index per canvas\n * - Higher z-index = rendered on top\n *\n * **Why per-canvas**:\n * - Items in different canvases don't overlap\n * - Simplifies z-index calculations\n * - Prevents z-index conflicts\n * - Independent stacking contexts\n *\n * **Bringing to front**:\n * ```typescript\n * item.zIndex = canvas.zIndexCounter++;\n * state.canvases = { ...state.canvases }; // Trigger update\n * ```\n *\n * ## State Structure\n *\n * ```typescript\n * {\n * canvases: {\n * 'canvas1': {\n * items: [GridItem, GridItem, ...],\n * zIndexCounter: 5,\n * backgroundColor: '#ffffff'\n * },\n * 'canvas2': { ... },\n * ...\n * },\n * selectedItemId: 'item-3' | null,\n * selectedCanvasId: 'canvas1' | null,\n * currentViewport: 'desktop' | 'mobile',\n * showGrid: true | false\n * }\n * ```\n *\n * ## Performance Characteristics\n *\n * **State access**: O(1) - direct property access\n * **State updates**: O(n) - spread operation copies references\n * **Component re-renders**: Only components consuming changed state\n * **Memory**: Lightweight (~1KB store + actual state data)\n *\n * **Optimization**: Immutable updates only copy top-level references,\n * not deep clones. Child objects remain same reference if unchanged.\n *\n * ## Integration with Undo/Redo\n *\n * State structure supports undo/redo via snapshots:\n * ```typescript\n * // Save snapshot\n * const snapshot = JSON.parse(JSON.stringify(state.canvases));\n *\n * // Restore snapshot\n * state.canvases = JSON.parse(JSON.stringify(snapshot));\n * ```\n *\n * Deep cloning required because:\n * - Prevents mutations from affecting history\n * - Ensures independent state snapshots\n * - Simple and reliable (no ref tracking)\n *\n * ## Extracting This Pattern\n *\n * To adapt for other frameworks:\n *\n * **React + Zustand**:\n * ```typescript\n * import create from 'zustand';\n *\n * const useStore = create<GridState>((set) => ({\n * ...initialState,\n * addItem: (canvasId, item) => set((state) => ({\n * canvases: {\n * ...state.canvases,\n * [canvasId]: {\n * ...state.canvases[canvasId],\n * items: [...state.canvases[canvasId].items, item]\n * }\n * }\n * }))\n * }));\n * ```\n *\n * **Vue + Pinia**:\n * ```typescript\n * import { defineStore } from 'pinia';\n *\n * export const useGridStore = defineStore('grid', {\n * state: () => initialState,\n * actions: {\n * addItem(canvasId, item) {\n * this.canvases[canvasId].items.push(item);\n * }\n * }\n * });\n * ```\n *\n * **Angular + NgRx**:\n * ```typescript\n * export const addItem = createAction(\n * '[Grid] Add Item',\n * props<{ canvasId: string; item: GridItem }>()\n * );\n *\n * export const gridReducer = createReducer(\n * initialState,\n * on(addItem, (state, { canvasId, item }) => ({\n * ...state,\n * canvases: {\n * ...state.canvases,\n * [canvasId]: {\n * ...state.canvases[canvasId],\n * items: [...state.canvases[canvasId].items, item]\n * }\n * }\n * }))\n * );\n * ```\n * @module state-manager\n */\n\nimport { createStore } from \"@stencil/store\";\nimport { createDebugLogger } from \"../utils/debug\";\nimport { validateGridItem, validateItemUpdates } from \"../utils/validation\";\n\n/**\n * Grid Item Interface\n * ====================\n *\n * Core data structure representing a single component instance in the grid.\n * Each item has dual layouts (desktop + mobile) and positioning metadata.\n *\n * **Lifecycle**:\n * 1. Created when dropped from palette or added programmatically\n * 2. Updated during drag/resize operations\n * 3. Persisted in state for undo/redo\n * 4. Removed when deleted\n *\n * **Key Properties**:\n * - `id`: Unique identifier (generated via generateItemId)\n * - `canvasId`: Which canvas owns this item\n * - `type`: Component type ('header', 'text', 'button', etc.)\n * - `name`: Display name (shown in UI)\n * - `layouts`: Desktop and mobile positioning\n * - `zIndex`: Stacking order within canvas\n *\n * **Type System Integration**:\n * The `type` field determines which component renders via dynamic imports:\n * ```typescript\n * switch (item.type) {\n *   case 'header': return <component-header />;\n *   case 'text': return <component-text-block />;\n *   case 'button': return <component-button />;\n *   // ...\n * }\n * ```\n */\nexport interface GridItem {\n  /** Unique item identifier (e.g., 'item-1', 'item-2') */\n  id: string;\n\n  /** Canvas ID this item belongs to (e.g., 'canvas1', 'canvas2') */\n  canvasId: string;\n\n  /** Component type determining which component renders ('header', 'text', 'button', etc.) */\n  type: string;\n\n  /** Display name shown in UI */\n  name: string;\n\n  /**\n   * Dual layout system for responsive design\n   *\n   * **Desktop Layout** (required, never null):\n   * - Primary layout used in desktop viewport\n   * - All properties (x, y, width, height) always have numeric values\n   * - Coordinates in grid units (not pixels)\n   *\n   * **Mobile Layout** (optional/auto-generated):\n   * - Properties can be null when not customized\n   * - `customized: false` → Auto-generated layout (full-width, stacked)\n   * - `customized: true` → User manually positioned in mobile view\n   *\n   * **Auto-generation behavior** (when mobile.customized = false):\n   * ```typescript\n   * // grid-item-wrapper.tsx calculates:\n   * x: 0 (left edge)\n   * y: calculatedFromStackOrder\n   * width: 50 (full width = 100% of viewport)\n   * height: desktop.height (maintain aspect ratio)\n   * ```\n   *\n   * **Example usage**:\n   * ```typescript\n   * const item: GridItem = {\n   *   id: 'item-1',\n   *   canvasId: 'canvas1',\n   *   type: 'header',\n   *   name: 'Hero Header',\n   *   layouts: {\n   *     desktop: { x: 5, y: 2, width: 20, height: 8 },\n   *     mobile: {\n   *       x: null, y: null, width: null, height: null,\n   *       customized: false // Will auto-generate\n   *     }\n   *   },\n   *   zIndex: 1\n   * };\n   * ```\n   */\n  layouts: {\n    /** Desktop layout (always fully defined) */\n    desktop: {\n      /** Horizontal position in grid units (0 = left edge) */\n      x: number;\n\n      /** Vertical position in grid units (0 = top edge) */\n      y: number;\n\n      /** Width in grid units (e.g., 20 units at 2% = 40% of container) */\n      width: number;\n\n      /** Height in grid units (e.g., 8 units × 20px = 160px) */\n      height: number;\n    };\n\n    /** Mobile layout (optional/auto-generated) */\n    mobile: {\n      /** Horizontal position or null for auto-generation */\n      x: number | null;\n\n      /** Vertical position or null for auto-generation */\n      y: number | null;\n\n      /** Width or null for auto-generation (typically full-width) */\n      width: number | null;\n\n      /** Height or null for auto-generation */\n      height: number | null;\n\n      /**\n       * Whether user manually customized mobile layout\n       *\n       * **false**: Auto-generate from desktop layout\n       * - Full width (50 grid units)\n       * - Stacked vertically\n       * - Maintains desktop height\n       *\n       * **true**: Use explicit mobile x/y/width/height\n       * - User dragged/resized in mobile view\n       * - Ignore desktop layout\n       * - Persist custom positioning\n       */\n      customized: boolean;\n    };\n  };\n\n  /**\n   * Stacking order within canvas (higher = on top)\n   *\n   * **Assignment**: New items get `canvas.zIndexCounter++`\n   * **Bringing to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Per-canvas**: Z-indexes only compete within same canvas\n   */\n  zIndex: number;\n\n  /**\n   * Component configuration data\n   *\n   * **Purpose**: Store component-specific settings (text, color, etc.)\n   * **Structure**: Record<string, any> matching ComponentDefinition.configSchema\n   * **Default**: Empty object {} when component created\n   *\n   * **Example**:\n   * ```typescript\n   * // Header component config\n   * config: {\n   *   text: 'Welcome!',\n   *   level: 'H1',\n   *   color: '#000000',\n   *   alignment: 'center'\n   * }\n   * ```\n   */\n  config?: Record<string, any>;\n}\n\n/**\n * Canvas Interface\n * =================\n *\n * Represents a single canvas container (section) in the grid builder.\n * Each canvas is an independent dropzone with its own items and z-index tracking.\n *\n * **Typical usage**: Multi-section landing pages\n * - canvas1 = Hero section\n * - canvas2 = Content section\n * - canvas3 = Footer section\n *\n * **Why multiple canvases**:\n * - Logical content sections\n * - Independent z-index contexts\n * - Different background colors per section\n * - Easier content organization\n *\n * **Example**:\n * ```typescript\n * const heroCanvas: Canvas = {\n *   items: [headerItem, textItem, buttonItem, imageItem],\n *   zIndexCounter: 5, // Next item gets zIndex: 5\n *   backgroundColor: '#ffffff'\n * };\n * ```\n */\n/**\n * Canvas Interface\n * ==================\n *\n * Minimal canvas structure focused purely on item placement management.\n *\n * **Library responsibilities** (what IS in this interface):\n * - Item placement and layouts\n * - Z-index management for stacking\n *\n * **Host app responsibilities** (what is NOT in this interface):\n * - Canvas styling (backgroundColor, themes, etc.)\n * - Canvas metadata (title, description, etc.)\n * - Presentation concerns (how canvases look)\n *\n * **Why this separation**:\n * - Different apps have different styling needs\n * - Library focuses on layout, not presentation\n * - Host app owns the complete data model\n * - Enables library to be used in any context\n *\n * **Host app pattern**:\n * ```typescript\n * // Host app maintains its own canvas metadata\n * const canvasMetadata = {\n *   'canvas1': { title: 'Hero Section', backgroundColor: '#f0f4f8', ... },\n *   'canvas2': { title: 'Footer', backgroundColor: '#e8f0f2', ... }\n * };\n *\n * // Library only knows about item placement\n * const gridState = {\n *   canvases: {\n *     'canvas1': { items: [...], zIndexCounter: 5 },\n *     'canvas2': { items: [...], zIndexCounter: 3 }\n *   }\n * };\n * ```\n */\nexport interface Canvas {\n  /**\n   * Array of grid items in this canvas\n   *\n   * **Rendering**: Items render in DOM order, styled with z-index for stacking\n   * **Mutation**: Always use spread pattern to trigger reactivity\n   */\n  items: GridItem[];\n\n  /**\n   * Monotonically increasing counter for z-index assignment\n   *\n   * **New items**: `item.zIndex = canvas.zIndexCounter++`\n   * **Bring to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Never decreases**: Only increments to prevent conflicts\n   */\n  zIndexCounter: number;\n}\n\n/**\n * Grid State Interface\n * =====================\n *\n * Root state structure for entire grid builder application.\n * Manages all canvases, selection state, and viewport configuration.\n *\n * **Single source of truth**: All app state in this one object\n * **Reactivity**: Changes trigger automatic component re-renders\n * **Persistence**: Can be serialized to JSON for save/export\n *\n * **Access pattern**:\n * ```typescript\n * import { gridState } from './state-manager';\n *\n * // Read state\n * const items = gridState.canvases['canvas1'].items;\n *\n * // Mutate state (triggers reactivity)\n * gridState.selectedItemId = 'item-5';\n * gridState.canvases = { ...gridState.canvases }; // After mutations\n * ```\n */\nexport interface GridState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': Canvas, 'canvas2': Canvas, ... }`\n   * **Access**: `gridState.canvases['canvas1']`\n   * **Dynamic canvases**: Can add/remove canvases at runtime\n   */\n  canvases: Record<string, Canvas>;\n\n  /**\n   * Currently selected item ID or null if no selection\n   *\n   * **Selection flow**:\n   * 1. User clicks item → `selectItem(itemId, canvasId)`\n   * 2. State updates → `selectedItemId = 'item-3'`\n   * 3. Components re-render with visual selection indicators\n   *\n   * **Deselection**: Click canvas background → `deselectItem()` → `null`\n   */\n  selectedItemId: string | null;\n\n  /**\n   * Canvas ID containing currently selected item\n   *\n   * **Why needed**: Item IDs are unique across canvases, but need canvas\n   * for operations like delete, move, etc.\n   *\n   * **Always paired**: When `selectedItemId` is set, `selectedCanvasId` must be set\n   */\n  selectedCanvasId: string | null;\n\n  /**\n   * Currently active/focused canvas ID or null if none active\n   *\n   * **Selection flow**:\n   * 1. User interacts with canvas (click, drag, resize) → `setActiveCanvas(canvasId)`\n   * 2. State updates → `activeCanvasId = 'canvas1'`\n   * 3. Canvas section component receives isActive prop\n   * 4. Visual feedback applied (title opacity, border, etc.)\n   *\n   * **Activation triggers**:\n   * - Clicking item on canvas\n   * - Clicking canvas background\n   * - Starting drag operation on item\n   * - Starting resize operation on item\n   *\n   * **Use cases**:\n   * - Highlight which section user is working on\n   * - Show canvas-specific settings panel\n   * - Provide visual context in multi-section layouts\n   *\n   * **Difference from selectedCanvasId**:\n   * - `selectedCanvasId`: Canvas containing selected **item** (editing focus)\n   * - `activeCanvasId`: Canvas that is **active** for interaction (section focus)\n   */\n  activeCanvasId: string | null;\n\n  /**\n   * Current viewport mode (desktop or mobile)\n   *\n   * **Affects**:\n   * - Which layout is rendered (item.layouts.desktop vs item.layouts.mobile)\n   * - Grid calculations (responsive vs fixed)\n   * - Canvas width (full vs mobile viewport)\n   *\n   * **Toggle**: User clicks viewport switcher button\n   */\n  currentViewport: \"desktop\" | \"mobile\";\n\n  /**\n   * Whether to show grid lines on canvases\n   *\n   * **Visual aid**: Helps users align items to grid\n   * **Toggle**: User clicks grid visibility button\n   * **Rendering**: CSS background-image with grid pattern\n   */\n  showGrid: boolean;\n}\n\n/**\n * Viewer-Only State Interfaces\n * ==============================\n *\n * Minimal state types for grid-viewer component (rendering-only mode).\n * These are subsets of the full editing state, excluding editing-specific properties.\n *\n * ## Separation of Concerns\n *\n * **Builder App** (grid-builder):\n * - Full GridState with selection, z-index tracking, etc.\n * - Includes interact.js for drag-and-drop (~45KB)\n * - Bundle size: ~150KB\n *\n * **Viewer App** (grid-viewer):\n * - Minimal ViewerState without editing features\n * - No interact.js dependency\n * - Bundle size: ~30KB (80% reduction)\n *\n * ## Export/Import Workflow\n *\n * ```typescript\n * // Builder App → Export layout\n * const builder = document.querySelector('grid-builder');\n * const exportData = await builder.exportState();\n * await fetch('/api/layouts', {\n *   method: 'POST',\n *   body: JSON.stringify(exportData)\n * });\n *\n * // Viewer App → Import layout\n * const layout = await fetch('/api/layouts/123').then(r => r.json());\n * const viewer = document.querySelector('grid-viewer');\n * viewer.initialState = layout;\n * ```\n *\n * ## What's Excluded from Viewer\n *\n * **Canvas.zIndexCounter** - Editing-only state:\n * - Tracks next z-index for new items\n * - Not needed in viewer (items already have zIndex)\n * - Viewer reads item.zIndex directly\n *\n * **GridState.selectedItemId/selectedCanvasId** - Editing-only state:\n * - Tracks which item is selected for editing\n * - Not needed in viewer (no selection UI)\n * - Viewer only renders, never selects\n *\n * **GridState.showGrid** - Editing-only state:\n * - Visual aid for aligning items during editing\n * - Not needed in viewer (no editing)\n * - Viewer renders clean output without grid lines\n *\n * ## Type Compatibility\n *\n * ViewerState is intentionally compatible with GridExport format:\n * ```typescript\n * // GridExport can be used as ViewerState\n * const exportData: GridExport = await builder.exportState();\n * viewer.initialState = exportData; // Type-safe!\n * ```\n */\n\n/**\n * Viewer Canvas Interface\n * ========================\n *\n * Minimal canvas structure for viewer mode (rendering-only).\n * Excludes editing-specific properties like zIndexCounter.\n *\n * **Differences from Canvas**:\n * - ✅ items: Array of ViewerItem (same as GridItem)\n * - ❌ zIndexCounter: Not needed (items already have zIndex)\n *\n * **Use in viewer**:\n * ```typescript\n * const canvas: ViewerCanvas = {\n *   items: [\n *     { id: 'item-1', type: 'header', zIndex: 1, ... },\n *     { id: 'item-2', type: 'text', zIndex: 2, ... }\n *   ]\n * };\n *\n * // Render items in z-index order\n * const sortedItems = canvas.items.sort((a, b) => a.zIndex - b.zIndex);\n * ```\n */\nexport interface ViewerCanvas {\n  /** Grid items in this canvas (rendering-only, no editing state) */\n  items: GridItem[]; // Reuse GridItem - it's already clean and serializable\n}\n\n/**\n * Viewer State Interface\n * =======================\n *\n * Minimal state structure for grid-viewer component (rendering-only mode).\n * Subset of GridState excluding all editing-specific properties.\n *\n * **Differences from GridState**:\n * - ✅ canvases: Record<string, ViewerCanvas>\n * - ✅ currentViewport: 'desktop' | 'mobile'\n * - ❌ selectedItemId: Not needed (no selection in viewer)\n * - ❌ selectedCanvasId: Not needed (no selection in viewer)\n * - ❌ showGrid: Not needed (no grid lines in viewer)\n *\n * **Why minimal state**:\n * - Smaller bundle size (no editing logic)\n * - Simpler component tree (no interact.js)\n * - Faster initialization (no drag/drop setup)\n * - Clean separation of concerns\n *\n * **Use in viewer**:\n * ```typescript\n * // Initialize viewer from exported layout\n * const viewerState: ViewerState = {\n *   canvases: {\n *     'hero-section': {\n *       items: [\n *         {\n *           id: 'header-1',\n *           canvasId: 'hero-section',\n *           type: 'header',\n *           name: 'Hero Header',\n *           layouts: {\n *             desktop: { x: 0, y: 0, width: 50, height: 6 },\n *             mobile: { x: null, y: null, width: null, height: null, customized: false }\n *           },\n *           zIndex: 1,\n *           config: { title: 'Welcome!' }\n *         }\n *       ]\n *     }\n *   },\n *   currentViewport: 'desktop'\n * };\n * ```\n *\n * **Type-safe import from GridExport**:\n * ```typescript\n * import { GridExport } from '../types/grid-export';\n *\n * function convertExportToViewerState(exportData: GridExport): ViewerState {\n *   return {\n *     canvases: exportData.canvases,\n *     currentViewport: exportData.viewport\n *   };\n * }\n * ```\n */\nexport interface ViewerState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': ViewerCanvas, 'canvas2': ViewerCanvas, ... }`\n   * **Rendering**: Each canvas section renders its items in z-index order\n   * **Responsive**: Switches between desktop/mobile layouts based on currentViewport\n   */\n  canvases: Record<string, ViewerCanvas>;\n\n  /**\n   * Current viewport mode (desktop or mobile)\n   *\n   * **Affects**:\n   * - Which layout is rendered (item.layouts.desktop vs item.layouts.mobile)\n   * - Responsive layout calculations\n   * - Canvas width and item positioning\n   *\n   * **Auto-switching**: Can use ResizeObserver for container-based switching\n   * **Manual override**: Can be set via props or API\n   */\n  currentViewport: \"desktop\" | \"mobile\";\n\n  /**\n   * Selected item ID (editing-only, always null in viewer mode)\n   *\n   * **Purpose**: Allows grid-item-wrapper to access this field without defensive guards\n   * **Value**: Always null in viewer mode (no selection support)\n   * **Builder mode**: This field is actively used for selection tracking\n   */\n  selectedItemId: string | null;\n\n  /**\n   * Selected canvas ID (editing-only, always null in viewer mode)\n   *\n   * **Purpose**: Allows grid-item-wrapper to access this field without defensive guards\n   * **Value**: Always null in viewer mode (no selection support)\n   * **Builder mode**: This field is actively used for selection tracking\n   */\n  selectedCanvasId: string | null;\n\n  /**\n   * Active canvas ID (editing-only, always null in viewer mode)\n   *\n   * **Purpose**: Allows grid-item-wrapper to access this field without defensive guards\n   * **Value**: Always null in viewer mode (no active canvas concept)\n   * **Builder mode**: This field tracks which canvas is currently focused for editing\n   */\n  activeCanvasId: string | null;\n}\n\n/**\n * Initial State Configuration\n * ============================\n *\n * Default empty state for new StateManager instances.\n * Library starts with NO canvases by default.\n *\n * **Why completely empty**:\n * - Prevents state pollution between instances\n * - Ensures each grid-builder instance starts fresh\n * - Avoids \"Unknown component type\" errors\n * - Each instance builds its own canvas structure\n */\nconst defaultInitialState: GridState = {\n  canvases: {},\n  selectedItemId: null,\n  selectedCanvasId: null,\n  activeCanvasId: null,\n  currentViewport: \"desktop\",\n  showGrid: true,\n};\n\n/**\n * Debug logger for validation warnings\n */\nconst debug = createDebugLogger(\"state-manager\");\n\n/**\n * StateManager Class\n * ==================\n *\n * Instance-based state management for grid builder.\n * Each grid-builder component can create its own StateManager instance.\n *\n * ## Architecture\n *\n * **Before (Singleton)**:\n * - Single global state shared by all grid-builder instances\n * - Multiple instances pollute each other's state\n * - Storybook stories contaminate each other\n *\n * **After (Instance-based)**:\n * - Each grid-builder creates its own StateManager\n * - Isolated state per instance\n * - Multiple grid-builders on same page work independently\n *\n * ## Usage\n *\n * **New code (instance-based)**:\n * ```typescript\n * // In grid-builder component\n * componentWillLoad() {\n *   this.stateManager = new StateManager();\n *   this.state = this.stateManager.state;\n * }\n * ```\n *\n * **Legacy code (backward compatible)**:\n * ```typescript\n * // Still works via singleton export\n * import { gridState } from './state-manager';\n * const items = gridState.canvases['canvas1'].items;\n * ```\n *\n * ## Instance State\n *\n * Each instance has:\n * - Independent reactive state (StencilJS store)\n * - Own item ID counter (no collision between instances)\n * - Own change listeners\n * - Own lifecycle (dispose() cleanup)\n */\nexport class StateManager {\n  /**\n   * Reactive state proxy (mutate to trigger updates)\n   *\n   * **Access pattern**:\n   * ```typescript\n   * const items = stateManager.state.canvases['canvas1'].items;\n   * ```\n   *\n   * **Mutation pattern**:\n   * ```typescript\n   * stateManager.state.selectedItemId = 'item-5';\n   * stateManager.state.canvases = { ...stateManager.state.canvases };\n   * ```\n   */\n  public state: GridState;\n\n  /**\n   * Subscribe to state changes\n   *\n   * **Usage**:\n   * ```typescript\n   * const unsubscribe = stateManager.onChange('canvases', (newVal, oldVal) => {\n   *   console.log('Canvases changed:', newVal);\n   * });\n   * ```\n   *\n   * **Type**: Inferred from StencilJS store (OnChangeHandler<GridState>)\n   */\n  public onChange;\n\n  /**\n   * Cleanup subscriptions (called on component unmount)\n   *\n   * **Usage**:\n   * ```typescript\n   * disconnectedCallback() {\n   *   this.stateManager.dispose();\n   * }\n   * ```\n   */\n  public dispose: () => void;\n\n  /**\n   * Item ID counter for generating unique IDs\n   *\n   * **Starts at 0**: Each instance has independent counter\n   * **Increments**: Each generateItemId() call returns next ID\n   * **Format**: 'item-N' where N is the counter value\n   */\n  private itemIdCounter: number = 0;\n\n  /**\n   * Initial state snapshot for reset()\n   *\n   * **Purpose**: Deep clone of initial state for reset functionality\n   * **Updated**: When constructor receives custom initial state\n   */\n  private initialState: GridState;\n\n  /**\n   * Create new StateManager instance\n   * @param initialState - Optional custom initial state (for import/restore)\n   * @example\n   * ```typescript\n   * // Empty state (default)\n   * const manager = new StateManager();\n   *\n   * // Restore from saved state\n   * const savedState = JSON.parse(localStorage.getItem('grid-state'));\n   * const manager = new StateManager(savedState);\n   * ```\n   */\n  constructor(initialState?: Partial<GridState>) {\n    // Merge custom initial state with defaults\n    const fullInitialState: GridState = {\n      ...defaultInitialState,\n      ...initialState,\n    };\n\n    // Create StencilJS reactive store\n    const { state, onChange, dispose } =\n      createStore<GridState>(fullInitialState);\n\n    this.state = state;\n    this.onChange = onChange;\n    this.dispose = dispose;\n\n    // Store initial state for reset() (deep clone to prevent mutations)\n    this.initialState = JSON.parse(JSON.stringify(fullInitialState));\n  }\n\n  /**\n   * Reset state to initial empty configuration\n   *\n   * **When to call**:\n   * - User clicks \"Reset\" button\n   * - Starting fresh\n   * - Test cleanup (afterEach hooks)\n   *\n   * **What it resets**:\n   * - Clears all items from all canvases\n   * - Resets z-index counters\n   * - Clears selection state\n   * - Resets viewport to desktop\n   * - Shows grid\n   * - Resets item ID counter to 0\n   *\n   * **Deep clone pattern**:\n   * Uses `JSON.parse(JSON.stringify())` to create independent copy\n   * of initial state. Prevents mutations from affecting initialState.\n   * @example\n   * ```typescript\n   * // Reset button handler\n   * handleReset() {\n   *   if (confirm('Reset to initial state?')) {\n   *     this.stateManager.reset();\n   *     console.log('State reset to empty');\n   *   }\n   * }\n   * ```\n   */\n  reset(): void {\n    this.itemIdCounter = 0;\n\n    // Restore initial state (deep clone to prevent mutations)\n    this.state.canvases = JSON.parse(\n      JSON.stringify(this.initialState.canvases),\n    );\n    this.state.selectedItemId = this.initialState.selectedItemId;\n    this.state.selectedCanvasId = this.initialState.selectedCanvasId;\n    this.state.activeCanvasId = this.initialState.activeCanvasId;\n    this.state.currentViewport = this.initialState.currentViewport;\n    this.state.showGrid = this.initialState.showGrid;\n  }\n\n  /**\n   * Add item to canvas\n   *\n   * **Use cases**:\n   * - Dropping component from palette\n   * - Undo delete operation\n   * - Duplicating existing item\n   * - Programmatic item creation\n   *\n   * **Reactivity pattern**:\n   * 1. Push item to canvas.items array\n   * 2. Spread canvases object to trigger update\n   * 3. Components automatically re-render\n   *\n   * **Z-index assignment**:\n   * Item should have `zIndex: canvas.zIndexCounter++` before calling.\n   * This function doesn't assign z-index automatically.\n   *\n   * **Safety**: No-op if canvas doesn't exist\n   * @param canvasId - Target canvas ID\n   * @param item - GridItem to add (should have zIndex assigned)\n   * @example\n   * ```typescript\n   * // Add new item from palette drop\n   * const newItem: GridItem = {\n   *   id: stateManager.generateItemId(),\n   *   canvasId: 'canvas1',\n   *   type: 'header',\n   *   name: 'Header',\n   *   layouts: {\n   *     desktop: { x: 5, y: 5, width: 20, height: 8 },\n   *     mobile: { x: null, y: null, width: null, height: null, customized: false }\n   *   },\n   *   zIndex: stateManager.state.canvases['canvas1'].zIndexCounter++\n   * };\n   * stateManager.addItemToCanvas('canvas1', newItem);\n   * ```\n   */\n  addItemToCanvas(canvasId: string, item: GridItem): void {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Validate item structure (dev-only, tree-shaken in production)\n    const validation = validateGridItem(item);\n    if (!validation.valid) {\n      debug.warn(\"⚠️ [addItemToCanvas] with validation issues:\", {\n        itemId: item.id,\n        canvasId,\n        errors: validation.errors,\n      });\n    }\n\n    canvas.items.push(item);\n    this.state.canvases = { ...this.state.canvases }; // Trigger update\n  }\n\n  /**\n   * Remove item from canvas\n   *\n   * **Use cases**:\n   * - User deletes item (Delete key or button)\n   * - Undo add operation\n   * - Clearing canvas\n   *\n   * **Filter pattern**:\n   * Creates new array without the item, preserving array order.\n   * Reassignment triggers reactivity.\n   *\n   * **Index preservation**:\n   * Array order maintained for z-index rendering.\n   * Other items' indexes shift down by 1.\n   *\n   * **Safety**: No-op if canvas or item doesn't exist\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to remove\n   * @example\n   * ```typescript\n   * // Delete selected item\n   * if (gridState.selectedItemId && gridState.selectedCanvasId) {\n   *   removeItemFromCanvas(\n   *     gridState.selectedCanvasId,\n   *     gridState.selectedItemId\n   *   );\n   *   deselectItem(); // Clear selection\n   * }\n   * ```\n   */\n  removeItemFromCanvas(canvasId: string, itemId: string): void {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    canvas.items = canvas.items.filter((item) => item.id !== itemId);\n    this.state.canvases = { ...this.state.canvases }; // Trigger update\n  }\n\n  /**\n   * Update item properties in canvas\n   *\n   * **Use cases**:\n   * - After drag operation (update position)\n   * - After resize operation (update dimensions)\n   * - Changing item name or type\n   * - Bringing item to front (update zIndex)\n   *\n   * **Partial updates**:\n   * Uses `Partial<GridItem>` to allow updating subset of properties.\n   * Object.assign merges updates into existing item.\n   *\n   * **Typical update patterns**:\n   * ```typescript\n   * // Update position after drag\n   * updateItem(canvasId, itemId, {\n   * layouts: { ...item.layouts, desktop: { x: 10, y: 5, width: 20, height: 8 } }\n   * });\n   *\n   * // Bring to front\n   * updateItem(canvasId, itemId, {\n   * zIndex: gridState.canvases[canvasId].zIndexCounter++\n   * });\n   * ```\n   *\n   * **Safety**: No-op if canvas or item doesn't exist\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to update\n   * @param updates - Partial GridItem with properties to update\n   * @example\n   * ```typescript\n   * // After drag end\n   * const item = getItem('canvas1', 'item-3');\n   * if (item) {\n   *   item.layouts.desktop.x = newX;\n   *   item.layouts.desktop.y = newY;\n   *   updateItem('canvas1', 'item-3', item);\n   * }\n   * ```\n   */\n  updateItem(\n    canvasId: string,\n    itemId: string,\n    updates: Partial<GridItem>,\n  ): void {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return;\n    }\n\n    // Validate updates (dev-only, tree-shaken in production)\n    const validation = validateItemUpdates(updates);\n    if (!validation.valid) {\n      debug.warn(\"⚠️ [updateItem] with validation issues:\", {\n        itemId,\n        canvasId,\n        updates,\n        errors: validation.errors,\n      });\n    }\n\n    Object.assign(item, updates);\n    this.state.canvases = { ...this.state.canvases }; // Trigger update\n  }\n\n  /**\n   * Get item by ID\n   *\n   * **Use cases**:\n   * - Reading item data before update\n   * - Validation checks\n   * - Getting item for undo/redo snapshots\n   * - Checking if item exists\n   *\n   * **Read-only**: Returns reference to item in state.\n   * To modify, use `updateItem()` to trigger reactivity.\n   *\n   * **Safety**: Returns null if canvas or item doesn't exist\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to retrieve\n   * @returns GridItem or null if not found\n   * @example\n   * ```typescript\n   * // Check item before operation\n   * const item = getItem('canvas1', 'item-3');\n   * if (item) {\n   *   console.log(`Item at (${item.layouts.desktop.x}, ${item.layouts.desktop.y})`);\n   * }\n   *\n   * // Create snapshot for undo\n   * const snapshot = JSON.parse(JSON.stringify(getItem(canvasId, itemId)));\n   * ```\n   */\n  getItem(canvasId: string, itemId: string): GridItem | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    return canvas.items.find((i) => i.id === itemId) || null;\n  }\n\n  /**\n   * Move item to different canvas\n   *\n   * **Use cases**:\n   * - Dragging item across canvas boundaries\n   * - Reorganizing multi-section layouts\n   * - Undo move operation\n   *\n   * **Operation flow**:\n   * 1. Find item in source canvas\n   * 2. Remove from source canvas items array\n   * 3. Update item's canvasId property\n   * 4. Add to destination canvas items array\n   * 5. Trigger reactivity with spread\n   *\n   * **Important**: Item keeps its existing zIndex.\n   * May want to update with destination canvas's zIndexCounter.\n   *\n   * **Position handling**:\n   * Item keeps its grid coordinates. Caller should validate/adjust\n   * position fits within destination canvas bounds.\n   *\n   * **Safety**: No-op if either canvas doesn't exist or item not found\n   * @param fromCanvasId - Source canvas ID\n   * @param toCanvasId - Destination canvas ID\n   * @param itemId - Item to move\n   * @example\n   * ```typescript\n   * // Move item on cross-canvas drag\n   * handleDragEnd(event) {\n   *   const targetCanvasId = event.dropTarget.id;\n   *   if (targetCanvasId !== item.canvasId) {\n   *     moveItemToCanvas(item.canvasId, targetCanvasId, item.id);\n   *\n   *     // Optionally update z-index for new canvas\n   *     const canvas = gridState.canvases[targetCanvasId];\n   *     updateItem(targetCanvasId, item.id, {\n   *       zIndex: canvas.zIndexCounter++\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  moveItemToCanvas(\n    fromCanvasId: string,\n    toCanvasId: string,\n    itemId: string,\n  ): void {\n    const fromCanvas = this.state.canvases[fromCanvasId];\n    const toCanvas = this.state.canvases[toCanvasId];\n\n    if (!fromCanvas || !toCanvas) {\n      return;\n    }\n\n    const item = fromCanvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return;\n    }\n\n    // Validate item before moving (dev-only, tree-shaken in production)\n    const validation = validateGridItem(item);\n    if (!validation.valid) {\n      debug.warn(\"⚠️ [moveItemToCanvas] with validation issues:\", {\n        itemId,\n        fromCanvasId,\n        toCanvasId,\n        errors: validation.errors,\n      });\n    }\n\n    // Remove from old canvas\n    fromCanvas.items = fromCanvas.items.filter((i) => i.id !== itemId);\n\n    // Update item's canvasId\n    item.canvasId = toCanvasId;\n\n    // Add to new canvas\n    toCanvas.items.push(item);\n\n    this.state.canvases = { ...this.state.canvases }; // Trigger update\n  }\n\n  /**\n   * Generate unique item ID\n   *\n   * **Use cases**:\n   * - Creating new item from palette drop\n   * - Duplicating existing item\n   * - Any programmatic item creation\n   *\n   * **Uniqueness guarantee**:\n   * Monotonically increasing counter ensures no collisions.\n   * Even after delete, IDs never reused.\n   *\n   * **Format**: Returns 'item-N' (e.g., 'item-11', 'item-12')\n   *\n   * **Thread safety**: Not thread-safe, but not an issue in\n   * single-threaded JavaScript environment.\n   * @returns Unique item ID string\n   * @example\n   * ```typescript\n   * // Create new item from palette drop\n   * const newItem: GridItem = {\n   *   id: stateManager.generateItemId(), // 'item-11'\n   *   canvasId: 'canvas1',\n   *   type: 'button',\n   *   name: 'Button',\n   *   layouts: { ... },\n   *   zIndex: stateManager.state.canvases['canvas1'].zIndexCounter++\n   * };\n   * ```\n   */\n  generateItemId(): string {\n    return `item-${++this.itemIdCounter}`;\n  }\n\n  /**\n   * Set z-index for an item\n   *\n   * **Use cases**:\n   * - Layer panel drag-to-reorder\n   * - Bring to front / send to back operations\n   * - Manual z-index adjustment\n   *\n   * **Operation flow**:\n   * 1. Find item in canvas\n   * 2. Store old z-index for undo/redo\n   * 3. Update item's zIndex property\n   * 4. Update canvas zIndexCounter if needed\n   * 5. Trigger reactivity\n   * 6. Return old/new values for undo/redo\n   *\n   * **Safety**: Returns null if canvas or item doesn't exist\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to update\n   * @param newZIndex - New z-index value\n   * @returns Object with old and new z-index, or null if not found\n   */\n  setItemZIndex(\n    canvasId: string,\n    itemId: string,\n    newZIndex: number,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    const oldZIndex = item.zIndex;\n\n    // Update z-index\n    item.zIndex = newZIndex;\n\n    // Update counter if needed (maintain monotonically increasing counter)\n    if (newZIndex >= canvas.zIndexCounter) {\n      canvas.zIndexCounter = newZIndex + 1;\n    }\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Move item forward in z-index (one layer up)\n   *\n   * **Use cases**:\n   * - Layer panel \"move up\" button\n   * - Keyboard shortcut (e.g., Ctrl+Up)\n   * - Context menu \"Bring forward\"\n   *\n   * **Operation**:\n   * Finds next higher z-index and swaps with that item.\n   * If already on top, does nothing.\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to move forward\n   * @returns Object with old and new z-index, or null if not found/already on top\n   */\n  moveItemForward(\n    canvasId: string,\n    itemId: string,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    // Find next higher z-index\n    const sortedItems = [...canvas.items].sort((a, b) => a.zIndex - b.zIndex);\n    const currentIndex = sortedItems.findIndex((i) => i.id === itemId);\n\n    // Already on top\n    if (currentIndex === sortedItems.length - 1) {\n      return null;\n    }\n\n    const nextItem = sortedItems[currentIndex + 1];\n    const oldZIndex = item.zIndex;\n    const newZIndex = nextItem.zIndex;\n\n    // Swap z-index values\n    item.zIndex = newZIndex;\n    nextItem.zIndex = oldZIndex;\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Move item backward in z-index (one layer down)\n   *\n   * **Use cases**:\n   * - Layer panel \"move down\" button\n   * - Keyboard shortcut (e.g., Ctrl+Down)\n   * - Context menu \"Send backward\"\n   *\n   * **Operation**:\n   * Finds next lower z-index and swaps with that item.\n   * If already on bottom, does nothing.\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to move backward\n   * @returns Object with old and new z-index, or null if not found/already on bottom\n   */\n  moveItemBackward(\n    canvasId: string,\n    itemId: string,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    // Find next lower z-index\n    const sortedItems = [...canvas.items].sort((a, b) => a.zIndex - b.zIndex);\n    const currentIndex = sortedItems.findIndex((i) => i.id === itemId);\n\n    // Already on bottom\n    if (currentIndex === 0) {\n      return null;\n    }\n\n    const prevItem = sortedItems[currentIndex - 1];\n    const oldZIndex = item.zIndex;\n    const newZIndex = prevItem.zIndex;\n\n    // Swap z-index values\n    item.zIndex = newZIndex;\n    prevItem.zIndex = oldZIndex;\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Bring item to front (highest z-index)\n   *\n   * **Use cases**:\n   * - Layer panel \"bring to front\" button\n   * - Context menu \"Bring to front\"\n   * - Double-click to bring to front\n   *\n   * **Operation**:\n   * Sets z-index to highest value in canvas + 1\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to bring to front\n   * @returns Object with old and new z-index, or null if not found/already on top\n   */\n  bringItemToFront(\n    canvasId: string,\n    itemId: string,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    const oldZIndex = item.zIndex;\n    const maxZIndex = Math.max(...canvas.items.map((i) => i.zIndex));\n\n    // Already on top\n    if (oldZIndex === maxZIndex) {\n      return null;\n    }\n\n    const newZIndex = canvas.zIndexCounter++;\n    item.zIndex = newZIndex;\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Send item to back (lowest z-index)\n   *\n   * **Use cases**:\n   * - Layer panel \"send to back\" button\n   * - Context menu \"Send to back\"\n   *\n   * **Operation**:\n   * Sets z-index to lowest value in canvas - 1\n   * @param canvasId - Canvas containing the item\n   * @param itemId - Item ID to send to back\n   * @returns Object with old and new z-index, or null if not found/already on bottom\n   */\n  sendItemToBack(\n    canvasId: string,\n    itemId: string,\n  ): { oldZIndex: number; newZIndex: number } | null {\n    const canvas = this.state.canvases[canvasId];\n    if (!canvas) {\n      return null;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      return null;\n    }\n\n    const oldZIndex = item.zIndex;\n    const minZIndex = Math.min(...canvas.items.map((i) => i.zIndex));\n\n    // Already on bottom\n    if (oldZIndex === minZIndex) {\n      return null;\n    }\n\n    const newZIndex = minZIndex - 1;\n    item.zIndex = newZIndex;\n\n    // Trigger reactivity\n    this.state.canvases = { ...this.state.canvases };\n\n    return { oldZIndex, newZIndex };\n  }\n\n  /**\n   * Select item and set active canvas\n   *\n   * **Use cases**:\n   * - User clicks item\n   * - After creating new item (auto-select)\n   * - Keyboard navigation\n   *\n   * **Visual effects**:\n   * - Selected item gets visual highlight (via CSS)\n   * - Resize/drag handles appear\n   * - Item can be deleted with Delete key\n   *\n   * **State changes**:\n   * - `selectedItemId` = itemId\n   * - `selectedCanvasId` = canvasId\n   * - Components re-render with selection styles\n   *\n   * **Single selection**: Selecting new item automatically deselects previous\n   * @param itemId - Item to select\n   * @param canvasId - Canvas containing the item\n   */\n  selectItem(itemId: string, canvasId: string): void {\n    this.state.selectedItemId = itemId;\n    this.state.selectedCanvasId = canvasId;\n  }\n\n  /**\n   * Deselect currently selected item\n   *\n   * **Use cases**:\n   * - User clicks canvas background\n   * - After deleting selected item\n   * - Escape key pressed\n   * - Starting drag operation\n   *\n   * **Visual effects**:\n   * - Selection highlight removed\n   * - Resize/drag handles hidden\n   * - Item no longer delete-able with Delete key\n   *\n   * **State changes**:\n   * - `selectedItemId` = null\n   * - `selectedCanvasId` = null\n   * - Components re-render without selection styles\n   *\n   * **Safety**: Safe to call even if nothing selected\n   */\n  deselectItem(): void {\n    this.state.selectedItemId = null;\n    this.state.selectedCanvasId = null;\n  }\n\n  /**\n   * Set active canvas\n   *\n   * **Use cases**:\n   * - User clicks item on canvas → activate that canvas\n   * - User clicks canvas background → activate that canvas\n   * - User starts dragging item → activate canvas containing item\n   * - User starts resizing item → activate canvas containing item\n   * - Programmatic canvas focus (e.g., after adding item)\n   *\n   * **Visual effects**:\n   * - Canvas title opacity changes (consumer-controlled CSS)\n   * - Canvas border/highlight applied\n   * - Canvas-specific settings panel shown\n   *\n   * **State changes**:\n   * - `activeCanvasId` = canvasId\n   * - Components re-render with isActive prop\n   * - 'canvasActivated' event emitted\n   *\n   * **Reactivity**: Direct assignment (no spread needed for primitive)\n   * @param canvasId - Canvas ID to activate\n   */\n  setActiveCanvas(canvasId: string): void {\n    this.state.activeCanvasId = canvasId;\n  }\n\n  /**\n   * Clear active canvas\n   *\n   * **Use cases**:\n   * - Reset application state\n   * - Close all panels\n   * - Deactivate all canvases\n   *\n   * **Visual effects**:\n   * - All canvas titles return to inactive state\n   * - No canvas highlighted\n   * - Canvas settings panel hidden\n   *\n   * **State changes**:\n   * - `activeCanvasId` = null\n   * - Components re-render without active state\n   *\n   * **Safety**: Safe to call even if no canvas active\n   */\n  clearActiveCanvas(): void {\n    this.state.activeCanvasId = null;\n  }\n\n  /**\n   * Add multiple items in a single batch\n   *\n   * **Performance benefit**: 1000 items added in ~10ms with single re-render\n   * vs ~200-500ms with 1000 individual add calls and 1000 re-renders.\n   *\n   * **Use cases**:\n   * - Stress testing (adding 100-1000 items)\n   * - Template/preset loading (page templates with many components)\n   * - Undo batch delete\n   * - Import from saved layout\n   *\n   * **Reactivity pattern**:\n   * 1. Clone canvases object\n   * 2. Add all items to cloned canvases\n   * 3. Single state assignment triggers single re-render\n   * 4. Single undo/redo command for entire batch\n   * @param items - Array of partial GridItem specs (missing id, zIndex auto-assigned)\n   * @returns Array of created item IDs\n   */\n  addItemsBatch(items: Partial<GridItem>[]): string[] {\n    const itemIds: string[] = [];\n    const updatedCanvases = { ...this.state.canvases };\n\n    for (const itemData of items) {\n      const id = this.generateItemId();\n      const canvasId = itemData.canvasId!;\n      const canvas = updatedCanvases[canvasId];\n\n      if (!canvas) {\n        console.warn(`Canvas ${canvasId} not found, skipping item`);\n        continue;\n      }\n\n      const newItem: GridItem = {\n        id,\n        canvasId,\n        type: itemData.type || \"unknown\",\n        name: itemData.name || \"Unnamed\",\n        layouts: itemData.layouts || {\n          desktop: { x: 0, y: 0, width: 20, height: 10 },\n          mobile: {\n            x: null,\n            y: null,\n            width: null,\n            height: null,\n            customized: false,\n          },\n        },\n        zIndex: canvas.zIndexCounter++,\n        config: itemData.config || {},\n      };\n\n      // Validate item before adding (dev-only, tree-shaken in production)\n      const validation = validateGridItem(newItem);\n      if (!validation.valid) {\n        debug.warn(\"⚠️ [addItemsBatch] with validation issues:\", {\n          itemId: id,\n          canvasId,\n          errors: validation.errors,\n        });\n      }\n\n      canvas.items.push(newItem);\n      itemIds.push(id);\n    }\n\n    // Single state update triggers single re-render\n    this.state.canvases = updatedCanvases;\n\n    return itemIds;\n  }\n\n  /**\n   * Delete multiple items in a single batch\n   *\n   * **Performance benefit**: 1000 items deleted in ~5ms with single re-render\n   * vs ~100-200ms with 1000 individual delete calls and 1000 re-renders.\n   *\n   * **Use cases**:\n   * - Clear canvas (delete all)\n   * - Delete selection group\n   * - Undo batch add\n   * - Cleanup operations\n   *\n   * **Reactivity pattern**:\n   * 1. Clone canvases object\n   * 2. Filter out all items from cloned canvases\n   * 3. Single state assignment triggers single re-render\n   * 4. Single undo/redo command for entire batch\n   * @param itemIds - Array of item IDs to delete\n   */\n  deleteItemsBatch(itemIds: string[]): void {\n    const itemIdSet = new Set(itemIds);\n    const updatedCanvases = { ...this.state.canvases };\n\n    // Filter out items from all canvases\n    for (const canvasId in updatedCanvases) {\n      updatedCanvases[canvasId] = {\n        ...updatedCanvases[canvasId],\n        items: updatedCanvases[canvasId].items.filter(\n          (item) => !itemIdSet.has(item.id),\n        ),\n      };\n    }\n\n    // Single state update triggers single re-render\n    this.state.canvases = updatedCanvases;\n  }\n\n  /**\n   * Update multiple item configs in a single batch\n   *\n   * **Performance benefit**: 1000 items updated in ~8ms with single re-render\n   * vs ~150-300ms with 1000 individual update calls and 1000 re-renders.\n   *\n   * **Use cases**:\n   * - Theme changes (update colors for all items)\n   * - Bulk property changes\n   * - Undo batch config change\n   * - Template application\n   *\n   * **Reactivity pattern**:\n   * 1. Clone canvases object\n   * 2. Apply all updates to cloned canvases\n   * 3. Single state assignment triggers single re-render\n   * 4. Single undo/redo command for entire batch\n   * @param updates - Array of { itemId, canvasId, updates } objects\n   */\n  updateItemsBatch(\n    updates: {\n      itemId: string;\n      canvasId: string;\n      updates: Partial<GridItem>;\n    }[],\n  ): void {\n    const updatedCanvases = { ...this.state.canvases };\n\n    for (const { itemId, canvasId, updates: itemUpdates } of updates) {\n      const canvas = updatedCanvases[canvasId];\n      if (!canvas) {\n        console.warn(`Canvas ${canvasId} not found, skipping item ${itemId}`);\n        continue;\n      }\n\n      const item = canvas.items.find((i) => i.id === itemId);\n      if (!item) {\n        console.warn(`Item ${itemId} not found in canvas ${canvasId}`);\n        continue;\n      }\n\n      Object.assign(item, itemUpdates);\n    }\n\n    // Single state update triggers single re-render\n    this.state.canvases = updatedCanvases;\n  }\n}\n\n/**\n * Backward Compatibility Layer\n * ==============================\n *\n * Singleton instance and helper function exports for backward compatibility.\n */\n\n// Create singleton instance (for backward compatibility only)\nconst defaultManager = new StateManager();\n\n// Export singleton state (backward compatible)\nexport const gridState = defaultManager.state;\nexport const state = defaultManager.state; // Alternative export name\nexport const onChange = defaultManager.onChange;\n\n// Export singleton instance methods as standalone functions (backward compatible)\nexport const reset = () => defaultManager.reset();\nexport const addItemToCanvas = (canvasId: string, item: GridItem) =>\n  defaultManager.addItemToCanvas(canvasId, item);\nexport const removeItemFromCanvas = (canvasId: string, itemId: string) =>\n  defaultManager.removeItemFromCanvas(canvasId, itemId);\nexport const updateItem = (\n  canvasId: string,\n  itemId: string,\n  updates: Partial<GridItem>,\n) => defaultManager.updateItem(canvasId, itemId, updates);\nexport const getItem = (canvasId: string, itemId: string) =>\n  defaultManager.getItem(canvasId, itemId);\nexport const moveItemToCanvas = (\n  fromCanvasId: string,\n  toCanvasId: string,\n  itemId: string,\n) => defaultManager.moveItemToCanvas(fromCanvasId, toCanvasId, itemId);\nexport const generateItemId = () => defaultManager.generateItemId();\nexport const setItemZIndex = (\n  canvasId: string,\n  itemId: string,\n  newZIndex: number,\n) => defaultManager.setItemZIndex(canvasId, itemId, newZIndex);\nexport const moveItemForward = (canvasId: string, itemId: string) =>\n  defaultManager.moveItemForward(canvasId, itemId);\nexport const moveItemBackward = (canvasId: string, itemId: string) =>\n  defaultManager.moveItemBackward(canvasId, itemId);\nexport const bringItemToFront = (canvasId: string, itemId: string) =>\n  defaultManager.bringItemToFront(canvasId, itemId);\nexport const sendItemToBack = (canvasId: string, itemId: string) =>\n  defaultManager.sendItemToBack(canvasId, itemId);\nexport const selectItem = (itemId: string, canvasId: string) =>\n  defaultManager.selectItem(itemId, canvasId);\nexport const deselectItem = () => defaultManager.deselectItem();\nexport const setActiveCanvas = (canvasId: string) =>\n  defaultManager.setActiveCanvas(canvasId);\nexport const clearActiveCanvas = () => defaultManager.clearActiveCanvas();\nexport const addItemsBatch = (items: Partial<GridItem>[]) =>\n  defaultManager.addItemsBatch(items);\nexport const deleteItemsBatch = (itemIds: string[]) =>\n  defaultManager.deleteItemsBatch(itemIds);\nexport const updateItemsBatch = (\n  updates: {\n    itemId: string;\n    canvasId: string;\n    updates: Partial<GridItem>;\n  }[],\n) => defaultManager.updateItemsBatch(updates);\n"],"names":["debug"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+EG;AAEH;;;;AAIG;MACU,QAAQ,CAAA;AAArB,IAAA,WAAA,GAAA;;AAEU,QAAA,IAAA,CAAA,QAAQ,GAA6B,IAAI,GAAG,EAAE;;AAEtD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BG;AACH,IAAA,SAAS,CAAC,QAAgB,EAAA;;QAExB,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;YAC/B,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAE;;;QAIrC,MAAM,MAAM,GAAG,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC;QAChD,IAAI,MAAM,EAAE;YACV,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC;;AAGrC,QAAA,OAAO,MAAM;;AAGf;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BG;AACH,IAAA,UAAU,CAAC,QAAgB,EAAA;AACzB,QAAA,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC;;AAGhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCG;IACH,KAAK,GAAA;AACH,QAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE;;AAExB;;AC9MD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DG;AAKH;AACA,MAAM,kBAAkB,GAAG,EAAE;AAE7B;;;AAGG;AACH,MAAM,4BAA4B,GAAG,IAAI;AAEzC;;;AAGG;AACH,MAAM,qBAAqB,GAAG,EAAE;AAEhC;;;AAGG;AACH,MAAM,qBAAqB,GAAG,EAAE;AAEhC;;;;;;;;;;;;;;;AAeG;AACH,MAAM,aAAa,GAAG,IAAI,GAAG,EAAkB;AAE/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCG;AACG,SAAU,kBAAkB,CAAC,UAAmB,EAAA;IACpD,IAAI,UAAU,EAAE;;AAEd,QAAA,MAAM,MAAM,GAAG,CAAG,EAAA,UAAU,GAAG;QAC/B,KAAK,MAAM,GAAG,IAAI,aAAa,CAAC,IAAI,EAAE,EAAE;AACtC,YAAA,IAAI,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;AAC1B,gBAAA,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC;;;;SAGxB;;QAEL,aAAa,CAAC,KAAK,EAAE;;AAEzB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCG;SACa,gBAAgB,CAC9B,QAAgB,EAChB,cAAsB,EACtB,MAAmB,EAAA;;;IAGnB,MAAM,QAAQ,GAAG,CAAA,MAAM,aAAN,MAAM,KAAA,MAAA,GAAA,MAAA,GAAN,MAAM,CAAE,UAAU;AACjC,UAAE,CAAG,EAAA,MAAM,CAAC,UAAU,CAAA,CAAA,EAAI,QAAQ,CAAI,EAAA;AACtC,UAAE,CAAA,EAAG,QAAQ,CAAA,EAAA,CAAI;;IAGnB,MAAM,eAAe,GAAG,CAAA,MAAM,aAAN,MAAM,KAAA,MAAA,GAAA,MAAA,GAAN,MAAM,CAAE,eAAe;AAC7C,UAAE,MAAM,CAAC,eAAe,GAAG;UACzB,4BAA4B;;AAGhC,IAAA,MAAM,OAAO,GAAG,cAAc,GAAG,eAAe;;AAGhD,IAAA,MAAM,OAAO,GAAG,CAAA,EAAA,GAAA,MAAM,KAAN,IAAA,IAAA,MAAM,KAAN,MAAA,GAAA,MAAA,GAAA,MAAM,CAAE,WAAW,MAAI,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,EAAA,GAAA,qBAAqB;AAC5D,IAAA,MAAM,OAAO,GAAG,CAAA,EAAA,GAAA,MAAM,KAAN,IAAA,IAAA,MAAM,KAAN,MAAA,GAAA,MAAA,GAAA,MAAM,CAAE,WAAW,MAAI,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,EAAA,GAAA,qBAAqB;AAC5D,IAAA,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;;AAG1D,IAAA,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC;AACnC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCG;AACG,SAAU,qBAAqB,CACnC,QAAgB,EAChB,MAAmB,EACnB,WAAA,GAAuB,KAAK,EAC5B,gBAA2B,EAAA;;;;IAI3B,MAAM,QAAQ,GAAG,CAAA,MAAM,aAAN,MAAM,KAAA,MAAA,GAAA,MAAA,GAAN,MAAM,CAAE,UAAU;AACjC,UAAE,CAAG,EAAA,MAAM,CAAC,UAAU,CAAA,CAAA,EAAI,QAAQ,CAAI,EAAA;AACtC,UAAE,CAAA,EAAG,QAAQ,CAAA,EAAA,CAAI;IAEnB,IAAI,CAAC,WAAW,IAAI,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;AAC/C,QAAA,OAAO,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAE;;;AAIrC,IAAA,MAAM,KAAK,GAAG,gBAAgB,IAAI,IAAI,QAAQ,EAAE;IAChD,MAAM,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC;IAC3C,IAAI,CAAC,SAAS,EAAE;AACd,QAAA,OAAO,CAAC,IAAI,CAAC,+BAA+B,QAAQ,CAAA,CAAE,CAAC;AACvD,QAAA,OAAO,CAAC;;;;IAKV,MAAM,eAAe,GAAG,CAAA,MAAM,aAAN,MAAM,KAAA,MAAA,GAAA,MAAA,GAAN,MAAM,CAAE,eAAe;AAC7C,UAAE,MAAM,CAAC,eAAe,GAAG;UACzB,4BAA4B;;AAGhC,IAAA,MAAM,OAAO,GAAG,SAAS,CAAC,WAAW,GAAG,eAAe;;AAGvD,IAAA,MAAM,OAAO,GAAG,CAAA,EAAA,GAAA,MAAM,KAAN,IAAA,IAAA,MAAM,KAAN,MAAA,GAAA,MAAA,GAAA,MAAM,CAAE,WAAW,MAAI,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,EAAA,GAAA,qBAAqB;AAC5D,IAAA,MAAM,OAAO,GAAG,CAAA,EAAA,GAAA,MAAM,KAAN,IAAA,IAAA,MAAM,KAAN,MAAA,GAAA,MAAA,GAAA,MAAM,CAAE,WAAW,MAAI,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,EAAA,GAAA,qBAAqB;AAC5D,IAAA,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;;;;AAK1D,IAAA,IAAI,SAAS,CAAC,WAAW,GAAG,GAAG,EAAE;AAC/B,QAAA,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC;;AAGnC,IAAA,OAAO,IAAI;AACb;AAEA;;;;;;;;;;;;;;;;AAgBG;AACG,SAAU,mBAAmB,CAAC,MAAmB,EAAA;;AACrD,IAAA,OAAO,CAAA,EAAA,GAAA,MAAM,KAAA,IAAA,IAAN,MAAM,KAAA,MAAA,GAAA,MAAA,GAAN,MAAM,CAAE,gBAAgB,MAAI,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,EAAA,GAAA,kBAAkB;AACvD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBG;SACa,aAAa,CAC3B,SAAiB,EACjB,QAAgB,EAChB,MAAmB,EAAA;;IAGnB,MAAM,QAAQ,GAAG,qBAAqB,CAAC,QAAQ,EAAE,MAAM,CAAC;IACxD,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,QAAQ,CAAC;AACzC;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBG;AACa,SAAA,aAAa,CAAC,SAAiB,EAAE,MAAmB,EAAA;AAClE,IAAA,OAAO,SAAS,GAAG,mBAAmB,CAAC,MAAM,CAAC;AAChD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBG;SACa,aAAa,CAC3B,MAAc,EACd,QAAgB,EAChB,MAAmB,EAAA;;IAGnB,MAAM,QAAQ,GAAG,qBAAqB,CAAC,QAAQ,EAAE,MAAM,CAAC;AACxD,IAAA,IAAI,QAAQ,KAAK,CAAC,EAAE;AAClB,QAAA,OAAO,CAAC;;IAEV,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,QAAQ,CAAC;AACtC;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBG;AACa,SAAA,aAAa,CAAC,MAAc,EAAE,MAAmB,EAAA;IAC/D,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;AACzD;;;;;;;;;;;;;;ACncA,MAAM,WAAW,GAAG,CAAC,GAAG,EAAE,QAAQ,EAAE,KAAK,KAAK;AAC9C,IAAI,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC;AACnC,IAAI,IAAI,CAAC,KAAK,EAAE;AAChB,QAAQ,GAAG,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,CAAC;AAClC;AACA,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;AACrC,QAAQ,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;AACzB;AACA,CAAC;AACD,MAAM,QAAQ,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK;AAC7B,IAAI,IAAI,SAAS;AACjB,IAAI,OAAO,CAAC,GAAG,IAAI,KAAK;AACxB,QAAQ,IAAI,SAAS,EAAE;AACvB,YAAY,YAAY,CAAC,SAAS,CAAC;AACnC;AACA,QAAQ,SAAS,GAAG,UAAU,CAAC,MAAM;AACrC,YAAY,SAAS,GAAG,CAAC;AACzB,YAAY,EAAE,CAAC,GAAG,IAAI,CAAC;AACvB,SAAS,EAAE,EAAE,CAAC;AACd,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,WAAW,GAAG,CAAC,YAAY,KAAK,EAAE,aAAa,IAAI,YAAY,CAAC,IAAI,YAAY,CAAC,WAAW;AAClG,MAAM,eAAe,GAAG,QAAQ,CAAC,CAAC,GAAG,KAAK;AAC1C,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,EAAE,EAAE;AAChC,QAAQ,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;AACtD;AACA,CAAC,EAAE,KAAK,CAAC;AACT,MAAM,mBAAmB,GAAG,MAAM;AAClC,IAAI,IAAI,OAAO,eAAe,KAAK,UAAU,EAAE;AAC/C;AACA;AACA,QAAQ,OAAO,EAAE;AACjB;AACA,IAAI,MAAM,YAAY,GAAG,IAAI,GAAG,EAAE;AAClC,IAAI,OAAO;AACX,QAAQ,OAAO,EAAE,MAAM,YAAY,CAAC,KAAK,EAAE;AAC3C,QAAQ,GAAG,EAAE,CAAC,QAAQ,KAAK;AAC3B,YAAY,MAAM,GAAG,GAAG,eAAe,EAAE;AACzC,YAAY,IAAI,GAAG,EAAE;AACrB,gBAAgB,WAAW,CAAC,YAAY,EAAE,QAAQ,EAAE,GAAG,CAAC;AACxD;AACA,SAAS;AACT,QAAQ,GAAG,EAAE,CAAC,QAAQ,KAAK;AAC3B,YAAY,MAAM,QAAQ,GAAG,YAAY,CAAC,GAAG,CAAC,QAAQ,CAAC;AACvD,YAAY,IAAI,QAAQ,EAAE;AAC1B,gBAAgB,YAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;AACxE;AACA,YAAY,eAAe,CAAC,YAAY,CAAC;AACzC,SAAS;AACT,QAAQ,KAAK,EAAE,MAAM;AACrB,YAAY,YAAY,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AACrE,YAAY,eAAe,CAAC,YAAY,CAAC;AACzC,SAAS;AACT,KAAK;AACL,CAAC;;AAED,MAAM,MAAM,GAAG,CAAC,GAAG,MAAM,OAAO,GAAG,KAAK,UAAU,GAAG,GAAG,EAAE,GAAG,GAAG,CAAC;AACjE,MAAM,mBAAmB,GAAG,CAAC,YAAY,EAAE,YAAY,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK;AAChF,IAAI,MAAM,cAAc,GAAG,MAAM,CAAC,YAAY,CAAC;AAC/C,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,cAAc,IAAI,EAAE,CAAC,CAAC;AAC9D,IAAI,MAAM,QAAQ,GAAG;AACrB,QAAQ,OAAO,EAAE,EAAE;AACnB,QAAQ,GAAG,EAAE,EAAE;AACf,QAAQ,GAAG,EAAE,EAAE;AACf,QAAQ,KAAK,EAAE,EAAE;AACjB,KAAK;AACL;AACA,IAAI,MAAM,eAAe,GAAG,IAAI,GAAG,EAAE;AACrC,IAAI,MAAM,KAAK,GAAG,MAAM;AACxB;AACA;AACA,QAAQ,MAAM,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC;AACpE,QAAQ,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC;AAC5C,KAAK;AACL,IAAI,MAAM,OAAO,GAAG,MAAM;AAC1B;AACA;AACA,QAAQ,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC;AAC9C,QAAQ,KAAK,EAAE;AACf,KAAK;AACL,IAAI,MAAM,GAAG,GAAG,CAAC,QAAQ,KAAK;AAC9B,QAAQ,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,CAAC,CAAC;AAClD,QAAQ,OAAO,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC;AACnC,KAAK;AACL,IAAI,MAAM,GAAG,GAAG,CAAC,QAAQ,EAAE,KAAK,KAAK;AACrC,QAAQ,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC;AAC7C,QAAQ,IAAI,YAAY,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,CAAC,EAAE;AACrD,YAAY,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC;AACvC,YAAY,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AACvE;AACA,KAAK;AACL,IAAI,MAAM,KAAK,IAAI,OAAO,KAAK,KAAK;AACpC,UAAU;AACV,UAAU,IAAI,KAAK,CAAC,cAAc,EAAE;AACpC,YAAY,GAAG,CAAC,CAAC,EAAE,QAAQ,EAAE;AAC7B,gBAAgB,OAAO,GAAG,CAAC,QAAQ,CAAC;AACpC,aAAa;AACb,YAAY,OAAO,CAAC,CAAC,EAAE;AACvB,gBAAgB,OAAO,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;AAChD,aAAa;AACb,YAAY,wBAAwB,GAAG;AACvC,gBAAgB,OAAO;AACvB,oBAAoB,UAAU,EAAE,IAAI;AACpC,oBAAoB,YAAY,EAAE,IAAI;AACtC,iBAAiB;AACjB,aAAa;AACb,YAAY,GAAG,CAAC,CAAC,EAAE,QAAQ,EAAE;AAC7B,gBAAgB,OAAO,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC;AAC3C,aAAa;AACb,YAAY,GAAG,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE;AACpC,gBAAgB,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC;AACpC,gBAAgB,OAAO,IAAI;AAC3B,aAAa;AACb,SAAS,CAAC,CAAC;AACX,IAAI,MAAM,EAAE,GAAG,CAAC,SAAS,EAAE,QAAQ,KAAK;AACxC,QAAQ,QAAQ,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;AAC1C,QAAQ,OAAO,MAAM;AACrB,YAAY,eAAe,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,QAAQ,CAAC;AAC1D,SAAS;AACT,KAAK;AACL,IAAI,MAAM,QAAQ,GAAG,CAAC,QAAQ,EAAE,EAAE,KAAK;AACvC,QAAQ,MAAM,UAAU,GAAG,CAAC,GAAG,EAAE,QAAQ,KAAK;AAC9C,YAAY,IAAI,GAAG,KAAK,QAAQ,EAAE;AAClC,gBAAgB,EAAE,CAAC,QAAQ,CAAC;AAC5B;AACA,SAAS;AACT,QAAQ,MAAM,YAAY,GAAG,MAAM,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,QAAQ,CAAC,CAAC;AACrE;AACA,QAAQ,MAAM,KAAK,GAAG,EAAE,CAAC,KAAK,EAAE,UAAU,CAAC;AAC3C,QAAQ,MAAM,OAAO,GAAG,EAAE,CAAC,OAAO,EAAE,YAAY,CAAC;AACjD;AACA,QAAQ,eAAe,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,UAAU,EAAE,YAAY,EAAE,QAAQ,EAAE,CAAC;AACvE,QAAQ,OAAO,MAAM;AACrB,YAAY,KAAK,EAAE;AACnB,YAAY,OAAO,EAAE;AACrB,YAAY,eAAe,CAAC,MAAM,CAAC,EAAE,CAAC;AACtC,SAAS;AACT,KAAK;AACL,IAAI,MAAM,GAAG,GAAG,CAAC,GAAG,aAAa,KAAK;AACtC,QAAQ,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,YAAY,KAAK;AACtE,YAAY,IAAI,YAAY,CAAC,GAAG,EAAE;AAClC,gBAAgB,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC;AACxD;AACA,YAAY,IAAI,YAAY,CAAC,GAAG,EAAE;AAClC,gBAAgB,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC;AACxD;AACA,YAAY,IAAI,YAAY,CAAC,KAAK,EAAE;AACpC,gBAAgB,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,YAAY,CAAC,KAAK,CAAC,CAAC;AAC5D;AACA,YAAY,IAAI,YAAY,CAAC,OAAO,EAAE;AACtC,gBAAgB,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,SAAS,EAAE,YAAY,CAAC,OAAO,CAAC,CAAC;AAChE;AACA,YAAY,OAAO,MAAM;AACzB,SAAS,EAAE,EAAE,CAAC;AACd,QAAQ,OAAO,MAAM,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,KAAK,KAAK,EAAE,CAAC;AACvD,KAAK;AACL,IAAI,MAAM,WAAW,GAAG,CAAC,GAAG,KAAK;AACjC,QAAQ,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC;AACxC,QAAQ,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;AACjE,KAAK;AACL,IAAI,MAAM,cAAc,GAAG,CAAC,QAAQ,EAAE,QAAQ,KAAK;AACnD,QAAQ,MAAM,YAAY,GAAG,eAAe,CAAC,GAAG,CAAC,QAAQ,CAAC;AAC1D,QAAQ,IAAI,YAAY,IAAI,YAAY,CAAC,QAAQ,KAAK,QAAQ,EAAE;AAChE;AACA,YAAY,eAAe,CAAC,QAAQ,CAAC,GAAG,EAAE,YAAY,CAAC,UAAU,CAAC;AAClE,YAAY,eAAe,CAAC,QAAQ,CAAC,KAAK,EAAE,YAAY,CAAC,YAAY,CAAC;AACtE,YAAY,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC;AAC5C;AACA,KAAK;AACL,IAAI,OAAO;AACX,QAAQ,KAAK;AACb,QAAQ,GAAG;AACX,QAAQ,GAAG;AACX,QAAQ,EAAE;AACV,QAAQ,QAAQ;AAChB,QAAQ,GAAG;AACX,QAAQ,OAAO;AACf,QAAQ,KAAK;AACb,QAAQ,WAAW;AACnB,QAAQ,cAAc;AACtB,KAAK;AACL,CAAC;AACD,MAAM,eAAe,GAAG,CAAC,KAAK,EAAE,IAAI,KAAK;AACzC,IAAI,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;AACrC,IAAI,IAAI,KAAK,IAAI,CAAC,EAAE;AACpB,QAAQ,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;AAC9C,QAAQ,KAAK,CAAC,MAAM,EAAE;AACtB;AACA,CAAC;;AAEI,MAAC,WAAW,GAAG,CAAC,YAAY,EAAE,YAAY,KAAK;AACpD,IAAI,MAAM,GAAG,GAAG,mBAAmB,CAAC,YAAY,EAAE,YAAY,CAAC;AAC/D,IAAI,GAAG,CAAC,GAAG,CAAC,mBAAmB,EAAE,CAAC;AAClC,IAAI,OAAO,GAAG;AACd;;AC9MA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDG;AAEH;;;;;;;;;;;AAWG;AACH,SAAS,cAAc,GAAA;;IAErB,IACE,OAAO,OAAO,KAAK,WAAW;AAC9B,QAAA,OAAO,CAAC,GAAG;AACX,QAAA,YAAoB,KAAK,aAAa,EACtC;;IAKF,IACE,OAAO,OAAO,KAAK,WAAW;AAC9B,QAAA,OAAO,CAAC,GAAG;AACX,QAAA,YAAoB,KAAK,MAAM,EAC/B;;AAKF,IAAA,OAAO,KAAK;AACd;AAEA;;;;;AAKG;AACI,MAAMA,OAAK,GAAG;AACnB;;;;;;;;;;;;;AAaG;IACH,GAAG,CAAC,GAAG,IAAW,EAAA;QAChB,IAAI,cAAc,EAAE,EAAE;AACpB,YAAA,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;;KAEvB;AAED;;;;;;;;;;;;;;;AAeG;IACH,IAAI,CAAC,GAAG,IAAW,EAAA;QACjB,IAAI,cAAc,EAAE,EAAE;AACpB,YAAA,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;;KAExB;AAED;;;;;;;;;;;;;;;AAeG;IACH,KAAK,CAAC,GAAG,IAAW,EAAA;QAClB,IAAI,cAAc,EAAE,EAAE;AACpB,YAAA,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;;KAEzB;AAED;;;;;;;;;;;;;;;;;AAiBG;IACH,KAAK,CAAC,KAAa,EAAE,EAAc,EAAA;QACjC,IAAI,cAAc,EAAE,EAAE;AACpB,YAAA,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC;AACpB,YAAA,EAAE,EAAE;YACJ,OAAO,CAAC,QAAQ,EAAE;;KAErB;AAED;;;;;;;;;;;;;AAaG;IACH,SAAS,GAAA;QACP,OAAO,cAAc,EAAE;KACxB;CACF;AAED;;;;;;;;;;;;AAYG;AACG,SAAU,iBAAiB,CAAC,SAAiB,EAAA;IACjD,OAAO;QACL,GAAG,CAAC,GAAG,IAAW,EAAA;YAChBA,OAAK,CAAC,GAAG,CAAC,CAAI,CAAA,EAAA,SAAS,GAAG,EAAE,GAAG,IAAI,CAAC;SACrC;QACD,IAAI,CAAC,GAAG,IAAW,EAAA;YACjBA,OAAK,CAAC,IAAI,CAAC,CAAI,CAAA,EAAA,SAAS,GAAG,EAAE,GAAG,IAAI,CAAC;SACtC;QACD,KAAK,CAAC,GAAG,IAAW,EAAA;YAClBA,OAAK,CAAC,KAAK,CAAC,CAAI,CAAA,EAAA,SAAS,GAAG,EAAE,GAAG,IAAI,CAAC;SACvC;QACD,KAAK,CAAC,KAAa,EAAE,EAAc,EAAA;YACjCA,OAAK,CAAC,KAAK,CAAC,CAAI,CAAA,EAAA,SAAS,CAAK,EAAA,EAAA,KAAK,CAAE,CAAA,EAAE,EAAE,CAAC;SAC3C;QACD,SAAS,GAAA;AACP,YAAA,OAAOA,OAAK,CAAC,SAAS,EAAE;SACzB;KACF;AACH;;ACxOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CG;AAaH;;AAEG;AACH,MAAM,aAAa,GAAG;IACpB,CAAC,EAAE,EAAE,GAAG,EAAE,CAAkB,CAAA;IAC5B,CAAC,EAAE,EAAE,GAAG,EAAE,CAAkB,CAAA;IAC5B,KAAK,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE;IAC1B,MAAM,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE;CAC7B;AAED;;;;;;;;;;AAUG;AACa,SAAA,cAAc,CAC5B,MAAW,EACX,UAAkB,EAAA;IAElB,MAAM,MAAM,GAAa,EAAE;;IAG3B,IAAI,CAAC,MAAM,EAAE;AACX,QAAA,MAAM,CAAC,IAAI,CAAC,GAAG,UAAU,CAAA,+BAAA,CAAiC,CAAC;AAC3D,QAAA,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE;;;IAIjC,MAAM,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC;AAClD,IAAA,KAAK,MAAM,IAAI,IAAI,YAAY,EAAE;AAC/B,QAAA,IAAI,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE;AACtE,YAAA,MAAM,CAAC,IAAI,CACT,CAAA,EAAG,UAAU,CAAW,QAAA,EAAA,IAAI,CAAkC,+BAAA,EAAA,MAAM,CAAC,IAAI,CAAC,CAAA,CAAE,CAC7E;;;;AAKL,IAAA,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,EAAE;AAC/D,QAAA,MAAM,CAAC,IAAI,CACT,CAAG,EAAA,UAAU,wBAAwB,aAAa,CAAC,CAAC,CAAC,GAAG,CAAU,OAAA,EAAA,MAAM,CAAC,CAAC,CAAA,CAAE,CAC7E;;AAGH,IAAA,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,EAAE;AAC/D,QAAA,MAAM,CAAC,IAAI,CACT,CAAG,EAAA,UAAU,wBAAwB,aAAa,CAAC,CAAC,CAAC,GAAG,CAAU,OAAA,EAAA,MAAM,CAAC,CAAC,CAAA,CAAE,CAC7E;;AAGH,IAAA,IACE,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC;SAC5B,MAAM,CAAC,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG;YACrC,MAAM,CAAC,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,EACzC;QACA,MAAM,CAAC,IAAI,CACT,CAAA,EAAG,UAAU,CAAiC,8BAAA,EAAA,aAAa,CAAC,KAAK,CAAC,GAAG,IAAI,aAAa,CAAC,KAAK,CAAC,GAAG,CAAA,OAAA,EAAU,MAAM,CAAC,KAAK,CAAE,CAAA,CACzH;;AAGH,IAAA,IACE,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC;SAC7B,MAAM,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,GAAG;YACvC,MAAM,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,EAC3C;QACA,MAAM,CAAC,IAAI,CACT,CAAA,EAAG,UAAU,CAAkC,+BAAA,EAAA,aAAa,CAAC,MAAM,CAAC,GAAG,IAAI,aAAa,CAAC,MAAM,CAAC,GAAG,CAAA,OAAA,EAAU,MAAM,CAAC,MAAM,CAAE,CAAA,CAC7H;;IAGH,OAAO;AACL,QAAA,KAAK,EAAE,MAAM,CAAC,MAAM,KAAK,CAAC;QAC1B,MAAM;KACP;AACH;AAEA;;;;;;;;;;;;;;;;;;;AAmBG;AACG,SAAU,gBAAgB,CAAC,IAAS,EAAA;IACxC,MAAM,MAAM,GAAa,EAAE;;IAG3B,IAAI,CAAC,IAAI,EAAE;AACT,QAAA,MAAM,CAAC,IAAI,CAAC,2BAA2B,CAAC;AACxC,QAAA,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE;;;AAIjC,IAAA,IAAI,OAAO,IAAI,CAAC,EAAE,KAAK,QAAQ,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACxD,MAAM,CAAC,IAAI,CAAC,CAAA,yCAAA,EAA4C,IAAI,CAAC,EAAE,CAAE,CAAA,CAAC;;;AAIpE,IAAA,IAAI,OAAO,IAAI,CAAC,QAAQ,KAAK,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACpE,MAAM,CAAC,IAAI,CACT,CAAA,+CAAA,EAAkD,IAAI,CAAC,QAAQ,CAAE,CAAA,CAClE;;;AAIH,IAAA,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QAC5D,MAAM,CAAC,IAAI,CAAC,CAAA,2CAAA,EAA8C,IAAI,CAAC,IAAI,CAAE,CAAA,CAAC;;;AAIxE,IAAA,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AACpE,QAAA,MAAM,CAAC,IAAI,CACT,CAAA,0CAAA,EAA6C,IAAI,CAAC,MAAM,CAAW,QAAA,EAAA,OAAO,IAAI,CAAC,MAAM,CAAA,CAAA,CAAG,CACzF;;;AAIH,IAAA,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,QAAQ,EAAE;AACrD,QAAA,MAAM,CAAC,IAAI,CAAC,gCAAgC,CAAC;AAC7C,QAAA,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE;;;AAIjC,IAAA,MAAM,aAAa,GAAG,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC;AACrE,IAAA,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE;QACxB,MAAM,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,MAAM,CAAC;;;AAItC,IAAA,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;AACvB,QAAA,MAAM,YAAY,GAAG,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,QAAQ,CAAC;AAClE,QAAA,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE;YACvB,MAAM,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC;;;IAIvC,OAAO;AACL,QAAA,KAAK,EAAE,MAAM,CAAC,MAAM,KAAK,CAAC;QAC1B,MAAM;KACP;AACH;AAEA;;;;;;;;;;;;;;;;;AAiBG;AACG,SAAU,mBAAmB,CAAC,OAAY,EAAA;IAC9C,MAAM,MAAM,GAAa,EAAE;IAE3B,IAAI,CAAC,OAAO,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;AAC3C,QAAA,MAAM,CAAC,IAAI,CAAC,2BAA2B,CAAC;AACxC,QAAA,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE;;;AAIjC,IAAA,IAAI,OAAO,CAAC,OAAO,EAAE;AACnB,QAAA,IAAI,OAAO,OAAO,CAAC,OAAO,KAAK,QAAQ,EAAE;AACvC,YAAA,MAAM,CAAC,IAAI,CAAC,mCAAmC,CAAC;;aAC3C;;AAEL,YAAA,IAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE;AAC3B,gBAAA,MAAM,aAAa,GAAG,cAAc,CAClC,OAAO,CAAC,OAAO,CAAC,OAAO,EACvB,SAAS,CACV;AACD,gBAAA,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE;oBACxB,MAAM,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,MAAM,CAAC;;;;AAKxC,YAAA,IAAI,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE;AAC1B,gBAAA,MAAM,YAAY,GAAG,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,QAAQ,CAAC;AACrE,gBAAA,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE;oBACvB,MAAM,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC;;;;;;IAO3C,IACE,QAAQ,IAAI,OAAO;AACnB,SAAC,OAAO,OAAO,CAAC,MAAM,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,EACxE;QACA,MAAM,CAAC,IAAI,CACT,CAAA,6CAAA,EAAgD,OAAO,CAAC,MAAM,CAAE,CAAA,CACjE;;;IAIH,IAAI,QAAQ,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,MAAM,KAAK,QAAQ,EAAE;QAC7D,MAAM,CAAC,IAAI,CACT,CAA0C,uCAAA,EAAA,OAAO,OAAO,CAAC,MAAM,CAAE,CAAA,CAClE;;IAGH,OAAO;AACL,QAAA,KAAK,EAAE,MAAM,CAAC,MAAM,KAAK,CAAC;QAC1B,MAAM;KACP;AACH;;AClSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqOG;AA4iBH;;;;;;;;;;;;AAYG;AACH,MAAM,mBAAmB,GAAc;AACrC,IAAA,QAAQ,EAAE,EAAE;AACZ,IAAA,cAAc,EAAE,IAAI;AACpB,IAAA,gBAAgB,EAAE,IAAI;AACtB,IAAA,cAAc,EAAE,IAAI;AACpB,IAAA,eAAe,EAAE,SAAS;AAC1B,IAAA,QAAQ,EAAE,IAAI;CACf;AAED;;AAEG;AACH,MAAM,KAAK,GAAG,iBAAiB,CAAC,eAAe,CAAC;AAEhD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CG;MACU,YAAY,CAAA;AA4DvB;;;;;;;;;;;;AAYG;AACH,IAAA,WAAA,CAAY,YAAiC,EAAA;AA9B7C;;;;;;AAMG;AACK,QAAA,IAAa,CAAA,aAAA,GAAW,CAAC;;AAyB/B,QAAA,MAAM,gBAAgB,GACjB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,mBAAmB,CACnB,EAAA,YAAY,CAChB;;AAGD,QAAA,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,GAChC,WAAW,CAAY,gBAAgB,CAAC;AAE1C,QAAA,IAAI,CAAC,KAAK,GAAG,KAAK;AAClB,QAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ;AACxB,QAAA,IAAI,CAAC,OAAO,GAAG,OAAO;;AAGtB,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;;AAGlE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BG;IACH,KAAK,GAAA;AACH,QAAA,IAAI,CAAC,aAAa,GAAG,CAAC;;QAGtB,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAC9B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAC3C;QACD,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc;QAC5D,IAAI,CAAC,KAAK,CAAC,gBAAgB,GAAG,IAAI,CAAC,YAAY,CAAC,gBAAgB;QAChE,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc;QAC5D,IAAI,CAAC,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe;QAC9D,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ;;AAGlD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCG;IACH,eAAe,CAAC,QAAgB,EAAE,IAAc,EAAA;QAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;YACX;;;AAIF,QAAA,MAAM,UAAU,GAAG,gBAAgB,CAAC,IAAI,CAAC;AACzC,QAAA,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE;AACrB,YAAA,KAAK,CAAC,IAAI,CAAC,8CAA8C,EAAE;gBACzD,MAAM,EAAE,IAAI,CAAC,EAAE;gBACf,QAAQ;gBACR,MAAM,EAAE,UAAU,CAAC,MAAM;AAC1B,aAAA,CAAC;;AAGJ,QAAA,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;AACvB,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAQ,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,CAAC;;AAGnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BG;IACH,oBAAoB,CAAC,QAAgB,EAAE,MAAc,EAAA;QACnD,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;YACX;;QAGF,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,EAAE,KAAK,MAAM,CAAC;AAChE,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAQ,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,CAAC;;AAGnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCG;AACH,IAAA,UAAU,CACR,QAAgB,EAChB,MAAc,EACd,OAA0B,EAAA;QAE1B,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;YACX;;AAGF,QAAA,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;QACtD,IAAI,CAAC,IAAI,EAAE;YACT;;;AAIF,QAAA,MAAM,UAAU,GAAG,mBAAmB,CAAC,OAAO,CAAC;AAC/C,QAAA,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE;AACrB,YAAA,KAAK,CAAC,IAAI,CAAC,yCAAyC,EAAE;gBACpD,MAAM;gBACN,QAAQ;gBACR,OAAO;gBACP,MAAM,EAAE,UAAU,CAAC,MAAM;AAC1B,aAAA,CAAC;;AAGJ,QAAA,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC;AAC5B,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAQ,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,CAAC;;AAGnD;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BG;IACH,OAAO,CAAC,QAAgB,EAAE,MAAc,EAAA;QACtC,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;AACX,YAAA,OAAO,IAAI;;AAGb,QAAA,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC,IAAI,IAAI;;AAG1D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CG;AACH,IAAA,gBAAgB,CACd,YAAoB,EACpB,UAAkB,EAClB,MAAc,EAAA;QAEd,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC;QACpD,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC;AAEhD,QAAA,IAAI,CAAC,UAAU,IAAI,CAAC,QAAQ,EAAE;YAC5B;;AAGF,QAAA,MAAM,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;QAC1D,IAAI,CAAC,IAAI,EAAE;YACT;;;AAIF,QAAA,MAAM,UAAU,GAAG,gBAAgB,CAAC,IAAI,CAAC;AACzC,QAAA,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE;AACrB,YAAA,KAAK,CAAC,IAAI,CAAC,+CAA+C,EAAE;gBAC1D,MAAM;gBACN,YAAY;gBACZ,UAAU;gBACV,MAAM,EAAE,UAAU,CAAC,MAAM;AAC1B,aAAA,CAAC;;;QAIJ,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;;AAGlE,QAAA,IAAI,CAAC,QAAQ,GAAG,UAAU;;AAG1B,QAAA,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;AAEzB,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAQ,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,CAAC;;AAGnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BG;IACH,cAAc,GAAA;AACZ,QAAA,OAAO,QAAQ,EAAE,IAAI,CAAC,aAAa,EAAE;;AAGvC;;;;;;;;;;;;;;;;;;;;;AAqBG;AACH,IAAA,aAAa,CACX,QAAgB,EAChB,MAAc,EACd,SAAiB,EAAA;QAEjB,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;AACX,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;QACtD,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM;;AAG7B,QAAA,IAAI,CAAC,MAAM,GAAG,SAAS;;AAGvB,QAAA,IAAI,SAAS,IAAI,MAAM,CAAC,aAAa,EAAE;AACrC,YAAA,MAAM,CAAC,aAAa,GAAG,SAAS,GAAG,CAAC;;;AAItC,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE;AAEhD,QAAA,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE;;AAGjC;;;;;;;;;;;;;;AAcG;IACH,eAAe,CACb,QAAgB,EAChB,MAAc,EAAA;QAEd,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;AACX,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;QACtD,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,IAAI;;;QAIb,MAAM,WAAW,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;AACzE,QAAA,MAAM,YAAY,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;;QAGlE,IAAI,YAAY,KAAK,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;AAC3C,YAAA,OAAO,IAAI;;QAGb,MAAM,QAAQ,GAAG,WAAW,CAAC,YAAY,GAAG,CAAC,CAAC;AAC9C,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM;AAC7B,QAAA,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM;;AAGjC,QAAA,IAAI,CAAC,MAAM,GAAG,SAAS;AACvB,QAAA,QAAQ,CAAC,MAAM,GAAG,SAAS;;AAG3B,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE;AAEhD,QAAA,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE;;AAGjC;;;;;;;;;;;;;;AAcG;IACH,gBAAgB,CACd,QAAgB,EAChB,MAAc,EAAA;QAEd,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;AACX,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;QACtD,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,IAAI;;;QAIb,MAAM,WAAW,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;AACzE,QAAA,MAAM,YAAY,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;;AAGlE,QAAA,IAAI,YAAY,KAAK,CAAC,EAAE;AACtB,YAAA,OAAO,IAAI;;QAGb,MAAM,QAAQ,GAAG,WAAW,CAAC,YAAY,GAAG,CAAC,CAAC;AAC9C,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM;AAC7B,QAAA,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM;;AAGjC,QAAA,IAAI,CAAC,MAAM,GAAG,SAAS;AACvB,QAAA,QAAQ,CAAC,MAAM,GAAG,SAAS;;AAG3B,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE;AAEhD,QAAA,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE;;AAGjC;;;;;;;;;;;;;AAaG;IACH,gBAAgB,CACd,QAAgB,EAChB,MAAc,EAAA;QAEd,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;AACX,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;QACtD,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM;QAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;;AAGhE,QAAA,IAAI,SAAS,KAAK,SAAS,EAAE;AAC3B,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,SAAS,GAAG,MAAM,CAAC,aAAa,EAAE;AACxC,QAAA,IAAI,CAAC,MAAM,GAAG,SAAS;;AAGvB,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE;AAEhD,QAAA,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE;;AAGjC;;;;;;;;;;;;AAYG;IACH,cAAc,CACZ,QAAgB,EAChB,MAAc,EAAA;QAEd,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE;AACX,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;QACtD,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM;QAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;;AAGhE,QAAA,IAAI,SAAS,KAAK,SAAS,EAAE;AAC3B,YAAA,OAAO,IAAI;;AAGb,QAAA,MAAM,SAAS,GAAG,SAAS,GAAG,CAAC;AAC/B,QAAA,IAAI,CAAC,MAAM,GAAG,SAAS;;AAGvB,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE;AAEhD,QAAA,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE;;AAGjC;;;;;;;;;;;;;;;;;;;;;AAqBG;IACH,UAAU,CAAC,MAAc,EAAE,QAAgB,EAAA;AACzC,QAAA,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,MAAM;AAClC,QAAA,IAAI,CAAC,KAAK,CAAC,gBAAgB,GAAG,QAAQ;;AAGxC;;;;;;;;;;;;;;;;;;;;AAoBG;IACH,YAAY,GAAA;AACV,QAAA,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,IAAI;AAChC,QAAA,IAAI,CAAC,KAAK,CAAC,gBAAgB,GAAG,IAAI;;AAGpC;;;;;;;;;;;;;;;;;;;;;;AAsBG;AACH,IAAA,eAAe,CAAC,QAAgB,EAAA;AAC9B,QAAA,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,QAAQ;;AAGtC;;;;;;;;;;;;;;;;;;AAkBG;IACH,iBAAiB,GAAA;AACf,QAAA,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,IAAI;;AAGlC;;;;;;;;;;;;;;;;;;;AAmBG;AACH,IAAA,aAAa,CAAC,KAA0B,EAAA;QACtC,MAAM,OAAO,GAAa,EAAE;AAC5B,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE;AAElD,QAAA,KAAK,MAAM,QAAQ,IAAI,KAAK,EAAE;AAC5B,YAAA,MAAM,EAAE,GAAG,IAAI,CAAC,cAAc,EAAE;AAChC,YAAA,MAAM,QAAQ,GAAG,QAAQ,CAAC,QAAS;AACnC,YAAA,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAC;YAExC,IAAI,CAAC,MAAM,EAAE;AACX,gBAAA,OAAO,CAAC,IAAI,CAAC,UAAU,QAAQ,CAAA,yBAAA,CAA2B,CAAC;gBAC3D;;AAGF,YAAA,MAAM,OAAO,GAAa;gBACxB,EAAE;gBACF,QAAQ;AACR,gBAAA,IAAI,EAAE,QAAQ,CAAC,IAAI,IAAI,SAAS;AAChC,gBAAA,IAAI,EAAE,QAAQ,CAAC,IAAI,IAAI,SAAS;AAChC,gBAAA,OAAO,EAAE,QAAQ,CAAC,OAAO,IAAI;AAC3B,oBAAA,OAAO,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE;AAC9C,oBAAA,MAAM,EAAE;AACN,wBAAA,CAAC,EAAE,IAAI;AACP,wBAAA,CAAC,EAAE,IAAI;AACP,wBAAA,KAAK,EAAE,IAAI;AACX,wBAAA,MAAM,EAAE,IAAI;AACZ,wBAAA,UAAU,EAAE,KAAK;AAClB,qBAAA;AACF,iBAAA;AACD,gBAAA,MAAM,EAAE,MAAM,CAAC,aAAa,EAAE;AAC9B,gBAAA,MAAM,EAAE,QAAQ,CAAC,MAAM,IAAI,EAAE;aAC9B;;AAGD,YAAA,MAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,CAAC;AAC5C,YAAA,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE;AACrB,gBAAA,KAAK,CAAC,IAAI,CAAC,4CAA4C,EAAE;AACvD,oBAAA,MAAM,EAAE,EAAE;oBACV,QAAQ;oBACR,MAAM,EAAE,UAAU,CAAC,MAAM;AAC1B,iBAAA,CAAC;;AAGJ,YAAA,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC;AAC1B,YAAA,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;;;AAIlB,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,eAAe;AAErC,QAAA,OAAO,OAAO;;AAGhB;;;;;;;;;;;;;;;;;;AAkBG;AACH,IAAA,gBAAgB,CAAC,OAAiB,EAAA;AAChC,QAAA,MAAM,SAAS,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC;AAClC,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE;;AAGlD,QAAA,KAAK,MAAM,QAAQ,IAAI,eAAe,EAAE;YACtC,eAAe,CAAC,QAAQ,CAAC,GACpB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,eAAe,CAAC,QAAQ,CAAC,CAC5B,EAAA,EAAA,KAAK,EAAE,eAAe,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,MAAM,CAC3C,CAAC,IAAI,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAClC,GACF;;;AAIH,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,eAAe;;AAGvC;;;;;;;;;;;;;;;;;;AAkBG;AACH,IAAA,gBAAgB,CACd,OAIG,EAAA;AAEH,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE;AAElD,QAAA,KAAK,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,WAAW,EAAE,IAAI,OAAO,EAAE;AAChE,YAAA,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAC;YACxC,IAAI,CAAC,MAAM,EAAE;gBACX,OAAO,CAAC,IAAI,CAAC,CAAA,OAAA,EAAU,QAAQ,CAA6B,0BAAA,EAAA,MAAM,CAAE,CAAA,CAAC;gBACrE;;AAGF,YAAA,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;YACtD,IAAI,CAAC,IAAI,EAAE;gBACT,OAAO,CAAC,IAAI,CAAC,CAAA,KAAA,EAAQ,MAAM,CAAwB,qBAAA,EAAA,QAAQ,CAAE,CAAA,CAAC;gBAC9D;;AAGF,YAAA,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,WAAW,CAAC;;;AAIlC,QAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,eAAe;;AAExC;AAED;;;;;AAKG;AAEH;AACA,MAAM,cAAc,GAAG,IAAI,YAAY,EAAE;AAEzC;AACa,MAAA,SAAS,GAAG,cAAc,CAAC;AAsB3B,MAAA,cAAc,GAAG,MAAM,cAAc,CAAC,cAAc;AAcpD,MAAA,UAAU,GAAG,CAAC,MAAc,EAAE,QAAgB,KACzD,cAAc,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ;AAErC,MAAM,eAAe,GAAG,CAAC,QAAgB,KAC9C,cAAc,CAAC,eAAe,CAAC,QAAQ;;;;","x_google_ignoreList":[2]}