{"file":"undo-redo-27e9fef6.js","mappings":";;AAAA;;;;;;;AA2BA;MACM,EAAE,KAAK,EAAE,aAAa,EAAE,GAAG,WAAW,CAAgB;IAC1D,OAAO,EAAE,KAAK;IACd,OAAO,EAAE,KAAK;CACf,EAAE;AAIH;;;AAGA,MAAM,cAAc,GAAc,EAAE,CAAC;AACrC,IAAI,eAAe,GAAW,CAAC,CAAC,CAAC;AACjC,MAAM,WAAW,GAAG,EAAE,CAAC;AAEvB;;;;AAIA,SAAS,kBAAkB;IACzB,aAAa,CAAC,OAAO,GAAG,eAAe,IAAI,CAAC,CAAC;IAC7C,aAAa,CAAC,OAAO,GAAG,eAAe,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;AACtE,CAAC;AAED;;;;SAIgB,WAAW,CAAC,OAAgB;;IAE1C,cAAc,CAAC,MAAM,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;;IAG3C,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;;IAG7B,IAAI,cAAc,CAAC,MAAM,GAAG,WAAW,EAAE;QACvC,cAAc,CAAC,KAAK,EAAE,CAAC;KACxB;SAAM;QACL,eAAe,EAAE,CAAC;KACnB;;IAGD,kBAAkB,EAAE,CAAC;AACvB,CAAC;AAED;;;SAGgB,IAAI;IAClB,IAAI,eAAe,GAAG,CAAC,EAAE;QACvB,OAAO;KACR;IAED,MAAM,OAAO,GAAG,cAAc,CAAC,eAAe,CAAC,CAAC;IAChD,OAAO,CAAC,IAAI,EAAE,CAAC;IACf,eAAe,EAAE,CAAC;IAElB,kBAAkB,EAAE,CAAC;AACvB,CAAC;AAED;;;SAGgB,IAAI;IAClB,IAAI,eAAe,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;QAChD,OAAO;KACR;IAED,eAAe,EAAE,CAAC;IAClB,MAAM,OAAO,GAAG,cAAc,CAAC,eAAe,CAAC,CAAC;IAChD,OAAO,CAAC,IAAI,EAAE,CAAC;IAEf,kBAAkB,EAAE,CAAC;AACvB,CAAC;AAED;;;SAGgB,OAAO;IACrB,OAAO,eAAe,IAAI,CAAC,CAAC;AAC9B,CAAC;AAED;;;SAGgB,OAAO;IACrB,OAAO,eAAe,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;AACrD,CAAC;AAED;;;SAGgB,YAAY;IAC1B,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;IAC1B,eAAe,GAAG,CAAC,CAAC,CAAC;IACrB,kBAAkB,EAAE,CAAC;AACvB;;;;","names":[],"sources":["src/services/undo-redo.ts"],"sourcesContent":["/**\n * Undo/Redo Service\n * Command pattern for undo/redo functionality\n *\n * Purpose: Provide undo/redo capabilities for user actions\n * Maintains a command history with max 50 operations\n */\n\nimport { createStore } from '@stencil/store';\n\n/**\n * Command Interface\n * All undoable operations must implement this interface\n */\nexport interface Command {\n  undo(): void;\n  redo(): void;\n}\n\n/**\n * Undo/Redo State\n */\ninterface UndoRedoState {\n  canUndo: boolean;\n  canRedo: boolean;\n}\n\n// Create store for undo/redo state (for UI reactivity)\nconst { state: undoRedoState } = createStore<UndoRedoState>({\n  canUndo: false,\n  canRedo: false,\n});\n\nexport { undoRedoState };\n\n/**\n * Internal state\n */\nconst commandHistory: Command[] = [];\nlet historyPosition: number = -1;\nconst MAX_HISTORY = 50;\n\n/**\n * Update undo/redo button states\n * This triggers UI updates via the store\n */\nfunction updateButtonStates(): void {\n  undoRedoState.canUndo = historyPosition >= 0;\n  undoRedoState.canRedo = historyPosition < commandHistory.length - 1;\n}\n\n/**\n * Push a new command to the history\n * Removes any commands after current position (if we undid and then did something new)\n */\nexport function pushCommand(command: Command): void {\n  // Remove any commands after current position\n  commandHistory.splice(historyPosition + 1);\n\n  // Add new command\n  commandHistory.push(command);\n\n  // Limit history size\n  if (commandHistory.length > MAX_HISTORY) {\n    commandHistory.shift();\n  } else {\n    historyPosition++;\n  }\n\n  // Update button states\n  updateButtonStates();\n}\n\n/**\n * Undo the last command\n */\nexport function undo(): void {\n  if (historyPosition < 0) {\n    return;\n  }\n\n  const command = commandHistory[historyPosition];\n  command.undo();\n  historyPosition--;\n\n  updateButtonStates();\n}\n\n/**\n * Redo the next command\n */\nexport function redo(): void {\n  if (historyPosition >= commandHistory.length - 1) {\n    return;\n  }\n\n  historyPosition++;\n  const command = commandHistory[historyPosition];\n  command.redo();\n\n  updateButtonStates();\n}\n\n/**\n * Check if undo is available\n */\nexport function canUndo(): boolean {\n  return historyPosition >= 0;\n}\n\n/**\n * Check if redo is available\n */\nexport function canRedo(): boolean {\n  return historyPosition < commandHistory.length - 1;\n}\n\n/**\n * Clear all history\n */\nexport function clearHistory(): void {\n  commandHistory.length = 0;\n  historyPosition = -1;\n  updateButtonStates();\n}\n"],"version":3}