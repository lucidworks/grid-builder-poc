{"version":3,"file":"p-C9Eu2TsU.js","sources":["src/services/undo-redo-commands.ts","src/utils/boundary-constraints.ts"],"sourcesContent":["/**\n * Undo/Redo Commands\n * ===================\n *\n * Concrete Command implementations for grid operations. Each command class\n * encapsulates a specific user action with the ability to undo and redo.\n *\n * ## Problem\n *\n * The Command pattern requires concrete implementations for each undoable operation.\n * Each command must:\n * - Capture enough state to reverse the operation (undo)\n * - Capture enough state to reapply the operation (redo)\n * - Be self-contained (no external dependencies)\n * - Handle edge cases (canvas switching, index preservation)\n *\n * ## Solution\n *\n * Four concrete command classes covering all grid operations:\n *\n * 1. **AddItemCommand**: Adding new items to canvas\n * 2. **DeleteItemCommand**: Removing items with index preservation\n * 3. **MoveItemCommand**: Dragging items (same or different canvas)\n * 4. **ResizeCommand**: (Not yet implemented - resize operations not tracked)\n *\n * ## Key Design Patterns\n *\n * ### Deep Cloning Strategy\n *\n * **Why deep clone**: Prevent mutations from affecting command snapshots\n *\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **When to clone**:\n * - ‚úÖ Constructor: Capture initial state\n * - ‚úÖ redo(): Create fresh copy for state mutation\n * - ‚ùå undo(): Usually work with existing state references\n *\n * **Trade-offs**:\n * - ‚úÖ Simple and reliable\n * - ‚úÖ No reference bugs\n * - ‚ùå Higher memory usage (~1-5 KB per command)\n * - ‚ùå Slower than structural sharing\n *\n * ### Index Preservation Pattern\n *\n * **Why preserve index**: Undo delete should restore item at original position\n *\n * ```typescript\n * class DeleteItemCommand {\n * private itemIndex: number;  // Capture index before deletion\n *\n * undo() {\n * canvas.items.splice(this.itemIndex, 0, item);  // Restore at index\n * }\n * }\n * ```\n *\n * **Important for**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * ### Selection State Management\n *\n * **Pattern**: Clear selection when deleting selected item\n *\n * ```typescript\n * if (gridState.selectedItemId === itemId) {\n * gridState.selectedItemId = null;\n * gridState.selectedCanvasId = null;\n * }\n * ```\n *\n * **Why needed**:\n * - Prevents dangling references to deleted items\n * - Avoids errors when accessing selectedItemId\n * - Matches user expectations (deleted item can't be selected)\n *\n * ### Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between canvases\n *\n * **Solution**: Track source and target canvas IDs\n *\n * ```typescript\n * class MoveItemCommand {\n * sourceCanvasId: string;\n * targetCanvasId: string;\n *\n * undo() {\n * // Move from target back to source\n * removeFrom(targetCanvasId);\n * addTo(sourceCanvasId, sourceIndex);  // Restore position\n * }\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Typical flow**:\n * ```\n * 1. User performs action (drag, delete, etc.)\n * 2. Operation completes (state already updated)\n * 3. Create command with before/after snapshots\n * 4. pushCommand(command) ‚Üí adds to history\n * 5. User presses Ctrl+Z\n * 6. command.undo() ‚Üí reverses operation\n * 7. User presses Ctrl+Y\n * 8. command.redo() ‚Üí reapplies operation\n * ```\n *\n * **Important**: Commands are created AFTER the operation completes,\n * not before. The constructor captures the final state.\n *\n * ## Extracting These Patterns\n *\n * To create new command types:\n *\n * ```typescript\n * export class MyCommand implements Command {\n * // Capture state needed for undo/redo\n * private beforeState: any;\n * private afterState: any;\n *\n * constructor(params) {\n * // Deep clone to prevent mutations\n * this.beforeState = JSON.parse(JSON.stringify(before));\n * this.afterState = JSON.parse(JSON.stringify(after));\n * }\n *\n * undo(): void {\n * // Restore before state\n * restoreState(this.beforeState);\n * gridState.canvases = { ...gridState.canvases };  // Trigger reactivity\n * }\n *\n * redo(): void {\n * // Apply after state\n * restoreState(this.afterState);\n * gridState.canvases = { ...gridState.canvases };\n * }\n * }\n * ```\n *\n * **Guidelines**:\n * - Always deep clone state in constructor\n * - Always trigger reactivity (`gridState.canvases = { ...gridState.canvases }`)\n * - Handle null cases (canvas/item not found)\n * - Clear selection if needed\n * - Preserve array indices for positional restore\n * @module undo-redo-commands\n */\n\nimport { GridItem } from \"./state-manager\";\nimport { Command } from \"./undo-redo\";\nimport { EventManager } from \"./event-manager\";\nimport { createDebugLogger } from \"../utils/debug\";\n\nconst debug = createDebugLogger(\"undo-redo-commands\");\n\n/**\n * Helper function to remove an item from a canvas and clear selection\n *\n * **Responsibilities**:\n * - Remove item from canvas items array\n * - Trigger state reactivity (spread pattern)\n * - Clear selection if deleted item was selected\n *\n * **Used by**:\n * - AddItemCommand.undo() - Remove just-added item\n * - DeleteItemCommand.redo() - Remove item again\n * - MoveItemCommand (implicitly via filter)\n *\n * **Why helper function**:\n * - DRY principle (used in multiple commands)\n * - Encapsulates selection clearing logic\n * - Consistent behavior across commands\n *\n * **Selection clearing**:\n * Prevents dangling references and UI errors when selected item deleted.\n *\n * **Instance-based architecture**:\n * - Requires state parameter for multi-instance support\n * @param canvasId - Canvas containing the item\n * @param itemId - Item to remove\n * @param state - GridState instance\n * @example\n * ```typescript\n * // Used internally by commands\n * undo() {\n *   removeItemFromCanvas(this.canvasId, this.item.id, this.stateInstance);\n * }\n * ```\n */\nfunction removeItemFromCanvas(\n  canvasId: string,\n  itemId: string,\n  state: any,\n): void {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((i) => i.id !== itemId);\n  state.canvases = { ...state.canvases };\n\n  // Clear selection if this item was selected\n  if (state.selectedItemId === itemId) {\n    state.selectedItemId = null;\n    state.selectedCanvasId = null;\n  }\n}\n\n/**\n * AddItemCommand\n * ==============\n *\n * Captures the addition of a new grid item to a canvas, enabling undo/redo\n * for create operations.\n *\n * ## Use Cases\n *\n * - User drops component from palette onto canvas\n * - Programmatic item creation (stress tests, templates)\n * - Duplicating existing items\n *\n * ## Command Lifecycle\n *\n * **Creation**: After item already added to canvas\n * ```typescript\n * // 1. Add item to canvas (operation completes)\n * addItemToCanvas('canvas1', newItem);\n *\n * // 2. Create command for undo (captures final state)\n * const command = new AddItemCommand('canvas1', newItem);\n * pushCommand(command);\n * ```\n *\n * **Undo**: Remove the item from canvas\n * ```typescript\n * command.undo(); // Item disappears from canvas\n * ```\n *\n * **Redo**: Re-add the item to canvas\n * ```typescript\n * command.redo(); // Item reappears in canvas\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures item state with deep clone\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Prevents mutations from affecting command's snapshot\n * - Item might be modified after command creation\n * - Ensures redo restores exact original state\n *\n * **Redo cloning**: Creates fresh copy for state mutation\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.push(itemCopy);\n * ```\n *\n * **Why redo also clones**:\n * - Multiple redo calls shouldn't share references\n * - Prevents undo/redo from affecting each other\n * - Safe state isolation\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: redo() returns early if canvas not found\n * - **Item modified**: Command stores original state, not current\n * - **Selection**: undo() automatically clears selection via helper\n * @example\n * ```typescript\n * // After palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(),\n *   canvasId: 'canvas1',\n *   type: 'header',\n *   name: 'Header',\n *   layouts: { desktop: { x: 5, y: 5, width: 20, height: 8 }, ... },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n *\n * addItemToCanvas('canvas1', newItem);\n * pushCommand(new AddItemCommand('canvas1', newItem));\n * ```\n */\nexport class AddItemCommand implements Command {\n  /** Deep clone of item at creation time */\n  private item: GridItem;\n\n  /** Canvas ID where item was added */\n  private canvasId: string;\n\n  /** GridState instance for multi-instance support */\n  private stateInstance: any;\n\n  /**\n   * Capture item addition operation\n   *\n   * **Important**: Call AFTER item added to canvas (not before)\n   *\n   * **Deep clones item**: Prevents future mutations from affecting snapshot\n   *\n   * **Instance-based architecture**:\n   * - Requires stateInstance parameter for multi-instance support\n   * @param canvasId - Canvas where item was added\n   * @param item - Item that was added (will be deep cloned)\n   * @param stateInstance - GridState instance\n   */\n  constructor(canvasId: string, item: GridItem, stateInstance: any) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state at time of creation\n    this.item = JSON.parse(JSON.stringify(item));\n    this.stateInstance = stateInstance;\n  }\n\n  /**\n   * Undo: Remove the item from canvas\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  undo(): void {\n    // Remove the item from the canvas\n    removeItemFromCanvas(this.canvasId, this.item.id, this.stateInstance);\n  }\n\n  /**\n   * Redo: Re-add the item to canvas\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Appends to end**: Doesn't preserve original index (acceptable for add)\n   *\n   * **Side effects**:\n   * - Item added to end of canvas.items array\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found (e.g., canvas was deleted)\n   */\n  redo(): void {\n    // Re-add the item to the canvas\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Use the cloned item state\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    canvas.items.push(itemCopy);\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n  }\n\n  /**\n   * Get description of this command\n   *\n   * @returns Object with action type, position, and item details\n   */\n  getDescription() {\n    const { x, y, width, height } = this.item.layouts.desktop;\n    return {\n      action: 'add',\n      type: this.item.type,\n      position: { x, y },\n      size: { width, height },\n    };\n  }\n}\n\n/**\n * DeleteItemCommand\n * ==================\n *\n * Captures the deletion of a grid item from a canvas, enabling undo/redo\n * for delete operations with index preservation.\n *\n * ## Use Cases\n *\n * - User deletes item with Delete key\n * - Delete button clicked\n * - Programmatic item removal\n * - Clearing canvas sections\n *\n * ## Index Preservation Pattern\n *\n * **Critical feature**: Restores deleted item at its ORIGINAL array position\n *\n * **Why important**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * **Implementation**:\n * ```typescript\n * constructor(canvasId, item, itemIndex) {\n * this.itemIndex = itemIndex;  // Capture before deletion!\n * }\n *\n * undo() {\n * canvas.items.splice(this.itemIndex, 0, itemCopy);  // Restore at index\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE deleting item (to capture index)\n * ```typescript\n * // 1. Get item and its index BEFORE deletion\n * const item = getItem('canvas1', 'item-5');\n * const index = gridState.canvases['canvas1'].items.indexOf(item);\n *\n * // 2. Create command (captures item and index)\n * const command = new DeleteItemCommand('canvas1', item, index);\n *\n * // 3. Perform deletion\n * removeItemFromCanvas('canvas1', 'item-5');\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Restore item at original position\n * ```typescript\n * command.undo(); // Item reappears at exact original position\n * ```\n *\n * **Redo**: Delete item again\n * ```typescript\n * command.redo(); // Item disappears (and selection cleared if selected)\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures complete item state before deletion\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Item will be deleted from state immediately after\n * - Reference would become invalid after deletion\n * - Must preserve complete state for restoration\n *\n * **Undo cloning**: Creates fresh copy for state insertion\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.splice(this.itemIndex, 0, itemCopy);\n * ```\n *\n * ## Selection State Handling\n *\n * **Redo behavior**: Delegates to removeItemFromCanvas helper\n *\n * **Helper automatically**:\n * - Clears selectedItemId if this item was selected\n * - Clears selectedCanvasId\n * - Prevents dangling references\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: undo() returns early if canvas not found\n * - **Invalid index**: Falls back to push() if index out of bounds\n * - **Item modified before delete**: Command stores pre-deletion state\n * - **Multiple deletes**: Each command independently tracks its item\n * @example\n * ```typescript\n * // Handle Delete key press\n * handleDeleteKey() {\n *   if (!gridState.selectedItemId || !gridState.selectedCanvasId) {\n *     return;\n *   }\n *\n *   const item = getItem(gridState.selectedCanvasId, gridState.selectedItemId);\n *   const canvas = gridState.canvases[gridState.selectedCanvasId];\n *   const index = canvas.items.indexOf(item);\n *\n *   // Create command before deleting\n *   const command = new DeleteItemCommand(\n *     gridState.selectedCanvasId,\n *     item,\n *     index\n *   );\n *\n *   // Perform deletion\n *   removeItemFromCanvas(gridState.selectedCanvasId, gridState.selectedItemId);\n *\n *   // Enable undo\n *   pushCommand(command);\n * }\n * ```\n */\nexport class DeleteItemCommand implements Command {\n  /** Deep clone of item before deletion */\n  private item: GridItem;\n\n  /** Canvas ID where item was deleted from */\n  private canvasId: string;\n\n  /** Original array index for position restoration */\n  private itemIndex: number;\n\n  /** GridState instance for multi-instance support */\n  private stateInstance: any;\n\n  /**\n   * Capture item deletion operation\n   *\n   * **Important**: Call BEFORE deleting item (to capture index)\n   *\n   * **Deep clones item**: Preserves state before deletion\n   *\n   * **Captures index**: Critical for restoring at original position\n   *\n   * **Instance-based architecture**:\n   * - Requires stateInstance parameter for multi-instance support\n   * @param canvasId - Canvas containing the item\n   * @param item - Item being deleted (will be deep cloned)\n   * @param itemIndex - Original array index (call indexOf before deletion!)\n   * @param stateInstance - GridState instance\n   */\n  constructor(\n    canvasId: string,\n    item: GridItem,\n    itemIndex: number,\n    stateInstance: any,\n  ) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state before deletion\n    this.item = JSON.parse(JSON.stringify(item));\n    this.itemIndex = itemIndex;\n    this.stateInstance = stateInstance;\n  }\n\n  /**\n   * Undo: Restore item at original position\n   *\n   * **Index preservation**: Uses splice to insert at exact original position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive coding)\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Side effects**:\n   * - Item restored to canvas.items array at original index\n   * - Other items shift to make room\n   * - Z-index order maintained (items render in array order)\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found\n   */\n  undo(): void {\n    // Re-add the item to its original position\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    // Insert at original index if possible, otherwise push to end\n    if (this.itemIndex >= 0 && this.itemIndex <= canvas.items.length) {\n      canvas.items.splice(this.itemIndex, 0, itemCopy);\n    } else {\n      canvas.items.push(itemCopy);\n    }\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n  }\n\n  /**\n   * Redo: Delete item again\n   *\n   * **Delegates to helper**: Uses removeItemFromCanvas for consistency\n   *\n   * **Automatic selection clearing**: Helper clears selection if this item selected\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  redo(): void {\n    // Remove the item again\n    removeItemFromCanvas(this.canvasId, this.item.id, this.stateInstance);\n  }\n\n  /**\n   * Get description of this command\n   *\n   * @returns Object with action type, position, and item details\n   */\n  getDescription() {\n    const { x, y, width, height } = this.item.layouts.desktop;\n    return {\n      action: 'delete',\n      type: this.item.type,\n      position: { x, y },\n      size: { width, height },\n    };\n  }\n}\n\n/**\n * MoveItemCommand\n * ===============\n *\n * Captures the movement of a grid item within the same canvas or across canvases,\n * enabling undo/redo for drag operations with position and index preservation.\n *\n * ## Use Cases\n *\n * - User drags item to new position in same canvas\n * - User drags item across canvas boundaries (cross-canvas move)\n * - Programmatic item repositioning\n * - Layout reorganization\n *\n * ## Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between different canvases\n *\n * **Solution**: Track both source and target canvas IDs\n *\n * **Same-canvas move**:\n * ```typescript\n * sourceCanvasId === targetCanvasId\n * // Only position changes, no canvas transfer\n * ```\n *\n * **Cross-canvas move**:\n * ```typescript\n * sourceCanvasId !== targetCanvasId\n * // Item removed from source, added to target\n * // Position updated to target coordinates\n * ```\n *\n * ## Position Tracking\n *\n * **Dual position capture**:\n * - `sourcePosition`: { x, y } before drag\n * - `targetPosition`: { x, y } after drag\n *\n * **Why both needed**:\n * - Undo must restore original position\n * - Redo must restore final position\n * - Positions are in grid coordinates (not pixels)\n *\n * ## Index Preservation Pattern\n *\n * **Critical for undo**: Restore item at original array position in source canvas\n *\n * **Why important**:\n * - Maintains visual z-order consistency\n * - Restores exact pre-drag state\n * - Items render in array order\n *\n * **Implementation**:\n * ```typescript\n * // Capture source index before move\n * const sourceIndex = sourceCanvas.items.indexOf(item);\n *\n * // Restore at index on undo\n * sourceCanvas.items.splice(sourceIndex, 0, item);\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE drag operation (capture source state)\n * ```typescript\n * // 1. Capture state before drag starts\n * const sourceIndex = canvas.items.indexOf(item);\n * const sourcePos = { x: item.layouts.desktop.x, y: item.layouts.desktop.y };\n *\n * // 2. Drag completes (position updated in DOM)\n * // ...\n *\n * // 3. Create command with before/after state\n * const command = new MoveItemCommand(\n * item.id,\n * sourceCanvasId,\n * targetCanvasId,  // May be same as source\n * sourcePos,\n * targetPos,       // New position after drag\n * sourceIndex\n * );\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Move back to source at original position\n * ```typescript\n * command.undo();\n * // Item returns to source canvas at original index\n * // Position restored to sourcePosition\n * ```\n *\n * **Redo**: Move to target at new position\n * ```typescript\n * command.redo();\n * // Item moves to target canvas (appended to end)\n * // Position updated to targetPosition\n * ```\n *\n * ## State Mutation Pattern\n *\n * **Unlike Add/Delete**: Does NOT deep clone item\n *\n * **Why reference-based**:\n * - Same item object moves between canvases\n * - Only position properties mutated\n * - Efficient (no serialization overhead)\n * - Item identity preserved (same ID, zIndex, etc.)\n *\n * **What gets cloned**:\n * ```typescript\n * // Only position objects cloned (shallow)\n * this.sourcePosition = { ...sourcePosition };\n * this.targetPosition = { ...targetPosition };\n * ```\n *\n * ## Position Coordinates\n *\n * **Uses desktop layout**: `item.layouts.desktop.x/y`\n *\n * **Why desktop**:\n * - Drag handler operates on desktop coordinates\n * - Mobile layout auto-generated or separately customized\n * - Single source of truth for command\n *\n * **Grid units**: Positions stored in grid units (not pixels)\n *\n * ## Canvas Mutation Flow\n *\n * **Undo sequence** (target ‚Üí source):\n * 1. Find item in target canvas\n * 2. Remove from target.items array\n * 3. Update item.canvasId to source\n * 4. Update item position to sourcePosition\n * 5. Insert at sourceIndex in source.items\n * 6. Trigger reactivity\n *\n * **Redo sequence** (source ‚Üí target):\n * 1. Find item in source canvas\n * 2. Remove from source.items array\n * 3. Update item.canvasId to target\n * 4. Update item position to targetPosition\n * 5. Append to target.items (no index preservation for redo)\n * 6. Trigger reactivity\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: Both undo/redo return early if canvas not found\n * - **Item not found**: Returns early (defensive coding)\n * - **Same position move**: Creates valid command (user expectation)\n * - **Invalid source index**: Fallback to append (defensive)\n * @example\n * ```typescript\n * // After drag end event\n * handleDragEnd(event) {\n *   const item = getItem(sourceCanvasId, itemId);\n *   const sourceIndex = gridState.canvases[sourceCanvasId].items.indexOf(item);\n *\n *   const command = new MoveItemCommand(\n *     itemId,\n *     sourceCanvasId,\n *     targetCanvasId,  // Detected from drop target\n *     { x: oldX, y: oldY },  // Captured on drag start\n *     { x: newX, y: newY },  // Calculated from drop position\n *     sourceIndex\n *   );\n *\n *   pushCommand(command);\n * }\n * ```\n */\nexport class MoveItemCommand implements Command {\n  /** Item ID (reference to item, not deep clone) */\n  private itemId: string;\n\n  /** Canvas ID where item started */\n  private sourceCanvasId: string;\n\n  /** Canvas ID where item ended (may equal source for same-canvas move) */\n  private targetCanvasId: string;\n\n  /** Position before drag (grid coordinates) */\n  private sourcePosition: { x: number; y: number };\n\n  /** Position after drag (grid coordinates) */\n  private targetPosition: { x: number; y: number };\n\n  /** Size before operation (grid units) - optional for resize tracking */\n  private sourceSize?: { width: number; height: number };\n\n  /** Size after operation (grid units) - optional for resize tracking */\n  private targetSize?: { width: number; height: number };\n\n  /** Mobile layout before operation - captures full mobile state including customized flag */\n  private sourceMobileLayout?: {\n    x: number | null;\n    y: number | null;\n    width: number | null;\n    height: number | null;\n    customized: boolean;\n  };\n\n  /** Mobile layout after operation - captures full mobile state including customized flag */\n  private targetMobileLayout?: {\n    x: number | null;\n    y: number | null;\n    width: number | null;\n    height: number | null;\n    customized: boolean;\n  };\n\n  /** Z-index in source canvas (for undo restoration) */\n  private sourceZIndex: number;\n\n  /**\n   * Z-index in target canvas (assigned during cross-canvas move)\n   *\n   * **Cross-canvas behavior**:\n   * - Same canvas move: sourceZIndex === targetZIndex (no change)\n   * - Cross-canvas move: targetZIndex = targetCanvas.zIndexCounter++ (new z-index)\n   *\n   * **Why needed**:\n   * - Prevents z-index conflicts between canvases\n   * - Each canvas has independent z-index space\n   * - Undo must restore original z-index in source canvas\n   */\n  private targetZIndex: number;\n\n  /** Original array index in source canvas (for undo restoration) */\n  private sourceIndex: number;\n\n  /** GridState instance for multi-instance support */\n  private stateInstance: any;\n\n  /** Active viewport during operation ('desktop' | 'mobile') - determines which layout to restore on undo/redo */\n  private activeViewport: 'desktop' | 'mobile';\n\n  /**\n   * Capture item move operation\n   *\n   * **Important**: Item should already be at target position\n   *\n   * **Shallow position clone**: Prevents mutation of passed objects\n   *\n   * **No item clone**: Uses reference-based approach (item ID tracking)\n   *\n   * **Resize support**: Optional size parameters track width/height changes\n   *\n   * **Z-index handling**:\n   * - Same canvas: sourceZIndex === targetZIndex (no change)\n   * - Cross-canvas: targetZIndex assigned from targetCanvas.zIndexCounter++\n   *\n   * **Instance-based architecture**:\n   * - Requires stateInstance parameter for multi-instance support\n   *\n   * **Viewport isolation**:\n   * - activeViewport parameter determines which layout (desktop/mobile) to restore on undo/redo\n   * - Only the specified viewport's layout is modified, the other viewport remains untouched\n   * @param itemId - ID of moved item\n   * @param sourceCanvasId - Canvas where item started\n   * @param targetCanvasId - Canvas where item ended\n   * @param sourcePosition - Position before drag (will be shallow cloned)\n   * @param targetPosition - Position after drag (will be shallow cloned)\n   * @param sourceIndex - Original array index in source canvas\n   * @param sourceZIndex - Z-index in source canvas (for undo restoration)\n   * @param targetZIndex - Z-index in target canvas (assigned during move)\n   * @param sourceSize - Optional: Size before operation (for resize tracking)\n   * @param targetSize - Optional: Size after operation (for resize tracking)\n   * @param stateInstance - GridState instance\n   * @param activeViewport - Which viewport was active during operation ('desktop' | 'mobile')\n   * @param sourceMobileLayout - Optional: Mobile layout before operation (for complete state tracking)\n   * @param targetMobileLayout - Optional: Mobile layout after operation (for complete state tracking)\n   */\n  constructor(\n    itemId: string,\n    sourceCanvasId: string,\n    targetCanvasId: string,\n    sourcePosition: { x: number; y: number },\n    targetPosition: { x: number; y: number },\n    sourceIndex: number,\n    sourceZIndex: number,\n    targetZIndex: number,\n    sourceSize: { width: number; height: number } | undefined,\n    targetSize: { width: number; height: number } | undefined,\n    stateInstance: any,\n    activeViewport: 'desktop' | 'mobile',\n    sourceMobileLayout?: {\n      x: number | null;\n      y: number | null;\n      width: number | null;\n      height: number | null;\n      customized: boolean;\n    },\n    targetMobileLayout?: {\n      x: number | null;\n      y: number | null;\n      width: number | null;\n      height: number | null;\n      customized: boolean;\n    },\n  ) {\n    this.itemId = itemId;\n    this.sourceCanvasId = sourceCanvasId;\n    this.targetCanvasId = targetCanvasId;\n    this.sourcePosition = { ...sourcePosition };\n    this.targetPosition = { ...targetPosition };\n    this.sourceIndex = sourceIndex;\n    this.sourceZIndex = sourceZIndex;\n    this.targetZIndex = targetZIndex;\n    this.sourceSize = sourceSize ? { ...sourceSize } : undefined;\n    this.targetSize = targetSize ? { ...targetSize } : undefined;\n    this.stateInstance = stateInstance;\n    this.activeViewport = activeViewport;\n    this.sourceMobileLayout = sourceMobileLayout\n      ? { ...sourceMobileLayout }\n      : undefined;\n    this.targetMobileLayout = targetMobileLayout\n      ? { ...targetMobileLayout }\n      : undefined;\n  }\n\n  /**\n   * Undo: Move item back to source canvas at original position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from target canvas\n   * - Updates canvasId back to source\n   * - Restores source position\n   * - Inserts at original index in source\n   *\n   * **Index preservation**: Uses splice to restore exact array position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive)\n   *\n   * **Side effects**:\n   * - Item removed from target canvas\n   * - Item added to source canvas at original index\n   * - Item position updated to sourcePosition\n   * - Item canvasId updated to sourceCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  undo(): void {\n    debug.log(\"üîô MoveItemCommand.undo()\", {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in target canvas first\n    let targetCanvas = this.stateInstance.canvases[this.targetCanvasId];\n    let item = targetCanvas?.items.find((i) => i.id === this.itemId);\n\n    // If target canvas doesn't exist or item not found there, search all canvases\n    // This handles the case where the target canvas was deleted\n    if (!item) {\n      for (const canvasId in this.stateInstance.canvases) {\n        const canvas = this.stateInstance.canvases[canvasId];\n        item = canvas.items.find((i) => i.id === this.itemId);\n        if (item) {\n          targetCanvas = canvas;\n          break;\n        }\n      }\n    }\n\n    if (!item || !targetCanvas) {\n      console.warn(\"  ‚ùå Item or canvas not found, aborting undo\");\n      return;\n    }\n\n    debug.log(\"  üìç Found item, current position:\", {\n      viewport: this.activeViewport,\n      x: item.layouts[this.activeViewport].x,\n      y: item.layouts[this.activeViewport].y,\n    });\n\n    // Remove from current canvas (wherever it is)\n    targetCanvas.items = targetCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's canvasId and z-index back to source\n    item.canvasId = this.sourceCanvasId;\n    item.zIndex = this.sourceZIndex;\n\n    // Restore position for the active viewport only (viewport isolation)\n    item.layouts[this.activeViewport].x = this.sourcePosition.x;\n    item.layouts[this.activeViewport].y = this.sourcePosition.y;\n\n    debug.log(\"  ‚úÖ Updated item position and z-index to:\", {\n      viewport: this.activeViewport,\n      x: item.layouts[this.activeViewport].x,\n      y: item.layouts[this.activeViewport].y,\n      zIndex: item.zIndex,\n    });\n\n    // Restore size for the active viewport only (for resize operations)\n    if (this.sourceSize) {\n      item.layouts[this.activeViewport].width = this.sourceSize.width;\n      item.layouts[this.activeViewport].height = this.sourceSize.height;\n    }\n\n    // Restore full mobile layout ONLY if we're undoing a desktop operation\n    // (Mobile operations already restored mobile via activeViewport logic above)\n    if (this.activeViewport === 'desktop' && this.sourceMobileLayout) {\n      item.layouts.mobile = { ...this.sourceMobileLayout };\n    }\n\n    // Add back to source canvas at original index\n    const sourceCanvas = this.stateInstance.canvases[this.sourceCanvasId];\n    if (!sourceCanvas) {\n      console.warn(\"  ‚ùå Source canvas not found, aborting undo\");\n      return;\n    }\n\n    if (\n      this.sourceIndex >= 0 &&\n      this.sourceIndex <= sourceCanvas.items.length\n    ) {\n      sourceCanvas.items.splice(this.sourceIndex, 0, item);\n    } else {\n      sourceCanvas.items.push(item);\n    }\n\n    // Trigger state update\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log(\"  üé® Clearing inline transform style\");\n      element.style.transform = \"\";\n    }\n\n    debug.log(\"  ‚úÖ Undo complete\");\n  }\n\n  /**\n   * Redo: Move item to target canvas at final position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from source canvas\n   * - Updates canvasId to target\n   * - Restores target position\n   * - Appends to target canvas (no index preservation for redo)\n   *\n   * **No index preservation for redo**: Appends to end of target array\n   * (undo needs original index, redo doesn't)\n   *\n   * **Side effects**:\n   * - Item removed from source canvas\n   * - Item added to end of target canvas\n   * - Item position updated to targetPosition\n   * - Item canvasId updated to targetCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  redo(): void {\n    debug.log(\"üîú MoveItemCommand.redo()\", {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in source canvas\n    const sourceCanvas = this.stateInstance.canvases[this.sourceCanvasId];\n    const item = sourceCanvas?.items.find((i) => i.id === this.itemId);\n    if (!item) {\n      console.warn(\"  ‚ùå Item not found, aborting redo\");\n      return;\n    }\n\n    debug.log(\"  üìç Found item, current position:\", {\n      viewport: this.activeViewport,\n      x: item.layouts[this.activeViewport].x,\n      y: item.layouts[this.activeViewport].y,\n    });\n\n    // Remove from source canvas\n    sourceCanvas.items = sourceCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's canvasId and z-index to target\n    item.canvasId = this.targetCanvasId;\n    item.zIndex = this.targetZIndex;\n\n    // Restore position for the active viewport only (viewport isolation)\n    item.layouts[this.activeViewport].x = this.targetPosition.x;\n    item.layouts[this.activeViewport].y = this.targetPosition.y;\n\n    debug.log(\"  ‚úÖ Updated item position and z-index to:\", {\n      viewport: this.activeViewport,\n      x: item.layouts[this.activeViewport].x,\n      y: item.layouts[this.activeViewport].y,\n      zIndex: item.zIndex,\n    });\n\n    // Restore size for the active viewport only (for resize operations)\n    if (this.targetSize) {\n      item.layouts[this.activeViewport].width = this.targetSize.width;\n      item.layouts[this.activeViewport].height = this.targetSize.height;\n    }\n\n    // Restore full mobile layout ONLY if we're redoing a desktop operation\n    // (Mobile operations already restored mobile via activeViewport logic above)\n    if (this.activeViewport === 'desktop' && this.targetMobileLayout) {\n      item.layouts.mobile = { ...this.targetMobileLayout };\n    }\n\n    // Add to target canvas\n    const targetCanvas = this.stateInstance.canvases[this.targetCanvasId];\n    if (!targetCanvas) {\n      console.warn(\"  ‚ùå Target canvas not found, aborting redo\");\n      return;\n    }\n\n    targetCanvas.items.push(item);\n\n    // Trigger state update\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log(\"  üé® Clearing inline transform style\");\n      element.style.transform = \"\";\n    }\n\n    debug.log(\"  ‚úÖ Redo complete\");\n  }\n\n  /**\n   * Get description of this command\n   *\n   * **Detects resize vs move**: Returns different action based on whether size changed\n   *\n   * @returns Object with action type, source/target positions and sizes\n   */\n  getDescription() {\n    // Check if this is a resize operation (size changed)\n    const isResize =\n      this.sourceSize &&\n      this.targetSize &&\n      (this.sourceSize.width !== this.targetSize.width ||\n        this.sourceSize.height !== this.targetSize.height);\n\n    return {\n      action: isResize ? 'resize' : 'move',\n      source: {\n        position: this.sourcePosition,\n        size: this.sourceSize,\n      },\n      target: {\n        position: this.targetPosition,\n        size: this.targetSize,\n      },\n    };\n  }\n}\n\n/**\n * UpdateItemCommand - Update item properties\n *\n * Records old item state and applies updates\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n */\nexport class UpdateItemCommand implements Command {\n  private stateInstance: any;\n\n  constructor(\n    private canvasId: string,\n    private itemId: string,\n    private oldItem: GridItem,\n    private updates: Partial<GridItem>,\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n  }\n\n  undo(): void {\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    const item = canvas?.items.find((i) => i.id === this.itemId);\n    if (item) {\n      Object.assign(item, this.oldItem);\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n    }\n  }\n\n  redo(): void {\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    const item = canvas?.items.find((i) => i.id === this.itemId);\n    if (item) {\n      Object.assign(item, this.updates);\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n    }\n  }\n\n  getDescription() {\n    return {\n      action: 'update',\n      itemId: this.itemId,\n      updates: this.updates,\n    };\n  }\n}\n\n/**\n * RemoveItemCommand - Remove item from canvas\n *\n * Stores removed item for restoration\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n */\nexport class RemoveItemCommand implements Command {\n  private stateInstance: any;\n\n  constructor(\n    private canvasId: string,\n    private item: GridItem,\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n  }\n\n  undo(): void {\n    const canvas = this.stateInstance.canvases[this.canvasId];\n    if (canvas) {\n      canvas.items.push(this.item);\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n    }\n  }\n\n  redo(): void {\n    removeItemFromCanvas(this.canvasId, this.item.id, this.stateInstance);\n  }\n\n  getDescription() {\n    const { x, y, width, height } = this.item.layouts.desktop;\n    return {\n      action: 'remove',\n      type: this.item.type,\n      position: { x, y },\n      size: { width, height },\n    };\n  }\n}\n\n/**\n * SetViewportCommand - Change current viewport\n *\n * Stores old and new viewport states\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n */\nexport class SetViewportCommand implements Command {\n  private stateInstance: any;\n\n  constructor(\n    private oldViewport: \"desktop\" | \"mobile\",\n    private newViewport: \"desktop\" | \"mobile\",\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n  }\n\n  undo(): void {\n    this.stateInstance.currentViewport = this.oldViewport;\n  }\n\n  redo(): void {\n    this.stateInstance.currentViewport = this.newViewport;\n  }\n\n  getDescription() {\n    return {\n      action: 'setViewport',\n      oldViewport: this.oldViewport,\n      newViewport: this.newViewport,\n    };\n  }\n}\n\n/**\n * ToggleGridCommand - Toggle grid visibility\n *\n * Stores old and new visibility states\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n */\nexport class ToggleGridCommand implements Command {\n  private stateInstance: any;\n\n  constructor(\n    private oldValue: boolean,\n    private newValue: boolean,\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n  }\n\n  undo(): void {\n    this.stateInstance.showGrid = this.oldValue;\n  }\n\n  redo(): void {\n    this.stateInstance.showGrid = this.newValue;\n  }\n\n  getDescription() {\n    return {\n      action: 'toggleGrid',\n      oldValue: this.oldValue,\n      newValue: this.newValue,\n    };\n  }\n}\n\n/**\n * BatchAddCommand - Add multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n * Reduces undo stack size and provides atomic undo/redo for batch operations.\n *\n * **Use cases**:\n * - Stress test (add 100+ items at once)\n * - Template application (add multiple pre-configured items)\n * - Undo batch delete operation\n * - Import from file (restore multiple items)\n *\n * **Undo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Re-adds all items with original IDs and properties\n * - Maintains z-index and positioning\n * - Single state update, single re-render\n */\nexport class BatchAddCommand implements Command {\n  private itemsData: GridItem[];\n  private stateInstance: any;\n\n  constructor(itemIds: string[], stateInstance: any) {\n    this.stateInstance = stateInstance;\n    // Store full item data for redo (deep clone to prevent mutations)\n    this.itemsData = itemIds\n      .map((id) => {\n        const item = Object.values(this.stateInstance.canvases)\n          .flatMap((canvas: any) => canvas.items)\n          .find((i: any) => i.id === id);\n        return item ? JSON.parse(JSON.stringify(item)) : null;\n      })\n      .filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n\n    // Manual delete logic for instance-based state\n    const updatedCanvases = { ...this.stateInstance.canvases };\n    for (const canvasId in updatedCanvases) {\n      const canvas = updatedCanvases[canvasId];\n      canvas.items = canvas.items.filter((item) => !itemIds.includes(item.id));\n    }\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Re-add all items (addItemsBatch will generate new IDs, so we need custom logic)\n    const updatedCanvases = { ...this.stateInstance.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  getDescription() {\n    return {\n      action: 'batchAdd',\n      itemCount: this.itemsData.length,\n      items: this.itemsData.map((item) => ({\n        id: item.id,\n        type: item.type,\n        position: { x: item.layouts.desktop.x, y: item.layouts.desktop.y },\n        size: {\n          width: item.layouts.desktop.width,\n          height: item.layouts.desktop.height,\n        },\n      })),\n    };\n  }\n}\n\n/**\n * BatchDeleteCommand - Delete multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n *\n * **Use cases**:\n * - Clear canvas (delete all items)\n * - Delete selection group\n * - Undo batch add operation\n * - Bulk cleanup operations\n *\n * **Undo behavior**:\n * - Re-adds all items with original properties and positions\n * - Maintains z-index and canvas placement\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchDeleteCommand implements Command {\n  private itemsData: GridItem[];\n  private stateInstance: any;\n\n  constructor(itemIds: string[], stateInstance: any) {\n    this.stateInstance = stateInstance;\n    // Store full item data for undo (deep clone to prevent mutations)\n    this.itemsData = itemIds\n      .map((id) => {\n        const item = Object.values(this.stateInstance.canvases)\n          .flatMap((canvas: any) => canvas.items)\n          .find((i: any) => i.id === id);\n        return item ? JSON.parse(JSON.stringify(item)) : null;\n      })\n      .filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Re-add all items (same logic as BatchAddCommand.redo)\n    const updatedCanvases = { ...this.stateInstance.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n\n    // Manual delete logic for instance-based state\n    const updatedCanvases = { ...this.stateInstance.canvases };\n    for (const canvasId in updatedCanvases) {\n      const canvas = updatedCanvases[canvasId];\n      canvas.items = canvas.items.filter((item) => !itemIds.includes(item.id));\n    }\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  getDescription() {\n    return {\n      action: 'batchDelete',\n      itemCount: this.itemsData.length,\n      items: this.itemsData.map((item) => ({\n        id: item.id,\n        type: item.type,\n        position: { x: item.layouts.desktop.x, y: item.layouts.desktop.y },\n        size: {\n          width: item.layouts.desktop.width,\n          height: item.layouts.desktop.height,\n        },\n      })),\n    };\n  }\n}\n\n/**\n * BatchUpdateConfigCommand - Update multiple item configs in a single batch\n *\n * **Performance benefit**: 1 undo/redo command for N config updates instead of N commands.\n *\n * **Use cases**:\n * - Theme changes (update colors for all headers)\n * - Bulk property changes (set all text sizes to 16px)\n * - Template application (apply preset configs)\n * - Undo/redo bulk config changes\n *\n * **Undo behavior**:\n * - Restores all old configs in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Applies all new configs in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchUpdateConfigCommand implements Command {\n  private updates: {\n    itemId: string;\n    canvasId: string;\n    oldItem: GridItem;\n    newItem: GridItem;\n  }[];\n  private stateInstance: any;\n\n  constructor(\n    updates: {\n      itemId: string;\n      canvasId: string;\n      updates: Partial<GridItem>;\n    }[],\n    stateInstance: any,\n  ) {\n    this.stateInstance = stateInstance;\n    // Store old and new state for each item (deep clone to prevent mutations)\n    this.updates = updates\n      .map(({ itemId, canvasId, updates: itemUpdates }) => {\n        const canvas = this.stateInstance.canvases[canvasId];\n        const item = canvas?.items.find((i) => i.id === itemId);\n\n        if (!item) {\n          return null;\n        }\n\n        return {\n          itemId,\n          canvasId,\n          oldItem: JSON.parse(JSON.stringify(item)),\n          newItem: JSON.parse(JSON.stringify({ ...item, ...itemUpdates })),\n        };\n      })\n      .filter(Boolean) as {\n      itemId: string;\n      canvasId: string;\n      oldItem: GridItem;\n      newItem: GridItem;\n    }[];\n  }\n\n  undo(): void {\n    // Restore old configs\n    const updatedCanvases = { ...this.stateInstance.canvases };\n    this.updates.forEach(({ itemId, canvasId, oldItem }) => {\n      const canvas = updatedCanvases[canvasId];\n      const item = canvas?.items.find((i) => i.id === itemId);\n      if (item) {\n        Object.assign(item, oldItem);\n      }\n    });\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Apply new configs\n    const updatedCanvases = { ...this.stateInstance.canvases };\n    this.updates.forEach(({ itemId, canvasId, newItem }) => {\n      const canvas = updatedCanvases[canvasId];\n      const item = canvas?.items.find((i) => i.id === itemId);\n      if (item) {\n        Object.assign(item, newItem);\n      }\n    });\n    this.stateInstance.canvases = updatedCanvases;\n  }\n\n  getDescription() {\n    return {\n      action: 'batchUpdateConfig',\n      updateCount: this.updates.length,\n      updates: this.updates.map(({ itemId, canvasId, oldItem, newItem }) => ({\n        itemId,\n        canvasId,\n        oldConfig: oldItem.config,\n        newConfig: newItem.config,\n      })),\n    };\n  }\n}\n\n/**\n * AddCanvasCommand\n * =================\n *\n * Undoable command for adding a canvas to the grid.\n *\n * **Pattern**: Host app owns canvas metadata, library manages item placement\n *\n * **Library responsibility** (what this command does):\n * - Create canvas in gridState.canvases with empty items array\n * - Initialize zIndexCounter for item stacking\n * - Track operation in undo/redo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or other metadata\n * - Host app maintains its own canvas metadata separately\n * - Host app listens to canvasAdded event to sync its state\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app maintains canvas metadata\n * const canvasMetadata = {\n * 'section-1': { title: 'Hero Section', backgroundColor: '#f0f4f8' }\n * };\n *\n * // Create canvas in library (just placement state)\n * const cmd = new AddCanvasCommand('section-1');\n * pushCommand(cmd); // Add to undo/redo stack\n * cmd.redo(); // Creates canvas with items: [], zIndexCounter: 1\n *\n * // Host app listens to event and syncs its own state\n * api.on('canvasAdded', (event) => {\n * // Host app can now add its own metadata\n * });\n * ```\n *\n * **Why this separation**:\n * - Library focuses on layout (items, positions, z-index)\n * - Host app owns presentation (styling, titles, metadata)\n * - Different apps can use library with different data models\n */\nexport class AddCanvasCommand implements Command {\n  description = \"Add Canvas\";\n  private canvasId: string;\n  private stateInstance: any; // GridState instance\n  private eventManagerInstance: any; // EventManager instance\n\n  constructor(canvasId: string, stateInstance: any, eventManagerInstance: any) {\n    this.canvasId = canvasId;\n    this.stateInstance = stateInstance;\n    this.eventManagerInstance = eventManagerInstance;\n  }\n\n  undo(): void {\n    debug.log(\"üîô AddCanvasCommand.undo() - removing canvas:\", this.canvasId);\n\n    // Remove canvas from instance state\n    delete this.stateInstance.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    debug.log(\"  üì¢ Emitting canvasRemoved event for:\", this.canvasId);\n    this.eventManagerInstance.emit(\"canvasRemoved\", {\n      canvasId: this.canvasId,\n    });\n  }\n\n  redo(): void {\n    // Add canvas to instance state (minimal - just item placement management)\n    this.stateInstance.canvases[this.canvasId] = {\n      zIndexCounter: 1,\n      items: [],\n    };\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    this.eventManagerInstance.emit(\"canvasAdded\", { canvasId: this.canvasId });\n  }\n\n  getDescription() {\n    return {\n      action: 'addCanvas',\n      canvasId: this.canvasId,\n    };\n  }\n}\n\n/**\n * RemoveCanvasCommand\n * ====================\n *\n * Undoable command for removing a canvas from the grid.\n *\n * **Critical**: Snapshots canvas items and zIndexCounter before removal\n *\n * **Library responsibility** (what this command does):\n * - Snapshot canvas items array and zIndexCounter\n * - Remove canvas from gridState.canvases\n * - Restore canvas with all items on undo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or metadata\n * - Host app must listen to canvasRemoved event\n * - Host app must manage its own metadata undo/redo separately\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app listens to events and manages its own metadata\n * api.on('canvasRemoved', (event) => {\n * // Host app removes its own metadata\n * delete canvasMetadata[event.canvasId];\n * });\n *\n * api.on('canvasAdded', (event) => {\n * // On undo of remove, host app restores metadata\n * if (wasUndoOperation) {\n * canvasMetadata[event.canvasId] = savedMetadata;\n * }\n * });\n *\n * // Remove canvas\n * const cmd = new RemoveCanvasCommand('section-1');\n * pushCommand(cmd);\n * cmd.redo(); // Removes canvas from library\n * ```\n *\n * **Edge case handling**:\n * - Canvas doesn't exist: command becomes no-op\n * - Canvas has items: all items removed with canvas\n * - Undo restores items with original layouts and zIndex\n */\nexport class RemoveCanvasCommand implements Command {\n  description = \"Remove Canvas\";\n  private canvasId: string;\n  private stateInstance: any; // GridState instance\n  private eventManagerInstance: any; // EventManager instance\n  private canvasSnapshot: {\n    zIndexCounter: number;\n    items: GridItem[];\n  } | null = null;\n\n  constructor(canvasId: string, stateInstance: any, eventManagerInstance: any) {\n    this.canvasId = canvasId;\n    this.stateInstance = stateInstance;\n    this.eventManagerInstance = eventManagerInstance;\n\n    // Snapshot canvas state (deep clone to prevent mutations)\n    const canvas = this.stateInstance.canvases[canvasId];\n    if (canvas) {\n      this.canvasSnapshot = JSON.parse(JSON.stringify(canvas));\n    }\n  }\n\n  undo(): void {\n    // Restore canvas from snapshot (just layout state, no metadata)\n    if (this.canvasSnapshot) {\n      this.stateInstance.canvases[this.canvasId] = JSON.parse(\n        JSON.stringify(this.canvasSnapshot),\n      );\n\n      // Trigger state change for reactivity\n      this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n      // Emit event so host app can sync its metadata\n      this.eventManagerInstance.emit(\"canvasAdded\", {\n        canvasId: this.canvasId,\n      });\n    }\n  }\n\n  redo(): void {\n    // Remove canvas from instance state\n    delete this.stateInstance.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit event so host app can sync its metadata\n    this.eventManagerInstance.emit(\"canvasRemoved\", {\n      canvasId: this.canvasId,\n    });\n  }\n\n  getDescription() {\n    return {\n      action: 'removeCanvas',\n      canvasId: this.canvasId,\n      itemCount: this.canvasSnapshot?.items.length || 0,\n    };\n  }\n}\n\n/**\n * Change Z-Index Command\n * ======================\n *\n * Handles undo/redo for z-index changes (layer reordering).\n * Supports both single-item changes and multi-item swaps.\n *\n * **Use cases**:\n * - Layer panel drag-to-reorder (swap with other item)\n * - Bring to front / send to back (single item)\n * - Move forward / move backward (swap with adjacent item)\n * - Direct z-index assignment (single item)\n *\n * **What it captures**:\n * - Array of z-index changes (supports cascading/swap operations)\n * - Each change: { itemId, canvasId, oldZIndex, newZIndex }\n *\n * **Why array-based**:\n * - Move forward/backward swaps z-index with adjacent item (2 items affected)\n * - Drag-to-reorder can shuffle multiple items\n * - Undo must atomically restore all affected items\n *\n * **Operation**:\n * - Updates all items' zIndex properties in single undo/redo operation\n * - Maintains canvas zIndexCounter\n * - Triggers reactivity once for UI updates\n * - Emits events for layer panel to update\n *\n * **Instance-based architecture**:\n * - Requires stateInstance parameter for multi-instance support\n * - Operates on instance state\n *\n * **Example usage**:\n * ```typescript\n * // Instance-based (multi-grid support)\n * const cmd = new ChangeZIndexCommand(\n *   changes,\n *   eventManager,\n *   stateInstance\n * );\n * ```\n *\n * **Edge case handling**:\n * - Item doesn't exist: skips that item (doesn't fail entire command)\n * - Canvas doesn't exist: skips that item\n * - Undo restores exact z-index values for all items\n * - Maintains visual layer order across all affected items\n */\nexport class ChangeZIndexCommand implements Command {\n  description: string;\n  private changes: {\n    itemId: string;\n    canvasId: string;\n    oldZIndex: number;\n    newZIndex: number;\n  }[];\n  private eventManager: EventManager;\n  private stateInstance: any; // GridState instance\n\n  constructor(\n    changes: {\n      itemId: string;\n      canvasId: string;\n      oldZIndex: number;\n      newZIndex: number;\n    }[],\n    eventManager: EventManager,\n    stateInstance: any,\n  ) {\n    this.changes = changes;\n    this.eventManager = eventManager;\n    this.stateInstance = stateInstance;\n\n    // Descriptive message for command history\n    if (changes.length === 1) {\n      const change = changes[0];\n      this.description = `Change Z-Index (${change.oldZIndex} ‚Üí ${change.newZIndex})`;\n    } else {\n      this.description = `Reorder ${changes.length} Layers`;\n    }\n  }\n\n  undo(): void {\n    // Restore old z-index for all affected items\n    this.changes.forEach((change) => {\n      const canvas = this.stateInstance.canvases[change.canvasId];\n      const item = canvas?.items.find((i) => i.id === change.itemId);\n      if (item) {\n        item.zIndex = change.oldZIndex;\n        debug.log(\n          `Undo z-index change: ${change.itemId} from ${change.newZIndex} to ${change.oldZIndex}`,\n        );\n      }\n    });\n\n    // Trigger reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit single event (batch or individual based on change count)\n    if (this.changes.length === 1) {\n      const change = this.changes[0];\n      this.eventManager.emit(\"zIndexChanged\", {\n        itemId: change.itemId,\n        canvasId: change.canvasId,\n        oldZIndex: change.newZIndex, // Swapped for undo\n        newZIndex: change.oldZIndex,\n      });\n    } else {\n      // Emit batch event for atomic update\n      this.eventManager.emit(\"zIndexBatchChanged\", {\n        changes: this.changes.map((change) => ({\n          itemId: change.itemId,\n          canvasId: change.canvasId,\n          oldZIndex: change.newZIndex, // Swapped for undo\n          newZIndex: change.oldZIndex,\n        })),\n      });\n    }\n  }\n\n  redo(): void {\n    // Reapply new z-index for all affected items\n    this.changes.forEach((change) => {\n      const canvas = this.stateInstance.canvases[change.canvasId];\n      const item = canvas?.items.find((i) => i.id === change.itemId);\n      if (item) {\n        item.zIndex = change.newZIndex;\n        debug.log(\n          `Redo z-index change: ${change.itemId} from ${change.oldZIndex} to ${change.newZIndex}`,\n        );\n      }\n    });\n\n    // Trigger reactivity\n    this.stateInstance.canvases = { ...this.stateInstance.canvases };\n\n    // Emit single event (batch or individual based on change count)\n    if (this.changes.length === 1) {\n      const change = this.changes[0];\n      this.eventManager.emit(\"zIndexChanged\", {\n        itemId: change.itemId,\n        canvasId: change.canvasId,\n        oldZIndex: change.oldZIndex,\n        newZIndex: change.newZIndex,\n      });\n    } else {\n      // Emit batch event for atomic update\n      this.eventManager.emit(\"zIndexBatchChanged\", {\n        changes: this.changes.map((change) => ({\n          itemId: change.itemId,\n          canvasId: change.canvasId,\n          oldZIndex: change.oldZIndex,\n          newZIndex: change.newZIndex,\n        })),\n      });\n    }\n  }\n\n  getDescription() {\n    return {\n      action: 'changeZIndex',\n      changeCount: this.changes.length,\n      changes: this.changes.map((change) => ({\n        itemId: change.itemId,\n        canvasId: change.canvasId,\n        oldZIndex: change.oldZIndex,\n        newZIndex: change.newZIndex,\n      })),\n    };\n  }\n}\n","/**\n * Boundary Constraints Utility\n * =============================\n *\n * Utilities for constraining component placement and sizing within canvas boundaries.\n * Ensures components stay fully within canvas and handles size fitting when needed.\n *\n * ## Problem\n *\n * Components can be placed or dragged such that they extend beyond canvas boundaries:\n * - Dropped from palette outside canvas bounds\n * - Dragged beyond edges\n * - Default size larger than canvas\n *\n * ## Solution\n *\n * Provides constraint functions that:\n * 1. Validate component can fit within canvas (respecting minSize)\n * 2. Adjust size to fit canvas if needed (respecting minSize/maxSize)\n * 3. Constrain position to keep component fully within bounds\n * @module boundary-constraints\n */\n\nimport { ComponentDefinition } from \"../types/component-definition\";\n\n/**\n * Canvas dimensions in grid units\n *\n * **Standard canvas size**:\n * - Width: 50 units (100% width, 2% per unit)\n * - Height: Unlimited (grows with content)\n */\nexport const CANVAS_WIDTH_UNITS = 50;\n\n/**\n * Component size after constraint validation\n */\nexport interface ConstrainedSize {\n  /** Width in grid units (may be adjusted from default) */\n  width: number;\n  /** Height in grid units (may be adjusted from default) */\n  height: number;\n  /** Whether size was adjusted to fit */\n  wasAdjusted: boolean;\n}\n\n/**\n * Component position and size after boundary constraints\n */\nexport interface ConstrainedPlacement {\n  /** X position in grid units */\n  x: number;\n  /** Y position in grid units */\n  y: number;\n  /** Width in grid units */\n  width: number;\n  /** Height in grid units */\n  height: number;\n  /** Whether position was adjusted */\n  positionAdjusted: boolean;\n  /** Whether size was adjusted */\n  sizeAdjusted: boolean;\n}\n\n/**\n * Validate if component can fit within canvas\n *\n * Checks if component's minimum size is smaller than or equal to canvas size.\n * If component's minSize > canvas size, placement should be rejected.\n * @param definition - Component definition with min/max size constraints\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns true if component can fit, false if too large\n * @example\n * ```typescript\n * const hugeComponent = {\n *   type: 'huge-widget',\n *   minSize: { width: 60, height: 10 } // 60 > 50 canvas width\n * };\n *\n * if (!canComponentFitCanvas(hugeComponent)) {\n *   console.warn('Component too large for canvas');\n *   return; // Don't allow placement\n * }\n * ```\n */\nexport function canComponentFitCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): boolean {\n  // Get minimum size (or use default minimums if not specified)\n  const minWidth = definition.minSize?.width || 0;\n\n  // Check if minimum size fits within canvas\n  // Height is unlimited, so only check width\n  return minWidth <= canvasWidth;\n}\n\n/**\n * Constrain component size to fit within canvas\n *\n * Adjusts component size if default size exceeds canvas bounds,\n * while respecting min/max size constraints.\n *\n * **Size adjustment rules**:\n * 1. If defaultSize fits, use it\n * 2. If defaultSize > canvas, shrink to canvas size\n * 3. Never shrink below minSize\n * 4. Never grow beyond maxSize\n *\n * **Width constraint**: Canvas width (50 units)\n * **Height constraint**: None (canvas height grows with content)\n * @param definition - Component definition\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained size and adjustment flag\n * @example\n * ```typescript\n * const wideComponent = {\n *   type: 'banner',\n *   defaultSize: { width: 60, height: 10 }, // Too wide\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const size = constrainSizeToCanvas(wideComponent);\n * // { width: 50, height: 10, wasAdjusted: true }\n * ```\n */\nexport function constrainSizeToCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedSize {\n  const defaultWidth = definition.defaultSize.width;\n  const defaultHeight = definition.defaultSize.height;\n\n  const minWidth = definition.minSize?.width || 0;\n  const maxWidth = definition.maxSize?.width || Infinity;\n\n  let width = defaultWidth;\n  let height = defaultHeight;\n  let wasAdjusted = false;\n\n  // Constrain width to canvas\n  if (width > canvasWidth) {\n    width = canvasWidth;\n    wasAdjusted = true;\n  }\n\n  // Respect minSize\n  if (width < minWidth) {\n    width = minWidth;\n  }\n\n  // Respect maxSize\n  if (width > maxWidth) {\n    width = maxWidth;\n  }\n\n  // Height is not constrained by canvas (canvas grows vertically)\n  // but still respect min/max if specified\n  const minHeight = definition.minSize?.height || 0;\n  const maxHeight = definition.maxSize?.height || Infinity;\n\n  if (height < minHeight) {\n    height = minHeight;\n  }\n  if (height > maxHeight) {\n    height = maxHeight;\n  }\n\n  return { width, height, wasAdjusted };\n}\n\n/**\n * Constrain component position to keep it fully within canvas bounds\n *\n * Adjusts position so component stays completely inside canvas.\n * Snaps to edges if component would extend beyond boundaries.\n *\n * **Boundary rules**:\n * - Left edge: x >= 0\n * - Right edge: x + width <= canvasWidth\n * - Top edge: y >= 0\n * - Bottom edge: No constraint (canvas height grows)\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param width - Component width in grid units\n * @param height - Component height in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement\n * @example\n * ```typescript\n * // Component would extend beyond right edge\n * const placement = constrainPositionToCanvas(45, 10, 20, 10);\n * // { x: 30, y: 10, width: 20, height: 10, positionAdjusted: true, sizeAdjusted: false }\n * // Adjusted from 45 to 30 so (30 + 20 = 50) stays within canvas\n * ```\n */\nexport function constrainPositionToCanvas(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedPlacement {\n  let newX = x;\n  let newY = y;\n  let positionAdjusted = false;\n\n  // Constrain left edge\n  if (newX < 0) {\n    newX = 0;\n    positionAdjusted = true;\n  }\n\n  // Constrain right edge\n  if (newX + width > canvasWidth) {\n    newX = canvasWidth - width;\n    positionAdjusted = true;\n  }\n\n  // Constrain top edge\n  if (newY < 0) {\n    newY = 0;\n    positionAdjusted = true;\n  }\n\n  // No bottom edge constraint - canvas grows vertically\n\n  // Ensure position doesn't go negative after adjustment\n  newX = Math.max(0, newX);\n  newY = Math.max(0, newY);\n\n  return {\n    x: newX,\n    y: newY,\n    width,\n    height,\n    positionAdjusted,\n    sizeAdjusted: false,\n  };\n}\n\n/**\n * Apply full boundary constraints to component placement\n *\n * Complete constraint pipeline:\n * 1. Check if component can fit (validate minSize <= canvas)\n * 2. Adjust size to fit canvas (if needed)\n * 3. Constrain position to keep within bounds\n *\n * **Returns null if component cannot fit** (minSize > canvas)\n * @param definition - Component definition\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement, or null if component too large\n * @example\n * ```typescript\n * const definition = {\n *   type: 'widget',\n *   defaultSize: { width: 60, height: 10 },\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const placement = applyBoundaryConstraints(definition, 45, 10);\n * // {\n * //   x: 0,              // Adjusted from 45 to fit\n * //   y: 10,             // No Y adjustment needed\n * //   width: 50,         // Shrunk from 60 to fit canvas\n * //   height: 10,        // No height adjustment\n * //   positionAdjusted: true,\n * //   sizeAdjusted: true\n * // }\n * ```\n */\nexport function applyBoundaryConstraints(\n  definition: ComponentDefinition,\n  x: number,\n  y: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS,\n): ConstrainedPlacement | null {\n  // 1. Validate component can fit\n  if (!canComponentFitCanvas(definition, canvasWidth)) {\n    console.warn(\n      `Component \"${definition.name}\" minSize (${definition.minSize?.width}) ` +\n        `exceeds canvas width (${canvasWidth}). Placement rejected.`,\n    );\n    return null;\n  }\n\n  // 2. Adjust size to fit canvas\n  const constrainedSize = constrainSizeToCanvas(definition, canvasWidth);\n\n  // 3. Constrain position to keep within bounds\n  const constrainedPlacement = constrainPositionToCanvas(\n    x,\n    y,\n    constrainedSize.width,\n    constrainedSize.height,\n    canvasWidth,\n  );\n\n  // Combine size and position adjustments\n  return {\n    ...constrainedPlacement,\n    sizeAdjusted: constrainedSize.wasAdjusted,\n  };\n}\n"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0JG;AAOH,MAAM,KAAK,GAAG,iBAAiB,CAAC,oBAAoB,CAAC;AAucrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4KG;MACU,eAAe,CAAA;AAkE1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCG;IACH,WACE,CAAA,MAAc,EACd,cAAsB,EACtB,cAAsB,EACtB,cAAwC,EACxC,cAAwC,EACxC,WAAmB,EACnB,YAAoB,EACpB,YAAoB,EACpB,UAAyD,EACzD,UAAyD,EACzD,aAAkB,EAClB,cAAoC,EACpC,kBAMC,EACD,kBAMC,EAAA;AAED,QAAA,IAAI,CAAC,MAAM,GAAG,MAAM;AACpB,QAAA,IAAI,CAAC,cAAc,GAAG,cAAc;AACpC,QAAA,IAAI,CAAC,cAAc,GAAG,cAAc;QACpC,IAAI,CAAC,cAAc,GAAQ,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,cAAc,CAAE;QAC3C,IAAI,CAAC,cAAc,GAAQ,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,cAAc,CAAE;AAC3C,QAAA,IAAI,CAAC,WAAW,GAAG,WAAW;AAC9B,QAAA,IAAI,CAAC,YAAY,GAAG,YAAY;AAChC,QAAA,IAAI,CAAC,YAAY,GAAG,YAAY;AAChC,QAAA,IAAI,CAAC,UAAU,GAAG,UAAU,GAAQ,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,UAAU,CAAG,GAAE,SAAS;AAC5D,QAAA,IAAI,CAAC,UAAU,GAAG,UAAU,GAAQ,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,UAAU,CAAG,GAAE,SAAS;AAC5D,QAAA,IAAI,CAAC,aAAa,GAAG,aAAa;AAClC,QAAA,IAAI,CAAC,cAAc,GAAG,cAAc;QACpC,IAAI,CAAC,kBAAkB,GAAG;AACxB,gCAAO,kBAAkB,CAAA,GACvB,SAAS;QACb,IAAI,CAAC,kBAAkB,GAAG;AACxB,gCAAO,kBAAkB,CAAA,GACvB,SAAS;;AAGf;;;;;;;;;;;;;;;;;;;;;AAqBG;IACH,IAAI,GAAA;AACF,QAAA,KAAK,CAAC,GAAG,CAAC,2BAA2B,EAAE;YACrC,MAAM,EAAE,IAAI,CAAC,MAAM;YACnB,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,cAAc,EAAE,IAAI,CAAC,cAAc;AACpC,SAAA,CAAC;;AAGF,QAAA,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC;AACnE,QAAA,IAAI,IAAI,GAAG,YAAY,KAAZ,IAAA,IAAA,YAAY,uBAAZ,YAAY,CAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,MAAM,CAAC;;;QAIhE,IAAI,CAAC,IAAI,EAAE;YACT,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE;gBAClD,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC;gBACpD,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,MAAM,CAAC;gBACrD,IAAI,IAAI,EAAE;oBACR,YAAY,GAAG,MAAM;oBACrB;;;;AAKN,QAAA,IAAI,CAAC,IAAI,IAAI,CAAC,YAAY,EAAE;AAC1B,YAAA,OAAO,CAAC,IAAI,CAAC,6CAA6C,CAAC;YAC3D;;AAGF,QAAA,KAAK,CAAC,GAAG,CAAC,oCAAoC,EAAE;YAC9C,QAAQ,EAAE,IAAI,CAAC,cAAc;YAC7B,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACtC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;AACvC,SAAA,CAAC;;QAGF,YAAY,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,MAAM,CAAC;;AAG3E,QAAA,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,cAAc;AACnC,QAAA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY;;AAG/B,QAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC;AAC3D,QAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC;AAE3D,QAAA,KAAK,CAAC,GAAG,CAAC,2CAA2C,EAAE;YACrD,QAAQ,EAAE,IAAI,CAAC,cAAc;YAC7B,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACtC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACtC,MAAM,EAAE,IAAI,CAAC,MAAM;AACpB,SAAA,CAAC;;AAGF,QAAA,IAAI,IAAI,CAAC,UAAU,EAAE;AACnB,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK;AAC/D,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM;;;;QAKnE,IAAI,IAAI,CAAC,cAAc,KAAK,SAAS,IAAI,IAAI,CAAC,kBAAkB,EAAE;AAChE,YAAA,IAAI,CAAC,OAAO,CAAC,MAAM,qBAAQ,IAAI,CAAC,kBAAkB,CAAE;;;AAItD,QAAA,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC;QACrE,IAAI,CAAC,YAAY,EAAE;AACjB,YAAA,OAAO,CAAC,IAAI,CAAC,4CAA4C,CAAC;YAC1D;;AAGF,QAAA,IACE,IAAI,CAAC,WAAW,IAAI,CAAC;YACrB,IAAI,CAAC,WAAW,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,EAC7C;AACA,YAAA,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,EAAE,IAAI,CAAC;;aAC/C;AACL,YAAA,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;;;AAI/B,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;;;QAIhE,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC;QACpD,IAAI,OAAO,EAAE;AACX,YAAA,KAAK,CAAC,GAAG,CAAC,sCAAsC,CAAC;AACjD,YAAA,OAAO,CAAC,KAAK,CAAC,SAAS,GAAG,EAAE;;AAG9B,QAAA,KAAK,CAAC,GAAG,CAAC,mBAAmB,CAAC;;AAGhC;;;;;;;;;;;;;;;;;;;;AAoBG;IACH,IAAI,GAAA;AACF,QAAA,KAAK,CAAC,GAAG,CAAC,2BAA2B,EAAE;YACrC,MAAM,EAAE,IAAI,CAAC,MAAM;YACnB,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,cAAc,EAAE,IAAI,CAAC,cAAc;AACpC,SAAA,CAAC;;AAGF,QAAA,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC;AACrE,QAAA,MAAM,IAAI,GAAG,YAAY,KAAZ,IAAA,IAAA,YAAY,uBAAZ,YAAY,CAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,MAAM,CAAC;QAClE,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,CAAC,IAAI,CAAC,mCAAmC,CAAC;YACjD;;AAGF,QAAA,KAAK,CAAC,GAAG,CAAC,oCAAoC,EAAE;YAC9C,QAAQ,EAAE,IAAI,CAAC,cAAc;YAC7B,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACtC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;AACvC,SAAA,CAAC;;QAGF,YAAY,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,MAAM,CAAC;;AAG3E,QAAA,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,cAAc;AACnC,QAAA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY;;AAG/B,QAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC;AAC3D,QAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC;AAE3D,QAAA,KAAK,CAAC,GAAG,CAAC,2CAA2C,EAAE;YACrD,QAAQ,EAAE,IAAI,CAAC,cAAc;YAC7B,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACtC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACtC,MAAM,EAAE,IAAI,CAAC,MAAM;AACpB,SAAA,CAAC;;AAGF,QAAA,IAAI,IAAI,CAAC,UAAU,EAAE;AACnB,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK;AAC/D,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM;;;;QAKnE,IAAI,IAAI,CAAC,cAAc,KAAK,SAAS,IAAI,IAAI,CAAC,kBAAkB,EAAE;AAChE,YAAA,IAAI,CAAC,OAAO,CAAC,MAAM,qBAAQ,IAAI,CAAC,kBAAkB,CAAE;;;AAItD,QAAA,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC;QACrE,IAAI,CAAC,YAAY,EAAE;AACjB,YAAA,OAAO,CAAC,IAAI,CAAC,4CAA4C,CAAC;YAC1D;;AAGF,QAAA,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;;AAG7B,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;;;QAIhE,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC;QACpD,IAAI,OAAO,EAAE;AACX,YAAA,KAAK,CAAC,GAAG,CAAC,sCAAsC,CAAC;AACjD,YAAA,OAAO,CAAC,KAAK,CAAC,SAAS,GAAG,EAAE;;AAG9B,QAAA,KAAK,CAAC,GAAG,CAAC,mBAAmB,CAAC;;AAGhC;;;;;;AAMG;IACH,cAAc,GAAA;;AAEZ,QAAA,MAAM,QAAQ,GACZ,IAAI,CAAC,UAAU;AACf,YAAA,IAAI,CAAC,UAAU;aACd,IAAI,CAAC,UAAU,CAAC,KAAK,KAAK,IAAI,CAAC,UAAU,CAAC,KAAK;gBAC9C,IAAI,CAAC,UAAU,CAAC,MAAM,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;QAEtD,OAAO;YACL,MAAM,EAAE,QAAQ,GAAG,QAAQ,GAAG,MAAM;AACpC,YAAA,MAAM,EAAE;gBACN,QAAQ,EAAE,IAAI,CAAC,cAAc;gBAC7B,IAAI,EAAE,IAAI,CAAC,UAAU;AACtB,aAAA;AACD,YAAA,MAAM,EAAE;gBACN,QAAQ,EAAE,IAAI,CAAC,cAAc;gBAC7B,IAAI,EAAE,IAAI,CAAC,UAAU;AACtB,aAAA;SACF;;AAEJ;AAoKD;;;;;;;;;;;;;;;;;;;;AAoBG;MACU,eAAe,CAAA;IAI1B,WAAY,CAAA,OAAiB,EAAE,aAAkB,EAAA;AAC/C,QAAA,IAAI,CAAC,aAAa,GAAG,aAAa;;QAElC,IAAI,CAAC,SAAS,GAAG;AACd,aAAA,GAAG,CAAC,CAAC,EAAE,KAAI;YACV,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ;iBACnD,OAAO,CAAC,CAAC,MAAW,KAAK,MAAM,CAAC,KAAK;AACrC,iBAAA,IAAI,CAAC,CAAC,CAAM,KAAK,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC;AAChC,YAAA,OAAO,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI;AACvD,SAAC;aACA,MAAM,CAAC,OAAO,CAAe;;IAGlC,IAAI,GAAA;;AAEF,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;;AAGrD,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;AAC1D,QAAA,KAAK,MAAM,QAAQ,IAAI,eAAe,EAAE;AACtC,YAAA,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAC;YACxC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;;AAE1E,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,eAAe;;IAG/C,IAAI,GAAA;;AAEF,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;AAE1D,QAAA,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,SAAS,EAAE;YACrC,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC;YACjD,IAAI,MAAM,EAAE;;gBAEV,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,QAAQ,CAAC,EAAE,CAAC;gBAC7D,IAAI,CAAC,MAAM,EAAE;AACX,oBAAA,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;;;;AAKjC,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,eAAe;;IAG/C,cAAc,GAAA;QACZ,OAAO;AACL,YAAA,MAAM,EAAE,UAAU;AAClB,YAAA,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM;AAChC,YAAA,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,MAAM;gBACnC,EAAE,EAAE,IAAI,CAAC,EAAE;gBACX,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,QAAQ,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE;AAClE,gBAAA,IAAI,EAAE;AACJ,oBAAA,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK;AACjC,oBAAA,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM;AACpC,iBAAA;AACF,aAAA,CAAC,CAAC;SACJ;;AAEJ;AAED;;;;;;;;;;;;;;;;;;;AAmBG;MACU,kBAAkB,CAAA;IAI7B,WAAY,CAAA,OAAiB,EAAE,aAAkB,EAAA;AAC/C,QAAA,IAAI,CAAC,aAAa,GAAG,aAAa;;QAElC,IAAI,CAAC,SAAS,GAAG;AACd,aAAA,GAAG,CAAC,CAAC,EAAE,KAAI;YACV,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ;iBACnD,OAAO,CAAC,CAAC,MAAW,KAAK,MAAM,CAAC,KAAK;AACrC,iBAAA,IAAI,CAAC,CAAC,CAAM,KAAK,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC;AAChC,YAAA,OAAO,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI;AACvD,SAAC;aACA,MAAM,CAAC,OAAO,CAAe;;IAGlC,IAAI,GAAA;;AAEF,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;AAE1D,QAAA,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,SAAS,EAAE;YACrC,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC;YACjD,IAAI,MAAM,EAAE;;gBAEV,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,QAAQ,CAAC,EAAE,CAAC;gBAC7D,IAAI,CAAC,MAAM,EAAE;AACX,oBAAA,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;;;;AAKjC,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,eAAe;;IAG/C,IAAI,GAAA;;AAEF,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;;AAGrD,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;AAC1D,QAAA,KAAK,MAAM,QAAQ,IAAI,eAAe,EAAE;AACtC,YAAA,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAC;YACxC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;;AAE1E,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,eAAe;;IAG/C,cAAc,GAAA;QACZ,OAAO;AACL,YAAA,MAAM,EAAE,aAAa;AACrB,YAAA,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM;AAChC,YAAA,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,MAAM;gBACnC,EAAE,EAAE,IAAI,CAAC,EAAE;gBACX,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,QAAQ,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE;AAClE,gBAAA,IAAI,EAAE;AACJ,oBAAA,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK;AACjC,oBAAA,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM;AACpC,iBAAA;AACF,aAAA,CAAC,CAAC;SACJ;;AAEJ;AAED;;;;;;;;;;;;;;;;;;AAkBG;MACU,wBAAwB,CAAA;IASnC,WACE,CAAA,OAIG,EACH,aAAkB,EAAA;AAElB,QAAA,IAAI,CAAC,aAAa,GAAG,aAAa;;QAElC,IAAI,CAAC,OAAO,GAAG;AACZ,aAAA,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,WAAW,EAAE,KAAI;YAClD,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC;AACpD,YAAA,MAAM,IAAI,GAAG,MAAM,KAAA,IAAA,IAAN,MAAM,KAAN,MAAA,GAAA,MAAA,GAAA,MAAM,CAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;YAEvD,IAAI,CAAC,IAAI,EAAE;AACT,gBAAA,OAAO,IAAI;;YAGb,OAAO;gBACL,MAAM;gBACN,QAAQ;gBACR,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBACzC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAM,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,IAAI,CAAK,EAAA,WAAW,EAAG,CAAC;aACjE;AACH,SAAC;aACA,MAAM,CAAC,OAAO,CAKd;;IAGL,IAAI,GAAA;;AAEF,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;AAC1D,QAAA,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAI;AACrD,YAAA,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAC;AACxC,YAAA,MAAM,IAAI,GAAG,MAAM,KAAA,IAAA,IAAN,MAAM,KAAN,MAAA,GAAA,MAAA,GAAA,MAAM,CAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;YACvD,IAAI,IAAI,EAAE;AACR,gBAAA,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC;;AAEhC,SAAC,CAAC;AACF,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,eAAe;;IAG/C,IAAI,GAAA;;AAEF,QAAA,MAAM,eAAe,qBAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;AAC1D,QAAA,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAI;AACrD,YAAA,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAC;AACxC,YAAA,MAAM,IAAI,GAAG,MAAM,KAAA,IAAA,IAAN,MAAM,KAAN,MAAA,GAAA,MAAA,GAAA,MAAM,CAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC;YACvD,IAAI,IAAI,EAAE;AACR,gBAAA,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC;;AAEhC,SAAC,CAAC;AACF,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,eAAe;;IAG/C,cAAc,GAAA;QACZ,OAAO;AACL,YAAA,MAAM,EAAE,mBAAmB;AAC3B,YAAA,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM;YAChC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM;gBACrE,MAAM;gBACN,QAAQ;gBACR,SAAS,EAAE,OAAO,CAAC,MAAM;gBACzB,SAAS,EAAE,OAAO,CAAC,MAAM;AAC1B,aAAA,CAAC,CAAC;SACJ;;AAEJ;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCG;MACU,gBAAgB,CAAA;AAM3B,IAAA,WAAA,CAAY,QAAgB,EAAE,aAAkB,EAAE,oBAAyB,EAAA;AAL3E,QAAA,IAAW,CAAA,WAAA,GAAG,YAAY;AAMxB,QAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ;AACxB,QAAA,IAAI,CAAC,aAAa,GAAG,aAAa;AAClC,QAAA,IAAI,CAAC,oBAAoB,GAAG,oBAAoB;;IAGlD,IAAI,GAAA;QACF,KAAK,CAAC,GAAG,CAAC,+CAA+C,EAAE,IAAI,CAAC,QAAQ,CAAC;;QAGzE,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;;AAGjD,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;;QAGhE,KAAK,CAAC,GAAG,CAAC,wCAAwC,EAAE,IAAI,CAAC,QAAQ,CAAC;AAClE,QAAA,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,EAAE;YAC9C,QAAQ,EAAE,IAAI,CAAC,QAAQ;AACxB,SAAA,CAAC;;IAGJ,IAAI,GAAA;;QAEF,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG;AAC3C,YAAA,aAAa,EAAE,CAAC;AAChB,YAAA,KAAK,EAAE,EAAE;SACV;;AAGD,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;;AAGhE,QAAA,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC;;IAG5E,cAAc,GAAA;QACZ,OAAO;AACL,YAAA,MAAM,EAAE,WAAW;YACnB,QAAQ,EAAE,IAAI,CAAC,QAAQ;SACxB;;AAEJ;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CG;MACU,mBAAmB,CAAA;AAU9B,IAAA,WAAA,CAAY,QAAgB,EAAE,aAAkB,EAAE,oBAAyB,EAAA;AAT3E,QAAA,IAAW,CAAA,WAAA,GAAG,eAAe;AAIrB,QAAA,IAAc,CAAA,cAAA,GAGX,IAAI;AAGb,QAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ;AACxB,QAAA,IAAI,CAAC,aAAa,GAAG,aAAa;AAClC,QAAA,IAAI,CAAC,oBAAoB,GAAG,oBAAoB;;QAGhD,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC;QACpD,IAAI,MAAM,EAAE;AACV,YAAA,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;;;IAI5D,IAAI,GAAA;;AAEF,QAAA,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,KAAK,CACrD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,CACpC;;AAGD,YAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;;AAGhE,YAAA,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,aAAa,EAAE;gBAC5C,QAAQ,EAAE,IAAI,CAAC,QAAQ;AACxB,aAAA,CAAC;;;IAIN,IAAI,GAAA;;QAEF,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;;AAGjD,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;;AAGhE,QAAA,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,EAAE;YAC9C,QAAQ,EAAE,IAAI,CAAC,QAAQ;AACxB,SAAA,CAAC;;IAGJ,cAAc,GAAA;;QACZ,OAAO;AACL,YAAA,MAAM,EAAE,cAAc;YACtB,QAAQ,EAAE,IAAI,CAAC,QAAQ;AACvB,YAAA,SAAS,EAAE,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,cAAc,MAAA,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,MAAA,GAAA,EAAA,CAAE,KAAK,CAAC,MAAM,KAAI,CAAC;SAClD;;AAEJ;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CG;MACU,mBAAmB,CAAA;AAW9B,IAAA,WAAA,CACE,OAKG,EACH,YAA0B,EAC1B,aAAkB,EAAA;AAElB,QAAA,IAAI,CAAC,OAAO,GAAG,OAAO;AACtB,QAAA,IAAI,CAAC,YAAY,GAAG,YAAY;AAChC,QAAA,IAAI,CAAC,aAAa,GAAG,aAAa;;AAGlC,QAAA,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,YAAA,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC;AACzB,YAAA,IAAI,CAAC,WAAW,GAAG,CAAA,gBAAA,EAAmB,MAAM,CAAC,SAAS,CAAA,GAAA,EAAM,MAAM,CAAC,SAAS,CAAA,CAAA,CAAG;;aAC1E;YACL,IAAI,CAAC,WAAW,GAAG,CAAA,QAAA,EAAW,OAAO,CAAC,MAAM,SAAS;;;IAIzD,IAAI,GAAA;;QAEF,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;AAC9B,YAAA,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC;AAC3D,YAAA,MAAM,IAAI,GAAG,MAAM,KAAN,IAAA,IAAA,MAAM,uBAAN,MAAM,CAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC,MAAM,CAAC;YAC9D,IAAI,IAAI,EAAE;AACR,gBAAA,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,SAAS;AAC9B,gBAAA,KAAK,CAAC,GAAG,CACP,CAAwB,qBAAA,EAAA,MAAM,CAAC,MAAM,CAAA,MAAA,EAAS,MAAM,CAAC,SAAS,CAAO,IAAA,EAAA,MAAM,CAAC,SAAS,CAAA,CAAE,CACxF;;AAEL,SAAC,CAAC;;AAGF,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;;QAGhE,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;AAC9B,YAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,eAAe,EAAE;gBACtC,MAAM,EAAE,MAAM,CAAC,MAAM;gBACrB,QAAQ,EAAE,MAAM,CAAC,QAAQ;AACzB,gBAAA,SAAS,EAAE,MAAM,CAAC,SAAS;gBAC3B,SAAS,EAAE,MAAM,CAAC,SAAS;AAC5B,aAAA,CAAC;;aACG;;AAEL,YAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,oBAAoB,EAAE;AAC3C,gBAAA,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,MAAM;oBACrC,MAAM,EAAE,MAAM,CAAC,MAAM;oBACrB,QAAQ,EAAE,MAAM,CAAC,QAAQ;AACzB,oBAAA,SAAS,EAAE,MAAM,CAAC,SAAS;oBAC3B,SAAS,EAAE,MAAM,CAAC,SAAS;AAC5B,iBAAA,CAAC,CAAC;AACJ,aAAA,CAAC;;;IAIN,IAAI,GAAA;;QAEF,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;AAC9B,YAAA,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC;AAC3D,YAAA,MAAM,IAAI,GAAG,MAAM,KAAN,IAAA,IAAA,MAAM,uBAAN,MAAM,CAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC,MAAM,CAAC;YAC9D,IAAI,IAAI,EAAE;AACR,gBAAA,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,SAAS;AAC9B,gBAAA,KAAK,CAAC,GAAG,CACP,CAAwB,qBAAA,EAAA,MAAM,CAAC,MAAM,CAAA,MAAA,EAAS,MAAM,CAAC,SAAS,CAAO,IAAA,EAAA,MAAM,CAAC,SAAS,CAAA,CAAE,CACxF;;AAEL,SAAC,CAAC;;AAGF,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE;;QAGhE,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;AAC9B,YAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,eAAe,EAAE;gBACtC,MAAM,EAAE,MAAM,CAAC,MAAM;gBACrB,QAAQ,EAAE,MAAM,CAAC,QAAQ;gBACzB,SAAS,EAAE,MAAM,CAAC,SAAS;gBAC3B,SAAS,EAAE,MAAM,CAAC,SAAS;AAC5B,aAAA,CAAC;;aACG;;AAEL,YAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,oBAAoB,EAAE;AAC3C,gBAAA,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,MAAM;oBACrC,MAAM,EAAE,MAAM,CAAC,MAAM;oBACrB,QAAQ,EAAE,MAAM,CAAC,QAAQ;oBACzB,SAAS,EAAE,MAAM,CAAC,SAAS;oBAC3B,SAAS,EAAE,MAAM,CAAC,SAAS;AAC5B,iBAAA,CAAC,CAAC;AACJ,aAAA,CAAC;;;IAIN,cAAc,GAAA;QACZ,OAAO;AACL,YAAA,MAAM,EAAE,cAAc;AACtB,YAAA,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM;AAChC,YAAA,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,MAAM;gBACrC,MAAM,EAAE,MAAM,CAAC,MAAM;gBACrB,QAAQ,EAAE,MAAM,CAAC,QAAQ;gBACzB,SAAS,EAAE,MAAM,CAAC,SAAS;gBAC3B,SAAS,EAAE,MAAM,CAAC,SAAS;AAC5B,aAAA,CAAC,CAAC;SACJ;;AAEJ;;ACj8DD;;;;;;;;;;;;;;;;;;;;;AAqBG;AAIH;;;;;;AAMG;AACI,MAAM,kBAAkB,GAAG;AAgClC;;;;;;;;;;;;;;;;;;;;AAoBG;SACa,qBAAqB,CACnC,UAA+B,EAC/B,cAAsB,kBAAkB,EAAA;;;AAGxC,IAAA,MAAM,QAAQ,GAAG,CAAA,CAAA,EAAA,GAAA,UAAU,CAAC,OAAO,MAAE,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,MAAA,GAAA,EAAA,CAAA,KAAK,KAAI,CAAC;;;IAI/C,OAAO,QAAQ,IAAI,WAAW;AAChC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BG;SACa,qBAAqB,CACnC,UAA+B,EAC/B,cAAsB,kBAAkB,EAAA;;AAExC,IAAA,MAAM,YAAY,GAAG,UAAU,CAAC,WAAW,CAAC,KAAK;AACjD,IAAA,MAAM,aAAa,GAAG,UAAU,CAAC,WAAW,CAAC,MAAM;AAEnD,IAAA,MAAM,QAAQ,GAAG,CAAA,CAAA,EAAA,GAAA,UAAU,CAAC,OAAO,MAAE,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,MAAA,GAAA,EAAA,CAAA,KAAK,KAAI,CAAC;AAC/C,IAAA,MAAM,QAAQ,GAAG,CAAA,CAAA,EAAA,GAAA,UAAU,CAAC,OAAO,MAAE,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,MAAA,GAAA,EAAA,CAAA,KAAK,KAAI,QAAQ;IAEtD,IAAI,KAAK,GAAG,YAAY;IACxB,IAAI,MAAM,GAAG,aAAa;IAC1B,IAAI,WAAW,GAAG,KAAK;;AAGvB,IAAA,IAAI,KAAK,GAAG,WAAW,EAAE;QACvB,KAAK,GAAG,WAAW;QACnB,WAAW,GAAG,IAAI;;;AAIpB,IAAA,IAAI,KAAK,GAAG,QAAQ,EAAE;QACpB,KAAK,GAAG,QAAQ;;;AAIlB,IAAA,IAAI,KAAK,GAAG,QAAQ,EAAE;QACpB,KAAK,GAAG,QAAQ;;;;AAKlB,IAAA,MAAM,SAAS,GAAG,CAAA,CAAA,EAAA,GAAA,UAAU,CAAC,OAAO,MAAE,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,MAAA,GAAA,EAAA,CAAA,MAAM,KAAI,CAAC;AACjD,IAAA,MAAM,SAAS,GAAG,CAAA,CAAA,EAAA,GAAA,UAAU,CAAC,OAAO,MAAE,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,MAAA,GAAA,EAAA,CAAA,MAAM,KAAI,QAAQ;AAExD,IAAA,IAAI,MAAM,GAAG,SAAS,EAAE;QACtB,MAAM,GAAG,SAAS;;AAEpB,IAAA,IAAI,MAAM,GAAG,SAAS,EAAE;QACtB,MAAM,GAAG,SAAS;;AAGpB,IAAA,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,WAAW,EAAE;AACvC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAwBG;AACa,SAAA,yBAAyB,CACvC,CAAS,EACT,CAAS,EACT,KAAa,EACb,MAAc,EACd,WAAA,GAAsB,kBAAkB,EAAA;IAExC,IAAI,IAAI,GAAG,CAAC;IACZ,IAAI,IAAI,GAAG,CAAC;IACZ,IAAI,gBAAgB,GAAG,KAAK;;AAG5B,IAAA,IAAI,IAAI,GAAG,CAAC,EAAE;QACZ,IAAI,GAAG,CAAC;QACR,gBAAgB,GAAG,IAAI;;;AAIzB,IAAA,IAAI,IAAI,GAAG,KAAK,GAAG,WAAW,EAAE;AAC9B,QAAA,IAAI,GAAG,WAAW,GAAG,KAAK;QAC1B,gBAAgB,GAAG,IAAI;;;AAIzB,IAAA,IAAI,IAAI,GAAG,CAAC,EAAE;QACZ,IAAI,GAAG,CAAC;QACR,gBAAgB,GAAG,IAAI;;;;IAMzB,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC;IACxB,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC;IAExB,OAAO;AACL,QAAA,CAAC,EAAE,IAAI;AACP,QAAA,CAAC,EAAE,IAAI;QACP,KAAK;QACL,MAAM;QACN,gBAAgB;AAChB,QAAA,YAAY,EAAE,KAAK;KACpB;AACH;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCG;AACG,SAAU,wBAAwB,CACtC,UAA+B,EAC/B,CAAS,EACT,CAAS,EACT,WAAA,GAAsB,kBAAkB,EAAA;;;IAGxC,IAAI,CAAC,qBAAqB,CAAC,UAAU,EAAE,WAAW,CAAC,EAAE;AACnD,QAAA,OAAO,CAAC,IAAI,CACV,CAAA,WAAA,EAAc,UAAU,CAAC,IAAI,CAAc,WAAA,EAAA,CAAA,EAAA,GAAA,UAAU,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,MAAA,GAAA,MAAA,GAAA,EAAA,CAAE,KAAK,CAAI,EAAA,CAAA;YACtE,CAAyB,sBAAA,EAAA,WAAW,CAAwB,sBAAA,CAAA,CAC/D;AACD,QAAA,OAAO,IAAI;;;IAIb,MAAM,eAAe,GAAG,qBAAqB,CAAC,UAAU,EAAE,WAAW,CAAC;;AAGtE,IAAA,MAAM,oBAAoB,GAAG,yBAAyB,CACpD,CAAC,EACD,CAAC,EACD,eAAe,CAAC,KAAK,EACrB,eAAe,CAAC,MAAM,EACtB,WAAW,CACZ;;IAGD,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,oBAAoB,CACvB,EAAA,EAAA,YAAY,EAAE,eAAe,CAAC,WAAW,EACzC,CAAA;AACJ;;;;"}