{"file":"state-manager-b0e7f282.js","mappings":"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","names":[],"sources":["src/services/state-manager.ts"],"sourcesContent":["/**\n * State Manager\n * ==============\n *\n * Centralized reactive state management for the grid builder using StencilJS Store.\n * Manages grid items, canvases, layouts, selection state, and viewport configuration\n * with automatic component re-renders on state changes.\n *\n * ## Problem\n *\n * Complex interactive applications need:\n * - Centralized state accessible across all components\n * - Automatic UI updates when state changes\n * - Type-safe state mutations\n * - Undo/redo support (requires state snapshots)\n * - Desktop + mobile layout management\n * - Selection tracking across multiple canvases\n *\n * Without centralized state:\n * - Props drilling through component hierarchies\n * - Manual event subscriptions and cleanup\n * - Synchronization issues between components\n * - Difficult undo/redo implementation\n *\n * ## Solution\n *\n * Use @stencil/store for reactive state management with:\n * 1. **Single source of truth**: All state in one store\n * 2. **Automatic reactivity**: Components re-render on state changes\n * 3. **Type safety**: Full TypeScript support\n * 4. **Simple API**: Direct property access (no actions/reducers)\n * 5. **Lightweight**: ~1KB, built into StencilJS\n *\n * ## Architecture Decisions\n *\n * ### Why @stencil/store vs Redux/Zustand?\n *\n * **@stencil/store chosen because**:\n * - ✅ Native StencilJS integration (zero setup)\n * - ✅ Automatic component subscriptions (no manual connect/subscribe)\n * - ✅ Simple mutation API (direct property assignment)\n * - ✅ Tiny bundle size (~1KB)\n * - ✅ Full TypeScript support\n * - ✅ Perfect for component-scoped state\n *\n * **Redux would add**:\n * - ❌ Boilerplate (actions, reducers, dispatch)\n * - ❌ Bundle size (~15KB min)\n * - ❌ Learning curve (middleware, selectors)\n * - ❌ Manual component subscriptions\n *\n * **Zustand would work but**:\n * - ⚠️ External dependency (not StencilJS native)\n * - ⚠️ Manual subscriptions in StencilJS\n * - ⚠️ Less TypeScript integration\n *\n * ### Dual Layout System (Desktop + Mobile)\n *\n * Each grid item has TWO layout configurations:\n *\n * **Desktop Layout** (always present):\n * - Primary layout with full positioning data\n * - x, y, width, height in grid units\n * - Never null, always has values\n *\n * **Mobile Layout** (optional/auto-generated):\n * - x, y, width, height can be null\n * - `customized: false` → auto-generated from desktop layout\n * - `customized: true` → user manually positioned in mobile view\n *\n * **Why dual layouts**:\n * - Different screen sizes need different layouts\n * - Mobile can auto-adapt OR be manually customized\n * - Single item definition works across viewports\n *\n * **Auto-generation strategy**:\n * ```typescript\n * // When mobile layout is null (not customized):\n * // - Full width items (span entire mobile viewport)\n * // - Stacked vertically\n * // - Responsive heights\n *\n * // When mobile.customized = true:\n * // - Use explicit mobile.x, mobile.y, mobile.width, mobile.height\n * // - Ignore desktop layout\n * ```\n *\n * ### State Mutation Pattern\n *\n * **Immutable spread pattern** for reactivity:\n * ```typescript\n * // ❌ Wrong: Direct mutation doesn't trigger updates\n * canvas.items.push(newItem);\n *\n * // ✅ Correct: Spread triggers reactivity\n * canvas.items.push(newItem);\n * state.canvases = { ...state.canvases };\n * ```\n *\n * **Why this pattern**:\n * - StencilJS store detects reference changes\n * - Object spread creates new reference\n * - Components automatically re-render\n * - Simple and performant\n *\n * ### Z-Index Management\n *\n * **Per-canvas z-index tracking**:\n * - Each canvas has `zIndexCounter` (monotonically increasing)\n * - New items get `zIndexCounter++`\n * - Ensures unique z-index per canvas\n * - Higher z-index = rendered on top\n *\n * **Why per-canvas**:\n * - Items in different canvases don't overlap\n * - Simplifies z-index calculations\n * - Prevents z-index conflicts\n * - Independent stacking contexts\n *\n * **Bringing to front**:\n * ```typescript\n * item.zIndex = canvas.zIndexCounter++;\n * state.canvases = { ...state.canvases }; // Trigger update\n * ```\n *\n * ## State Structure\n *\n * ```typescript\n * {\n *   canvases: {\n *     'canvas1': {\n *       items: [GridItem, GridItem, ...],\n *       zIndexCounter: 5,\n *       backgroundColor: '#ffffff'\n *     },\n *     'canvas2': { ... },\n *     ...\n *   },\n *   selectedItemId: 'item-3' | null,\n *   selectedCanvasId: 'canvas1' | null,\n *   currentViewport: 'desktop' | 'mobile',\n *   showGrid: true | false\n * }\n * ```\n *\n * ## Performance Characteristics\n *\n * **State access**: O(1) - direct property access\n * **State updates**: O(n) - spread operation copies references\n * **Component re-renders**: Only components consuming changed state\n * **Memory**: Lightweight (~1KB store + actual state data)\n *\n * **Optimization**: Immutable updates only copy top-level references,\n * not deep clones. Child objects remain same reference if unchanged.\n *\n * ## Integration with Undo/Redo\n *\n * State structure supports undo/redo via snapshots:\n * ```typescript\n * // Save snapshot\n * const snapshot = JSON.parse(JSON.stringify(state.canvases));\n *\n * // Restore snapshot\n * state.canvases = JSON.parse(JSON.stringify(snapshot));\n * ```\n *\n * Deep cloning required because:\n * - Prevents mutations from affecting history\n * - Ensures independent state snapshots\n * - Simple and reliable (no ref tracking)\n *\n * ## Extracting This Pattern\n *\n * To adapt for other frameworks:\n *\n * **React + Zustand**:\n * ```typescript\n * import create from 'zustand';\n *\n * const useStore = create<GridState>((set) => ({\n *   ...initialState,\n *   addItem: (canvasId, item) => set((state) => ({\n *     canvases: {\n *       ...state.canvases,\n *       [canvasId]: {\n *         ...state.canvases[canvasId],\n *         items: [...state.canvases[canvasId].items, item]\n *       }\n *     }\n *   }))\n * }));\n * ```\n *\n * **Vue + Pinia**:\n * ```typescript\n * import { defineStore } from 'pinia';\n *\n * export const useGridStore = defineStore('grid', {\n *   state: () => initialState,\n *   actions: {\n *     addItem(canvasId, item) {\n *       this.canvases[canvasId].items.push(item);\n *     }\n *   }\n * });\n * ```\n *\n * **Angular + NgRx**:\n * ```typescript\n * export const addItem = createAction(\n *   '[Grid] Add Item',\n *   props<{ canvasId: string; item: GridItem }>()\n * );\n *\n * export const gridReducer = createReducer(\n *   initialState,\n *   on(addItem, (state, { canvasId, item }) => ({\n *     ...state,\n *     canvases: {\n *       ...state.canvases,\n *       [canvasId]: {\n *         ...state.canvases[canvasId],\n *         items: [...state.canvases[canvasId].items, item]\n *       }\n *     }\n *   }))\n * );\n * ```\n *\n * @module state-manager\n */\n\nimport { createStore } from '@stencil/store';\n\n/**\n * Grid Item Interface\n * ====================\n *\n * Core data structure representing a single component instance in the grid.\n * Each item has dual layouts (desktop + mobile) and positioning metadata.\n *\n * **Lifecycle**:\n * 1. Created when dropped from palette or added programmatically\n * 2. Updated during drag/resize operations\n * 3. Persisted in state for undo/redo\n * 4. Removed when deleted\n *\n * **Key Properties**:\n * - `id`: Unique identifier (generated via generateItemId)\n * - `canvasId`: Which canvas owns this item\n * - `type`: Component type ('header', 'text', 'button', etc.)\n * - `name`: Display name (shown in UI)\n * - `layouts`: Desktop and mobile positioning\n * - `zIndex`: Stacking order within canvas\n *\n * **Type System Integration**:\n * The `type` field determines which component renders via dynamic imports:\n * ```typescript\n * switch (item.type) {\n *   case 'header': return <component-header />;\n *   case 'text': return <component-text-block />;\n *   case 'button': return <component-button />;\n *   // ...\n * }\n * ```\n */\nexport interface GridItem {\n  /** Unique item identifier (e.g., 'item-1', 'item-2') */\n  id: string;\n\n  /** Canvas ID this item belongs to (e.g., 'canvas1', 'canvas2') */\n  canvasId: string;\n\n  /** Component type determining which component renders ('header', 'text', 'button', etc.) */\n  type: string;\n\n  /** Display name shown in UI */\n  name: string;\n\n  /**\n   * Dual layout system for responsive design\n   *\n   * **Desktop Layout** (required, never null):\n   * - Primary layout used in desktop viewport\n   * - All properties (x, y, width, height) always have numeric values\n   * - Coordinates in grid units (not pixels)\n   *\n   * **Mobile Layout** (optional/auto-generated):\n   * - Properties can be null when not customized\n   * - `customized: false` → Auto-generated layout (full-width, stacked)\n   * - `customized: true` → User manually positioned in mobile view\n   *\n   * **Auto-generation behavior** (when mobile.customized = false):\n   * ```typescript\n   * // grid-item-wrapper.tsx calculates:\n   * x: 0 (left edge)\n   * y: calculatedFromStackOrder\n   * width: 50 (full width = 100% of viewport)\n   * height: desktop.height (maintain aspect ratio)\n   * ```\n   *\n   * **Example usage**:\n   * ```typescript\n   * const item: GridItem = {\n   *   id: 'item-1',\n   *   canvasId: 'canvas1',\n   *   type: 'header',\n   *   name: 'Hero Header',\n   *   layouts: {\n   *     desktop: { x: 5, y: 2, width: 20, height: 8 },\n   *     mobile: {\n   *       x: null, y: null, width: null, height: null,\n   *       customized: false // Will auto-generate\n   *     }\n   *   },\n   *   zIndex: 1\n   * };\n   * ```\n   */\n  layouts: {\n    /** Desktop layout (always fully defined) */\n    desktop: {\n      /** Horizontal position in grid units (0 = left edge) */\n      x: number;\n\n      /** Vertical position in grid units (0 = top edge) */\n      y: number;\n\n      /** Width in grid units (e.g., 20 units at 2% = 40% of container) */\n      width: number;\n\n      /** Height in grid units (e.g., 8 units × 20px = 160px) */\n      height: number;\n    };\n\n    /** Mobile layout (optional/auto-generated) */\n    mobile: {\n      /** Horizontal position or null for auto-generation */\n      x: number | null;\n\n      /** Vertical position or null for auto-generation */\n      y: number | null;\n\n      /** Width or null for auto-generation (typically full-width) */\n      width: number | null;\n\n      /** Height or null for auto-generation */\n      height: number | null;\n\n      /**\n       * Whether user manually customized mobile layout\n       *\n       * **false**: Auto-generate from desktop layout\n       * - Full width (50 grid units)\n       * - Stacked vertically\n       * - Maintains desktop height\n       *\n       * **true**: Use explicit mobile x/y/width/height\n       * - User dragged/resized in mobile view\n       * - Ignore desktop layout\n       * - Persist custom positioning\n       */\n      customized: boolean;\n    };\n  };\n\n  /**\n   * Stacking order within canvas (higher = on top)\n   *\n   * **Assignment**: New items get `canvas.zIndexCounter++`\n   * **Bringing to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Per-canvas**: Z-indexes only compete within same canvas\n   */\n  zIndex: number;\n}\n\n/**\n * Canvas Interface\n * =================\n *\n * Represents a single canvas container (section) in the grid builder.\n * Each canvas is an independent dropzone with its own items and z-index tracking.\n *\n * **Typical usage**: Multi-section landing pages\n * - canvas1 = Hero section\n * - canvas2 = Content section\n * - canvas3 = Footer section\n *\n * **Why multiple canvases**:\n * - Logical content sections\n * - Independent z-index contexts\n * - Different background colors per section\n * - Easier content organization\n *\n * **Example**:\n * ```typescript\n * const heroCanvas: Canvas = {\n *   items: [headerItem, textItem, buttonItem, imageItem],\n *   zIndexCounter: 5, // Next item gets zIndex: 5\n *   backgroundColor: '#ffffff'\n * };\n * ```\n */\nexport interface Canvas {\n  /**\n   * Array of grid items in this canvas\n   *\n   * **Rendering**: Items render in DOM order, styled with z-index for stacking\n   * **Mutation**: Always use spread pattern to trigger reactivity\n   */\n  items: GridItem[];\n\n  /**\n   * Monotonically increasing counter for z-index assignment\n   *\n   * **New items**: `item.zIndex = canvas.zIndexCounter++`\n   * **Bring to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Never decreases**: Only increments to prevent conflicts\n   */\n  zIndexCounter: number;\n\n  /**\n   * Canvas background color (CSS color value)\n   *\n   * **Examples**: '#ffffff', '#f5f5f5', 'rgb(255, 255, 255)'\n   * **Applied to**: canvas-section component background\n   */\n  backgroundColor: string;\n}\n\n/**\n * Grid State Interface\n * =====================\n *\n * Root state structure for entire grid builder application.\n * Manages all canvases, selection state, and viewport configuration.\n *\n * **Single source of truth**: All app state in this one object\n * **Reactivity**: Changes trigger automatic component re-renders\n * **Persistence**: Can be serialized to JSON for save/export\n *\n * **Access pattern**:\n * ```typescript\n * import { gridState } from './state-manager';\n *\n * // Read state\n * const items = gridState.canvases['canvas1'].items;\n *\n * // Mutate state (triggers reactivity)\n * gridState.selectedItemId = 'item-5';\n * gridState.canvases = { ...gridState.canvases }; // After mutations\n * ```\n */\nexport interface GridState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': Canvas, 'canvas2': Canvas, ... }`\n   * **Access**: `gridState.canvases['canvas1']`\n   * **Dynamic canvases**: Can add/remove canvases at runtime\n   */\n  canvases: Record<string, Canvas>;\n\n  /**\n   * Currently selected item ID or null if no selection\n   *\n   * **Selection flow**:\n   * 1. User clicks item → `selectItem(itemId, canvasId)`\n   * 2. State updates → `selectedItemId = 'item-3'`\n   * 3. Components re-render with visual selection indicators\n   *\n   * **Deselection**: Click canvas background → `deselectItem()` → `null`\n   */\n  selectedItemId: string | null;\n\n  /**\n   * Canvas ID containing currently selected item\n   *\n   * **Why needed**: Item IDs are unique across canvases, but need canvas\n   * for operations like delete, move, etc.\n   *\n   * **Always paired**: When `selectedItemId` is set, `selectedCanvasId` must be set\n   */\n  selectedCanvasId: string | null;\n\n  /**\n   * Current viewport mode (desktop or mobile)\n   *\n   * **Affects**:\n   * - Which layout is rendered (item.layouts.desktop vs item.layouts.mobile)\n   * - Grid calculations (responsive vs fixed)\n   * - Canvas width (full vs mobile viewport)\n   *\n   * **Toggle**: User clicks viewport switcher button\n   */\n  currentViewport: 'desktop' | 'mobile';\n\n  /**\n   * Whether to show grid lines on canvases\n   *\n   * **Visual aid**: Helps users align items to grid\n   * **Toggle**: User clicks grid visibility button\n   * **Rendering**: CSS background-image with grid pattern\n   */\n  showGrid: boolean;\n}\n\n/**\n * Initial State with prepopulated demo items\n */\nconst initialState: GridState = {\n  canvases: {\n    canvas1: {\n      items: [\n        // Hero section demo items\n        {\n          id: 'item-1',\n          canvasId: 'canvas1',\n          type: 'header',\n          name: 'Header',\n          layouts: {\n            desktop: { x: 2, y: 2, width: 20, height: 6 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 1,\n        },\n        {\n          id: 'item-2',\n          canvasId: 'canvas1',\n          type: 'text',\n          name: 'Text',\n          layouts: {\n            desktop: { x: 2, y: 9, width: 20, height: 5 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 2,\n        },\n        {\n          id: 'item-3',\n          canvasId: 'canvas1',\n          type: 'button',\n          name: 'Button',\n          layouts: {\n            desktop: { x: 2, y: 15, width: 9, height: 4 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 3,\n        },\n        {\n          id: 'item-4',\n          canvasId: 'canvas1',\n          type: 'image',\n          name: 'Image',\n          layouts: {\n            desktop: { x: 23, y: 2, width: 15, height: 12 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 4,\n        },\n      ],\n      zIndexCounter: 5,\n      backgroundColor: '#ffffff',\n    },\n    canvas2: {\n      items: [\n        // Content section demo items\n        {\n          id: 'item-5',\n          canvasId: 'canvas2',\n          type: 'header',\n          name: 'Header',\n          layouts: {\n            desktop: { x: 2, y: 2, width: 18, height: 4 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 1,\n        },\n        {\n          id: 'item-6',\n          canvasId: 'canvas2',\n          type: 'text',\n          name: 'Text',\n          layouts: {\n            desktop: { x: 2, y: 7, width: 18, height: 8 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 2,\n        },\n        {\n          id: 'item-7',\n          canvasId: 'canvas2',\n          type: 'video',\n          name: 'Video',\n          layouts: {\n            desktop: { x: 21, y: 2, width: 17, height: 13 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 3,\n        },\n      ],\n      zIndexCounter: 4,\n      backgroundColor: '#f5f5f5',\n    },\n    canvas3: {\n      items: [\n        // Footer section demo items\n        {\n          id: 'item-8',\n          canvasId: 'canvas3',\n          type: 'text',\n          name: 'Text',\n          layouts: {\n            desktop: { x: 2, y: 2, width: 15, height: 5 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 1,\n        },\n        {\n          id: 'item-9',\n          canvasId: 'canvas3',\n          type: 'button',\n          name: 'Button',\n          layouts: {\n            desktop: { x: 18, y: 2, width: 8, height: 4 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 2,\n        },\n        {\n          id: 'item-10',\n          canvasId: 'canvas3',\n          type: 'button',\n          name: 'Button',\n          layouts: {\n            desktop: { x: 27, y: 2, width: 8, height: 4 },\n            mobile: { x: null, y: null, width: null, height: null, customized: false },\n          },\n          zIndex: 3,\n        },\n      ],\n      zIndexCounter: 4,\n      backgroundColor: '#ffffff',\n    },\n  },\n  selectedItemId: null,\n  selectedCanvasId: null,\n  currentViewport: 'desktop',\n  showGrid: true,\n};\n\n/**\n * Global Grid State Store\n * ========================\n *\n * StencilJS store instance providing reactive state management.\n *\n * **Exports**:\n * - `state`: Reactive state proxy (mutate to trigger updates)\n * - `onChange`: Subscribe to state changes\n * - `dispose`: Cleanup subscriptions (typically not needed)\n *\n * **Usage in components**:\n * ```typescript\n * import { gridState } from './state-manager';\n *\n * // Component automatically re-renders when state changes\n * render() {\n *   const items = gridState.canvases['canvas1'].items;\n *   return items.map(item => <div>{item.name}</div>);\n * }\n * ```\n */\nconst { state, onChange, dispose } = createStore<GridState>(initialState);\n\n/**\n * Reset state to initial demo configuration\n *\n * **When to call**:\n * - User clicks \"Reset\" button\n * - Starting fresh demo\n * - Test cleanup (afterEach hooks)\n *\n * **What it resets**:\n * - Restores all 3 demo canvases with original items\n * - Clears selection state\n * - Resets viewport to desktop\n * - Shows grid\n * - Resets item ID counter to 10\n *\n * **Deep clone pattern**:\n * Uses `JSON.parse(JSON.stringify())` to create independent copy\n * of initial state. Prevents mutations from affecting initialState.\n *\n * **Why reset ID counter to 10**:\n * Initial state has items 1-10 prepopulated. Starting at 10 ensures\n * new items get IDs 11, 12, 13... without conflicts.\n *\n * @example\n * ```typescript\n * // Reset button handler\n * handleReset() {\n *   if (confirm('Reset to initial state?')) {\n *     reset();\n *     console.log('State reset to demo configuration');\n *   }\n * }\n * ```\n */\nexport function reset() {\n  itemIdCounter = 10; // Reset to 10 to account for prepopulated items\n\n  // Restore initial state with prepopulated items\n  state.canvases = JSON.parse(JSON.stringify(initialState.canvases));\n  state.selectedItemId = null;\n  state.selectedCanvasId = null;\n  state.currentViewport = 'desktop';\n  state.showGrid = true;\n}\n\nexport { state as gridState, onChange, dispose };\n\n/**\n * Helper Functions\n * ================\n *\n * CRUD operations for managing grid items and canvases.\n * All mutations use spread pattern to trigger reactivity.\n */\n\n/**\n * Add item to canvas\n *\n * **Use cases**:\n * - Dropping component from palette\n * - Undo delete operation\n * - Duplicating existing item\n * - Programmatic item creation\n *\n * **Reactivity pattern**:\n * 1. Push item to canvas.items array\n * 2. Spread canvases object to trigger update\n * 3. Components automatically re-render\n *\n * **Z-index assignment**:\n * Item should have `zIndex: canvas.zIndexCounter++` before calling.\n * This function doesn't assign z-index automatically.\n *\n * **Safety**: No-op if canvas doesn't exist\n *\n * @param canvasId - Target canvas ID\n * @param item - GridItem to add (should have zIndex assigned)\n *\n * @example\n * ```typescript\n * // Add new item from palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(),\n *   canvasId: 'canvas1',\n *   type: 'header',\n *   name: 'Header',\n *   layouts: {\n *     desktop: { x: 5, y: 5, width: 20, height: 8 },\n *     mobile: { x: null, y: null, width: null, height: null, customized: false }\n *   },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n * addItemToCanvas('canvas1', newItem);\n * ```\n */\nexport function addItemToCanvas(canvasId: string, item: GridItem) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items.push(item);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Remove item from canvas\n *\n * **Use cases**:\n * - User deletes item (Delete key or button)\n * - Undo add operation\n * - Clearing canvas\n *\n * **Filter pattern**:\n * Creates new array without the item, preserving array order.\n * Reassignment triggers reactivity.\n *\n * **Index preservation**:\n * Array order maintained for z-index rendering.\n * Other items' indexes shift down by 1.\n *\n * **Safety**: No-op if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to remove\n *\n * @example\n * ```typescript\n * // Delete selected item\n * if (gridState.selectedItemId && gridState.selectedCanvasId) {\n *   removeItemFromCanvas(\n *     gridState.selectedCanvasId,\n *     gridState.selectedItemId\n *   );\n *   deselectItem(); // Clear selection\n * }\n * ```\n */\nexport function removeItemFromCanvas(canvasId: string, itemId: string) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((item) => item.id !== itemId);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Update item properties in canvas\n *\n * **Use cases**:\n * - After drag operation (update position)\n * - After resize operation (update dimensions)\n * - Changing item name or type\n * - Bringing item to front (update zIndex)\n *\n * **Partial updates**:\n * Uses `Partial<GridItem>` to allow updating subset of properties.\n * Object.assign merges updates into existing item.\n *\n * **Typical update patterns**:\n * ```typescript\n * // Update position after drag\n * updateItem(canvasId, itemId, {\n *   layouts: { ...item.layouts, desktop: { x: 10, y: 5, width: 20, height: 8 } }\n * });\n *\n * // Bring to front\n * updateItem(canvasId, itemId, {\n *   zIndex: gridState.canvases[canvasId].zIndexCounter++\n * });\n * ```\n *\n * **Safety**: No-op if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to update\n * @param updates - Partial GridItem with properties to update\n *\n * @example\n * ```typescript\n * // After drag end\n * const item = getItem('canvas1', 'item-3');\n * if (item) {\n *   item.layouts.desktop.x = newX;\n *   item.layouts.desktop.y = newY;\n *   updateItem('canvas1', 'item-3', item);\n * }\n * ```\n */\nexport function updateItem(canvasId: string, itemId: string, updates: Partial<GridItem>) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  const item = canvas.items.find((i) => i.id === itemId);\n  if (!item) {\n    return;\n  }\n\n  Object.assign(item, updates);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Get item by ID\n *\n * **Use cases**:\n * - Reading item data before update\n * - Validation checks\n * - Getting item for undo/redo snapshots\n * - Checking if item exists\n *\n * **Read-only**: Returns reference to item in state.\n * To modify, use `updateItem()` to trigger reactivity.\n *\n * **Safety**: Returns null if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to retrieve\n * @returns GridItem or null if not found\n *\n * @example\n * ```typescript\n * // Check item before operation\n * const item = getItem('canvas1', 'item-3');\n * if (item) {\n *   console.log(`Item at (${item.layouts.desktop.x}, ${item.layouts.desktop.y})`);\n * }\n *\n * // Create snapshot for undo\n * const snapshot = JSON.parse(JSON.stringify(getItem(canvasId, itemId)));\n * ```\n */\nexport function getItem(canvasId: string, itemId: string): GridItem | null {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return null;\n  }\n\n  return canvas.items.find((i) => i.id === itemId) || null;\n}\n\n/**\n * Move item to different canvas\n *\n * **Use cases**:\n * - Dragging item across canvas boundaries\n * - Reorganizing multi-section layouts\n * - Undo move operation\n *\n * **Operation flow**:\n * 1. Find item in source canvas\n * 2. Remove from source canvas items array\n * 3. Update item's canvasId property\n * 4. Add to destination canvas items array\n * 5. Trigger reactivity with spread\n *\n * **Important**: Item keeps its existing zIndex.\n * May want to update with destination canvas's zIndexCounter.\n *\n * **Position handling**:\n * Item keeps its grid coordinates. Caller should validate/adjust\n * position fits within destination canvas bounds.\n *\n * **Safety**: No-op if either canvas doesn't exist or item not found\n *\n * @param fromCanvasId - Source canvas ID\n * @param toCanvasId - Destination canvas ID\n * @param itemId - Item to move\n *\n * @example\n * ```typescript\n * // Move item on cross-canvas drag\n * handleDragEnd(event) {\n *   const targetCanvasId = event.dropTarget.id;\n *   if (targetCanvasId !== item.canvasId) {\n *     moveItemToCanvas(item.canvasId, targetCanvasId, item.id);\n *\n *     // Optionally update z-index for new canvas\n *     const canvas = gridState.canvases[targetCanvasId];\n *     updateItem(targetCanvasId, item.id, {\n *       zIndex: canvas.zIndexCounter++\n *     });\n *   }\n * }\n * ```\n */\nexport function moveItemToCanvas(fromCanvasId: string, toCanvasId: string, itemId: string) {\n  const fromCanvas = state.canvases[fromCanvasId];\n  const toCanvas = state.canvases[toCanvasId];\n\n  if (!fromCanvas || !toCanvas) {\n    return;\n  }\n\n  const item = fromCanvas.items.find((i) => i.id === itemId);\n  if (!item) {\n    return;\n  }\n\n  // Remove from old canvas\n  fromCanvas.items = fromCanvas.items.filter((i) => i.id !== itemId);\n\n  // Update item's canvasId\n  item.canvasId = toCanvasId;\n\n  // Add to new canvas\n  toCanvas.items.push(item);\n\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * ID counter for generating unique item IDs\n *\n * **Starts at 10**: Initial state has items 1-10 prepopulated\n * **Increments**: Each call to generateItemId() returns next ID\n * **Format**: 'item-N' where N is the counter value\n */\nlet itemIdCounter = 10; // Start at 10 to account for prepopulated items (item-1 through item-10)\n\n/**\n * Generate unique item ID\n *\n * **Use cases**:\n * - Creating new item from palette drop\n * - Duplicating existing item\n * - Any programmatic item creation\n *\n * **Uniqueness guarantee**:\n * Monotonically increasing counter ensures no collisions.\n * Even after delete, IDs never reused.\n *\n * **Format**: Returns 'item-N' (e.g., 'item-11', 'item-12')\n *\n * **Thread safety**: Not thread-safe, but not an issue in\n * single-threaded JavaScript environment.\n *\n * @returns Unique item ID string\n *\n * @example\n * ```typescript\n * // Create new item from palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(), // 'item-11'\n *   canvasId: 'canvas1',\n *   type: 'button',\n *   name: 'Button',\n *   layouts: { ... },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n * ```\n */\nexport function generateItemId(): string {\n  return `item-${++itemIdCounter}`;\n}\n\n/**\n * Select item and set active canvas\n *\n * **Use cases**:\n * - User clicks item\n * - After creating new item (auto-select)\n * - Keyboard navigation\n *\n * **Visual effects**:\n * - Selected item gets visual highlight (via CSS)\n * - Resize/drag handles appear\n * - Item can be deleted with Delete key\n *\n * **State changes**:\n * - `selectedItemId` = itemId\n * - `selectedCanvasId` = canvasId\n * - Components re-render with selection styles\n *\n * **Single selection**: Selecting new item automatically deselects previous\n *\n * @param itemId - Item to select\n * @param canvasId - Canvas containing the item\n *\n * @example\n * ```typescript\n * // Handle item click\n * handleItemClick(item: GridItem) {\n *   selectItem(item.id, item.canvasId);\n * }\n *\n * // Auto-select after creating item\n * const newItem = createNewItem();\n * addItemToCanvas('canvas1', newItem);\n * selectItem(newItem.id, 'canvas1');\n * ```\n */\nexport function selectItem(itemId: string, canvasId: string) {\n  state.selectedItemId = itemId;\n  state.selectedCanvasId = canvasId;\n}\n\n/**\n * Deselect currently selected item\n *\n * **Use cases**:\n * - User clicks canvas background\n * - After deleting selected item\n * - Escape key pressed\n * - Starting drag operation\n *\n * **Visual effects**:\n * - Selection highlight removed\n * - Resize/drag handles hidden\n * - Item no longer delete-able with Delete key\n *\n * **State changes**:\n * - `selectedItemId` = null\n * - `selectedCanvasId` = null\n * - Components re-render without selection styles\n *\n * **Safety**: Safe to call even if nothing selected\n *\n * @example\n * ```typescript\n * // Handle canvas click (deselect)\n * handleCanvasClick(event) {\n *   if (event.target === canvasElement) {\n *     deselectItem();\n *   }\n * }\n *\n * // After deleting item\n * removeItemFromCanvas(canvasId, itemId);\n * deselectItem();\n * ```\n */\nexport function deselectItem() {\n  state.selectedItemId = null;\n  state.selectedCanvasId = null;\n}\n"],"version":3}