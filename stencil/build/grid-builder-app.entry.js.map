{"file":"grid-builder-app.entry.esm.js","mappings":"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","names":["gridState","state","interact"],"sources":["src/utils/virtual-rendering.ts","src/components/grid-builder-app/grid-builder-app.scss?tag=grid-builder-app","src/components/grid-builder-app/grid-builder-app.tsx"],"sourcesContent":["/**\n * Virtual Rendering Utility\n * Lazy-load complex components using IntersectionObserver\n *\n * Purpose: Only initialize complex/heavy components when they become visible\n * This improves initial render performance and reduces memory usage\n */\n\ntype ComplexComponentType = 'gallery' | 'dashboard' | 'livedata';\n\n/**\n * Virtual Renderer using IntersectionObserver\n * Observes grid items and initializes complex components when visible\n */\nexport class VirtualRenderer {\n  private observer: IntersectionObserver;\n  private visibleItems: Set<string> = new Set();\n  private intervalIds: Map<string, number> = new Map();\n\n  constructor() {\n    // Create observer with 200px margin (pre-render before entering viewport)\n    this.observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          const itemElement = entry.target as HTMLElement;\n          const itemId = itemElement.id;\n          const itemType = itemElement.getAttribute('data-item-type') as ComplexComponentType;\n\n          if (entry.isIntersecting) {\n            // Item is visible - check if we need to initialize it\n            if (!this.visibleItems.has(itemId)) {\n              this.visibleItems.add(itemId);\n              this.initializeComplexComponent(itemId, itemType);\n            }\n          } else {\n            // Item left viewport - cleanup if needed\n            this.visibleItems.delete(itemId);\n          }\n        });\n      },\n      {\n        rootMargin: '200px', // Start loading 200px before entering viewport\n        threshold: 0.01, // Trigger when even 1% is visible\n      }\n    );\n  }\n\n  /**\n   * Start observing an element for lazy loading\n   */\n  observe(element: HTMLElement, _itemId: string, itemType: ComplexComponentType): void {\n    // Store item type as data attribute for retrieval in observer callback\n    element.setAttribute('data-item-type', itemType);\n    this.observer.observe(element);\n  }\n\n  /**\n   * Stop observing an element\n   */\n  unobserve(itemId: string): void {\n    const element = document.getElementById(itemId);\n    if (element) {\n      this.observer.unobserve(element);\n    }\n\n    // Cleanup any intervals\n    this.cleanup(itemId);\n\n    this.visibleItems.delete(itemId);\n  }\n\n  /**\n   * Destroy the virtual renderer\n   */\n  destroy(): void {\n    this.observer.disconnect();\n\n    // Cleanup all intervals\n    this.intervalIds.forEach((intervalId) => clearInterval(intervalId));\n    this.intervalIds.clear();\n    this.visibleItems.clear();\n  }\n\n  /**\n   * Cleanup resources for an item\n   */\n  private cleanup(itemId: string): void {\n    const intervalId = this.intervalIds.get(itemId);\n    if (intervalId) {\n      clearInterval(intervalId);\n      this.intervalIds.delete(itemId);\n    }\n  }\n\n  /**\n   * Initialize complex component behavior\n   * Only called when item becomes visible (via Intersection Observer)\n   */\n  private initializeComplexComponent(itemId: string, type: ComplexComponentType): void {\n    const contentEl = document.getElementById(`${itemId}-content`);\n    if (!contentEl) {\n      return;\n    }\n\n    // Check if already initialized (prevent double-init)\n    if (contentEl.dataset.initialized === 'true') {\n      return;\n    }\n    contentEl.dataset.initialized = 'true';\n\n    switch (type) {\n      case 'gallery':\n        this.renderGallery(contentEl);\n        break;\n\n      case 'dashboard':\n        this.renderDashboard(contentEl);\n        break;\n\n      case 'livedata':\n        this.renderLiveData(contentEl, itemId);\n        break;\n    }\n  }\n\n  /**\n   * Render image gallery component\n   */\n  private renderGallery(contentEl: HTMLElement): void {\n    contentEl.innerHTML = `\n      <div style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; height: 100%;\">\n        <div style=\"position: relative; width: 100%; padding-bottom: 100%; overflow: hidden; border-radius: 4px; background: #f0f0f0;\">\n          <img src=\"https://picsum.photos/400?random=${Math.random()}\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;\" loading=\"lazy\" alt=\"Gallery image 1\">\n        </div>\n        <div style=\"position: relative; width: 100%; padding-bottom: 100%; overflow: hidden; border-radius: 4px; background: #f0f0f0;\">\n          <img src=\"https://picsum.photos/400?random=${Math.random()}\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;\" loading=\"lazy\" alt=\"Gallery image 2\">\n        </div>\n        <div style=\"position: relative; width: 100%; padding-bottom: 100%; overflow: hidden; border-radius: 4px; background: #f0f0f0;\">\n          <img src=\"https://picsum.photos/400?random=${Math.random()}\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;\" loading=\"lazy\" alt=\"Gallery image 3\">\n        </div>\n        <div style=\"position: relative; width: 100%; padding-bottom: 100%; overflow: hidden; border-radius: 4px; background: #f0f0f0;\">\n          <img src=\"https://picsum.photos/400?random=${Math.random()}\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;\" loading=\"lazy\" alt=\"Gallery image 4\">\n        </div>\n        <div style=\"position: relative; width: 100%; padding-bottom: 100%; overflow: hidden; border-radius: 4px; background: #f0f0f0;\">\n          <img src=\"https://picsum.photos/400?random=${Math.random()}\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;\" loading=\"lazy\" alt=\"Gallery image 5\">\n        </div>\n        <div style=\"position: relative; width: 100%; padding-bottom: 100%; overflow: hidden; border-radius: 4px; background: #f0f0f0;\">\n          <img src=\"https://picsum.photos/400?random=${Math.random()}\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;\" loading=\"lazy\" alt=\"Gallery image 6\">\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Render dashboard widget component\n   */\n  private renderDashboard(contentEl: HTMLElement): void {\n    contentEl.innerHTML = `\n      <div style=\"font-size: 11px; line-height: 1.4;\">\n        <div style=\"display: flex; justify-content: space-between; margin-bottom: 8px;\">\n          <div style=\"flex: 1; padding: 6px; background: #f0f0f0; border-radius: 3px; margin-right: 4px;\">\n            <div style=\"font-weight: 600; color: #666;\">Users</div>\n            <div style=\"font-size: 16px; font-weight: 700; color: #4A90E2;\">2,547</div>\n          </div>\n          <div style=\"flex: 1; padding: 6px; background: #f0f0f0; border-radius: 3px;\">\n            <div style=\"font-weight: 600; color: #666;\">Revenue</div>\n            <div style=\"font-size: 16px; font-weight: 700; color: #28a745;\">$12.4K</div>\n          </div>\n        </div>\n        <div style=\"background: #f8f8f8; padding: 8px; border-radius: 3px; margin-bottom: 6px;\">\n          <div style=\"font-weight: 600; margin-bottom: 4px;\">Activity Chart</div>\n          <div style=\"display: flex; align-items: flex-end; height: 40px; gap: 2px;\">\n            <div style=\"flex: 1; background: #4A90E2; height: 60%;\"></div>\n            <div style=\"flex: 1; background: #4A90E2; height: 80%;\"></div>\n            <div style=\"flex: 1; background: #4A90E2; height: 40%;\"></div>\n            <div style=\"flex: 1; background: #4A90E2; height: 90%;\"></div>\n            <div style=\"flex: 1; background: #4A90E2; height: 70%;\"></div>\n            <div style=\"flex: 1; background: #4A90E2; height: 85%;\"></div>\n            <div style=\"flex: 1; background: #4A90E2; height: 95%;\"></div>\n          </div>\n        </div>\n        <div style=\"font-size: 10px; color: #999;\">\n          <div>‚Ä¢ 24 active sessions</div>\n          <div>‚Ä¢ 156 page views</div>\n          <div>‚Ä¢ 89% bounce rate</div>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Render live data component (with polling)\n   */\n  private renderLiveData(contentEl: HTMLElement, itemId: string): void {\n    let counter = 0;\n\n    const updateLiveData = () => {\n      counter++;\n      const temperature = (20 + Math.random() * 10).toFixed(1);\n      const cpu = (Math.random() * 100).toFixed(0);\n      const memory = (40 + Math.random() * 50).toFixed(0);\n\n      if (contentEl) {\n        contentEl.innerHTML = `\n          <div style=\"font-size: 11px;\">\n            <div style=\"margin-bottom: 8px; padding: 6px; background: #e3f2fd; border-radius: 3px;\">\n              <div style=\"font-weight: 600; color: #1976d2;\">üå°Ô∏è Temperature</div>\n              <div style=\"font-size: 20px; font-weight: 700; color: #1976d2;\">${temperature}¬∞C</div>\n            </div>\n            <div style=\"margin-bottom: 6px;\">\n              <div style=\"display: flex; justify-content: space-between; margin-bottom: 2px;\">\n                <span style=\"font-weight: 600;\">CPU</span>\n                <span>${cpu}%</span>\n              </div>\n              <div style=\"background: #e0e0e0; height: 6px; border-radius: 3px; overflow: hidden;\">\n                <div style=\"background: #4A90E2; height: 100%; width: ${cpu}%; transition: width 0.5s;\"></div>\n              </div>\n            </div>\n            <div style=\"margin-bottom: 6px;\">\n              <div style=\"display: flex; justify-content: space-between; margin-bottom: 2px;\">\n                <span style=\"font-weight: 600;\">Memory</span>\n                <span>${memory}%</span>\n              </div>\n              <div style=\"background: #e0e0e0; height: 6px; border-radius: 3px; overflow: hidden;\">\n                <div style=\"background: #28a745; height: 100%; width: ${memory}%; transition: width 0.5s;\"></div>\n              </div>\n            </div>\n            <div style=\"font-size: 10px; color: #999; margin-top: 8px;\">\n              Updated ${counter} times ‚Ä¢ Last: ${new Date().toLocaleTimeString()}\n            </div>\n          </div>\n        `;\n      }\n    };\n\n    // Initial render\n    updateLiveData();\n\n    // Poll every 2 seconds\n    const intervalId = window.setInterval(updateLiveData, 2000);\n\n    // Store interval ID for cleanup\n    this.intervalIds.set(itemId, intervalId);\n  }\n}\n","@import '../../global/variables';\n\n/* Grid Builder App - Root Component Styles */\n\n// Error Notification\n.error-notification {\n  position: fixed;\n  z-index: $z-index-tooltip;\n  top: $spacing-xl;\n  left: 50%;\n  transform: translateX(-50%);\n  display: flex;\n  align-items: center;\n  gap: $spacing-md;\n  padding: $spacing-lg $spacing-xl;\n  border-radius: $border-radius-md;\n  background: $color-danger;\n  color: white;\n  box-shadow: $shadow-lg;\n  animation: slideDown 0.3s ease;\n\n  .error-icon {\n    font-size: $font-size-lg;\n  }\n\n  .error-text {\n    flex: 1;\n    font-size: $font-size-sm;\n    font-weight: $font-weight-medium;\n  }\n\n  .error-dismiss {\n    padding: 0;\n    border: none;\n    background: transparent;\n    color: white;\n    cursor: pointer;\n    font-size: $font-size-xl;\n    line-height: 1;\n    opacity: 0.8;\n    transition: opacity $transition-fast;\n\n    &:hover {\n      opacity: 1;\n    }\n  }\n}\n\n@keyframes slideDown {\n  from {\n    opacity: 0;\n    transform: translateX(-50%) translateY(-20px);\n  }\n  to {\n    opacity: 1;\n    transform: translateX(-50%) translateY(0);\n  }\n}\n\n* {\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n\nbody {\n  overflow: hidden;\n  height: 100vh;\n  background: #f5f5f5;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n}\n\n.app {\n  display: flex;\n  height: 100vh;\n}\n\n/* Main Canvas */\n.canvas {\n  position: relative;\n  overflow: auto;\n  flex: 1;\n  padding: 20px;\n}\n\n.canvas-header {\n  padding: 15px 20px;\n  border-radius: 4px;\n  margin-bottom: 20px;\n  background: white;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 5%);\n}\n\n.canvas-header h1 {\n  margin-bottom: 10px;\n  color: #333;\n  font-size: 24px;\n}\n\n.canvas-header p {\n  margin-bottom: 15px;\n  color: #666;\n}\n\n/* Controls */\n.controls {\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n  gap: 10px;\n}\n\n.controls button {\n  padding: 8px 16px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  background: white;\n  cursor: pointer;\n  font-size: 14px;\n  transition: all 0.2s;\n}\n\n.controls button:hover {\n  border-color: #4a90e2;\n  background: #f5f5f5;\n}\n\n.controls button.active {\n  border-color: #4a90e2;\n  background: #4a90e2;\n  color: white;\n}\n\n/* Viewport Toggle */\n.viewport-toggle {\n  display: flex;\n  overflow: hidden;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  gap: 5px;\n}\n\n.viewport-btn {\n  padding: 8px 16px;\n  border: none;\n  background: white;\n  cursor: pointer;\n  font-size: 14px;\n  transition: all 0.2s;\n}\n\n.viewport-btn:hover {\n  background: #f5f5f5;\n}\n\n.viewport-btn.active {\n  background: #4a90e2;\n  color: white;\n}\n\n/* Version Switcher */\n.version-switcher {\n  display: flex;\n  align-items: center;\n  margin-left: auto;\n  gap: 8px;\n}\n\n.version-switcher-label {\n  color: #666;\n  font-size: 12px;\n  font-weight: 500;\n}\n\n.version-switcher select {\n  padding: 6px 12px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  background: white;\n  cursor: pointer;\n  font-size: 13px;\n}\n\n/* Canvases Container */\n.canvases-container {\n  display: flex;\n  flex-direction: column;\n  gap: 0;\n}\n\n/* Mobile View */\n.canvases-container.mobile-view {\n  max-width: 375px;\n  margin: 0 auto;\n  box-shadow: 0 0 20px rgba(0, 0, 0, 10%);\n}\n","/**\n * Grid Builder App - Main Application Component\n * ==============================================\n *\n * Root application component coordinating multi-section page builder with drag-and-drop,\n * undo/redo, keyboard shortcuts, and responsive viewport switching. Serves as the central\n * orchestrator for all user interactions and state management.\n *\n * ## Problem\n *\n * Visual page builders need a central coordination point that:\n * - Manages global keyboard shortcuts (undo/redo, delete, arrow keys)\n * - Coordinates events between decoupled components (palette, canvas, items)\n * - Provides UI controls for viewport switching, grid toggle, export\n * - Initializes global dependencies (interact.js, VirtualRenderer)\n * - Handles error notifications and user feedback\n * - Manages section addition and stress testing\n *\n * **Without root coordinator**:\n * - Keyboard shortcuts scattered across components\n * - Event handling duplicated everywhere\n * - No consistent error handling\n * - Difficult to test interactions\n * - Global state mutations untracked\n *\n * ## Solution\n *\n * Centralized app component providing:\n * 1. **Global event orchestration**: @Listen decorators for custom events\n * 2. **Keyboard handler**: Unified keyboard shortcut system\n * 3. **Error notifications**: Centralized error display with auto-dismiss\n * 4. **Viewport switching**: Desktop/mobile mode with automatic re-layout\n * 5. **State export**: Debug functionality for state inspection\n * 6. **Stress testing**: Performance testing with bulk item creation\n * 7. **Lifecycle initialization**: Setup interact.js, VirtualRenderer, PerformanceMonitor\n *\n * ## Architecture: Coordinator Pattern\n *\n * **Component hierarchy**:\n * ```\n * <grid-builder-app>\n *   ‚îú‚îÄ‚îÄ Error Notification (conditional)\n *   ‚îú‚îÄ‚îÄ <component-palette>\n *   ‚îú‚îÄ‚îÄ Canvas Header (controls + viewport toggle)\n *   ‚îú‚îÄ‚îÄ Canvases Container\n *   ‚îÇ   ‚îî‚îÄ‚îÄ <canvas-section> √ó N\n *   ‚îÇ       ‚îî‚îÄ‚îÄ <grid-item-wrapper> √ó M\n *   ‚îî‚îÄ‚îÄ <config-panel>\n * ```\n *\n * **Event flow (decoupled architecture)**:\n * ```\n * 1. Palette emits drag clone\n * 2. Canvas detects drop ‚Üí dispatches 'canvas-drop' event\n * 3. App handles event ‚Üí creates GridItem ‚Üí pushes undo command\n * 4. State updates ‚Üí components re-render\n * ```\n *\n * **Why @Listen decorators**:\n * - Decouples child components from app logic\n * - Testable (can dispatch custom events in tests)\n * - Follows web component best practices\n * - Clean separation of concerns\n *\n * ## Global Event Coordination\n *\n * **Three custom events handled**:\n *\n * ### 1. canvas-drop (New Item Creation)\n * ```typescript\n * @Listen('canvas-drop', { target: 'document' })\n * handleCanvasDrop(event: CustomEvent) {\n *   const { canvasId, componentType, x, y } = event.detail;\n *   // Convert pixels to grid units\n *   // Create GridItem with default size (10√ó6 units)\n *   // Add to canvas state\n *   // Push AddItemCommand for undo\n * }\n * ```\n *\n * **Flow**: Palette drag ‚Üí Canvas dropzone ‚Üí Dispatch event ‚Üí App creates item\n *\n * ### 2. item-delete (Item Deletion)\n * ```typescript\n * @Listen('item-delete', { target: 'document' })\n * handleItemDelete(event: CustomEvent) {\n *   const { itemId, canvasId } = event.detail;\n *   // Find item and index\n *   // Push DeleteItemCommand (BEFORE deletion)\n *   // Remove from state\n * }\n * ```\n *\n * **Flow**: Grid item delete button ‚Üí Dispatch event ‚Üí App removes item with undo\n *\n * ### 3. canvas-move (Cross-Canvas Move)\n * ```typescript\n * @Listen('canvas-move', { target: 'document' })\n * handleCanvasMove(event: CustomEvent) {\n *   const { itemId, sourceCanvasId, targetCanvasId, x, y } = event.detail;\n *   // Convert pixels to grid units\n *   // Capture source/target positions\n *   // Push MoveItemCommand\n *   // Move item between canvases\n * }\n * ```\n *\n * **Flow**: Drag item across canvas ‚Üí Canvas detects ‚Üí Dispatch event ‚Üí App moves item\n *\n * ## Keyboard Shortcut System\n *\n * **Refactored architecture**: Single handleKeyboard ‚Üí delegates to specialized handlers\n *\n * **Handler chain pattern**:\n * ```typescript\n * handleKeyboard(e) {\n *   if (handleArrowKeys(e)) return;    // Nudge selected item\n *   if (handleUndoRedo(e)) return;     // Ctrl+Z / Ctrl+Y\n *   if (handleDelete(e)) return;       // Delete / Backspace\n *   if (handleEscape(e)) return;       // Clear selection\n * }\n * ```\n *\n * **Why early return pattern**:\n * - Each handler returns boolean (true = handled)\n * - First matching handler processes event\n * - Cleaner than nested if/else\n * - Easy to add new shortcuts\n * - Testable handlers\n *\n * **Keyboard shortcuts**:\n * - `‚Üë ‚Üì ‚Üê ‚Üí` - Nudge selected item (1 unit, or 10 with Shift)\n * - `Ctrl+Z` / `Cmd+Z` - Undo\n * - `Ctrl+Y` / `Cmd+Shift+Z` - Redo\n * - `Delete` / `Backspace` - Delete selected item\n * - `Escape` - Clear selection\n *\n * ## Viewport Switching\n *\n * **Desktop ‚Üî Mobile toggle**:\n * ```typescript\n * handleViewportChange(viewport) {\n *   gridState.currentViewport = viewport;\n *   // Triggers re-render of all grid-item-wrapper components\n *   // Each wrapper selects appropriate layout (desktop or mobile)\n *   // Grid calculations cached per canvas (single DOM read)\n *   // StencilJS batches all style updates (single reflow)\n * }\n * ```\n *\n * **Performance optimization**:\n * - With 100 items: Only 1 DOM read per canvas (not 100+)\n * - All position updates batched by StencilJS\n * - Single reflow for entire viewport switch\n * - ~50-100ms for 100 items (very responsive)\n *\n * **Mobile auto-layout**:\n * - Items without customized mobile layout stack vertically\n * - Full width (50 units = 100%)\n * - Handled by grid-item-wrapper.tsx (not here)\n * - App just switches viewport flag\n *\n * ## Error Notification System\n *\n * **State-driven notifications**:\n * ```typescript\n * @State() showErrorHeading: boolean = false;\n * @State() errorHeadingText: string = '';\n *\n * try {\n *   // Operation that might fail\n * } catch (e) {\n *   this.showErrorHeading = true;\n *   this.errorHeadingText = `Error: ${e.message}`;\n *   setTimeout(() => this.showErrorHeading = false, 5000);\n * }\n * ```\n *\n * **Auto-dismiss pattern**:\n * - Error shown for 5 seconds\n * - User can manually dismiss with √ó button\n * - Non-blocking (doesn't prevent other interactions)\n * - Prevents error spam (one at a time)\n *\n * **Error notification UI**:\n * - Fixed position at top of viewport\n * - Warning icon (‚ö†Ô∏è) + error text + dismiss button\n * - Yellow/amber color scheme for warnings\n *\n * ## Item Count Tracking\n *\n * **Reactive count display**:\n * ```typescript\n * @State() itemCount: number = 0;\n *\n * updateItemCount() {\n *   this.itemCount = Object.values(gridState.canvases)\n *     .reduce((sum, canvas) => sum + canvas.items.length, 0);\n * }\n * ```\n *\n * **Called from**:\n * - componentWillLoad (initial count)\n * - componentWillUpdate (every state change)\n * - Ensures count always accurate\n *\n * **Why reduce pattern**:\n * - Sums items across all canvases\n * - Single operation (no loops)\n * - Functional programming style\n *\n * ## Stress Test Implementation\n *\n * **Bulk item creation for performance testing**:\n * ```typescript\n * handleStressTest() {\n *   const count = parseInt(prompt('How many items? (1-1000)'));\n *   for (let i = 0; i < count; i++) {\n *     // Random component type\n *     // Random canvas\n *     // Random position\n *     addItemToCanvas(canvasId, newItem);\n *   }\n *   gridState.canvases = { ...gridState.canvases };  // Single update\n * }\n * ```\n *\n * **Performance optimization**:\n * - All items added to state first\n * - Single reactivity trigger at end\n * - No undo commands (would bloat history)\n * - Tests render performance with many items\n *\n * **Use cases**:\n * - Test virtual rendering (lazy loading)\n * - Test grid calculation caching\n * - Test transform-based positioning\n * - Identify performance bottlenecks\n *\n * ## Global Initialization\n *\n * **componentDidLoad setup**:\n * ```typescript\n * componentDidLoad() {\n *   // 1. Expose interact.js globally\n *   (window as any).interact = interact;\n *\n *   // 2. Initialize VirtualRenderer for lazy loading\n *   (window as any).virtualRenderer = new VirtualRenderer();\n *\n *   // 3. Initialize PerformanceMonitor (if available)\n *   (window as any).perfMonitor = new PerformanceMonitor();\n *\n *   // 4. Add keyboard event listener\n *   document.addEventListener('keydown', handleKeyboard);\n *\n *   // 5. Debug helper for inspect.js debugging\n *   (window as any).debugInteractables = () => { ... };\n * }\n * ```\n *\n * **Why global initialization**:\n * - Child components load after app\n * - Need interact.js before drag handlers initialize\n * - VirtualRenderer must exist before items observe\n * - Keyboard shortcuts global (not component-specific)\n *\n * ## State Export Feature\n *\n * **Debug functionality**:\n * ```typescript\n * handleExportState() {\n *   const state = {\n *     canvases: gridState.canvases,\n *     currentViewport: gridState.currentViewport,\n *     timestamp: new Date().toISOString()\n *   };\n *   console.log('Grid State:', state);\n * }\n * ```\n *\n * **Use cases**:\n * - Debugging layout issues\n * - Inspecting item positions\n * - Saving/loading layouts (future feature)\n * - Reporting bugs with state snapshot\n *\n * ## Performance Characteristics\n *\n * **Viewport switch (100 items)**: ~50-100ms\n * - 1 DOM read per canvas (grid size)\n * - 100 position calculations (cached)\n * - 1 reflow (batched writes)\n *\n * **Stress test (1000 items)**: ~200-500ms\n * - Single state update\n * - Virtual rendering reduces initial load\n * - Only visible items rendered\n *\n * **Keyboard shortcuts**: <5ms\n * - Direct state mutations\n * - No layout recalculation\n * - Immediate visual feedback\n *\n * **Error notifications**: ~1ms\n * - State update triggers render\n * - Fixed position (no reflow)\n * - Auto-dismiss with setTimeout\n *\n * ## Extracting This Pattern\n *\n * To adapt app coordinator pattern for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * export function App() {\n *   // 1. Setup global event listeners\n *   useEffect(() => {\n *     const handleDrop = (e) => {\n *       // Create item from drop event\n *       addItem(e.detail.type, e.detail.x, e.detail.y);\n *     };\n *     document.addEventListener('canvas-drop', handleDrop);\n *     return () => document.removeEventListener('canvas-drop', handleDrop);\n *   }, []);\n *\n *   // 2. Setup keyboard shortcuts\n *   useEffect(() => {\n *     const handleKeyboard = (e) => {\n *       if (e.key === 'Delete') deleteSelected();\n *       if (e.ctrlKey && e.key === 'z') undo();\n *     };\n *     document.addEventListener('keydown', handleKeyboard);\n *     return () => document.removeEventListener('keydown', handleKeyboard);\n *   }, []);\n *\n *   // 3. Render app structure\n *   return (\n *     <div>\n *       <Palette />\n *       {canvases.map(canvas => <Canvas key={canvas.id} {...canvas} />)}\n *       <ConfigPanel />\n *     </div>\n *   );\n * }\n * ```\n *\n * **For different frameworks**:\n * - **React**: Use useEffect for lifecycle, custom hooks for shortcuts\n * - **Vue**: Use onMounted/onUnmounted, composables for shortcuts\n * - **Angular**: Use ngOnInit/ngOnDestroy, services for shortcuts\n *\n * **Key patterns to preserve**:\n * 1. Centralized event coordination (custom events bubble to app)\n * 2. Keyboard shortcut delegation (handler chain pattern)\n * 3. Global initialization before children mount\n * 4. Error notification state management\n * 5. Cleanup in unmount/disconnected callback\n *\n * @module grid-builder-app\n */\n\n// External libraries (alphabetical)\nimport { Component, h, Host, Listen, State } from '@stencil/core';\nimport interact from 'interactjs';\n\n// Internal imports (alphabetical)\nimport { componentTemplates } from '../../data/component-templates';\nimport { addItemToCanvas, generateItemId, gridState, removeItemFromCanvas } from '../../services/state-manager';\nimport { pushCommand, redo, undo } from '../../services/undo-redo';\nimport { AddItemCommand, DeleteItemCommand, MoveItemCommand } from '../../services/undo-redo-commands';\nimport { pixelsToGridX, pixelsToGridY } from '../../utils/grid-calculations';\nimport { VirtualRenderer } from '../../utils/virtual-rendering';\n\n/**\n * GridBuilderApp Component\n * =========================\n *\n * StencilJS root component providing app coordination and global event handling.\n *\n * **Tag**: `<grid-builder-app>`\n * **Shadow DOM**: Disabled (required for interact.js compatibility)\n * **Lifecycle**: Standard StencilJS (componentWillLoad ‚Üí componentDidLoad ‚Üí render ‚Üí disconnectedCallback)\n */\n@Component({\n  tag: 'grid-builder-app',\n  styleUrl: 'grid-builder-app.scss',\n  shadow: false, // Use light DOM for compatibility with interact.js\n})\nexport class GridBuilderApp {\n  /**\n   * Item count across all canvases (reactive display)\n   *\n   * **Updated in**: componentWillLoad, componentWillUpdate\n   * **Calculated by**: updateItemCount() using reduce\n   * **Displayed in**: Canvas header controls\n   */\n  @State() itemCount: number = 0;\n\n  /**\n   * Error notification visibility flag\n   *\n   * **Managed by**: try/catch blocks in event handlers\n   * **Auto-dismisses**: After 5 seconds via setTimeout\n   * **Manual dismiss**: User clicks √ó button\n   */\n  @State() showErrorHeading: boolean = false;\n\n  /**\n   * Error message text\n   *\n   * **Set by**: catch blocks with e.message\n   * **Displayed in**: Error notification banner\n   * **Format**: \"Error: [error message]\"\n   */\n  @State() errorHeadingText: string = '';\n\n  /**\n   * Component will load lifecycle hook\n   *\n   * **Called**: Before first render\n   * **Purpose**: Expose globals before child components load\n   *\n   * **Critical initialization**:\n   * - Expose interact.js to window (required by grid-item-wrapper)\n   * - Calculate initial item count\n   *\n   * **Why expose interact.js**:\n   * - Child components (grid-item-wrapper) initialize drag/resize handlers in componentDidLoad\n   * - Handlers need interact to be available immediately\n   * - Cannot use ES6 imports in handlers (interact.js uses UMD)\n   * - Global window.interact ensures availability\n   *\n   * **Order matters**:\n   * - componentWillLoad runs before child components mount\n   * - Guarantees interact available when children need it\n   */\n  componentWillLoad() {\n    // Expose interact to global scope before child components load\n    // This ensures drag/resize handlers in grid-item-wrapper can initialize\n    (window as any).interact = interact;\n\n    // Initial item count\n    this.updateItemCount();\n  }\n\n  /**\n   * Component will update lifecycle hook\n   *\n   * **Called**: Before each re-render\n   * **Purpose**: Update item count when state changes\n   *\n   * **Why needed**:\n   * - State changes may add/remove items\n   * - Item count display must stay accurate\n   * - Runs before every render to ensure fresh data\n   *\n   * **Delegates to**: updateItemCount()\n   * - Calculates total items across all canvases\n   * - Uses reduce pattern for efficiency\n   * - Updates @State() itemCount (triggers display update)\n   */\n  componentWillUpdate() {\n    // Update item count when state changes\n    this.updateItemCount();\n  }\n\n  /**\n   * Component did load lifecycle hook\n   *\n   * **Called**: After first render (DOM available)\n   * **Purpose**: Initialize global dependencies and keyboard shortcuts\n   *\n   * ## Global Initialization Sequence\n   *\n   * **1. Update item count**:\n   * ```typescript\n   * this.updateItemCount();  // Initial count display\n   * ```\n   *\n   * **2. Initialize PerformanceMonitor** (optional):\n   * ```typescript\n   * if ((window as any).PerformanceMonitor) {\n   *   (window as any).perfMonitor = new (window as any).PerformanceMonitor('stencil');\n   * }\n   * ```\n   * - From shared library (may not be present)\n   * - Tracks render performance metrics\n   * - Helps identify bottlenecks\n   * - 'stencil' tag for variant identification\n   *\n   * **3. Initialize VirtualRenderer**:\n   * ```typescript\n   * (window as any).virtualRenderer = new VirtualRenderer();\n   * ```\n   * - Global singleton for lazy component loading\n   * - Used by grid-item-wrapper for complex components\n   * - Must exist before items mount\n   * - Reduces initial render cost\n   *\n   * **4. Add debugInteractables helper**:\n   * ```typescript\n   * (window as any).debugInteractables = () => { ... };\n   * ```\n   * - Console helper for debugging interact.js\n   * - Lists all active interactables (drag/resize/dropzone)\n   * - Shows configuration and state\n   * - Useful for troubleshooting drag/drop issues\n   *\n   * **5. Setup keyboard shortcuts**:\n   * ```typescript\n   * document.addEventListener('keydown', this.handleKeyboard);\n   * ```\n   * - Global keyboard handler for all shortcuts\n   * - Handles undo/redo, delete, arrow keys, escape\n   * - Document-level (works anywhere in app)\n   * - Cleanup in disconnectedCallback\n   *\n   * ## Why Global Initialization Here\n   *\n   * - **After DOM available**: Ensures elements exist for event listeners\n   * - **Before child interactions**: Dependencies ready when children need them\n   * - **One-time setup**: Doesn't re-run on re-renders\n   * - **Centralized**: Single point of initialization\n   *\n   * ## Order Matters\n   *\n   * 1. VirtualRenderer must exist before grid-item-wrapper components mount\n   * 2. Keyboard listener must be attached before user interactions\n   * 3. PerformanceMonitor should start early to capture full lifecycle\n   * 4. Debug helpers can be added any time\n   */\n  componentDidLoad() {\n    // Initialize item count\n    this.updateItemCount();\n\n    // Initialize performance monitor (from shared library)\n    if ((window as any).PerformanceMonitor) {\n      (window as any).perfMonitor = new (window as any).PerformanceMonitor('stencil');\n    }\n\n    // Initialize global VirtualRenderer for lazy-loading complex components\n    (window as any).virtualRenderer = new VirtualRenderer();\n\n    // Add debug helper to inspect all interactables\n    (window as any).debugInteractables = () => {\n      const interactables = (interact as any).interactables.list;\n      console.log('Total interactables:', interactables.length);\n      interactables.forEach((interactable: any, index: number) => {\n        console.log(`Interactable ${index}:`, {\n          target: interactable.target,\n          actions: interactable._actions,\n          options: interactable.options,\n        });\n      });\n    };\n\n    // Set up keyboard shortcuts\n    document.addEventListener('keydown', this.handleKeyboard);\n  }\n\n  /**\n   * Disconnected callback (cleanup)\n   *\n   * **Called**: When component removed from DOM\n   * **Purpose**: Remove keyboard event listener\n   *\n   * **Why needed**:\n   * - Prevents memory leaks\n   * - Removes document-level event listener\n   * - Standard cleanup pattern\n   *\n   * **What if skipped**:\n   * - Listener remains active even after unmount\n   * - Multiple listeners accumulate on remount\n   * - Memory leak (~1-5KB per unmount)\n   * - Potential errors accessing unmounted component\n   */\n  disconnectedCallback() {\n    document.removeEventListener('keydown', this.handleKeyboard);\n  }\n\n  /**\n   * Handle canvas drop event (create new item)\n   *\n   * **Triggered by**: canvas-section dispatches 'canvas-drop' when palette item dropped\n   * **Purpose**: Create new grid item from component type and add to canvas\n   *\n   * ## Event Flow\n   *\n   * ```\n   * 1. User drags component from palette\n   * 2. User drops on canvas\n   * 3. Canvas calculates drop position (pixels)\n   * 4. Canvas dispatches 'canvas-drop' event\n   * 5. App receives event (this handler)\n   * 6. App creates GridItem from template\n   * 7. App adds item to state\n   * 8. App pushes undo command\n   * 9. Canvas re-renders with new item\n   * ```\n   *\n   * ## Event Detail Structure\n   *\n   * ```typescript\n   * {\n   *   canvasId: string,      // Which canvas received the drop\n   *   componentType: string, // Component type from data-component-type\n   *   x: number,             // Drop position in pixels (relative to canvas)\n   *   y: number              // Drop position in pixels (relative to canvas)\n   * }\n   * ```\n   *\n   * ## Item Creation Process\n   *\n   * **1. Validate component type**:\n   * ```typescript\n   * const template = componentTemplates[componentType];\n   * if (!template) throw new Error(`Unknown component type`);\n   * ```\n   *\n   * **2. Convert pixels to grid units**:\n   * ```typescript\n   * const gridX = pixelsToGridX(x, canvasId);  // Responsive conversion\n   * const gridY = pixelsToGridY(y);            // Fixed conversion\n   * ```\n   *\n   * **3. Get canvas for z-index**:\n   * ```typescript\n   * const canvas = gridState.canvases[canvasId];\n   * const zIndex = canvas.zIndexCounter++;  // Monotonic increment\n   * ```\n   *\n   * **4. Create GridItem object**:\n   * ```typescript\n   * const newItem = {\n   *   id: generateItemId(),     // Unique ID\n   *   canvasId,                 // Which canvas\n   *   type: componentType,      // Component type (header, text, etc.)\n   *   name: template.title,     // Display name from template\n   *   layouts: {\n   *     desktop: { x, y, width: 10, height: 6 },  // Default size\n   *     mobile: { x: null, y: null, width: null, height: null, customized: false }\n   *   },\n   *   zIndex: canvas.zIndexCounter++\n   * };\n   * ```\n   *\n   * **5. Add to canvas**:\n   * ```typescript\n   * addItemToCanvas(canvasId, newItem);  // Helper function\n   * ```\n   *\n   * **6. Push undo command**:\n   * ```typescript\n   * pushCommand(new AddItemCommand(canvasId, newItem));\n   * ```\n   *\n   * **7. Trigger reactivity**:\n   * ```typescript\n   * gridState.canvases = { ...gridState.canvases };  // New object reference\n   * ```\n   *\n   * ## Default Item Sizing\n   *\n   * - **Width**: 10 grid units (20% of canvas width with 2% per unit)\n   * - **Height**: 6 grid units (120px with 20px per unit)\n   * - **Mobile**: Not customized (will auto-layout full-width stacked)\n   *\n   * ## Error Handling\n   *\n   * **Try/catch pattern**:\n   * ```typescript\n   * try {\n   *   // Item creation logic\n   * } catch (e) {\n   *   this.showErrorHeading = true;\n   *   this.errorHeadingText = `Error adding component: ${e.message}`;\n   *   setTimeout(() => this.showErrorHeading = false, 5000);\n   * }\n   * ```\n   *\n   * **Error scenarios**:\n   * - Unknown component type (invalid data-component-type)\n   * - Canvas not found (invalid canvasId)\n   * - State mutation error (canvas items not array)\n   *\n   * **User feedback**:\n   * - Error banner at top of app\n   * - Auto-dismisses after 5 seconds\n   * - Manual dismiss with √ó button\n   *\n   * ## Undo Support\n   *\n   * **AddItemCommand**:\n   * - Stores canvasId and item snapshot\n   * - Undo: Removes item from canvas\n   * - Redo: Re-adds item at same position\n   * - Preserves z-index and all properties\n   *\n   * @param event - CustomEvent with canvas drop details\n   *\n   * @example\n   * ```typescript\n   * // User drops header component at (100, 200) on canvas1\n   * handleCanvasDrop({\n   *   detail: {\n   *     canvasId: 'canvas1',\n   *     componentType: 'header',\n   *     x: 100,  // pixels\n   *     y: 200   // pixels\n   *   }\n   * })\n   * // ‚Üí gridX = 5 units (100px √∑ 20px per unit at 2%)\n   * // ‚Üí gridY = 10 units (200px √∑ 20px per unit)\n   * // ‚Üí Creates item: { x: 5, y: 10, width: 10, height: 6 }\n   * // ‚Üí Item appears on canvas, undo available\n   * ```\n   */\n  @Listen('canvas-drop', { target: 'document' })\n  handleCanvasDrop(event: CustomEvent) {\n    const { canvasId, componentType, x, y } = event.detail;\n\n    try {\n      // Get template for the component type\n      const template = componentTemplates[componentType];\n      if (!template) {\n        throw new Error(`Unknown component type: ${componentType}`);\n      }\n\n      // Convert pixel coordinates to grid units\n      const gridX = pixelsToGridX(x, canvasId);\n      const gridY = pixelsToGridY(y);\n\n      // Get canvas to determine next z-index\n      const canvas = gridState.canvases[canvasId];\n      if (!canvas) {\n        throw new Error(`Canvas not found: ${canvasId}`);\n      }\n\n      // Create new item\n      const newItem = {\n        id: generateItemId(),\n        canvasId,\n        type: componentType,\n        name: template.title,\n        layouts: {\n          desktop: {\n            x: gridX,\n            y: gridY,\n            width: 10, // Default 10 grid units wide\n            height: 6, // Default 6 grid units tall\n          },\n          mobile: {\n            x: null,\n            y: null,\n            width: null,\n            height: null,\n            customized: false,\n          },\n        },\n        zIndex: canvas.zIndexCounter++,\n      };\n\n      // Add item to canvas\n      addItemToCanvas(canvasId, newItem);\n\n      // Push undo command\n      pushCommand(new AddItemCommand(canvasId, newItem));\n\n      // Trigger update\n      gridState.canvases = { ...gridState.canvases };\n    } catch (e) {\n      this.showErrorHeading = true;\n      this.errorHeadingText = `Error adding component: ${e.message || e}`;\n      setTimeout(() => {\n        this.showErrorHeading = false;\n      }, 5000); // Auto-dismiss after 5 seconds\n    }\n  }\n\n  /**\n   * Handle item delete event\n   *\n   * **Triggered by**: grid-item-wrapper dispatches 'item-delete' when delete button clicked\n   * **Purpose**: Remove item from canvas with undo support\n   *\n   * ## Event Flow\n   *\n   * ```\n   * 1. User clicks delete button (√ó) on grid item\n   * 2. grid-item-wrapper dispatches 'item-delete' event\n   * 3. App receives event (this handler)\n   * 4. App finds item and captures state for undo\n   * 5. App pushes DeleteItemCommand\n   * 6. App removes item from canvas\n   * 7. Item disappears, undo available\n   * ```\n   *\n   * ## Event Detail Structure\n   *\n   * ```typescript\n   * {\n   *   itemId: string,    // ID of item to delete\n   *   canvasId: string   // Which canvas contains the item\n   * }\n   * ```\n   *\n   * ## Deletion Process\n   *\n   * **1. Find canvas**:\n   * ```typescript\n   * const canvas = gridState.canvases[canvasId];\n   * if (!canvas) return;  // Safety check\n   * ```\n   *\n   * **2. Find item and index**:\n   * ```typescript\n   * const itemIndex = canvas.items.findIndex(i => i.id === itemId);\n   * const item = canvas.items[itemIndex];\n   * if (!item) return;  // Item not found\n   * ```\n   *\n   * **Why capture index**:\n   * - Undo needs to restore item at same position\n   * - Preserves z-index stacking order\n   * - Critical for undo accuracy\n   *\n   * **3. Push undo command BEFORE deletion**:\n   * ```typescript\n   * pushCommand(new DeleteItemCommand(canvasId, item, itemIndex));\n   * ```\n   *\n   * **Why before**:\n   * - Command needs item data\n   * - After deletion, item is gone\n   * - Undo restores exact snapshot\n   *\n   * **4. Remove item**:\n   * ```typescript\n   * removeItemFromCanvas(canvasId, itemId);\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   *\n   * **removeItemFromCanvas helper**:\n   * - Filters item from items array\n   * - Also clears selection if item was selected\n   * - Defined in state-manager.ts\n   *\n   * ## Undo Support\n   *\n   * **DeleteItemCommand**:\n   * - Stores canvasId, item snapshot, and original index\n   * - Undo: Re-inserts item at original index\n   * - Redo: Removes item again\n   * - Preserves position, size, z-index, all properties\n   *\n   * ## Why Separate from Keyboard Delete\n   *\n   * **Two deletion paths**:\n   * 1. Button click ‚Üí This handler (via event)\n   * 2. Delete key ‚Üí handleDeleteSelected (directly)\n   *\n   * **Why split**:\n   * - Button: Specific item (from event detail)\n   * - Keyboard: Currently selected item (from gridState)\n   * - Different data sources, same operation\n   *\n   * @param event - CustomEvent with item delete details\n   *\n   * @example\n   * ```typescript\n   * // User clicks delete on item-3 in canvas1\n   * handleItemDelete({\n   *   detail: {\n   *     itemId: 'item-3',\n   *     canvasId: 'canvas1'\n   *   }\n   * })\n   * // ‚Üí Finds item at index 2\n   * // ‚Üí Pushes DeleteItemCommand(canvas1, item-3, index: 2)\n   * // ‚Üí Removes item from state\n   * // ‚Üí Item disappears, undo available\n   * ```\n   */\n  @Listen('item-delete', { target: 'document' })\n  handleItemDelete(event: CustomEvent) {\n    const { itemId, canvasId } = event.detail;\n\n    // Find the item and its index before deletion\n    const canvas = gridState.canvases[canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const itemIndex = canvas.items.findIndex((i) => i.id === itemId);\n    const item = canvas.items[itemIndex];\n    if (!item) {\n      return;\n    }\n\n    // Push undo command before deleting\n    pushCommand(new DeleteItemCommand(canvasId, item, itemIndex));\n\n    // Delete the item\n    removeItemFromCanvas(canvasId, itemId);\n    gridState.canvases = { ...gridState.canvases };\n  }\n\n  /**\n   * Handle canvas move event (cross-canvas drag)\n   *\n   * **Triggered by**: canvas-section dispatches 'canvas-move' when item dragged to different canvas\n   * **Purpose**: Move item between canvases with undo support\n   *\n   * ## Event Flow\n   *\n   * ```\n   * 1. User drags item from canvas A\n   * 2. User drops on canvas B\n   * 3. Canvas B detects sourceCanvasId !== targetCanvasId\n   * 4. Canvas B dispatches 'canvas-move' event\n   * 5. App receives event (this handler)\n   * 6. App captures source/target positions\n   * 7. App pushes MoveItemCommand\n   * 8. App moves item between canvases\n   * 9. Both canvases re-render\n   * ```\n   *\n   * ## Event Detail Structure\n   *\n   * ```typescript\n   * {\n   *   itemId: string,           // ID of item being moved\n   *   sourceCanvasId: string,   // Original canvas\n   *   targetCanvasId: string,   // Destination canvas\n   *   x: number,                // Drop position in pixels (relative to target)\n   *   y: number                 // Drop position in pixels (relative to target)\n   * }\n   * ```\n   *\n   * ## Move Process\n   *\n   * **1. Find item in source canvas**:\n   * ```typescript\n   * const sourceCanvas = gridState.canvases[sourceCanvasId];\n   * const sourceIndex = sourceCanvas.items.findIndex(i => i.id === itemId);\n   * const item = sourceCanvas.items[sourceIndex];\n   * if (!item) return;\n   * ```\n   *\n   * **2. Capture source position** (before changes):\n   * ```typescript\n   * const sourcePosition = {\n   *   x: item.layouts.desktop.x,\n   *   y: item.layouts.desktop.y\n   * };\n   * ```\n   *\n   * **Why capture**:\n   * - Undo needs original position\n   * - Before mutation occurs\n   * - Exact restoration on undo\n   *\n   * **3. Convert drop position to grid units**:\n   * ```typescript\n   * const gridX = pixelsToGridX(x, targetCanvasId);\n   * const gridY = pixelsToGridY(y);\n   * ```\n   *\n   * **Why target canvas for x**:\n   * - Grid width varies by canvas\n   * - 2% per unit responsive to container\n   * - Correct conversion for target\n   *\n   * **4. Capture target position**:\n   * ```typescript\n   * const targetPosition = { x: gridX, y: gridY };\n   * ```\n   *\n   * **5. Push undo command BEFORE moving**:\n   * ```typescript\n   * pushCommand(new MoveItemCommand(\n   *   itemId,\n   *   sourceCanvasId,\n   *   targetCanvasId,\n   *   sourcePosition,\n   *   targetPosition,\n   *   sourceIndex\n   * ));\n   * ```\n   *\n   * **MoveItemCommand stores**:\n   * - Source and target canvas IDs\n   * - Source and target positions\n   * - Original array index\n   *\n   * **6. Update item properties**:\n   * ```typescript\n   * item.canvasId = targetCanvasId;\n   * item.layouts.desktop.x = gridX;\n   * item.layouts.desktop.y = gridY;\n   * ```\n   *\n   * **7. Remove from source canvas**:\n   * ```typescript\n   * sourceCanvas.items = sourceCanvas.items.filter(i => i.id !== itemId);\n   * ```\n   *\n   * **8. Add to target canvas**:\n   * ```typescript\n   * const targetCanvas = gridState.canvases[targetCanvasId];\n   * targetCanvas.items.push(item);\n   * ```\n   *\n   * **9. Trigger reactivity**:\n   * ```typescript\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   *\n   * ## Same-Canvas Moves\n   *\n   * **Not handled here**: canvas-section only dispatches event for cross-canvas\n   *\n   * **Same-canvas handled by**:\n   * - drag-handler.ts directly updates item position\n   * - No canvas coordination needed\n   * - Simpler, faster path\n   *\n   * ## Undo Support\n   *\n   * **Undo operation**:\n   * - Move item back to source canvas\n   * - Restore source position\n   * - Insert at original index\n   *\n   * **Redo operation**:\n   * - Move item to target canvas again\n   * - Restore target position\n   * - Append to target items\n   *\n   * @param event - CustomEvent with cross-canvas move details\n   *\n   * @example\n   * ```typescript\n   * // User drags item-5 from canvas1 to canvas2 at (300, 400)\n   * handleCanvasMove({\n   *   detail: {\n   *     itemId: 'item-5',\n   *     sourceCanvasId: 'canvas1',\n   *     targetCanvasId: 'canvas2',\n   *     x: 300,  // pixels relative to canvas2\n   *     y: 400   // pixels relative to canvas2\n   *   }\n   * })\n   * // ‚Üí Captures source position: { x: 10, y: 5 }\n   * // ‚Üí Converts to grid: gridX = 15, gridY = 20\n   * // ‚Üí Pushes MoveItemCommand\n   * // ‚Üí Item moves to canvas2 at (15, 20)\n   * // ‚Üí Both canvases update, undo available\n   * ```\n   */\n  @Listen('canvas-move', { target: 'document' })\n  handleCanvasMove(event: CustomEvent) {\n    const { itemId, sourceCanvasId, targetCanvasId, x, y } = event.detail;\n\n    // Find the item in the source canvas\n    const sourceCanvas = gridState.canvases[sourceCanvasId];\n    const sourceIndex = sourceCanvas.items.findIndex((i) => i.id === itemId);\n    const item = sourceCanvas.items[sourceIndex];\n\n    if (!item) {\n      return;\n    }\n\n    // Capture source position\n    const sourcePosition = {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    };\n\n    // Convert pixel position to grid units\n    const gridX = pixelsToGridX(x, targetCanvasId);\n    const gridY = pixelsToGridY(y);\n\n    // Capture target position\n    const targetPosition = {\n      x: gridX,\n      y: gridY,\n    };\n\n    // Push undo command before moving\n    pushCommand(\n      new MoveItemCommand(itemId, sourceCanvasId, targetCanvasId, sourcePosition, targetPosition, sourceIndex)\n    );\n\n    // Update item's canvas ID and position\n    item.canvasId = targetCanvasId;\n    item.layouts.desktop.x = gridX;\n    item.layouts.desktop.y = gridY;\n\n    // Remove from source canvas\n    sourceCanvas.items = sourceCanvas.items.filter((i) => i.id !== itemId);\n\n    // Add to target canvas\n    const targetCanvas = gridState.canvases[targetCanvasId];\n    targetCanvas.items.push(item);\n\n    // Trigger update\n    gridState.canvases = { ...gridState.canvases };\n  }\n\n  /**\n   * Render component template\n   *\n   * **Reactive**: Re-runs when state changes (itemCount, showErrorHeading, gridState)\n   * **Pure**: No side effects, only returns JSX\n   *\n   * ## Template Structure\n   *\n   * **Root** (`<Host>`):\n   * - Stencil component wrapper\n   * - Contains all app UI\n   *\n   * **Error notification** (conditional):\n   * - Rendered when showErrorHeading = true\n   * - Auto-dismisses after 5 seconds\n   * - Manual dismiss with √ó button\n   *\n   * **App container** (`.app`):\n   * - Component palette (sidebar)\n   * - Canvas area (main content)\n   * - Config panel (not rendered here, separate component)\n   *\n   * **Canvas header**:\n   * - Title and description\n   * - Viewport toggle (desktop/mobile)\n   * - Grid toggle button\n   * - Export state button\n   * - Add section button\n   * - Stress test button\n   * - Item count display\n   * - Version switcher dropdown\n   *\n   * **Canvases container**:\n   * - Dynamic class: `.mobile-view` when currentViewport = 'mobile'\n   * - Maps over canvasIds to render canvas-section components\n   * - Key = canvasId for efficient diffing\n   *\n   * ## Dynamic Canvas Rendering\n   *\n   * **Pattern**:\n   * ```tsx\n   * {canvasIds.map((canvasId, index) => (\n   *   <canvas-section\n   *     canvasId={canvasId}\n   *     sectionNumber={index + 1}\n   *     key={canvasId}\n   *   />\n   * ))}\n   * ```\n   *\n   * **Why index + 1**:\n   * - Section numbers user-facing (start at 1, not 0)\n   * - canvasId is technical (canvas1, canvas2)\n   * - Clearer UX (\"Section 1\" vs \"canvas1\")\n   *\n   * @returns JSX template for entire application\n   */\n  render() {\n    const canvasIds = Object.keys(gridState.canvases);\n\n    return (\n      <Host>\n        {/* Error Notification */}\n        {this.showErrorHeading && (\n          <div class=\"error-notification\">\n            <span class=\"error-icon\">‚ö†Ô∏è</span>\n            <span class=\"error-text\">{this.errorHeadingText}</span>\n            <button class=\"error-dismiss\" onClick={() => (this.showErrorHeading = false)}>\n              √ó\n            </button>\n          </div>\n        )}\n\n        <div class=\"app\">\n          {/* Component Palette */}\n          <component-palette />\n\n          {/* Main Canvas */}\n          <div class=\"canvas\">\n            <div class=\"canvas-header\">\n              <h1>Grid Builder POC - StencilJS Variant</h1>\n              <p>\n                Drag components from the palette into the page sections below. Build your page layout section by\n                section.\n              </p>\n\n              <div class=\"controls\">\n                {/* Viewport Toggle */}\n                <div class=\"viewport-toggle\">\n                  <button\n                    class={{\n                      'viewport-btn': true,\n                      active: gridState.currentViewport === 'desktop',\n                    }}\n                    onClick={() => this.handleViewportChange('desktop')}\n                  >\n                    üñ•Ô∏è Desktop\n                  </button>\n                  <button\n                    class={{\n                      'viewport-btn': true,\n                      active: gridState.currentViewport === 'mobile',\n                    }}\n                    onClick={() => this.handleViewportChange('mobile')}\n                  >\n                    üì± Mobile\n                  </button>\n                </div>\n\n                <button class={{ active: gridState.showGrid }} onClick={() => this.handleGridToggle()}>\n                  {gridState.showGrid ? 'Show Grid' : 'Hide Grid'}\n                </button>\n\n                <button onClick={() => this.handleExportState()}>Export State</button>\n\n                <button onClick={() => this.handleAddSection()}>‚ûï Add Section</button>\n\n                <button onClick={() => this.handleStressTest()}>üöÄ Stress Test</button>\n\n                {/* Item Count */}\n                <div\n                  style={{\n                    display: 'inline-flex',\n                    alignItems: 'center',\n                    gap: '6px',\n                    marginLeft: '12px',\n                    padding: '6px 12px',\n                    background: '#fff3cd',\n                    border: '1px solid #ffc107',\n                    borderRadius: '4px',\n                  }}\n                >\n                  <span style={{ fontSize: '11px', color: '#666', marginLeft: '4px' }}>{this.itemCount} items</span>\n                </div>\n\n                {/* Version Switcher */}\n                <div class=\"version-switcher\">\n                  <span class=\"version-switcher-label\">Version:</span>\n                  <select onChange={(e) => (window.location.href = (e.target as HTMLSelectElement).value)}>\n                    <option value=\"../left-top/\">Left/Top</option>\n                    <option value=\"../transform/\">Transform üß™</option>\n                    <option value=\"../masonry/\">Masonry üß™</option>\n                    <option value=\"../virtual/\">Virtual üß™</option>\n                    <option value=\"../stencil/\" selected>\n                      StencilJS üß™\n                    </option>\n                  </select>\n                </div>\n              </div>\n            </div>\n\n            {/* Canvas Sections */}\n            <div\n              class={{\n                'canvases-container': true,\n                'mobile-view': gridState.currentViewport === 'mobile',\n              }}\n            >\n              {canvasIds.map((canvasId, index) => (\n                <canvas-section canvasId={canvasId} sectionNumber={index + 1} key={canvasId} />\n              ))}\n            </div>\n          </div>\n        </div>\n\n        {/* Configuration Panel */}\n        <config-panel />\n      </Host>\n    );\n  }\n\n  /**\n   * Update item count (helper method)\n   *\n   * **Called from**: componentWillLoad, componentWillUpdate\n   * **Purpose**: Calculate total items across all canvases\n   *\n   * **Implementation**:\n   * ```typescript\n   * this.itemCount = Object.values(gridState.canvases)\n   *   .reduce((sum, canvas) => sum + canvas.items.length, 0);\n   * ```\n   *\n   * **Reduce pattern**:\n   * - Iterates over all canvases\n   * - Sums items.length from each\n   * - Single pass through canvases\n   * - Functional programming style\n   *\n   * **Why reduce**:\n   * - Clean and concise\n   * - No temporary variables\n   * - Chainable with other operations\n   * - Standard JS pattern\n   *\n   * **Updates @State()**:\n   * - Setting this.itemCount triggers re-render\n   * - Item count display updates automatically\n   * - Reactive UI pattern\n   *\n   * @private\n   */\n  private updateItemCount = () => {\n    this.itemCount = Object.values(gridState.canvases).reduce((sum, canvas) => sum + canvas.items.length, 0);\n  };\n\n  /**\n   * Handle keyboard events (main dispatcher)\n   *\n   * **Triggered by**: Document keydown event (global)\n   * **Purpose**: Route keyboard shortcuts to specialized handlers\n   *\n   * ## Handler Chain Pattern\n   *\n   * **Delegation sequence**:\n   * ```typescript\n   * if (this.handleArrowKeys(e)) return;    // 1. Arrow keys (nudge)\n   * if (this.handleUndoRedo(e)) return;     // 2. Undo/redo\n   * if (this.handleDelete(e)) return;       // 3. Delete/backspace\n   * if (this.handleEscape(e)) return;       // 4. Escape (clear selection)\n   * ```\n   *\n   * **Early return pattern**:\n   * - Each handler returns boolean (true = handled)\n   * - First matching handler processes event\n   * - Subsequent handlers skipped\n   * - Cleaner than nested if/else\n   *\n   * **Why this pattern**:\n   * - Single responsibility per handler\n   * - Easy to add new shortcuts\n   * - Testable in isolation\n   * - Clear precedence order\n   * - No code duplication\n   *\n   * **Debug logging**:\n   * ```typescript\n   * console.log('Keyboard event:', e.key, 'selectedItemId:', gridState.selectedItemId);\n   * ```\n   * - Helps debug keyboard issues\n   * - Shows which item selected\n   * - Can be removed in production\n   *\n   * ## Supported Shortcuts\n   *\n   * - **Arrow keys**: Nudge selected item (1 unit or 10 with Shift)\n   * - **Ctrl+Z / Cmd+Z**: Undo last operation\n   * - **Ctrl+Y / Cmd+Shift+Z**: Redo last undone operation\n   * - **Delete / Backspace**: Delete selected item\n   * - **Escape**: Clear selection\n   *\n   * @param e - Keyboard event from document\n   * @private\n   */\n  private handleKeyboard = (e: KeyboardEvent) => {\n    console.log('Keyboard event:', e.key, 'selectedItemId:', gridState.selectedItemId);\n\n    if (this.handleArrowKeys(e)) return;\n    if (this.handleUndoRedo(e)) return;\n    if (this.handleDelete(e)) return;\n    if (this.handleEscape(e)) return;\n  };\n\n  /**\n   * Handle arrow key events (nudge selected item)\n   *\n   * **Triggered by**: handleKeyboard when arrow key pressed\n   * **Purpose**: Move selected item by 1 or 10 units\n   *\n   * ## Validation Checks\n   *\n   * **1. Is arrow key**:\n   * ```typescript\n   * if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown' && ...) return false;\n   * ```\n   * - Returns false if not arrow key\n   * - Allows handleKeyboard to try next handler\n   *\n   * **2. Has selection**:\n   * ```typescript\n   * if (!gridState.selectedItemId || !gridState.selectedCanvasId) {\n   *   return false;  // Allow normal page scrolling\n   * }\n   * ```\n   * - Returns false if no item selected\n   * - Browser handles arrow keys normally (scroll page)\n   * - Good UX (arrows scroll when nothing selected)\n   *\n   * **3. Prevent default**:\n   * ```typescript\n   * e.preventDefault();  // Stop page scroll\n   * ```\n   * - Only called if item selected\n   * - Prevents page scroll while nudging\n   * - Arrow keys control item, not scroll\n   *\n   * ## Item Lookup\n   *\n   * **Find selected item**:\n   * ```typescript\n   * const canvas = gridState.canvases[gridState.selectedCanvasId];\n   * const item = canvas?.items.find(i => i.id === gridState.selectedItemId);\n   * if (!item) return true;\n   * ```\n   *\n   * **Returns true if not found**:\n   * - Event was arrow key, so mark as handled\n   * - Prevents default (no page scroll)\n   * - Gracefully handles invalid selection state\n   *\n   * ## Nudge Operation\n   *\n   * **Delegate to nudgeItem**:\n   * ```typescript\n   * this.nudgeItem(item, e.key, e.shiftKey);\n   * ```\n   * - Passes item, direction, and shift modifier\n   * - nudgeItem handles actual position update\n   * - Separation of concerns\n   *\n   * @param e - Keyboard event\n   * @returns true if arrow key (handled), false otherwise\n   * @private\n   */\n  private handleArrowKeys = (e: KeyboardEvent): boolean => {\n    if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown' && e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') {\n      return false;\n    }\n\n    if (!gridState.selectedItemId || !gridState.selectedCanvasId) {\n      return false; // Allow normal page scrolling\n    }\n\n    e.preventDefault();\n    console.log('Arrow key pressed, nudging item:', e.key);\n\n    const canvas = gridState.canvases[gridState.selectedCanvasId];\n    const item = canvas?.items.find((i) => i.id === gridState.selectedItemId);\n\n    if (!item) {\n      return true;\n    }\n\n    this.nudgeItem(item, e.key, e.shiftKey);\n    return true;\n  };\n\n  /**\n   * Nudge item in direction (helper for arrow keys)\n   *\n   * **Called by**: handleArrowKeys\n   * **Purpose**: Update item position by nudge amount\n   *\n   * ## Nudge Amount Calculation\n   *\n   * **Standard vs Large nudge**:\n   * ```typescript\n   * const nudgeAmount = shiftKey ? 10 : 1;  // 10 units with Shift, 1 normally\n   * ```\n   *\n   * **Why 10 with Shift**:\n   * - Large movements (20% of canvas with 2% units)\n   * - Fine control without Shift (2% of canvas)\n   * - Common UX pattern (Shift = 10√ó)\n   *\n   * ## Direction Handling\n   *\n   * **Switch statement**:\n   * ```typescript\n   * switch (key) {\n   *   case 'ArrowUp':    layout.y = Math.max(0, layout.y - nudgeAmount); break;\n   *   case 'ArrowDown':  layout.y = layout.y + nudgeAmount; break;\n   *   case 'ArrowLeft':  layout.x = Math.max(0, layout.x - nudgeAmount); break;\n   *   case 'ArrowRight': layout.x = layout.x + nudgeAmount; break;\n   * }\n   * ```\n   *\n   * **Boundary constraints**:\n   * - `Math.max(0, ...)` prevents negative positions (Up/Left)\n   * - No upper limit (can nudge beyond canvas, user's choice)\n   * - Down/Right unconstrained (allows infinite canvas)\n   *\n   * ## Viewport Awareness\n   *\n   * **Current viewport layout**:\n   * ```typescript\n   * const currentViewport = gridState.currentViewport;  // 'desktop' | 'mobile'\n   * const layout = item.layouts[currentViewport];\n   * ```\n   *\n   * **Mobile customization flag**:\n   * ```typescript\n   * if (currentViewport === 'mobile') {\n   *   item.layouts.mobile.customized = true;\n   * }\n   * ```\n   * - Marks mobile layout as customized\n   * - Prevents auto-layout from overriding\n   * - User explicitly positioned in mobile view\n   *\n   * ## State Update\n   *\n   * **Trigger reactivity**:\n   * ```typescript\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   * - Spread creates new object reference\n   * - StencilJS detects change\n   * - Components re-render with new position\n   *\n   * ## No Undo Support\n   *\n   * **Note**: Nudge operations NOT added to undo history\n   * - Too granular (1 unit moves)\n   * - Would flood undo stack\n   * - User can drag to undo if needed\n   * - Could add command aggregation if needed\n   *\n   * @param item - Grid item to nudge\n   * @param key - Arrow key direction\n   * @param shiftKey - Whether Shift modifier pressed\n   * @private\n   */\n  private nudgeItem = (item: any, key: string, shiftKey: boolean) => {\n    const currentViewport = gridState.currentViewport;\n    const layout = item.layouts[currentViewport];\n    const nudgeAmount = shiftKey ? 10 : 1;\n\n    switch (key) {\n      case 'ArrowUp':\n        layout.y = Math.max(0, layout.y - nudgeAmount);\n        break;\n      case 'ArrowDown':\n        layout.y = layout.y + nudgeAmount;\n        break;\n      case 'ArrowLeft':\n        layout.x = Math.max(0, layout.x - nudgeAmount);\n        break;\n      case 'ArrowRight':\n        layout.x = layout.x + nudgeAmount;\n        break;\n    }\n\n    if (currentViewport === 'mobile') {\n      item.layouts.mobile.customized = true;\n    }\n\n    gridState.canvases = { ...gridState.canvases };\n  };\n\n  /**\n   * Handle undo/redo keyboard shortcuts\n   *\n   * **Triggered by**: handleKeyboard when Ctrl/Cmd+Z or Ctrl/Cmd+Y pressed\n   * **Purpose**: Execute undo or redo operations\n   *\n   * ## Undo Shortcut\n   *\n   * **Pattern**:\n   * ```typescript\n   * if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n   *   e.preventDefault();\n   *   undo();\n   *   return true;\n   * }\n   * ```\n   *\n   * **Cross-platform**:\n   * - `e.ctrlKey` for Windows/Linux\n   * - `e.metaKey` for macOS (Cmd key)\n   * - Standard keyboard convention\n   *\n   * **Shift exclusion**: `!e.shiftKey`\n   * - Prevents Ctrl+Shift+Z from triggering undo\n   * - Ctrl+Shift+Z reserved for redo\n   * - Important for key combo disambiguation\n   *\n   * ## Redo Shortcuts\n   *\n   * **Two patterns supported**:\n   * ```typescript\n   * if ((e.ctrlKey || e.metaKey) && (\n   *   e.key === 'y' ||                  // Ctrl+Y (Windows)\n   *   (e.key === 'z' && e.shiftKey)     // Ctrl+Shift+Z (macOS)\n   * )) {\n   *   e.preventDefault();\n   *   redo();\n   *   return true;\n   * }\n   * ```\n   *\n   * **Why two patterns**:\n   * - Windows/Linux convention: Ctrl+Y\n   * - macOS convention: Cmd+Shift+Z\n   * - Supports both for better UX\n   * - Matches user expectations per platform\n   *\n   * ## undo/redo Functions\n   *\n   * **Imported from**: undo-redo.ts\n   * - `undo()`: Executes previous command's undo() method\n   * - `redo()`: Executes next command's redo() method\n   * - Updates undoRedoState (canUndo/canRedo)\n   * - Triggers UI button state updates\n   *\n   * **State restoration**:\n   * - Commands restore gridState.canvases\n   * - Reactivity triggers component re-renders\n   * - Items appear/disappear/move automatically\n   *\n   * @param e - Keyboard event\n   * @returns true if undo/redo shortcut, false otherwise\n   * @private\n   */\n  private handleUndoRedo = (e: KeyboardEvent): boolean => {\n    // Undo (Ctrl+Z or Cmd+Z)\n    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n      e.preventDefault();\n      undo();\n      return true;\n    }\n\n    // Redo (Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z)\n    if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n      e.preventDefault();\n      redo();\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handle delete key (delete selected item)\n   *\n   * **Triggered by**: handleKeyboard when Delete or Backspace pressed\n   * **Purpose**: Delete currently selected item\n   *\n   * ## Key Detection\n   *\n   * **Two keys supported**:\n   * ```typescript\n   * if ((e.key === 'Delete' || e.key === 'Backspace') && gridState.selectedItemId)\n   * ```\n   * - Delete key (PC keyboards)\n   * - Backspace key (Mac keyboards, some PCs)\n   * - Both trigger same operation\n   *\n   * **Selection check**:\n   * - Only proceeds if item selected\n   * - Returns false if no selection\n   * - Allows normal Backspace behavior (navigate back) when nothing selected\n   *\n   * ## Deletion Process\n   *\n   * **Prevent default**:\n   * ```typescript\n   * e.preventDefault();  // Stop browser back navigation\n   * ```\n   * - Backspace normally navigates browser back\n   * - preventDefault stops this when item selected\n   * - Only affects Backspace when used for deletion\n   *\n   * **Delegate to handleDeleteSelected**:\n   * ```typescript\n   * this.handleDeleteSelected();\n   * ```\n   * - Separate method for actual deletion logic\n   * - Shared with button click deletion (handleItemDelete)\n   * - DRY principle\n   *\n   * **Debug logging**:\n   * ```typescript\n   * console.log('Deleting item:', gridState.selectedItemId);\n   * ```\n   * - Helps debug deletion issues\n   * - Shows which item being deleted\n   * - Can be removed in production\n   *\n   * @param e - Keyboard event\n   * @returns true if delete key with selection, false otherwise\n   * @private\n   */\n  private handleDelete = (e: KeyboardEvent): boolean => {\n    if ((e.key === 'Delete' || e.key === 'Backspace') && gridState.selectedItemId) {\n      console.log('Deleting item:', gridState.selectedItemId);\n      e.preventDefault();\n      this.handleDeleteSelected();\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Handle Escape key (clear selection)\n   *\n   * **Triggered by**: handleKeyboard when Escape pressed\n   * **Purpose**: Deselect currently selected item\n   *\n   * ## Selection Clearing\n   *\n   * **Clear selection state**:\n   * ```typescript\n   * gridState.selectedItemId = null;\n   * gridState.selectedCanvasId = null;\n   * ```\n   * - Both IDs cleared together\n   * - Prevents orphaned selection state\n   * - Consistent deselection\n   *\n   * **Trigger re-render**:\n   * ```typescript\n   * const canvases = gridState.canvases;\n   * gridState.canvases = { ...canvases };\n   * ```\n   * - Spread operator creates new reference\n   * - StencilJS detects change\n   * - grid-item-wrapper components re-render\n   * - Selected item loses visual feedback\n   *\n   * ## Why Spread Pattern Here\n   *\n   * **Reactivity trigger**:\n   * - selectedItemId/selectedCanvasId not @State in app\n   * - They're in gridState (global)\n   * - Need to trigger canvases update to re-render items\n   * - Spread ensures wrapper components update selection state\n   *\n   * **Debug logging**:\n   * ```typescript\n   * console.log('Escape pressed, clearing selection');\n   * console.log('Canvases updated to trigger re-render');\n   * ```\n   * - Tracks selection clearing\n   * - Confirms re-render triggered\n   * - Can be removed in production\n   *\n   * @param e - Keyboard event\n   * @returns true if Escape key, false otherwise\n   * @private\n   */\n  private handleEscape = (e: KeyboardEvent): boolean => {\n    if (e.key === 'Escape') {\n      console.log('Escape pressed, clearing selection');\n      gridState.selectedItemId = null;\n      gridState.selectedCanvasId = null;\n      const canvases = gridState.canvases;\n      gridState.canvases = { ...canvases };\n      console.log('Canvases updated to trigger re-render');\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Delete currently selected item (helper method)\n   *\n   * **Called by**: handleDelete (keyboard) or could be called from UI\n   * **Purpose**: Shared deletion logic with undo support\n   *\n   * ## Validation Checks\n   *\n   * **Has selection**:\n   * ```typescript\n   * if (!gridState.selectedItemId || !gridState.selectedCanvasId) return;\n   * ```\n   * - Early return if nothing selected\n   * - Prevents errors from invalid state\n   *\n   * **Canvas exists**:\n   * ```typescript\n   * const canvas = gridState.canvases[gridState.selectedCanvasId];\n   * if (!canvas) return;\n   * ```\n   * - Guards against stale selection\n   * - Canvas may have been deleted\n   *\n   * **Item exists**:\n   * ```typescript\n   * const itemIndex = canvas.items.findIndex(i => i.id === gridState.selectedItemId);\n   * const item = canvas.items[itemIndex];\n   * if (!item) return;\n   * ```\n   * - Item may have been deleted elsewhere\n   * - Graceful handling of race conditions\n   *\n   * ## Deletion with Undo\n   *\n   * **Push command BEFORE deletion**:\n   * ```typescript\n   * pushCommand(new DeleteItemCommand(canvasId, item, itemIndex));\n   * ```\n   * - Captures item state before removal\n   * - Includes original index for accurate undo\n   * - Same pattern as handleItemDelete\n   *\n   * **Remove item**:\n   * ```typescript\n   * canvas.items = canvas.items.filter(i => i.id !== gridState.selectedItemId);\n   * ```\n   * - Filter creates new array (immutable pattern)\n   * - Triggers reactivity\n   *\n   * **Clear selection**:\n   * ```typescript\n   * gridState.selectedItemId = null;\n   * gridState.selectedCanvasId = null;\n   * ```\n   * - Deleted item no longer selectable\n   * - Prevents errors accessing deleted item\n   * - Good UX (nothing selected after delete)\n   *\n   * **Trigger update**:\n   * ```typescript\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   * - Standard reactivity trigger\n   * - Components re-render without item\n   *\n   * @private\n   */\n  private handleDeleteSelected = () => {\n    if (!gridState.selectedItemId || !gridState.selectedCanvasId) {\n      return;\n    }\n\n    const canvas = gridState.canvases[gridState.selectedCanvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Find the item and its index before deletion\n    const itemIndex = canvas.items.findIndex((i) => i.id === gridState.selectedItemId);\n    const item = canvas.items[itemIndex];\n    if (!item) {\n      return;\n    }\n\n    // Push undo command before deleting\n    pushCommand(new DeleteItemCommand(gridState.selectedCanvasId, item, itemIndex));\n\n    // Delete the item\n    canvas.items = canvas.items.filter((i) => i.id !== gridState.selectedItemId);\n    gridState.selectedItemId = null;\n    gridState.selectedCanvasId = null;\n\n    // Trigger update\n    gridState.canvases = { ...gridState.canvases };\n  };\n\n  /**\n   * Handle viewport change (desktop ‚Üî mobile toggle)\n   *\n   * **Triggered by**: User clicks viewport toggle buttons\n   * **Purpose**: Switch between desktop and mobile layouts\n   *\n   * ## Performance Optimization\n   *\n   * **Automatic read/write batching**:\n   * ```\n   * 1. Setting currentViewport triggers re-render of all grid-item-wrapper components\n   * 2. Each component's render() calls gridToPixelsX() which uses getGridSizeHorizontal()\n   * 3. Grid size caching ensures container.clientWidth is only read once per canvas\n   * 4. All subsequent components use the cached grid size (no DOM reads)\n   * 5. StencilJS automatically batches all resulting DOM writes\n   * ```\n   *\n   * **Result**:\n   * - With 100+ items: Only 1 DOM read per canvas instead of 100+\n   * - All style updates batched by StencilJS for single reflow\n   * - ~50-100ms for viewport switch with 100 items\n   * - Very responsive UX\n   *\n   * ## Mobile Auto-Layout\n   *\n   * **Handled by grid-item-wrapper**:\n   * - Items without customized mobile layout stack vertically\n   * - Full width (50 units = 100%)\n   * - Maintains desktop height\n   * - No work needed here (just switch flag)\n   *\n   * **State update**:\n   * ```typescript\n   * gridState.currentViewport = viewport;  // 'desktop' | 'mobile'\n   * ```\n   * - Reactive state update\n   * - All wrappers re-render with new viewport\n   * - Layout selection happens in wrapper render\n   *\n   * @param viewport - Target viewport ('desktop' or 'mobile')\n   * @private\n   */\n  private handleViewportChange = (viewport: 'desktop' | 'mobile') => {\n    /**\n     * Viewport switching with automatic read/write batching:\n     *\n     * 1. Setting currentViewport triggers re-render of all grid-item-wrapper components\n     * 2. Each component's render() calls gridToPixelsX() which uses getGridSizeHorizontal()\n     * 3. Grid size caching ensures container.clientWidth is only read once per canvas\n     * 4. All subsequent components use the cached grid size (no DOM reads)\n     * 5. StencilJS automatically batches all resulting DOM writes\n     *\n     * Result: With 100+ items, only 1 DOM read per canvas instead of 100+,\n     * and all style updates are batched by StencilJS for a single reflow\n     */\n    gridState.currentViewport = viewport;\n  };\n\n  /**\n   * Handle grid toggle (show/hide grid background)\n   *\n   * **Triggered by**: User clicks grid toggle button\n   * **Purpose**: Toggle visual grid alignment guides\n   *\n   * **Simple toggle**:\n   * ```typescript\n   * gridState.showGrid = !gridState.showGrid;\n   * ```\n   * - Reactive state update\n   * - canvas-section components update CSS classes\n   * - `.hide-grid` class added/removed\n   * - CSS background-image shown/hidden\n   *\n   * **CSS implementation** (in canvas-section):\n   * ```scss\n   * .grid-container {\n   *   background-image: linear-gradient(...);  // Grid lines\n   * }\n   * .grid-container.hide-grid {\n   *   background-image: none;  // No grid\n   * }\n   * ```\n   *\n   * **No performance impact**:\n   * - Pure CSS toggle\n   * - No JavaScript overhead\n   * - Instant visual feedback\n   *\n   * @private\n   */\n  private handleGridToggle = () => {\n    gridState.showGrid = !gridState.showGrid;\n  };\n\n  /**\n   * Handle state export (debug feature)\n   *\n   * **Triggered by**: User clicks \"Export State\" button\n   * **Purpose**: Output current grid state to console for debugging\n   *\n   * ## State Snapshot\n   *\n   * **Captured data**:\n   * ```typescript\n   * const state = {\n   *   canvases: gridState.canvases,        // All canvases and items\n   *   currentViewport: gridState.currentViewport,  // Desktop or mobile\n   *   timestamp: new Date().toISOString()  // When exported\n   * };\n   * ```\n   *\n   * **Console output**:\n   * ```typescript\n   * console.log('Grid State:', state);\n   * ```\n   * - Full state tree logged\n   * - Can be copied from console\n   * - Used for debugging layout issues\n   * - Could be saved to file in future\n   *\n   * **User feedback**:\n   * ```typescript\n   * alert(`Grid state exported to console!\\n\\nTotal Items: ${this.itemCount}\\nViewport: ${gridState.currentViewport}`);\n   * ```\n   * - Confirms export success\n   * - Shows item count summary\n   * - Shows current viewport\n   * - Directs user to console\n   *\n   * ## Use Cases\n   *\n   * - **Debugging**: Inspect item positions and properties\n   * - **Bug reports**: Include state snapshot in report\n   * - **Testing**: Verify state correctness\n   * - **Save/load**: Foundation for future feature\n   *\n   * @private\n   */\n  private handleExportState = () => {\n    const state = {\n      canvases: gridState.canvases,\n      currentViewport: gridState.currentViewport,\n      timestamp: new Date().toISOString(),\n    };\n\n    console.log('Grid State:', state);\n    alert(`Grid state exported to console!\\n\\nTotal Items: ${this.itemCount}\\nViewport: ${gridState.currentViewport}`);\n  };\n\n  /**\n   * Handle add section (create new canvas)\n   *\n   * **Triggered by**: User clicks \"‚ûï Add Section\" button\n   * **Purpose**: Add new canvas section to page\n   *\n   * ## Section Creation\n   *\n   * **Calculate next ID**:\n   * ```typescript\n   * const canvasIds = Object.keys(gridState.canvases);\n   * const nextId = canvasIds.length + 1;\n   * const newCanvasId = `canvas${nextId}`;\n   * ```\n   * - Simple sequential numbering\n   * - canvas1, canvas2, canvas3, etc.\n   * - No gaps in sequence\n   *\n   * **Create canvas object**:\n   * ```typescript\n   * gridState.canvases = {\n   *   ...gridState.canvases,\n   *   [newCanvasId]: {\n   *     items: [],              // Empty items array\n   *     zIndexCounter: 1,       // Start z-index at 1\n   *     backgroundColor: '#ffffff'  // Default white background\n   *   }\n   * };\n   * ```\n   *\n   * **Spread pattern**:\n   * - Creates new canvases object\n   * - Triggers reactivity\n   * - Components re-render with new canvas\n   * - New canvas-section appears\n   *\n   * **User feedback**:\n   * ```typescript\n   * alert(`Section ${nextId} added!`);\n   * ```\n   * - Confirms section creation\n   * - Shows section number\n   * - Simple and clear\n   *\n   * ## No Undo Support\n   *\n   * **Note**: Section creation NOT in undo history\n   * - Structural change (not item operation)\n   * - Could be added if needed\n   * - User can delete section if mistake\n   *\n   * @private\n   */\n  private handleAddSection = () => {\n    // Add new section logic\n    const canvasIds = Object.keys(gridState.canvases);\n    const nextId = canvasIds.length + 1;\n    const newCanvasId = `canvas${nextId}`;\n\n    gridState.canvases = {\n      ...gridState.canvases,\n      [newCanvasId]: {\n        items: [],\n        zIndexCounter: 1,\n        backgroundColor: '#ffffff',\n      },\n    };\n\n    alert(`Section ${nextId} added!`);\n  };\n\n  /**\n   * Handle stress test (performance testing)\n   *\n   * **Triggered by**: User clicks \"üöÄ Stress Test\" button\n   * **Purpose**: Add many items quickly for performance testing\n   *\n   * ## User Input\n   *\n   * **Prompt for count**:\n   * ```typescript\n   * const input = prompt('How many items to add? (1-1000)', '100');\n   * if (!input) return;  // User cancelled\n   * ```\n   * - Default: 100 items\n   * - Max: 1000 items (safety limit)\n   * - Validates range\n   *\n   * **Validation**:\n   * ```typescript\n   * const count = parseInt(input, 10);\n   * if (isNaN(count) || count < 1 || count > 1000) {\n   *   alert('Please enter a number between 1 and 1000');\n   *   return;\n   * }\n   * ```\n   * - Rejects invalid input\n   * - Prevents extreme loads\n   * - Good UX\n   *\n   * ## Bulk Item Creation\n   *\n   * **Random distribution**:\n   * ```typescript\n   * for (let i = 0; i < count; i++) {\n   *   // Random component type\n   *   const componentType = componentTypes[Math.floor(Math.random() * componentTypes.length)];\n   *\n   *   // Random canvas\n   *   const canvasId = canvasIds[Math.floor(Math.random() * canvasIds.length)];\n   *\n   *   // Random position\n   *   const gridX = Math.floor(Math.random() * 40);  // 0-40 units (80% of width)\n   *   const gridY = Math.floor(Math.random() * 100); // 0-100 units\n   *\n   *   // Create and add item\n   *   addItemToCanvas(canvasId, newItem);\n   * }\n   * ```\n   *\n   * **Why random**:\n   * - Tests varied layouts\n   * - Distributed across canvases\n   * - Realistic performance scenario\n   * - Different component types\n   *\n   * ## Performance Optimization\n   *\n   * **Single state update**:\n   * ```typescript\n   * // Add all items first\n   * for (let i = 0; i < count; i++) {\n   *   addItemToCanvas(canvasId, newItem);  // Mutates state\n   * }\n   *\n   * // Single reactivity trigger at end\n   * gridState.canvases = { ...gridState.canvases };\n   * ```\n   *\n   * **Why single update**:\n   * - Avoids 100+ re-renders\n   * - All items added, then render once\n   * - Much faster than individual updates\n   * - 100 items: ~200-500ms total\n   *\n   * **No undo commands**:\n   * - Would bloat undo history\n   * - Stress test = testing tool\n   * - Not normal user operation\n   * - Can clear section if needed\n   *\n   * ## Use Cases\n   *\n   * - **Test virtual rendering**: Lazy load performance\n   * - **Test grid caching**: Many items share cached calculations\n   * - **Test transform positioning**: GPU acceleration with many items\n   * - **Identify bottlenecks**: Where does performance degrade?\n   *\n   * @private\n   */\n  private handleStressTest = () => {\n    // Prompt for number of items\n    const input = prompt('How many items to add? (1-1000)', '100');\n    if (!input) {\n      return;\n    }\n\n    const count = parseInt(input, 10);\n    if (isNaN(count) || count < 1 || count > 1000) {\n      alert('Please enter a number between 1 and 1000');\n      return;\n    }\n\n    // Get available component types\n    const componentTypes = Object.keys(componentTemplates);\n    const canvasIds = Object.keys(gridState.canvases);\n\n    // Add items\n    for (let i = 0; i < count; i++) {\n      // Random component type\n      const componentType = componentTypes[Math.floor(Math.random() * componentTypes.length)];\n      const template = componentTemplates[componentType];\n\n      // Random canvas\n      const canvasId = canvasIds[Math.floor(Math.random() * canvasIds.length)];\n      const canvas = gridState.canvases[canvasId];\n\n      // Random position (0-40 grid units horizontally, 0-100 grid units vertically)\n      const gridX = Math.floor(Math.random() * 40);\n      const gridY = Math.floor(Math.random() * 100);\n\n      // Create new item\n      const newItem = {\n        id: generateItemId(),\n        canvasId,\n        type: componentType,\n        name: `${template.title} ${i + 1}`,\n        layouts: {\n          desktop: {\n            x: gridX,\n            y: gridY,\n            width: 10, // Default 10 grid units wide\n            height: 6, // Default 6 grid units tall\n          },\n          mobile: {\n            x: null,\n            y: null,\n            width: null,\n            height: null,\n            customized: false,\n          },\n        },\n        zIndex: canvas.zIndexCounter++,\n      };\n\n      // Add item to canvas (without pushing undo command to avoid history bloat)\n      addItemToCanvas(canvasId, newItem);\n    }\n\n    // Trigger single update after all items added\n    gridState.canvases = { ...gridState.canvases };\n\n    alert(`Added ${count} items!`);\n  };\n}\n"],"version":3}