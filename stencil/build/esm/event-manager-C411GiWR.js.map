{"version":3,"file":"event-manager-C411GiWR.js","sources":["src/services/event-manager.ts"],"sourcesContent":["/**\n * Event Manager Service\n * ======================\n *\n * Simple event emitter for grid builder events. Provides on/off/emit pattern\n * for plugins and API consumers to subscribe to grid builder actions.\n *\n * ## Design Pattern\n *\n * **EventEmitter pattern**:\n * - on(event, callback) - Subscribe to event\n * - off(event, callback) - Unsubscribe from event\n * - emit(event, data) - Fire event to all subscribers\n *\n * **Callback storage**: Map<eventName, Set<callback>>\n * - O(1) subscription/unsubscription\n * - Set prevents duplicate callbacks\n * - Easy cleanup (delete entire event Set)\n *\n * ## Usage Example\n *\n * ```typescript\n * import { eventManager } from './event-manager';\n *\n * // Subscribe\n * const callback = (data) => console.log('Item added:', data);\n * eventManager.on('componentAdded', callback);\n *\n * // Fire event\n * eventManager.emit('componentAdded', { itemId: '123', canvasId: 'canvas1' });\n *\n * // Unsubscribe\n * eventManager.off('componentAdded', callback);\n * ```\n *\n * ## Memory Management\n *\n * **Plugin cleanup**:\n * - Plugins MUST unsubscribe in destroy()\n * - Use same callback reference for on/off\n * - Prevents memory leaks\n *\n * **Internal cleanup**:\n * - Empty event Sets auto-deleted\n * - No memory retention for unused events\n *\n * @module event-manager\n */\n\nimport { EventCallback } from '../types/api';\n\n/**\n * EventManager Class\n * ==================\n *\n * Simple event emitter for grid builder events.\n *\n * **Storage structure**:\n * ```typescript\n * Map {\n *   'componentAdded' => Set([callback1, callback2, ...]),\n *   'componentDeleted' => Set([callback3, callback4, ...]),\n *   ...\n * }\n * ```\n *\n * **Why Set instead of Array**:\n * - O(1) lookup for has/delete\n * - Prevents duplicate callbacks\n * - Better performance for large subscriber counts\n */\nexport class EventManager {\n  /**\n   * Event listeners storage\n   *\n   * **Key**: Event name (e.g., 'componentAdded')\n   * **Value**: Set of callback functions\n   *\n   * **Why Map instead of plain object**:\n   * - Better type safety\n   * - No prototype pollution\n   * - Better performance for dynamic keys\n   */\n  private listeners: Map<string, Set<EventCallback>> = new Map();\n\n  /**\n   * Debounce timers for events\n   *\n   * **Key**: Event name\n   * **Value**: setTimeout timer ID\n   *\n   * **Purpose**: Store timers for debounced events\n   */\n  private debounceTimers: Map<string, NodeJS.Timeout> = new Map();\n\n  /**\n   * Debounce delay in milliseconds\n   *\n   * **Default**: 300ms\n   * **Configured by**: grid-builder via setDebounceDelay()\n   */\n  private debounceDelay: number = 300;\n\n  /**\n   * Events that should be debounced\n   *\n   * **Events**: componentDragged, componentResized, stateChanged\n   * **Reason**: Fire on every pixel during drag/resize\n   */\n  private debouncedEvents: Set<string> = new Set([\n    'componentDragged',\n    'componentResized',\n    'stateChanged',\n  ]);\n\n  /**\n   * Subscribe to event\n   *\n   * **Idempotent**: Calling multiple times with same callback does nothing\n   * **Thread-safe**: Uses Set which handles concurrent additions\n   *\n   * @param eventName - Event to subscribe to\n   * @param callback - Function called when event fires\n   *\n   * @example\n   * ```typescript\n   * eventManager.on('componentAdded', (data) => {\n   *   console.log(`Added ${data.item.type} to ${data.canvasId}`);\n   * });\n   * ```\n   */\n  on<T = any>(eventName: string, callback: EventCallback<T>): void {\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, new Set());\n    }\n    this.listeners.get(eventName)!.add(callback as EventCallback);\n  }\n\n  /**\n   * Unsubscribe from event\n   *\n   * **Requirements**:\n   * - Must pass EXACT same callback reference used in on()\n   * - Callback stored as property or bound method\n   *\n   * **Cleanup**: If event has no more listeners, delete the Set\n   *\n   * @param eventName - Event to unsubscribe from\n   * @param callback - Exact callback reference used in on()\n   *\n   * @example\n   * ```typescript\n   * // âœ… Correct pattern\n   * class MyPlugin {\n   *   private handleAdd = (data) => console.log(data);\n   *\n   *   init(api) {\n   *     eventManager.on('componentAdded', this.handleAdd);\n   *   }\n   *\n   *   destroy() {\n   *     eventManager.off('componentAdded', this.handleAdd);\n   *   }\n   * }\n   * ```\n   */\n  off<T = any>(eventName: string, callback: EventCallback<T>): void {\n    const callbacks = this.listeners.get(eventName);\n    if (callbacks) {\n      callbacks.delete(callback as EventCallback);\n\n      // Cleanup empty event listeners\n      if (callbacks.size === 0) {\n        this.listeners.delete(eventName);\n      }\n    }\n  }\n\n  /**\n   * Fire event to all subscribers\n   *\n   * **Debouncing**: Some events are automatically debounced:\n   * - componentDragged (fires on every pixel)\n   * - componentResized (fires on every pixel)\n   * - stateChanged (fires on every state update)\n   *\n   * **Immediate events** (not debounced):\n   * - componentSelected, componentDeleted, componentAdded, etc.\n   *\n   * **Execution order**: Subscribers called in insertion order\n   * **Error handling**: One callback error doesn't prevent others\n   *\n   * **Performance**: O(n) where n = number of callbacks for this event\n   *\n   * @param eventName - Event to fire\n   * @param data - Data to pass to callbacks\n   *\n   * @example\n   * ```typescript\n   * // Internal usage (in state-manager.ts)\n   * eventManager.emit('componentAdded', {\n   *   item: newItem,\n   *   canvasId: 'canvas1',\n   *   timestamp: Date.now()\n   * });\n   * ```\n   */\n  emit<T = any>(eventName: string, data: T): void {\n    // Check if this event should be debounced\n    if (this.debouncedEvents.has(eventName)) {\n      this.emitDebounced(eventName, data);\n    } else {\n      this.emitImmediate(eventName, data);\n    }\n  }\n\n  /**\n   * Fire event immediately (no debouncing)\n   *\n   * **Private method**: Called by emit()\n   *\n   * @param eventName - Event to fire\n   * @param data - Data to pass to callbacks\n   */\n  private emitImmediate<T = any>(eventName: string, data: T): void {\n    const callbacks = this.listeners.get(eventName);\n    if (callbacks) {\n      callbacks.forEach((callback) => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event callback for \"${eventName}\":`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Fire event with debouncing\n   *\n   * **How it works**:\n   * 1. Clear any existing timer for this event\n   * 2. Set new timer with debounceDelay\n   * 3. When timer fires, call emitImmediate()\n   * 4. If emit() called again before timer fires, restart timer\n   *\n   * **Result**: Event only fires once after activity stops\n   *\n   * **Private method**: Called by emit()\n   *\n   * @param eventName - Event to fire\n   * @param data - Data to pass to callbacks\n   */\n  private emitDebounced<T = any>(eventName: string, data: T): void {\n    // Clear existing timer for this event\n    const existingTimer = this.debounceTimers.get(eventName);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n\n    // Set new timer\n    const timer = setTimeout(() => {\n      this.emitImmediate(eventName, data);\n      this.debounceTimers.delete(eventName);\n    }, this.debounceDelay);\n\n    this.debounceTimers.set(eventName, timer);\n  }\n\n  /**\n   * Set debounce delay for all debounced events\n   *\n   * **Configurable**: Called by grid-builder with config.eventDebounceDelay\n   *\n   * @param delay - Delay in milliseconds\n   *\n   * @example\n   * ```typescript\n   * // In grid-builder componentDidLoad\n   * eventManager.setDebounceDelay(config?.eventDebounceDelay || 300);\n   * ```\n   */\n  setDebounceDelay(delay: number): void {\n    this.debounceDelay = delay;\n  }\n\n  /**\n   * Get current debounce delay\n   *\n   * **Use case**: Debugging, testing\n   *\n   * @returns Debounce delay in milliseconds\n   */\n  getDebounceDelay(): number {\n    return this.debounceDelay;\n  }\n\n  /**\n   * Remove all listeners for specific event\n   *\n   * **Use case**: Cleanup during component unmount\n   *\n   * @param eventName - Event to remove all listeners from\n   *\n   * @example\n   * ```typescript\n   * // Clear all componentAdded listeners\n   * eventManager.removeAllListeners('componentAdded');\n   * ```\n   */\n  removeAllListeners(eventName?: string): void {\n    if (eventName) {\n      this.listeners.delete(eventName);\n    } else {\n      this.listeners.clear();\n    }\n  }\n\n  /**\n   * Get listener count for debugging\n   *\n   * **Use case**: Check for memory leaks (too many listeners)\n   *\n   * @param eventName - Event to count listeners for\n   * @returns Number of listeners or 0 if event not registered\n   *\n   * @example\n   * ```typescript\n   * const count = eventManager.listenerCount('componentAdded');\n   * console.log(`${count} listeners for componentAdded`);\n   * ```\n   */\n  listenerCount(eventName: string): number {\n    return this.listeners.get(eventName)?.size || 0;\n  }\n}\n\n/**\n * Global event manager instance\n *\n * **Singleton pattern**: One instance shared across entire library\n * **Why singleton**: Ensures all components/plugins use same event bus\n */\nexport const eventManager = new EventManager();\n"],"names":[],"mappings":"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"}