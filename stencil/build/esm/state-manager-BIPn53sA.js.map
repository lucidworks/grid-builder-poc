{"version":3,"file":"state-manager-BIPn53sA.js","sources":["node_modules/@stencil/store/dist/index.js","src/services/state-manager.ts"],"sourcesContent":["import { getRenderingRef, forceUpdate } from '@stencil/core';\n\nconst appendToMap = (map, propName, value) => {\n    const items = map.get(propName);\n    if (!items) {\n        map.set(propName, [value]);\n    }\n    else if (!items.includes(value)) {\n        items.push(value);\n    }\n};\nconst debounce = (fn, ms) => {\n    let timeoutId;\n    return (...args) => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = 0;\n            fn(...args);\n        }, ms);\n    };\n};\n\n/**\n * Check if a possible element isConnected.\n * The property might not be there, so we check for it.\n *\n * We want it to return true if isConnected is not a property,\n * otherwise we would remove these elements and would not update.\n *\n * Better leak in Edge than to be useless.\n */\nconst isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;\nconst cleanupElements = debounce((map) => {\n    for (let key of map.keys()) {\n        map.set(key, map.get(key).filter(isConnected));\n    }\n}, 2_000);\nconst stencilSubscription = () => {\n    if (typeof getRenderingRef !== 'function') {\n        // If we are not in a stencil project, we do nothing.\n        // This function is not really exported by @stencil/core.\n        return {};\n    }\n    const elmsToUpdate = new Map();\n    return {\n        dispose: () => elmsToUpdate.clear(),\n        get: (propName) => {\n            const elm = getRenderingRef();\n            if (elm) {\n                appendToMap(elmsToUpdate, propName, elm);\n            }\n        },\n        set: (propName) => {\n            const elements = elmsToUpdate.get(propName);\n            if (elements) {\n                elmsToUpdate.set(propName, elements.filter(forceUpdate));\n            }\n            cleanupElements(elmsToUpdate);\n        },\n        reset: () => {\n            elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));\n            cleanupElements(elmsToUpdate);\n        },\n    };\n};\n\nconst unwrap = (val) => (typeof val === 'function' ? val() : val);\nconst createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {\n    const unwrappedState = unwrap(defaultState);\n    let states = new Map(Object.entries(unwrappedState ?? {}));\n    const handlers = {\n        dispose: [],\n        get: [],\n        set: [],\n        reset: [],\n    };\n    // Track onChange listeners to enable removeListener functionality\n    const changeListeners = new Map();\n    const reset = () => {\n        // When resetting the state, the default state may be a function - unwrap it to invoke it.\n        // otherwise, the state won't be properly reset\n        states = new Map(Object.entries(unwrap(defaultState) ?? {}));\n        handlers.reset.forEach((cb) => cb());\n    };\n    const dispose = () => {\n        // Call first dispose as resetting the state would\n        // cause less updates ;)\n        handlers.dispose.forEach((cb) => cb());\n        reset();\n    };\n    const get = (propName) => {\n        handlers.get.forEach((cb) => cb(propName));\n        return states.get(propName);\n    };\n    const set = (propName, value) => {\n        const oldValue = states.get(propName);\n        if (shouldUpdate(value, oldValue, propName)) {\n            states.set(propName, value);\n            handlers.set.forEach((cb) => cb(propName, value, oldValue));\n        }\n    };\n    const state = (typeof Proxy === 'undefined'\n        ? {}\n        : new Proxy(unwrappedState, {\n            get(_, propName) {\n                return get(propName);\n            },\n            ownKeys(_) {\n                return Array.from(states.keys());\n            },\n            getOwnPropertyDescriptor() {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            },\n            has(_, propName) {\n                return states.has(propName);\n            },\n            set(_, propName, value) {\n                set(propName, value);\n                return true;\n            },\n        }));\n    const on = (eventName, callback) => {\n        handlers[eventName].push(callback);\n        return () => {\n            removeFromArray(handlers[eventName], callback);\n        };\n    };\n    const onChange = (propName, cb) => {\n        const setHandler = (key, newValue) => {\n            if (key === propName) {\n                cb(newValue);\n            }\n        };\n        const resetHandler = () => cb(unwrap(defaultState)[propName]);\n        // Register the handlers\n        const unSet = on('set', setHandler);\n        const unReset = on('reset', resetHandler);\n        // Track the relationship between the user callback and internal handlers\n        changeListeners.set(cb, { setHandler, resetHandler, propName });\n        return () => {\n            unSet();\n            unReset();\n            changeListeners.delete(cb);\n        };\n    };\n    const use = (...subscriptions) => {\n        const unsubs = subscriptions.reduce((unsubs, subscription) => {\n            if (subscription.set) {\n                unsubs.push(on('set', subscription.set));\n            }\n            if (subscription.get) {\n                unsubs.push(on('get', subscription.get));\n            }\n            if (subscription.reset) {\n                unsubs.push(on('reset', subscription.reset));\n            }\n            if (subscription.dispose) {\n                unsubs.push(on('dispose', subscription.dispose));\n            }\n            return unsubs;\n        }, []);\n        return () => unsubs.forEach((unsub) => unsub());\n    };\n    const forceUpdate = (key) => {\n        const oldValue = states.get(key);\n        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));\n    };\n    const removeListener = (propName, listener) => {\n        const listenerInfo = changeListeners.get(listener);\n        if (listenerInfo && listenerInfo.propName === propName) {\n            // Remove the specific handlers that were created for this listener\n            removeFromArray(handlers.set, listenerInfo.setHandler);\n            removeFromArray(handlers.reset, listenerInfo.resetHandler);\n            changeListeners.delete(listener);\n        }\n    };\n    return {\n        state,\n        get,\n        set,\n        on,\n        onChange,\n        use,\n        dispose,\n        reset,\n        forceUpdate,\n        removeListener,\n    };\n};\nconst removeFromArray = (array, item) => {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array[index] = array[array.length - 1];\n        array.length--;\n    }\n};\n\nconst createStore = (defaultState, shouldUpdate) => {\n    const map = createObservableMap(defaultState, shouldUpdate);\n    map.use(stencilSubscription());\n    return map;\n};\n\nexport { createObservableMap, createStore };\n","/**\n * State Manager\n * ==============\n *\n * Centralized reactive state management for the grid builder using StencilJS Store.\n * Manages grid items, canvases, layouts, selection state, and viewport configuration\n * with automatic component re-renders on state changes.\n *\n * ## Problem\n *\n * Complex interactive applications need:\n * - Centralized state accessible across all components\n * - Automatic UI updates when state changes\n * - Type-safe state mutations\n * - Undo/redo support (requires state snapshots)\n * - Desktop + mobile layout management\n * - Selection tracking across multiple canvases\n *\n * Without centralized state:\n * - Props drilling through component hierarchies\n * - Manual event subscriptions and cleanup\n * - Synchronization issues between components\n * - Difficult undo/redo implementation\n *\n * ## Solution\n *\n * Use @stencil/store for reactive state management with:\n * 1. **Single source of truth**: All state in one store\n * 2. **Automatic reactivity**: Components re-render on state changes\n * 3. **Type safety**: Full TypeScript support\n * 4. **Simple API**: Direct property access (no actions/reducers)\n * 5. **Lightweight**: ~1KB, built into StencilJS\n *\n * ## Architecture Decisions\n *\n * ### Why @stencil/store vs Redux/Zustand?\n *\n * **@stencil/store chosen because**:\n * - ✅ Native StencilJS integration (zero setup)\n * - ✅ Automatic component subscriptions (no manual connect/subscribe)\n * - ✅ Simple mutation API (direct property assignment)\n * - ✅ Tiny bundle size (~1KB)\n * - ✅ Full TypeScript support\n * - ✅ Perfect for component-scoped state\n *\n * **Redux would add**:\n * - ❌ Boilerplate (actions, reducers, dispatch)\n * - ❌ Bundle size (~15KB min)\n * - ❌ Learning curve (middleware, selectors)\n * - ❌ Manual component subscriptions\n *\n * **Zustand would work but**:\n * - ⚠️ External dependency (not StencilJS native)\n * - ⚠️ Manual subscriptions in StencilJS\n * - ⚠️ Less TypeScript integration\n *\n * ### Dual Layout System (Desktop + Mobile)\n *\n * Each grid item has TWO layout configurations:\n *\n * **Desktop Layout** (always present):\n * - Primary layout with full positioning data\n * - x, y, width, height in grid units\n * - Never null, always has values\n *\n * **Mobile Layout** (optional/auto-generated):\n * - x, y, width, height can be null\n * - `customized: false` → auto-generated from desktop layout\n * - `customized: true` → user manually positioned in mobile view\n *\n * **Why dual layouts**:\n * - Different screen sizes need different layouts\n * - Mobile can auto-adapt OR be manually customized\n * - Single item definition works across viewports\n *\n * **Auto-generation strategy**:\n * ```typescript\n * // When mobile layout is null (not customized):\n * // - Full width items (span entire mobile viewport)\n * // - Stacked vertically\n * // - Responsive heights\n *\n * // When mobile.customized = true:\n * // - Use explicit mobile.x, mobile.y, mobile.width, mobile.height\n * // - Ignore desktop layout\n * ```\n *\n * ### State Mutation Pattern\n *\n * **Immutable spread pattern** for reactivity:\n * ```typescript\n * // ❌ Wrong: Direct mutation doesn't trigger updates\n * canvas.items.push(newItem);\n *\n * // ✅ Correct: Spread triggers reactivity\n * canvas.items.push(newItem);\n * state.canvases = { ...state.canvases };\n * ```\n *\n * **Why this pattern**:\n * - StencilJS store detects reference changes\n * - Object spread creates new reference\n * - Components automatically re-render\n * - Simple and performant\n *\n * ### Z-Index Management\n *\n * **Per-canvas z-index tracking**:\n * - Each canvas has `zIndexCounter` (monotonically increasing)\n * - New items get `zIndexCounter++`\n * - Ensures unique z-index per canvas\n * - Higher z-index = rendered on top\n *\n * **Why per-canvas**:\n * - Items in different canvases don't overlap\n * - Simplifies z-index calculations\n * - Prevents z-index conflicts\n * - Independent stacking contexts\n *\n * **Bringing to front**:\n * ```typescript\n * item.zIndex = canvas.zIndexCounter++;\n * state.canvases = { ...state.canvases }; // Trigger update\n * ```\n *\n * ## State Structure\n *\n * ```typescript\n * {\n *   canvases: {\n *     'canvas1': {\n *       items: [GridItem, GridItem, ...],\n *       zIndexCounter: 5,\n *       backgroundColor: '#ffffff'\n *     },\n *     'canvas2': { ... },\n *     ...\n *   },\n *   selectedItemId: 'item-3' | null,\n *   selectedCanvasId: 'canvas1' | null,\n *   currentViewport: 'desktop' | 'mobile',\n *   showGrid: true | false\n * }\n * ```\n *\n * ## Performance Characteristics\n *\n * **State access**: O(1) - direct property access\n * **State updates**: O(n) - spread operation copies references\n * **Component re-renders**: Only components consuming changed state\n * **Memory**: Lightweight (~1KB store + actual state data)\n *\n * **Optimization**: Immutable updates only copy top-level references,\n * not deep clones. Child objects remain same reference if unchanged.\n *\n * ## Integration with Undo/Redo\n *\n * State structure supports undo/redo via snapshots:\n * ```typescript\n * // Save snapshot\n * const snapshot = JSON.parse(JSON.stringify(state.canvases));\n *\n * // Restore snapshot\n * state.canvases = JSON.parse(JSON.stringify(snapshot));\n * ```\n *\n * Deep cloning required because:\n * - Prevents mutations from affecting history\n * - Ensures independent state snapshots\n * - Simple and reliable (no ref tracking)\n *\n * ## Extracting This Pattern\n *\n * To adapt for other frameworks:\n *\n * **React + Zustand**:\n * ```typescript\n * import create from 'zustand';\n *\n * const useStore = create<GridState>((set) => ({\n *   ...initialState,\n *   addItem: (canvasId, item) => set((state) => ({\n *     canvases: {\n *       ...state.canvases,\n *       [canvasId]: {\n *         ...state.canvases[canvasId],\n *         items: [...state.canvases[canvasId].items, item]\n *       }\n *     }\n *   }))\n * }));\n * ```\n *\n * **Vue + Pinia**:\n * ```typescript\n * import { defineStore } from 'pinia';\n *\n * export const useGridStore = defineStore('grid', {\n *   state: () => initialState,\n *   actions: {\n *     addItem(canvasId, item) {\n *       this.canvases[canvasId].items.push(item);\n *     }\n *   }\n * });\n * ```\n *\n * **Angular + NgRx**:\n * ```typescript\n * export const addItem = createAction(\n *   '[Grid] Add Item',\n *   props<{ canvasId: string; item: GridItem }>()\n * );\n *\n * export const gridReducer = createReducer(\n *   initialState,\n *   on(addItem, (state, { canvasId, item }) => ({\n *     ...state,\n *     canvases: {\n *       ...state.canvases,\n *       [canvasId]: {\n *         ...state.canvases[canvasId],\n *         items: [...state.canvases[canvasId].items, item]\n *       }\n *     }\n *   }))\n * );\n * ```\n *\n * @module state-manager\n */\n\nimport { createStore } from '@stencil/store';\n\n/**\n * Grid Item Interface\n * ====================\n *\n * Core data structure representing a single component instance in the grid.\n * Each item has dual layouts (desktop + mobile) and positioning metadata.\n *\n * **Lifecycle**:\n * 1. Created when dropped from palette or added programmatically\n * 2. Updated during drag/resize operations\n * 3. Persisted in state for undo/redo\n * 4. Removed when deleted\n *\n * **Key Properties**:\n * - `id`: Unique identifier (generated via generateItemId)\n * - `canvasId`: Which canvas owns this item\n * - `type`: Component type ('header', 'text', 'button', etc.)\n * - `name`: Display name (shown in UI)\n * - `layouts`: Desktop and mobile positioning\n * - `zIndex`: Stacking order within canvas\n *\n * **Type System Integration**:\n * The `type` field determines which component renders via dynamic imports:\n * ```typescript\n * switch (item.type) {\n *   case 'header': return <component-header />;\n *   case 'text': return <component-text-block />;\n *   case 'button': return <component-button />;\n *   // ...\n * }\n * ```\n */\nexport interface GridItem {\n  /** Unique item identifier (e.g., 'item-1', 'item-2') */\n  id: string;\n\n  /** Canvas ID this item belongs to (e.g., 'canvas1', 'canvas2') */\n  canvasId: string;\n\n  /** Component type determining which component renders ('header', 'text', 'button', etc.) */\n  type: string;\n\n  /** Display name shown in UI */\n  name: string;\n\n  /**\n   * Dual layout system for responsive design\n   *\n   * **Desktop Layout** (required, never null):\n   * - Primary layout used in desktop viewport\n   * - All properties (x, y, width, height) always have numeric values\n   * - Coordinates in grid units (not pixels)\n   *\n   * **Mobile Layout** (optional/auto-generated):\n   * - Properties can be null when not customized\n   * - `customized: false` → Auto-generated layout (full-width, stacked)\n   * - `customized: true` → User manually positioned in mobile view\n   *\n   * **Auto-generation behavior** (when mobile.customized = false):\n   * ```typescript\n   * // grid-item-wrapper.tsx calculates:\n   * x: 0 (left edge)\n   * y: calculatedFromStackOrder\n   * width: 50 (full width = 100% of viewport)\n   * height: desktop.height (maintain aspect ratio)\n   * ```\n   *\n   * **Example usage**:\n   * ```typescript\n   * const item: GridItem = {\n   *   id: 'item-1',\n   *   canvasId: 'canvas1',\n   *   type: 'header',\n   *   name: 'Hero Header',\n   *   layouts: {\n   *     desktop: { x: 5, y: 2, width: 20, height: 8 },\n   *     mobile: {\n   *       x: null, y: null, width: null, height: null,\n   *       customized: false // Will auto-generate\n   *     }\n   *   },\n   *   zIndex: 1\n   * };\n   * ```\n   */\n  layouts: {\n    /** Desktop layout (always fully defined) */\n    desktop: {\n      /** Horizontal position in grid units (0 = left edge) */\n      x: number;\n\n      /** Vertical position in grid units (0 = top edge) */\n      y: number;\n\n      /** Width in grid units (e.g., 20 units at 2% = 40% of container) */\n      width: number;\n\n      /** Height in grid units (e.g., 8 units × 20px = 160px) */\n      height: number;\n    };\n\n    /** Mobile layout (optional/auto-generated) */\n    mobile: {\n      /** Horizontal position or null for auto-generation */\n      x: number | null;\n\n      /** Vertical position or null for auto-generation */\n      y: number | null;\n\n      /** Width or null for auto-generation (typically full-width) */\n      width: number | null;\n\n      /** Height or null for auto-generation */\n      height: number | null;\n\n      /**\n       * Whether user manually customized mobile layout\n       *\n       * **false**: Auto-generate from desktop layout\n       * - Full width (50 grid units)\n       * - Stacked vertically\n       * - Maintains desktop height\n       *\n       * **true**: Use explicit mobile x/y/width/height\n       * - User dragged/resized in mobile view\n       * - Ignore desktop layout\n       * - Persist custom positioning\n       */\n      customized: boolean;\n    };\n  };\n\n  /**\n   * Stacking order within canvas (higher = on top)\n   *\n   * **Assignment**: New items get `canvas.zIndexCounter++`\n   * **Bringing to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Per-canvas**: Z-indexes only compete within same canvas\n   */\n  zIndex: number;\n\n  /**\n   * Component configuration data\n   *\n   * **Purpose**: Store component-specific settings (text, color, etc.)\n   * **Structure**: Record<string, any> matching ComponentDefinition.configSchema\n   * **Default**: Empty object {} when component created\n   *\n   * **Example**:\n   * ```typescript\n   * // Header component config\n   * config: {\n   *   text: 'Welcome!',\n   *   level: 'H1',\n   *   color: '#000000',\n   *   alignment: 'center'\n   * }\n   * ```\n   */\n  config?: Record<string, any>;\n}\n\n/**\n * Canvas Interface\n * =================\n *\n * Represents a single canvas container (section) in the grid builder.\n * Each canvas is an independent dropzone with its own items and z-index tracking.\n *\n * **Typical usage**: Multi-section landing pages\n * - canvas1 = Hero section\n * - canvas2 = Content section\n * - canvas3 = Footer section\n *\n * **Why multiple canvases**:\n * - Logical content sections\n * - Independent z-index contexts\n * - Different background colors per section\n * - Easier content organization\n *\n * **Example**:\n * ```typescript\n * const heroCanvas: Canvas = {\n *   items: [headerItem, textItem, buttonItem, imageItem],\n *   zIndexCounter: 5, // Next item gets zIndex: 5\n *   backgroundColor: '#ffffff'\n * };\n * ```\n */\n/**\n * Canvas Interface\n * ==================\n *\n * Minimal canvas structure focused purely on item placement management.\n *\n * **Library responsibilities** (what IS in this interface):\n * - Item placement and layouts\n * - Z-index management for stacking\n *\n * **Host app responsibilities** (what is NOT in this interface):\n * - Canvas styling (backgroundColor, themes, etc.)\n * - Canvas metadata (title, description, etc.)\n * - Presentation concerns (how canvases look)\n *\n * **Why this separation**:\n * - Different apps have different styling needs\n * - Library focuses on layout, not presentation\n * - Host app owns the complete data model\n * - Enables library to be used in any context\n *\n * **Host app pattern**:\n * ```typescript\n * // Host app maintains its own canvas metadata\n * const canvasMetadata = {\n *   'canvas1': { title: 'Hero Section', backgroundColor: '#f0f4f8', ... },\n *   'canvas2': { title: 'Footer', backgroundColor: '#e8f0f2', ... }\n * };\n *\n * // Library only knows about item placement\n * const gridState = {\n *   canvases: {\n *     'canvas1': { items: [...], zIndexCounter: 5 },\n *     'canvas2': { items: [...], zIndexCounter: 3 }\n *   }\n * };\n * ```\n */\nexport interface Canvas {\n  /**\n   * Array of grid items in this canvas\n   *\n   * **Rendering**: Items render in DOM order, styled with z-index for stacking\n   * **Mutation**: Always use spread pattern to trigger reactivity\n   */\n  items: GridItem[];\n\n  /**\n   * Monotonically increasing counter for z-index assignment\n   *\n   * **New items**: `item.zIndex = canvas.zIndexCounter++`\n   * **Bring to front**: `item.zIndex = canvas.zIndexCounter++`\n   * **Never decreases**: Only increments to prevent conflicts\n   */\n  zIndexCounter: number;\n}\n\n/**\n * Grid State Interface\n * =====================\n *\n * Root state structure for entire grid builder application.\n * Manages all canvases, selection state, and viewport configuration.\n *\n * **Single source of truth**: All app state in this one object\n * **Reactivity**: Changes trigger automatic component re-renders\n * **Persistence**: Can be serialized to JSON for save/export\n *\n * **Access pattern**:\n * ```typescript\n * import { gridState } from './state-manager';\n *\n * // Read state\n * const items = gridState.canvases['canvas1'].items;\n *\n * // Mutate state (triggers reactivity)\n * gridState.selectedItemId = 'item-5';\n * gridState.canvases = { ...gridState.canvases }; // After mutations\n * ```\n */\nexport interface GridState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': Canvas, 'canvas2': Canvas, ... }`\n   * **Access**: `gridState.canvases['canvas1']`\n   * **Dynamic canvases**: Can add/remove canvases at runtime\n   */\n  canvases: Record<string, Canvas>;\n\n  /**\n   * Currently selected item ID or null if no selection\n   *\n   * **Selection flow**:\n   * 1. User clicks item → `selectItem(itemId, canvasId)`\n   * 2. State updates → `selectedItemId = 'item-3'`\n   * 3. Components re-render with visual selection indicators\n   *\n   * **Deselection**: Click canvas background → `deselectItem()` → `null`\n   */\n  selectedItemId: string | null;\n\n  /**\n   * Canvas ID containing currently selected item\n   *\n   * **Why needed**: Item IDs are unique across canvases, but need canvas\n   * for operations like delete, move, etc.\n   *\n   * **Always paired**: When `selectedItemId` is set, `selectedCanvasId` must be set\n   */\n  selectedCanvasId: string | null;\n\n  /**\n   * Currently active/focused canvas ID or null if none active\n   *\n   * **Selection flow**:\n   * 1. User interacts with canvas (click, drag, resize) → `setActiveCanvas(canvasId)`\n   * 2. State updates → `activeCanvasId = 'canvas1'`\n   * 3. Canvas section component receives isActive prop\n   * 4. Visual feedback applied (title opacity, border, etc.)\n   *\n   * **Activation triggers**:\n   * - Clicking item on canvas\n   * - Clicking canvas background\n   * - Starting drag operation on item\n   * - Starting resize operation on item\n   *\n   * **Use cases**:\n   * - Highlight which section user is working on\n   * - Show canvas-specific settings panel\n   * - Provide visual context in multi-section layouts\n   *\n   * **Difference from selectedCanvasId**:\n   * - `selectedCanvasId`: Canvas containing selected **item** (editing focus)\n   * - `activeCanvasId`: Canvas that is **active** for interaction (section focus)\n   */\n  activeCanvasId: string | null;\n\n  /**\n   * Current viewport mode (desktop or mobile)\n   *\n   * **Affects**:\n   * - Which layout is rendered (item.layouts.desktop vs item.layouts.mobile)\n   * - Grid calculations (responsive vs fixed)\n   * - Canvas width (full vs mobile viewport)\n   *\n   * **Toggle**: User clicks viewport switcher button\n   */\n  currentViewport: 'desktop' | 'mobile';\n\n  /**\n   * Whether to show grid lines on canvases\n   *\n   * **Visual aid**: Helps users align items to grid\n   * **Toggle**: User clicks grid visibility button\n   * **Rendering**: CSS background-image with grid pattern\n   */\n  showGrid: boolean;\n}\n\n/**\n * Viewer-Only State Interfaces\n * ==============================\n *\n * Minimal state types for grid-viewer component (rendering-only mode).\n * These are subsets of the full editing state, excluding editing-specific properties.\n *\n * ## Separation of Concerns\n *\n * **Builder App** (grid-builder):\n * - Full GridState with selection, z-index tracking, etc.\n * - Includes interact.js for drag-and-drop (~45KB)\n * - Bundle size: ~150KB\n *\n * **Viewer App** (grid-viewer):\n * - Minimal ViewerState without editing features\n * - No interact.js dependency\n * - Bundle size: ~30KB (80% reduction)\n *\n * ## Export/Import Workflow\n *\n * ```typescript\n * // Builder App → Export layout\n * const builder = document.querySelector('grid-builder');\n * const exportData = await builder.exportState();\n * await fetch('/api/layouts', {\n *   method: 'POST',\n *   body: JSON.stringify(exportData)\n * });\n *\n * // Viewer App → Import layout\n * const layout = await fetch('/api/layouts/123').then(r => r.json());\n * const viewer = document.querySelector('grid-viewer');\n * viewer.initialState = layout;\n * ```\n *\n * ## What's Excluded from Viewer\n *\n * **Canvas.zIndexCounter** - Editing-only state:\n * - Tracks next z-index for new items\n * - Not needed in viewer (items already have zIndex)\n * - Viewer reads item.zIndex directly\n *\n * **GridState.selectedItemId/selectedCanvasId** - Editing-only state:\n * - Tracks which item is selected for editing\n * - Not needed in viewer (no selection UI)\n * - Viewer only renders, never selects\n *\n * **GridState.showGrid** - Editing-only state:\n * - Visual aid for aligning items during editing\n * - Not needed in viewer (no editing)\n * - Viewer renders clean output without grid lines\n *\n * ## Type Compatibility\n *\n * ViewerState is intentionally compatible with GridExport format:\n * ```typescript\n * // GridExport can be used as ViewerState\n * const exportData: GridExport = await builder.exportState();\n * viewer.initialState = exportData; // Type-safe!\n * ```\n */\n\n/**\n * Viewer Canvas Interface\n * ========================\n *\n * Minimal canvas structure for viewer mode (rendering-only).\n * Excludes editing-specific properties like zIndexCounter.\n *\n * **Differences from Canvas**:\n * - ✅ items: Array of ViewerItem (same as GridItem)\n * - ❌ zIndexCounter: Not needed (items already have zIndex)\n *\n * **Use in viewer**:\n * ```typescript\n * const canvas: ViewerCanvas = {\n *   items: [\n *     { id: 'item-1', type: 'header', zIndex: 1, ... },\n *     { id: 'item-2', type: 'text', zIndex: 2, ... }\n *   ]\n * };\n *\n * // Render items in z-index order\n * const sortedItems = canvas.items.sort((a, b) => a.zIndex - b.zIndex);\n * ```\n */\nexport interface ViewerCanvas {\n  /** Grid items in this canvas (rendering-only, no editing state) */\n  items: GridItem[]; // Reuse GridItem - it's already clean and serializable\n}\n\n/**\n * Viewer State Interface\n * =======================\n *\n * Minimal state structure for grid-viewer component (rendering-only mode).\n * Subset of GridState excluding all editing-specific properties.\n *\n * **Differences from GridState**:\n * - ✅ canvases: Record<string, ViewerCanvas>\n * - ✅ currentViewport: 'desktop' | 'mobile'\n * - ❌ selectedItemId: Not needed (no selection in viewer)\n * - ❌ selectedCanvasId: Not needed (no selection in viewer)\n * - ❌ showGrid: Not needed (no grid lines in viewer)\n *\n * **Why minimal state**:\n * - Smaller bundle size (no editing logic)\n * - Simpler component tree (no interact.js)\n * - Faster initialization (no drag/drop setup)\n * - Clean separation of concerns\n *\n * **Use in viewer**:\n * ```typescript\n * // Initialize viewer from exported layout\n * const viewerState: ViewerState = {\n *   canvases: {\n *     'hero-section': {\n *       items: [\n *         {\n *           id: 'header-1',\n *           canvasId: 'hero-section',\n *           type: 'header',\n *           name: 'Hero Header',\n *           layouts: {\n *             desktop: { x: 0, y: 0, width: 50, height: 6 },\n *             mobile: { x: null, y: null, width: null, height: null, customized: false }\n *           },\n *           zIndex: 1,\n *           config: { title: 'Welcome!' }\n *         }\n *       ]\n *     }\n *   },\n *   currentViewport: 'desktop'\n * };\n * ```\n *\n * **Type-safe import from GridExport**:\n * ```typescript\n * import { GridExport } from '../types/grid-export';\n *\n * function convertExportToViewerState(exportData: GridExport): ViewerState {\n *   return {\n *     canvases: exportData.canvases,\n *     currentViewport: exportData.viewport\n *   };\n * }\n * ```\n */\nexport interface ViewerState {\n  /**\n   * Record of all canvas instances keyed by canvas ID\n   *\n   * **Structure**: `{ 'canvas1': ViewerCanvas, 'canvas2': ViewerCanvas, ... }`\n   * **Rendering**: Each canvas section renders its items in z-index order\n   * **Responsive**: Switches between desktop/mobile layouts based on currentViewport\n   */\n  canvases: Record<string, ViewerCanvas>;\n\n  /**\n   * Current viewport mode (desktop or mobile)\n   *\n   * **Affects**:\n   * - Which layout is rendered (item.layouts.desktop vs item.layouts.mobile)\n   * - Responsive layout calculations\n   * - Canvas width and item positioning\n   *\n   * **Auto-switching**: Can use ResizeObserver for container-based switching\n   * **Manual override**: Can be set via props or API\n   */\n  currentViewport: 'desktop' | 'mobile';\n}\n\n/**\n * Initial State (empty canvases for library)\n *\n * Library starts with empty canvases by default.\n * Consumers can add their own initial items programmatically.\n */\nconst initialState: GridState = {\n  canvases: {\n    canvas1: {\n      items: [],\n      zIndexCounter: 1,\n    },\n    canvas2: {\n      items: [],\n      zIndexCounter: 1,\n    },\n    canvas3: {\n      items: [],\n      zIndexCounter: 1,\n    },\n  },\n  selectedItemId: null,\n  selectedCanvasId: null,\n  activeCanvasId: null,\n  currentViewport: 'desktop',\n  showGrid: true,\n};\n\n/**\n * Global Grid State Store\n * ========================\n *\n * StencilJS store instance providing reactive state management.\n *\n * **Exports**:\n * - `state`: Reactive state proxy (mutate to trigger updates)\n * - `onChange`: Subscribe to state changes\n * - `dispose`: Cleanup subscriptions (typically not needed)\n *\n * **Usage in components**:\n * ```typescript\n * import { gridState } from './state-manager';\n *\n * // Component automatically re-renders when state changes\n * render() {\n *   const items = gridState.canvases['canvas1'].items;\n *   return items.map(item => <div>{item.name}</div>);\n * }\n * ```\n */\nconst { state, onChange, dispose } = createStore<GridState>(initialState);\n\n/**\n * Reset state to initial empty configuration\n *\n * **When to call**:\n * - User clicks \"Reset\" button\n * - Starting fresh\n * - Test cleanup (afterEach hooks)\n *\n * **What it resets**:\n * - Clears all items from all canvases\n * - Resets z-index counters\n * - Clears selection state\n * - Resets viewport to desktop\n * - Shows grid\n * - Resets item ID counter to 0\n *\n * **Deep clone pattern**:\n * Uses `JSON.parse(JSON.stringify())` to create independent copy\n * of initial state. Prevents mutations from affecting initialState.\n *\n * @example\n * ```typescript\n * // Reset button handler\n * handleReset() {\n *   if (confirm('Reset to initial state?')) {\n *     reset();\n *     console.log('State reset to empty');\n *   }\n * }\n * ```\n */\nexport function reset() {\n  itemIdCounter = 0; // Reset to 0 (library starts empty)\n\n  // Restore initial state (empty canvases)\n  state.canvases = JSON.parse(JSON.stringify(initialState.canvases));\n  state.selectedItemId = null;\n  state.selectedCanvasId = null;\n  state.activeCanvasId = null;\n  state.currentViewport = 'desktop';\n  state.showGrid = true;\n}\n\nexport { state as gridState, onChange, dispose };\n\n/**\n * Helper Functions\n * ================\n *\n * CRUD operations for managing grid items and canvases.\n * All mutations use spread pattern to trigger reactivity.\n */\n\n/**\n * Add item to canvas\n *\n * **Use cases**:\n * - Dropping component from palette\n * - Undo delete operation\n * - Duplicating existing item\n * - Programmatic item creation\n *\n * **Reactivity pattern**:\n * 1. Push item to canvas.items array\n * 2. Spread canvases object to trigger update\n * 3. Components automatically re-render\n *\n * **Z-index assignment**:\n * Item should have `zIndex: canvas.zIndexCounter++` before calling.\n * This function doesn't assign z-index automatically.\n *\n * **Safety**: No-op if canvas doesn't exist\n *\n * @param canvasId - Target canvas ID\n * @param item - GridItem to add (should have zIndex assigned)\n *\n * @example\n * ```typescript\n * // Add new item from palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(),\n *   canvasId: 'canvas1',\n *   type: 'header',\n *   name: 'Header',\n *   layouts: {\n *     desktop: { x: 5, y: 5, width: 20, height: 8 },\n *     mobile: { x: null, y: null, width: null, height: null, customized: false }\n *   },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n * addItemToCanvas('canvas1', newItem);\n * ```\n */\nexport function addItemToCanvas(canvasId: string, item: GridItem) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items.push(item);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Remove item from canvas\n *\n * **Use cases**:\n * - User deletes item (Delete key or button)\n * - Undo add operation\n * - Clearing canvas\n *\n * **Filter pattern**:\n * Creates new array without the item, preserving array order.\n * Reassignment triggers reactivity.\n *\n * **Index preservation**:\n * Array order maintained for z-index rendering.\n * Other items' indexes shift down by 1.\n *\n * **Safety**: No-op if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to remove\n *\n * @example\n * ```typescript\n * // Delete selected item\n * if (gridState.selectedItemId && gridState.selectedCanvasId) {\n *   removeItemFromCanvas(\n *     gridState.selectedCanvasId,\n *     gridState.selectedItemId\n *   );\n *   deselectItem(); // Clear selection\n * }\n * ```\n */\nexport function removeItemFromCanvas(canvasId: string, itemId: string) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((item) => item.id !== itemId);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Update item properties in canvas\n *\n * **Use cases**:\n * - After drag operation (update position)\n * - After resize operation (update dimensions)\n * - Changing item name or type\n * - Bringing item to front (update zIndex)\n *\n * **Partial updates**:\n * Uses `Partial<GridItem>` to allow updating subset of properties.\n * Object.assign merges updates into existing item.\n *\n * **Typical update patterns**:\n * ```typescript\n * // Update position after drag\n * updateItem(canvasId, itemId, {\n *   layouts: { ...item.layouts, desktop: { x: 10, y: 5, width: 20, height: 8 } }\n * });\n *\n * // Bring to front\n * updateItem(canvasId, itemId, {\n *   zIndex: gridState.canvases[canvasId].zIndexCounter++\n * });\n * ```\n *\n * **Safety**: No-op if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to update\n * @param updates - Partial GridItem with properties to update\n *\n * @example\n * ```typescript\n * // After drag end\n * const item = getItem('canvas1', 'item-3');\n * if (item) {\n *   item.layouts.desktop.x = newX;\n *   item.layouts.desktop.y = newY;\n *   updateItem('canvas1', 'item-3', item);\n * }\n * ```\n */\nexport function updateItem(canvasId: string, itemId: string, updates: Partial<GridItem>) {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  const item = canvas.items.find((i) => i.id === itemId);\n  if (!item) {\n    return;\n  }\n\n  Object.assign(item, updates);\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * Get item by ID\n *\n * **Use cases**:\n * - Reading item data before update\n * - Validation checks\n * - Getting item for undo/redo snapshots\n * - Checking if item exists\n *\n * **Read-only**: Returns reference to item in state.\n * To modify, use `updateItem()` to trigger reactivity.\n *\n * **Safety**: Returns null if canvas or item doesn't exist\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item ID to retrieve\n * @returns GridItem or null if not found\n *\n * @example\n * ```typescript\n * // Check item before operation\n * const item = getItem('canvas1', 'item-3');\n * if (item) {\n *   console.log(`Item at (${item.layouts.desktop.x}, ${item.layouts.desktop.y})`);\n * }\n *\n * // Create snapshot for undo\n * const snapshot = JSON.parse(JSON.stringify(getItem(canvasId, itemId)));\n * ```\n */\nexport function getItem(canvasId: string, itemId: string): GridItem | null {\n  const canvas = state.canvases[canvasId];\n  if (!canvas) {\n    return null;\n  }\n\n  return canvas.items.find((i) => i.id === itemId) || null;\n}\n\n/**\n * Move item to different canvas\n *\n * **Use cases**:\n * - Dragging item across canvas boundaries\n * - Reorganizing multi-section layouts\n * - Undo move operation\n *\n * **Operation flow**:\n * 1. Find item in source canvas\n * 2. Remove from source canvas items array\n * 3. Update item's canvasId property\n * 4. Add to destination canvas items array\n * 5. Trigger reactivity with spread\n *\n * **Important**: Item keeps its existing zIndex.\n * May want to update with destination canvas's zIndexCounter.\n *\n * **Position handling**:\n * Item keeps its grid coordinates. Caller should validate/adjust\n * position fits within destination canvas bounds.\n *\n * **Safety**: No-op if either canvas doesn't exist or item not found\n *\n * @param fromCanvasId - Source canvas ID\n * @param toCanvasId - Destination canvas ID\n * @param itemId - Item to move\n *\n * @example\n * ```typescript\n * // Move item on cross-canvas drag\n * handleDragEnd(event) {\n *   const targetCanvasId = event.dropTarget.id;\n *   if (targetCanvasId !== item.canvasId) {\n *     moveItemToCanvas(item.canvasId, targetCanvasId, item.id);\n *\n *     // Optionally update z-index for new canvas\n *     const canvas = gridState.canvases[targetCanvasId];\n *     updateItem(targetCanvasId, item.id, {\n *       zIndex: canvas.zIndexCounter++\n *     });\n *   }\n * }\n * ```\n */\nexport function moveItemToCanvas(fromCanvasId: string, toCanvasId: string, itemId: string) {\n  const fromCanvas = state.canvases[fromCanvasId];\n  const toCanvas = state.canvases[toCanvasId];\n\n  if (!fromCanvas || !toCanvas) {\n    return;\n  }\n\n  const item = fromCanvas.items.find((i) => i.id === itemId);\n  if (!item) {\n    return;\n  }\n\n  // Remove from old canvas\n  fromCanvas.items = fromCanvas.items.filter((i) => i.id !== itemId);\n\n  // Update item's canvasId\n  item.canvasId = toCanvasId;\n\n  // Add to new canvas\n  toCanvas.items.push(item);\n\n  state.canvases = { ...state.canvases }; // Trigger update\n}\n\n/**\n * ID counter for generating unique item IDs\n *\n * **Starts at 0**: Library starts with empty canvases\n * **Increments**: Each call to generateItemId() returns next ID\n * **Format**: 'item-N' where N is the counter value\n */\nexport let itemIdCounter = 0; // Start at 0 (library starts empty)\n\n/**\n * Generate unique item ID\n *\n * **Use cases**:\n * - Creating new item from palette drop\n * - Duplicating existing item\n * - Any programmatic item creation\n *\n * **Uniqueness guarantee**:\n * Monotonically increasing counter ensures no collisions.\n * Even after delete, IDs never reused.\n *\n * **Format**: Returns 'item-N' (e.g., 'item-11', 'item-12')\n *\n * **Thread safety**: Not thread-safe, but not an issue in\n * single-threaded JavaScript environment.\n *\n * @returns Unique item ID string\n *\n * @example\n * ```typescript\n * // Create new item from palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(), // 'item-11'\n *   canvasId: 'canvas1',\n *   type: 'button',\n *   name: 'Button',\n *   layouts: { ... },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n * ```\n */\nexport function generateItemId(): string {\n  return `item-${++itemIdCounter}`;\n}\n\n/**\n * Select item and set active canvas\n *\n * **Use cases**:\n * - User clicks item\n * - After creating new item (auto-select)\n * - Keyboard navigation\n *\n * **Visual effects**:\n * - Selected item gets visual highlight (via CSS)\n * - Resize/drag handles appear\n * - Item can be deleted with Delete key\n *\n * **State changes**:\n * - `selectedItemId` = itemId\n * - `selectedCanvasId` = canvasId\n * - Components re-render with selection styles\n *\n * **Single selection**: Selecting new item automatically deselects previous\n *\n * @param itemId - Item to select\n * @param canvasId - Canvas containing the item\n *\n * @example\n * ```typescript\n * // Handle item click\n * handleItemClick(item: GridItem) {\n *   selectItem(item.id, item.canvasId);\n * }\n *\n * // Auto-select after creating item\n * const newItem = createNewItem();\n * addItemToCanvas('canvas1', newItem);\n * selectItem(newItem.id, 'canvas1');\n * ```\n */\nexport function selectItem(itemId: string, canvasId: string) {\n  state.selectedItemId = itemId;\n  state.selectedCanvasId = canvasId;\n}\n\n/**\n * Deselect currently selected item\n *\n * **Use cases**:\n * - User clicks canvas background\n * - After deleting selected item\n * - Escape key pressed\n * - Starting drag operation\n *\n * **Visual effects**:\n * - Selection highlight removed\n * - Resize/drag handles hidden\n * - Item no longer delete-able with Delete key\n *\n * **State changes**:\n * - `selectedItemId` = null\n * - `selectedCanvasId` = null\n * - Components re-render without selection styles\n *\n * **Safety**: Safe to call even if nothing selected\n *\n * @example\n * ```typescript\n * // Handle canvas click (deselect)\n * handleCanvasClick(event) {\n *   if (event.target === canvasElement) {\n *     deselectItem();\n *   }\n * }\n *\n * // After deleting item\n * removeItemFromCanvas(canvasId, itemId);\n * deselectItem();\n * ```\n */\nexport function deselectItem() {\n  state.selectedItemId = null;\n  state.selectedCanvasId = null;\n}\n\n/**\n * Set active canvas\n *\n * **Use cases**:\n * - User clicks item on canvas → activate that canvas\n * - User clicks canvas background → activate that canvas\n * - User starts dragging item → activate canvas containing item\n * - User starts resizing item → activate canvas containing item\n * - Programmatic canvas focus (e.g., after adding item)\n *\n * **Visual effects**:\n * - Canvas title opacity changes (consumer-controlled CSS)\n * - Canvas border/highlight applied\n * - Canvas-specific settings panel shown\n *\n * **State changes**:\n * - `activeCanvasId` = canvasId\n * - Components re-render with isActive prop\n * - 'canvasActivated' event emitted\n *\n * **Reactivity**: Direct assignment (no spread needed for primitive)\n *\n * @param canvasId - Canvas ID to activate\n *\n * @example\n * ```typescript\n * // Handle item click (activate canvas)\n * handleItemClick(itemId, canvasId) {\n *   setActiveCanvas(canvasId);\n *   selectItem(itemId, canvasId);\n * }\n *\n * // Handle canvas background click\n * handleCanvasClick(canvasId) {\n *   setActiveCanvas(canvasId);\n *   deselectItem();\n * }\n * ```\n */\nexport function setActiveCanvas(canvasId: string) {\n  state.activeCanvasId = canvasId;\n}\n\n/**\n * Clear active canvas\n *\n * **Use cases**:\n * - Reset application state\n * - Close all panels\n * - Deactivate all canvases\n *\n * **Visual effects**:\n * - All canvas titles return to inactive state\n * - No canvas highlighted\n * - Canvas settings panel hidden\n *\n * **State changes**:\n * - `activeCanvasId` = null\n * - Components re-render without active state\n *\n * **Safety**: Safe to call even if no canvas active\n *\n * @example\n * ```typescript\n * // Reset button handler\n * handleReset() {\n *   clearActiveCanvas();\n *   deselectItem();\n *   reset();\n * }\n * ```\n */\nexport function clearActiveCanvas() {\n  state.activeCanvasId = null;\n}\n\n/**\n * Batch Operations\n * =================\n *\n * Performance-optimized functions for bulk operations.\n * Single state update = single re-render (vs N updates = N re-renders).\n */\n\n/**\n * Add multiple items in a single batch\n *\n * **Performance benefit**: 1000 items added in ~10ms with single re-render\n * vs ~200-500ms with 1000 individual add calls and 1000 re-renders.\n *\n * **Use cases**:\n * - Stress testing (adding 100-1000 items)\n * - Template/preset loading (page templates with many components)\n * - Undo batch delete\n * - Import from saved layout\n *\n * **Reactivity pattern**:\n * 1. Clone canvases object\n * 2. Add all items to cloned canvases\n * 3. Single state assignment triggers single re-render\n * 4. Single undo/redo command for entire batch\n *\n * @param items - Array of partial GridItem specs (missing id, zIndex auto-assigned)\n * @returns Array of created item IDs\n *\n * @example\n * ```typescript\n * // Add 100 items in stress test\n * const items = Array.from({ length: 100 }, (_, i) => ({\n *   canvasId: 'canvas1',\n *   type: i % 2 === 0 ? 'header' : 'text',\n *   name: `Item ${i}`,\n *   layouts: {\n *     desktop: { x: (i % 10) * 5, y: Math.floor(i / 10) * 5, width: 20, height: 5 },\n *     mobile: { x: null, y: null, width: null, height: null, customized: false }\n *   }\n * }));\n *\n * const itemIds = addItemsBatch(items);\n * // ✅ 1 state update, 1 re-render, 1 undo command\n * ```\n */\nexport function addItemsBatch(items: Partial<GridItem>[]): string[] {\n  const itemIds: string[] = [];\n  const updatedCanvases = { ...state.canvases };\n\n  for (const itemData of items) {\n    const id = generateItemId();\n    const canvasId = itemData.canvasId!;\n    const canvas = updatedCanvases[canvasId];\n\n    if (!canvas) {\n      console.warn(`Canvas ${canvasId} not found, skipping item`);\n      continue;\n    }\n\n    const newItem: GridItem = {\n      id,\n      canvasId,\n      type: itemData.type || 'unknown',\n      name: itemData.name || 'Unnamed',\n      layouts: itemData.layouts || {\n        desktop: { x: 0, y: 0, width: 20, height: 10 },\n        mobile: { x: null, y: null, width: null, height: null, customized: false },\n      },\n      zIndex: canvas.zIndexCounter++,\n      config: itemData.config || {},\n    };\n\n    canvas.items.push(newItem);\n    itemIds.push(id);\n  }\n\n  // Single state update triggers single re-render\n  state.canvases = updatedCanvases;\n\n  return itemIds;\n}\n\n/**\n * Delete multiple items in a single batch\n *\n * **Performance benefit**: 1000 items deleted in ~5ms with single re-render\n * vs ~100-200ms with 1000 individual delete calls and 1000 re-renders.\n *\n * **Use cases**:\n * - Clear canvas (delete all)\n * - Delete selection group\n * - Undo batch add\n * - Cleanup operations\n *\n * **Reactivity pattern**:\n * 1. Clone canvases object\n * 2. Filter out all items from cloned canvases\n * 3. Single state assignment triggers single re-render\n * 4. Single undo/redo command for entire batch\n *\n * @param itemIds - Array of item IDs to delete\n *\n * @example\n * ```typescript\n * // Clear entire canvas\n * const canvas = gridState.canvases['canvas1'];\n * const allItemIds = canvas.items.map(item => item.id);\n * deleteItemsBatch(allItemIds);\n * // ✅ 1 state update, 1 re-render, 1 undo command\n * ```\n */\nexport function deleteItemsBatch(itemIds: string[]): void {\n  const itemIdSet = new Set(itemIds);\n  const updatedCanvases = { ...state.canvases };\n\n  // Filter out items from all canvases\n  for (const canvasId in updatedCanvases) {\n    updatedCanvases[canvasId] = {\n      ...updatedCanvases[canvasId],\n      items: updatedCanvases[canvasId].items.filter((item) => !itemIdSet.has(item.id)),\n    };\n  }\n\n  // Single state update triggers single re-render\n  state.canvases = updatedCanvases;\n}\n\n/**\n * Update multiple item configs in a single batch\n *\n * **Performance benefit**: 1000 items updated in ~8ms with single re-render\n * vs ~150-300ms with 1000 individual update calls and 1000 re-renders.\n *\n * **Use cases**:\n * - Theme changes (update colors for all items)\n * - Bulk property changes\n * - Undo batch config change\n * - Template application\n *\n * **Reactivity pattern**:\n * 1. Clone canvases object\n * 2. Apply all updates to cloned canvases\n * 3. Single state assignment triggers single re-render\n * 4. Single undo/redo command for entire batch\n *\n * @param updates - Array of { itemId, canvasId, updates } objects\n *\n * @example\n * ```typescript\n * // Change all headers to blue\n * const headerUpdates = Object.values(gridState.canvases)\n *   .flatMap(canvas => canvas.items)\n *   .filter(item => item.type === 'header')\n *   .map(item => ({\n *     itemId: item.id,\n *     canvasId: item.canvasId,\n *     updates: { config: { ...item.config, color: 'blue' } }\n *   }));\n *\n * updateItemsBatch(headerUpdates);\n * // ✅ 1 state update, 1 re-render, 1 undo command\n * ```\n */\nexport function updateItemsBatch(\n  updates: Array<{ itemId: string; canvasId: string; updates: Partial<GridItem> }>\n): void {\n  const updatedCanvases = { ...state.canvases };\n\n  for (const { itemId, canvasId, updates: itemUpdates } of updates) {\n    const canvas = updatedCanvases[canvasId];\n    if (!canvas) {\n      console.warn(`Canvas ${canvasId} not found, skipping item ${itemId}`);\n      continue;\n    }\n\n    const item = canvas.items.find((i) => i.id === itemId);\n    if (!item) {\n      console.warn(`Item ${itemId} not found in canvas ${canvasId}`);\n      continue;\n    }\n\n    Object.assign(item, itemUpdates);\n  }\n\n  // Single state update triggers single re-render\n  state.canvases = updatedCanvases;\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}