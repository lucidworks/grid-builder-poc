{"version":3,"file":"grid-calculations-CcbD7Svb.js","sources":["src/utils/dom-cache.ts","src/utils/grid-calculations.ts"],"sourcesContent":["/**\n * DOM Cache Utility\n * =================\n *\n * Performance optimization layer that caches frequently accessed DOM elements to avoid\n * repeated `document.getElementById()` calls during drag/resize operations.\n *\n * ## Problem\n *\n * During interactive operations (drag, resize), we frequently need to access the same\n * DOM elements:\n * - Canvas containers for width calculations\n * - Grid items for position updates\n * - Parent elements for coordinate transforms\n *\n * Each `document.getElementById()` call:\n * - Traverses the DOM tree\n * - Can trigger layout calculations\n * - Becomes expensive when called hundreds of times per second during drag\n *\n * ## Solution\n *\n * Cache DOM references in memory after first lookup:\n * - **First access**: Query DOM once and store reference\n * - **Subsequent access**: Return cached reference (O(1) Map lookup)\n * - **Invalidation**: Clear cache when DOM structure changes\n *\n * ## Performance Impact\n *\n * **Without caching**:\n * - During drag: ~60 getElementById calls/second (60fps × multiple items)\n * - Each call traverses DOM tree\n * - Cumulative impact on frame budget\n *\n * **With caching**:\n * - First call: DOM query + cache store\n * - Subsequent: Map.get() (constant time)\n * - 90%+ reduction in DOM queries during operations\n *\n * ## When to Use This Pattern\n *\n * Apply DOM caching when:\n * ✅ Accessing same elements repeatedly in tight loops\n * ✅ During high-frequency events (mousemove, scroll, resize)\n * ✅ Elements are stable (not frequently added/removed)\n * ✅ Performance profiling shows getElementById as bottleneck\n *\n * Avoid when:\n * ❌ Elements change frequently (cache becomes stale)\n * ❌ Only accessing elements once\n * ❌ Using framework-managed refs (React useRef, Stencil @Element)\n *\n * ## Extracting This Pattern\n *\n * To adapt for your project:\n * ```typescript\n * class MyDOMCache {\n *   private elements = new Map<string, HTMLElement>();\n *\n *   get(id: string): HTMLElement | null {\n *     if (this.elements.has(id)) return this.elements.get(id)!;\n *     const el = document.getElementById(id);\n *     if (el) this.elements.set(id, el);\n *     return el;\n *   }\n *\n *   invalidate(id: string) { this.elements.delete(id); }\n * }\n * export const cache = new MyDOMCache();\n * ```\n *\n * ## Cache Invalidation Strategy\n *\n * Clear cache when:\n * - Canvas added/removed from DOM\n * - Component unmounts\n * - Major DOM restructuring\n * - Element IDs change\n *\n * @module dom-cache\n */\n\n/**\n * DOM Cache for canvas containers and frequently accessed elements\n *\n * Singleton pattern ensures all code uses same cache instance\n */\nclass DOMCache {\n  /** Canvas element cache - key: canvasId, value: HTMLElement */\n  private canvases: Map<string, HTMLElement> = new Map();\n\n  /**\n   * Get canvas element by ID with automatic caching\n   *\n   * **Caching behavior**:\n   * 1. Check Map cache first (O(1))\n   * 2. If miss, query DOM and cache result\n   * 3. Return cached or fresh element\n   *\n   * **Performance**:\n   * - Cached access: ~0.001ms (Map.get)\n   * - DOM query: ~0.1-1ms (getElementById + tree traversal)\n   * - Speedup: 100-1000x for cached access\n   *\n   * **Safety**:\n   * - Returns `null` if element doesn't exist\n   * - Safe to call before DOM ready (returns null, doesn't cache)\n   * - Cache automatically populated on first successful access\n   *\n   * @param canvasId - Canvas container element ID\n   * @returns HTMLElement or null if not found\n   *\n   * @example\n   * ```typescript\n   * // First call - queries DOM\n   * const canvas1 = domCache.getCanvas('canvas1'); // ~0.5ms\n   *\n   * // Subsequent calls - returns cached\n   * const canvas2 = domCache.getCanvas('canvas1'); // ~0.001ms\n   * const canvas3 = domCache.getCanvas('canvas1'); // ~0.001ms\n   *\n   * // Different canvas - new DOM query\n   * const canvas4 = domCache.getCanvas('canvas2'); // ~0.5ms\n   * ```\n   */\n  getCanvas(canvasId: string): HTMLElement | null {\n    // Check cache first\n    if (this.canvases.has(canvasId)) {\n      return this.canvases.get(canvasId)!;\n    }\n\n    // Query DOM and cache\n    const canvas = document.getElementById(canvasId);\n    if (canvas) {\n      this.canvases.set(canvasId, canvas);\n    }\n\n    return canvas;\n  }\n\n  /**\n   * Invalidate cache for a specific canvas\n   *\n   * **When to call**:\n   * - Canvas element removed from DOM\n   * - Canvas element replaced (same ID, different element)\n   * - Canvas component unmounts\n   * - Element ID changed\n   *\n   * **Why needed**:\n   * Cached references become stale when elements are removed or replaced.\n   * Invalidation ensures next access queries fresh element from DOM.\n   *\n   * **Performance**:\n   * Very cheap operation (Map.delete is O(1))\n   *\n   * @param canvasId - Canvas ID to remove from cache\n   *\n   * @example\n   * ```typescript\n   * // Component unmounting\n   * disconnectedCallback() {\n   *   domCache.invalidate(this.canvasId);\n   * }\n   *\n   * // Canvas removed from state\n   * delete gridState.canvases['canvas1'];\n   * domCache.invalidate('canvas1');\n   * ```\n   */\n  invalidate(canvasId: string): void {\n    this.canvases.delete(canvasId);\n  }\n\n  /**\n   * Clear entire DOM cache\n   *\n   * **When to call**:\n   * - Major DOM restructuring (e.g., navigation, full page reload)\n   * - All canvases removed/replaced\n   * - Test cleanup (afterEach hooks)\n   * - Memory cleanup when cache grows too large\n   *\n   * **Why needed**:\n   * Prevents memory leaks from cached references to removed elements\n   * and ensures clean slate after major DOM changes.\n   *\n   * **Performance**:\n   * Cheap operation - just clears Map references.\n   * Elements are garbage collected automatically.\n   *\n   * @example\n   * ```typescript\n   * // Test cleanup\n   * afterEach(() => {\n   *   domCache.clear();\n   * });\n   *\n   * // Navigation/route change\n   * router.beforeEach(() => {\n   *   domCache.clear();\n   * });\n   *\n   * // Memory management\n   * if (domCache.size() > 100) {\n   *   domCache.clear(); // Periodic cleanup\n   * }\n   * ```\n   */\n  clear(): void {\n    this.canvases.clear();\n  }\n}\n\n/**\n * Singleton DOM cache instance\n *\n * Export as const to ensure single instance across entire application.\n * All modules import same cache, preventing duplicate element caching\n * and ensuring consistent cache state.\n *\n * @example\n * ```typescript\n * import { domCache } from './dom-cache';\n *\n * // All modules use same cache instance\n * const el1 = domCache.getCanvas('canvas1');\n * const el2 = domCache.getCanvas('canvas1'); // Same reference\n * ```\n */\nexport const domCache = new DOMCache();\n","/**\n * Grid Calculations Utility\n * ========================\n *\n * Core system for converting between pixel coordinates and grid units in the drag-and-drop\n * grid builder. This module provides pure functions with performance optimizations through\n * intelligent caching.\n *\n * ## Grid System Architecture\n *\n * The grid uses a hybrid approach combining responsive and fixed sizing:\n *\n * ### Horizontal Grid (Responsive)\n * - **Size**: 2% of container width (50 units across full width)\n * - **Behavior**: Scales proportionally with canvas width changes\n * - **Use case**: Enables responsive layouts that adapt to different screen sizes\n * - **Example**: At 1000px width, each grid unit = 20px (1000 * 0.02)\n *\n * ### Vertical Grid (Fixed)\n * - **Size**: Fixed 20px per grid unit\n * - **Behavior**: Remains constant regardless of viewport size\n * - **Use case**: Provides consistent vertical spacing and predictable heights\n * - **Rationale**: Vertical scrolling is unlimited, so fixed sizing provides better UX\n *\n * ## Performance Optimization Strategy\n *\n * ### Grid Size Caching\n * The horizontal grid size is calculated from DOM elements (container.clientWidth),\n * which is an expensive operation. To minimize performance impact:\n *\n * 1. **First access**: Calculate once per canvas and cache the result\n * 2. **Subsequent access**: Return cached value (no DOM reads)\n * 3. **Cache invalidation**: Clear when canvas resizes (via ResizeObserver)\n *\n * **Performance Impact**:\n * - Without caching: 100 items = 100+ DOM reads during viewport switch\n * - With caching: 100 items = 1 DOM read per canvas during viewport switch\n * - Prevents layout thrashing and reduces reflows\n *\n * ### DOM Caching Integration\n * Uses `domCache` utility to avoid repeated `getElementById` calls, providing\n * a second layer of performance optimization.\n *\n * ## Usage Examples\n *\n * ```typescript\n * // Convert grid position to pixels for rendering\n * const pixelX = gridToPixelsX(10, 'canvas1'); // Grid unit 10 → pixels\n * const pixelY = gridToPixelsY(5);              // Grid unit 5 → 100px\n *\n * // Convert mouse position to grid coordinates\n * const gridX = pixelsToGridX(250, 'canvas1');  // Pixels → grid units\n * const gridY = pixelsToGridY(120);             // 120px → 6 grid units\n *\n * // Clear cache on canvas resize\n * resizeObserver.observe(canvasContainer);\n * resizeObserver.addEventListener(() => clearGridSizeCache());\n * ```\n *\n * @module grid-calculations\n */\n\nimport { domCache } from './dom-cache';\nimport { GridConfig } from '../types/grid-config';\n\n/** Fixed vertical grid size in pixels - provides consistent vertical spacing */\nconst GRID_SIZE_VERTICAL = 20;\n\n/**\n * Horizontal grid size as percentage of container width\n * 0.02 = 2% = 50 grid units across full width\n */\nconst GRID_SIZE_HORIZONTAL_PERCENT = 0.02;\n\n/**\n * Default minimum grid size in pixels\n * Prevents grid from becoming too small on tiny screens\n */\nconst DEFAULT_MIN_GRID_SIZE = 10;\n\n/**\n * Default maximum grid size in pixels\n * Prevents grid from becoming too large on huge screens\n */\nconst DEFAULT_MAX_GRID_SIZE = 50;\n\n/**\n * Grid size cache to avoid repeated DOM queries\n * Key format: `${canvasId}-h` for horizontal grid sizes\n * Cleared on canvas resize events\n */\nconst gridSizeCache = new Map<string, number>();\n\n/**\n * Clear the grid size cache for all canvases\n *\n * **When to call**:\n * - Canvas container is resized (via ResizeObserver)\n * - Viewport changes (desktop ↔ mobile)\n * - Canvas is added/removed from DOM\n *\n * **Why needed**:\n * Cached grid sizes become stale when container widths change. This ensures\n * fresh calculations on next access.\n *\n * **Performance note**:\n * Clearing cache is cheap (O(1)). The cost is in recalculation, which happens\n * lazily on next access.\n *\n * @example\n * ```typescript\n * resizeObserver.observe(canvasElement);\n * resizeCallback = () => {\n *   clearGridSizeCache();\n *   // Components will recalculate on next render\n * };\n * ```\n */\nexport function clearGridSizeCache() {\n  gridSizeCache.clear();\n}\n\n/**\n * Get the horizontal grid size for a specific canvas\n *\n * **Calculation**: `containerWidth * gridSizePercent` = size of one horizontal grid unit in pixels\n * **Min/Max constraints**: Applied from GridConfig (default: 10px-50px)\n *\n * **Caching behavior**:\n * - First call: Reads `container.clientWidth` from DOM and caches result\n * - Subsequent calls: Returns cached value (no DOM access)\n * - After resize: Cache cleared, recalculates on next call\n *\n * **Why responsive**:\n * Horizontal grid scales with container to support:\n * - Responsive layouts (desktop/mobile)\n * - Variable canvas widths\n * - Fluid grid-based designs\n *\n * **GridConfig customization**:\n * - `gridSizePercent`: Grid unit as % of width (default: 2% = 50 units per 100% width)\n * - `minGridSize`: Minimum size in pixels (default: 10px, prevents too small on mobile)\n * - `maxGridSize`: Maximum size in pixels (default: 50px, prevents too large on desktop)\n *\n * @param canvasId - The canvas element ID to calculate grid size for\n * @param config - Optional GridConfig for customization\n * @param forceRecalc - Set true to bypass cache and force fresh calculation\n * @returns Size of one horizontal grid unit in pixels (constrained by min/max)\n *\n * @example\n * ```typescript\n * // Default config (2% grid, 10px-50px)\n * const size1 = getGridSizeHorizontal('canvas1'); // → 20 (at 1000px width)\n *\n * // Custom config (3% grid, 15px-60px)\n * const size2 = getGridSizeHorizontal('canvas1', {\n *   gridSizePercent: 3,\n *   minGridSize: 15,\n *   maxGridSize: 60\n * }); // → 30 (at 1000px width)\n *\n * // Force recalculation\n * const size3 = getGridSizeHorizontal('canvas1', undefined, true);\n * ```\n */\nexport function getGridSizeHorizontal(\n  canvasId: string,\n  config?: GridConfig,\n  forceRecalc: boolean = false\n): number {\n  const cacheKey = `${canvasId}-h`;\n\n  if (!forceRecalc && gridSizeCache.has(cacheKey)) {\n    return gridSizeCache.get(cacheKey)!;\n  }\n\n  // Use DOM cache instead of getElementById\n  const container = domCache.getCanvas(canvasId);\n  if (!container) {\n    console.warn(`Canvas container not found: ${canvasId}`);\n    return 0;\n  }\n\n  // Get grid size percent from config or use default\n  // Config gridSizePercent is whole number (2 = 2%), default is already decimal (0.02)\n  const gridSizePercent = config?.gridSizePercent ? config.gridSizePercent / 100 : GRID_SIZE_HORIZONTAL_PERCENT;\n\n  // Calculate raw grid size\n  const rawSize = container.clientWidth * gridSizePercent;\n\n  // Apply min/max constraints from config or use defaults\n  const minSize = config?.minGridSize ?? DEFAULT_MIN_GRID_SIZE;\n  const maxSize = config?.maxGridSize ?? DEFAULT_MAX_GRID_SIZE;\n  const size = Math.max(minSize, Math.min(maxSize, rawSize));\n\n  gridSizeCache.set(cacheKey, size);\n  return size;\n}\n\n/**\n * Get the vertical grid size\n *\n * **Configurable vertical grid**:\n * Unlike horizontal grid, vertical uses fixed sizing (default 20px) because:\n * - Vertical scrolling is infinite (no container height limit)\n * - Provides predictable, consistent heights across all viewports\n * - Simplifies calculations (no container dependency)\n * - Better UX for vertical spacing\n *\n * @param config Optional GridConfig with verticalGridSize\n * @returns Vertical grid size in pixels (config.verticalGridSize || 20)\n *\n * @example\n * ```typescript\n * const vSize = getGridSizeVertical(); // → 20 (default)\n * const vSize2 = getGridSizeVertical({ verticalGridSize: 25 }); // → 25\n * ```\n */\nexport function getGridSizeVertical(config?: GridConfig): number {\n  return config?.verticalGridSize ?? GRID_SIZE_VERTICAL;\n}\n\n/**\n * Convert grid units to pixels for horizontal positioning and sizing\n *\n * **Use cases**:\n * - Converting item `x` position from grid coordinates to CSS left/transform\n * - Converting item `width` from grid units to CSS width\n * - Rendering grid items at correct horizontal positions\n *\n * **Performance**:\n * Uses cached grid size via `getGridSizeHorizontal()` to avoid DOM reads\n *\n * **Rounding**:\n * Uses `Math.round()` to prevent subpixel rendering issues\n *\n * @param gridUnits - Number of grid units\n * @param canvasId - Canvas ID for responsive grid size calculation\n * @param config - Optional GridConfig for customization\n * @returns Pixel value\n *\n * @example\n * ```typescript\n * // Item at grid position x=10 (default 2% grid)\n * const leftPx = gridToPixelsX(10, 'canvas1'); // → 200px (at 1000px container)\n *\n * // Item with grid width=15 (custom 3% grid)\n * const widthPx = gridToPixelsX(15, 'canvas1', { gridSizePercent: 3 }); // → 450px\n * ```\n */\nexport function gridToPixelsX(gridUnits: number, canvasId: string, config?: GridConfig): number {\n  // Use cached grid size for better performance\n  const gridSize = getGridSizeHorizontal(canvasId, config);\n  return Math.round(gridUnits * gridSize);\n}\n\n/**\n * Convert grid units to pixels for vertical positioning and sizing\n *\n * **Use cases**:\n * - Converting item `y` position from grid coordinates to CSS top/transform\n * - Converting item `height` from grid units to CSS height\n * - Calculating vertical spacing\n *\n * **Configurable vertical grid**:\n * Uses config.verticalGridSize (default 20px) for calculation\n *\n * @param gridUnits - Number of grid units\n * @param config - Optional GridConfig with verticalGridSize\n * @returns Pixel value (gridUnits * verticalGridSize)\n *\n * @example\n * ```typescript\n * // Item at grid position y=5 (default 20px)\n * const topPx = gridToPixelsY(5); // → 100px\n *\n * // Item with grid height=8 (custom 25px)\n * const heightPx = gridToPixelsY(8, { verticalGridSize: 25 }); // → 200px\n * ```\n */\nexport function gridToPixelsY(gridUnits: number, config?: GridConfig): number {\n  return gridUnits * getGridSizeVertical(config);\n}\n\n/**\n * Convert pixel coordinates to grid units for horizontal values\n *\n * **Use cases**:\n * - Converting mouse/drop position to grid coordinates\n * - Snapping dragged items to grid\n * - Calculating item positions after drag\n *\n * **Rounding**:\n * Uses `Math.round()` to snap to nearest grid unit (implements grid snapping)\n *\n * **Safety**:\n * Returns 0 if grid size is 0 (container not found/initialized)\n *\n * @param pixels - Pixel value to convert\n * @param canvasId - Canvas ID for responsive grid size calculation\n * @param config - Optional GridConfig for customization\n * @returns Number of grid units (rounded)\n *\n * @example\n * ```typescript\n * // Mouse drop at 250px (default 2% grid)\n * const gridX = pixelsToGridX(250, 'canvas1'); // → 13 (at 1000px container)\n *\n * // After drag, element at 371px (custom 3% grid)\n * const snappedX = pixelsToGridX(371, 'canvas1', { gridSizePercent: 3 }); // → 12\n * ```\n */\nexport function pixelsToGridX(pixels: number, canvasId: string, config?: GridConfig): number {\n  // Use cached grid size for better performance\n  const gridSize = getGridSizeHorizontal(canvasId, config);\n  if (gridSize === 0) {\n    return 0;\n  }\n  return Math.round(pixels / gridSize);\n}\n\n/**\n * Convert pixel coordinates to grid units for vertical values\n *\n * **Use cases**:\n * - Converting mouse Y position to grid coordinates\n * - Snapping vertical positions to grid\n * - Calculating vertical offsets\n *\n * **Rounding**:\n * Implements automatic grid snapping via `Math.round()`\n *\n * @param pixels - Pixel value to convert\n * @param config - Optional GridConfig with verticalGridSize\n * @returns Number of grid units (rounded)\n *\n * @example\n * ```typescript\n * // Mouse at 127px vertically (default 20px grid)\n * const gridY = pixelsToGridY(127); // → 6 (rounded from 6.35)\n *\n * // Element height 165px (custom 25px grid)\n * const gridHeight = pixelsToGridY(165, { verticalGridSize: 25 }); // → 7 (rounded from 6.6)\n * ```\n */\nexport function pixelsToGridY(pixels: number, config?: GridConfig): number {\n  return Math.round(pixels / getGridSizeVertical(config));\n}\n"],"names":[],"mappings":"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"}