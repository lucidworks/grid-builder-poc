{"version":3,"file":"boundary-constraints-C3OHvTXO.js","sources":["src/services/virtual-renderer.ts","src/utils/debug.ts","src/services/undo-redo-commands.ts","src/services/undo-redo.ts","src/utils/boundary-constraints.ts"],"sourcesContent":["/**\n * Virtual Renderer Service - Lazy Loading System\n * ===============================================\n *\n * Performance optimization using IntersectionObserver to lazy-load component content\n * only when visible in the viewport. Reduces initial render time, memory usage, and\n * improves page load performance for pages with 100+ grid items.\n *\n * ## Problem\n *\n * Grid builders with many items face performance challenges:\n * - **Initial render cost**: Rendering 100+ components at page load is expensive\n * - **Memory overhead**: All components in memory even if off-screen\n * - **Slow page load**: Long time to interactive (TTI)\n * - **Poor scrolling**: Heavy DOM operations during scroll\n * - **Wasted rendering**: Complex components rendered but never seen\n *\n * **Example scenario**:\n * - Page with 100 grid items\n * - 10 items visible initially\n * - 90 items rendered but off-screen (wasted work)\n * - Each complex component: ~5-50ms to render\n * - Total wasted: 450-4500ms (almost 5 seconds!)\n *\n * ## Solution\n *\n * IntersectionObserver pattern providing:\n * 1. **Lazy initialization**: Items start with placeholder content\n * 2. **Viewport detection**: Observe when items enter viewport\n * 3. **Callback notification**: Notify components when visible\n * 4. **Component rendering**: Replace placeholder with actual content\n * 5. **Pre-rendering**: Start loading 200px before entering viewport\n * 6. **Memory cleanup**: Unobserve removed components\n *\n * ## Architecture: IntersectionObserver Pattern\n *\n * **Observer setup**:\n * ```typescript\n * // In grid-builder-app.tsx componentDidLoad:\n * (window as any).virtualRenderer = new VirtualRendererService();\n *\n * // In grid-item-wrapper.tsx componentDidLoad:\n * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *   this.isVisible = isVisible;  // Triggers re-render\n * });\n * ```\n *\n * **Flow**:\n * ```\n * 1. Grid item mounts → observe(element, callback)\n * 2. Item scrolls into viewport (200px before visible)\n * 3. IntersectionObserver fires → callback(true)\n * 4. Component sets isVisible = true → re-renders\n * 5. Placeholder replaced with actual component\n * 6. User sees smooth transition\n * ```\n *\n * **Cleanup**:\n * ```\n * 1. Grid item unmounts → disconnectedCallback()\n * 2. unobserve(element, id) → stop watching\n * 3. Remove callback from map → allow GC\n * 4. Observer continues for other elements\n * ```\n *\n * ## IntersectionObserver Configuration\n *\n * **Root margin strategy** (`rootMargin: '200px'`):\n * - Pre-render items 200px before they enter viewport\n * - Ensures content ready when user scrolls\n * - Prevents \"pop-in\" effect (flash of placeholder)\n * - Balance between performance and UX\n *\n * **Why 200px**:\n * - Typical scroll speed: ~100-300px per second\n * - 200px gives ~1 second to render before visible\n * - Complex component: ~50-200ms to render\n * - Comfortable buffer for smooth loading\n *\n * **Threshold setting** (`threshold: 0.01`):\n * - Trigger when even 1% of element is visible\n * - Very early detection (as soon as edge appears)\n * - Maximizes pre-render time\n * - Prevents late loading\n *\n * **Why 0.01 not 0**:\n * - 0 = fully outside viewport\n * - 0.01 = edge just entering\n * - Better cross-browser behavior\n * - More reliable than 0\n *\n * ## Observer Callback Pattern\n *\n * **Callback signature**:\n * ```typescript\n * type VisibilityCallback = (isVisible: boolean) => void;\n * ```\n *\n * **Callback invocation**:\n * ```typescript\n * entries.forEach((entry) => {\n *   const callback = this.observedElements.get(elementId);\n *   if (callback) {\n *     callback(entry.isIntersecting);  // true when entering, false when exiting\n *   }\n * });\n * ```\n *\n * **Component handler**:\n * ```typescript\n * // In grid-item-wrapper.tsx:\n * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *   this.isVisible = isVisible;  // @State update triggers re-render\n * });\n * ```\n *\n * **Render method**:\n * ```typescript\n * renderComponent() {\n *   if (!this.isVisible) {\n *     return <div class=\"component-placeholder\">Loading...</div>;\n *   }\n *   // Render actual component (expensive)\n *   return <component-image-gallery itemId={this.item.id} />;\n * }\n * ```\n *\n * ## Memory Management\n *\n * **Callback storage**:\n * ```typescript\n * private observedElements: Map<string, VisibilityCallback> = new Map();\n * ```\n *\n * **Why Map**:\n * - O(1) lookup by element ID\n * - Easy cleanup (delete)\n * - Prevents memory leaks\n * - Standard pattern\n *\n * **Cleanup strategy**:\n * 1. Component unmounts → unobserve(element, id)\n * 2. Delete callback from map → allow GC\n * 3. Observer stops watching element\n * 4. Element can be garbage collected\n *\n * **Memory impact**:\n * - Each callback: ~100 bytes\n * - 100 items: ~10KB total\n * - Negligible overhead\n *\n * ## Performance Characteristics\n *\n * **Initial page load** (100 items, 10 visible):\n * - Without virtual rendering: ~500-5000ms (render all)\n * - With virtual rendering: ~50-500ms (render 10)\n * - **10× faster initial load**\n *\n * **Scroll performance**:\n * - Observer overhead: ~1-2ms per event\n * - Component render: ~5-50ms (varies by type)\n * - Pre-render buffer: Items ready when visible\n * - Smooth 60fps scrolling maintained\n *\n * **Memory usage** (100 items):\n * - Without virtual rendering: ~50-500MB (all components)\n * - With virtual rendering: ~5-50MB (visible + buffered)\n * - **10× lower memory usage**\n *\n * ## Complex Component Targeting\n *\n * **Simple components** (always render):\n * - header, text, button (fast ~1-5ms)\n * - No lazy loading needed\n * - Always visible immediately\n *\n * **Complex components** (lazy load):\n * - image-gallery: Multiple images to load (~50-200ms)\n * - dashboard-widget: Chart rendering (~100-500ms)\n * - live-data: API calls + updates (~100ms+)\n *\n * **How wrapper decides**:\n * ```typescript\n * // In grid-item-wrapper.tsx:\n * componentDidLoad() {\n *   // Always observe, component decides if needed\n *   virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *     this.isVisible = isVisible;\n *   });\n * }\n *\n * renderComponent() {\n *   // Simple components ignore isVisible flag\n *   if (!this.isVisible && this.item.type === 'imageGallery') {\n *     return <div class=\"component-placeholder\">Loading...</div>;\n *   }\n *   // Complex types use isVisible guard\n * }\n * ```\n *\n * ## Browser Compatibility\n *\n * **IntersectionObserver support**:\n * - Chrome 51+ (2016)\n * - Firefox 55+ (2017)\n * - Safari 12.1+ (2019)\n * - Edge 15+ (2017)\n * - ~97% global browser coverage (2024)\n *\n * **Polyfill option**:\n * ```typescript\n * // If needed for older browsers:\n * import 'intersection-observer'; // polyfill\n * ```\n *\n * **Graceful degradation**:\n * - If IntersectionObserver unavailable\n * - Could fallback to immediate rendering\n * - Or use scroll event listener (less efficient)\n *\n * ## Extracting This Pattern\n *\n * To adapt virtual rendering for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * // 1. Create observer service\n * class VirtualRenderer {\n *   private observer: IntersectionObserver;\n *   private callbacks = new Map<string, (visible: boolean) => void>();\n *\n *   constructor() {\n *     this.observer = new IntersectionObserver(\n *       (entries) => entries.forEach(e =>\n *         this.callbacks.get(e.target.id)?.(e.isIntersecting)\n *       ),\n *       { rootMargin: '200px', threshold: 0.01 }\n *     );\n *   }\n *\n *   observe(el: Element, id: string, cb: (visible: boolean) => void) {\n *     this.callbacks.set(id, cb);\n *     this.observer.observe(el);\n *   }\n *\n *   unobserve(el: Element, id: string) {\n *     this.callbacks.delete(id);\n *     this.observer.unobserve(el);\n *   }\n * }\n *\n * // 2. Create singleton\n * export const virtualRenderer = new VirtualRenderer();\n *\n * // 3. Use in component\n * useEffect(() => {\n *   virtualRenderer.observe(ref.current, id, setIsVisible);\n *   return () => virtualRenderer.unobserve(ref.current, id);\n * }, []);\n *\n * return isVisible ? <ComplexComponent /> : <Placeholder />;\n * ```\n *\n * **For different frameworks**:\n * - **React**: Use useEffect for lifecycle, useState for visibility\n * - **Vue**: Use onMounted/onUnmounted, ref() for visibility\n * - **Angular**: Use ngAfterViewInit/ngOnDestroy, signals for visibility\n * - **Svelte**: Use onMount/onDestroy, stores for visibility\n *\n * **Key patterns to preserve**:\n * 1. Singleton service (one observer for all components)\n * 2. Callback map for O(1) lookups\n * 3. 200px root margin for pre-rendering\n * 4. 0.01 threshold for early detection\n * 5. Cleanup on component unmount\n *\n * **Customization options**:\n * ```typescript\n * // Adjust root margin based on needs\n * rootMargin: '200px'  // Standard (1 second buffer)\n * rootMargin: '400px'  // Aggressive (2 second buffer, more memory)\n * rootMargin: '100px'  // Conservative (less memory, might see pop-in)\n *\n * // Adjust threshold based on needs\n * threshold: 0.01      // Trigger immediately\n * threshold: 0.1       // Trigger when 10% visible\n * threshold: 0.5       // Trigger when 50% visible (not recommended)\n * ```\n *\n * @module virtual-renderer\n */\n\n/**\n * Visibility callback function type\n *\n * **Signature**: `(isVisible: boolean) => void`\n * **Called when**: Element enters or exits viewport\n * **Parameter**: `isVisible` - true when entering, false when exiting\n *\n * **Usage**:\n * ```typescript\n * virtualRenderer.observe(element, id, (isVisible) => {\n *   this.isVisible = isVisible;  // Update component state\n * });\n * ```\n */\nexport type VisibilityCallback = (isVisible: boolean) => void;\n\n/**\n * VirtualRendererService Class\n * ==============================\n *\n * Singleton service managing IntersectionObserver for all grid items.\n *\n * **Lifecycle**:\n * 1. Created once in grid-builder-app.tsx componentDidLoad\n * 2. Shared across all grid-item-wrapper components\n * 3. Lives for entire application lifetime\n * 4. Destroyed only on page unload\n *\n * **Properties**:\n * - `observer`: IntersectionObserver instance (null during initialization)\n * - `observedElements`: Map of element IDs to visibility callbacks\n *\n * **Methods**:\n * - `constructor()`: Initialize observer with configuration\n * - `initialize()`: Create IntersectionObserver with rootMargin and threshold\n * - `observe(element, id, callback)`: Start observing element\n * - `unobserve(element, id)`: Stop observing element\n * - `destroy()`: Cleanup all observations\n */\nexport class VirtualRendererService {\n  /**\n   * IntersectionObserver instance\n   *\n   * **Lifecycle**: Created in initialize(), destroyed in destroy()\n   * **Configuration**: rootMargin: '200px', threshold: 0.01\n   * **Purpose**: Watch all grid items for viewport intersection\n   *\n   * **Null during**:\n   * - Before initialize() completes\n   * - After destroy() called\n   * - Error during initialization\n   */\n  private observer: IntersectionObserver | null = null;\n\n  /**\n   * Map of element IDs to visibility callbacks\n   *\n   * **Structure**: `Map<elementId: string, callback: VisibilityCallback>`\n   * **Lookup**: O(1) by element ID\n   * **Cleanup**: Entries deleted in unobserve()\n   *\n   * **Memory**: ~100 bytes per entry, ~10KB for 100 items\n   *\n   * **Why Map**:\n   * - Fast lookups in observer callback\n   * - Easy cleanup (delete by key)\n   * - Prevents memory leaks\n   * - Standard pattern for observer registries\n   */\n  private observedElements: Map<string, VisibilityCallback> = new Map();\n\n  /**\n   * Constructor - Initialize virtual renderer\n   *\n   * **Called**: Once when VirtualRendererService instantiated\n   * **Purpose**: Create IntersectionObserver with configuration\n   *\n   * **Delegates to**: initialize()\n   * - Sets up observer with rootMargin and threshold\n   * - Registers callback handler for intersection events\n   *\n   * **Usage**:\n   * ```typescript\n   * // In grid-builder-app.tsx componentDidLoad:\n   * (window as any).virtualRenderer = new VirtualRendererService();\n   * ```\n   */\n  constructor() {\n    this.initialize();\n  }\n\n  /**\n   * Initialize IntersectionObserver\n   *\n   * **Called by**: constructor (once)\n   * **Purpose**: Create and configure IntersectionObserver instance\n   *\n   * ## Observer Configuration\n   *\n   * **Observer callback**:\n   * ```typescript\n   * (entries) => {\n   *   entries.forEach((entry) => {\n   *     const elementId = entry.target.id;\n   *     const callback = this.observedElements.get(elementId);\n   *     if (callback) {\n   *       callback(entry.isIntersecting);  // true = entering, false = exiting\n   *     }\n   *   });\n   * }\n   * ```\n   *\n   * **Why forEach entries**:\n   * - IntersectionObserver can fire for multiple elements at once\n   * - Batch processing is more efficient\n   * - Each element gets independent callback\n   *\n   * **Element ID lookup**:\n   * ```typescript\n   * const elementId = entry.target.id;  // From element.id attribute\n   * const callback = this.observedElements.get(elementId);  // O(1) lookup\n   * ```\n   *\n   * **Why use element ID**:\n   * - Direct mapping to callback\n   * - No need to store element references\n   * - Simpler memory management\n   * - Works across DOM mutations\n   *\n   * ## Observer Options\n   *\n   * **Root margin** (`rootMargin: '200px'`):\n   * - Expand viewport bounds by 200px in all directions\n   * - Items render 200px before actually visible\n   * - 1 second buffer at typical scroll speed\n   * - Prevents \"pop-in\" effect\n   *\n   * **Threshold** (`threshold: 0.01`):\n   * - Fire when 1% of element visible\n   * - Very early detection\n   * - Maximizes pre-render time\n   * - More reliable than 0 across browsers\n   *\n   * **Why these specific values**:\n   * - 200px root margin: Balance between performance and UX\n   * - 0.01 threshold: As early as possible without false positives\n   * - Tested with 100+ items for optimal performance\n   *\n   * ## Callback Execution\n   *\n   * **entry.isIntersecting**:\n   * - `true`: Element entering viewport (or 200px buffer)\n   * - `false`: Element exiting viewport\n   * - Component can show/hide content accordingly\n   *\n   * **Callback guard** (`if (callback)`):\n   * - Handles race conditions\n   * - Element may have been unobserved but event still fires\n   * - Prevents errors from missing callbacks\n   * - Graceful degradation\n   *\n   * ## Performance Impact\n   *\n   * **Observer overhead**: ~1-2ms per intersection event\n   * **Callback execution**: ~0.1ms per callback\n   * **Total overhead**: Negligible compared to component rendering\n   *\n   * **Scalability**:\n   * - Single observer for all elements (efficient)\n   * - Map lookups O(1)\n   * - No DOM queries needed\n   * - Works well with 100+ elements\n   *\n   * @private\n   */\n  private initialize() {\n    // Create observer with 200px margin (pre-render before entering viewport)\n    this.observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          const elementId = entry.target.id;\n          const callback = this.observedElements.get(elementId);\n\n          if (callback) {\n            // Call callback with visibility state\n            callback(entry.isIntersecting);\n          }\n        });\n      },\n      {\n        rootMargin: '200px', // Start loading 200px before entering viewport\n        threshold: [0, 0.01], // Fire at 0% (just entered) AND 0.01% (already visible)\n      }\n    );\n  }\n\n  /**\n   * Observe element for visibility changes\n   *\n   * **Called from**: grid-item-wrapper.tsx componentDidLoad\n   * **Purpose**: Register element for lazy loading when it enters viewport\n   *\n   * ## Registration Process\n   *\n   * **Validation**:\n   * ```typescript\n   * if (!this.observer || !element) return;  // Guard against invalid state\n   * ```\n   *\n   * **Why validation needed**:\n   * - Observer may not be initialized (edge case)\n   * - Element may be null if ref not set\n   * - Fail gracefully without errors\n   * - Defensive programming\n   *\n   * **Store callback**:\n   * ```typescript\n   * this.observedElements.set(elementId, callback);  // Map: id → callback\n   * ```\n   *\n   * **Why store before observing**:\n   * - Callback ready when first intersection fires\n   * - No race condition between observe and callback\n   * - Guaranteed handler availability\n   *\n   * **Start observing**:\n   * ```typescript\n   * this.observer.observe(element);  // Add to observer's watch list\n   * ```\n   *\n   * ## Callback Invocation\n   *\n   * **When callback fires**:\n   * 1. Element enters viewport (or 200px buffer)\n   * 2. Observer callback runs\n   * 3. Looks up callback by elementId\n   * 4. Calls callback(true)\n   * 5. Component updates isVisible state\n   * 6. Component re-renders with actual content\n   *\n   * **Callback signature**:\n   * ```typescript\n   * (isVisible: boolean) => void\n   * ```\n   *\n   * **Typical usage**:\n   * ```typescript\n   * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n   *   this.isVisible = isVisible;  // @State update → re-render\n   * });\n   * ```\n   *\n   * ## Multiple Observations\n   *\n   * **Same element, different callback**:\n   * - New callback replaces old one\n   * - Map key is elementId (unique)\n   * - No duplicate observations\n   * - Latest callback wins\n   *\n   * **Multiple elements**:\n   * - Each gets own callback\n   * - All share single observer\n   * - Efficient batch processing\n   * - Scalable to 100+ items\n   *\n   * ## Memory Impact\n   *\n   * **Per observation**:\n   * - Map entry: ~100 bytes\n   * - Observer tracking: ~50 bytes\n   * - Total: ~150 bytes per item\n   *\n   * **100 items**:\n   * - Map overhead: ~10KB\n   * - Observer overhead: ~5KB\n   * - Total: ~15KB (negligible)\n   *\n   * ## Edge Cases\n   *\n   * **Element already observed**:\n   * - IntersectionObserver handles gracefully\n   * - No duplicate tracking\n   * - Callback map updated\n   *\n   * **Element without ID**:\n   * - Callback stored with undefined key\n   * - Lookups will fail\n   * - Element won't lazy load\n   * - Should ensure ID set\n   *\n   * **Observer not initialized**:\n   * - Guard returns early\n   * - No error thrown\n   * - Element renders immediately\n   * - Graceful degradation\n   *\n   * @param element - DOM element to observe (must have id attribute)\n   * @param elementId - Unique ID for callback lookup (should match element.id)\n   * @param callback - Function called when visibility changes\n   *\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper.tsx componentDidLoad:\n   * virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n   *   this.isVisible = isVisible;  // Trigger re-render\n   * });\n   * // → Element now monitored\n   * // → Callback fires when scrolled into view\n   * // → Component renders content instead of placeholder\n   * ```\n   */\n  observe(element: HTMLElement, elementId: string, callback: VisibilityCallback) {\n    if (!this.observer || !element) {\n      return;\n    }\n\n    // Store callback\n    this.observedElements.set(elementId, callback);\n\n    // Start observing\n    this.observer.observe(element);\n  }\n\n  /**\n   * Stop observing element (cleanup)\n   *\n   * **Called from**: grid-item-wrapper.tsx disconnectedCallback\n   * **Purpose**: Remove element from observation and free callback memory\n   *\n   * ## Cleanup Process\n   *\n   * **Validation**:\n   * ```typescript\n   * if (!this.observer || !element) return;  // Guard against invalid state\n   * ```\n   *\n   * **Why validation needed**:\n   * - Observer may be destroyed\n   * - Element may be null during unmount\n   * - Fail gracefully without errors\n   * - Safe cleanup pattern\n   *\n   * **Remove callback**:\n   * ```typescript\n   * this.observedElements.delete(elementId);  // Free callback from map\n   * ```\n   *\n   * **Why delete first**:\n   * - Prevents callback from firing during unobserve\n   * - Immediate cleanup of memory\n   * - No race conditions\n   * - Clean separation\n   *\n   * **Stop observing**:\n   * ```typescript\n   * this.observer.unobserve(element);  // Remove from observer's watch list\n   * ```\n   *\n   * ## Memory Management\n   *\n   * **Callback deletion**:\n   * - Removes Map entry\n   * - Allows callback garbage collection\n   * - Frees ~100 bytes per element\n   * - Critical for long-running apps\n   *\n   * **Observer cleanup**:\n   * - Removes element from internal list\n   * - Stops firing intersection events\n   * - Frees ~50 bytes per element\n   * - Reduces observer overhead\n   *\n   * **What if not called**:\n   * - Callback remains in memory (leak)\n   * - Observer still tracks element (leak)\n   * - ~150 bytes leaked per unmounted item\n   * - Adds up with many mount/unmount cycles\n   *\n   * ## Cleanup Timing\n   *\n   * **Component lifecycle**:\n   * ```\n   * 1. Component mounts → componentDidLoad → observe()\n   * 2. Component unmounts → disconnectedCallback → unobserve()\n   * 3. Element removed from DOM\n   * 4. Callback deleted from map\n   * 5. Observer stops watching\n   * 6. Garbage collector can free memory\n   * ```\n   *\n   * **Why in disconnectedCallback**:\n   * - Called when component removed from DOM\n   * - Guaranteed cleanup point\n   * - Standard web component lifecycle\n   * - No memory leaks\n   *\n   * ## Edge Cases\n   *\n   * **Element not observed**:\n   * - IntersectionObserver handles gracefully\n   * - No error thrown\n   * - Map.delete() returns false but safe\n   * - Idempotent operation\n   *\n   * **Called multiple times**:\n   * - First call removes callback and stops observing\n   * - Subsequent calls are no-ops\n   * - Safe to call multiple times\n   * - Defensive cleanup\n   *\n   * **Observer already destroyed**:\n   * - Guard returns early\n   * - No error thrown\n   * - Map cleanup still happens\n   * - Graceful degradation\n   *\n   * ## Performance Impact\n   *\n   * **Per unobserve**:\n   * - Map.delete(): ~0.01ms\n   * - observer.unobserve(): ~0.1ms\n   * - Total: ~0.11ms (negligible)\n   *\n   * **Batch cleanup** (100 items):\n   * - Sequential unobserve: ~11ms\n   * - Observer.disconnect() + Map.clear(): ~1ms\n   * - destroy() method more efficient for bulk\n   *\n   * @param element - DOM element to stop observing\n   * @param elementId - Element's ID for callback removal\n   *\n   * @example\n   * ```typescript\n   * // In grid-item-wrapper.tsx disconnectedCallback:\n   * disconnectedCallback() {\n   *   if (this.itemRef) {\n   *     virtualRenderer.unobserve(this.itemRef, this.item.id);\n   *   }\n   * }\n   * // → Callback removed from map\n   * // → Observer stops watching element\n   * // → Memory freed for garbage collection\n   * ```\n   */\n  unobserve(element: HTMLElement, elementId: string) {\n    if (!this.observer || !element) {\n      return;\n    }\n\n    // Remove callback\n    this.observedElements.delete(elementId);\n\n    // Stop observing\n    this.observer.unobserve(element);\n  }\n\n  /**\n   * Cleanup all observations (bulk cleanup)\n   *\n   * **Called**: Manually when destroying service (rare, typically page unload)\n   * **Purpose**: Completely tear down observer and free all memory\n   *\n   * ## Cleanup Operations\n   *\n   * **Disconnect observer**:\n   * ```typescript\n   * if (this.observer) {\n   *   this.observer.disconnect();  // Stop watching all elements\n   *   this.observer = null;         // Allow GC\n   * }\n   * ```\n   *\n   * **Why disconnect**:\n   * - Stops all intersection callbacks\n   * - Removes all elements from watch list\n   * - More efficient than unobserve for each element\n   * - Single operation vs N operations\n   *\n   * **Why set to null**:\n   * - Signals observer destroyed\n   * - Guards in other methods will return early\n   * - Allows IntersectionObserver GC\n   * - Clean state reset\n   *\n   * **Clear callbacks**:\n   * ```typescript\n   * this.observedElements.clear();  // Remove all Map entries\n   * ```\n   *\n   * **Why clear**:\n   * - Frees all callback references\n   * - Allows callback GC\n   * - Prevents memory leaks\n   * - Complete cleanup\n   *\n   * ## Performance Comparison\n   *\n   * **destroy() vs unobserve all** (100 items):\n   * - destroy(): disconnect + clear = ~1ms\n   * - unobserve × 100: ~11ms\n   * - **11× faster for bulk cleanup**\n   *\n   * **Memory freed** (100 items):\n   * - Callbacks: ~10KB\n   * - Observer tracking: ~5KB\n   * - Observer instance: ~1KB\n   * - Total: ~16KB\n   *\n   * ## When to Use\n   *\n   * **Appropriate scenarios**:\n   * - Page unload / navigation away\n   * - Application teardown\n   * - Test cleanup (afterEach)\n   * - Hot module reload (HMR)\n   *\n   * **Not appropriate**:\n   * - Individual component unmount (use unobserve)\n   * - Removing some items (use unobserve per item)\n   * - Temporary pause (no such feature needed)\n   *\n   * ## State After Destroy\n   *\n   * **Observer state**:\n   * - `this.observer = null`\n   * - All observe/unobserve calls become no-ops\n   * - Guards prevent errors\n   *\n   * **Callbacks state**:\n   * - `this.observedElements` empty\n   * - All callbacks freed\n   * - No memory leaks\n   *\n   * **Service unusable**:\n   * - Must create new instance to use again\n   * - Or call initialize() if made public\n   * - Current design: create new service\n   *\n   * ## Edge Cases\n   *\n   * **Observer not initialized**:\n   * - Guard skips disconnect\n   * - Only clears callbacks\n   * - Safe even if never initialized\n   *\n   * **Called multiple times**:\n   * - First call destroys everything\n   * - Subsequent calls are no-ops\n   * - Idempotent operation\n   * - Safe defensive cleanup\n   *\n   * **Active intersections**:\n   * - disconnect() cancels all pending callbacks\n   * - No callbacks fire after destroy\n   * - Clean shutdown\n   *\n   * ## Memory Leak Prevention\n   *\n   * **Without destroy**:\n   * - Observer remains in memory\n   * - All callbacks remain referenced\n   * - Elements can't be GC'd\n   * - ~16KB leak per 100 items\n   *\n   * **With destroy**:\n   * - Observer freed\n   * - Callbacks freed\n   * - Elements can be GC'd\n   * - No memory leaks\n   *\n   * @example\n   * ```typescript\n   * // On page unload:\n   * window.addEventListener('beforeunload', () => {\n   *   virtualRenderer.destroy();\n   * });\n   *\n   * // In tests:\n   * afterEach(() => {\n   *   virtualRenderer.destroy();\n   * });\n   *\n   * // Hot module reload:\n   * if (module.hot) {\n   *   module.hot.dispose(() => {\n   *     virtualRenderer.destroy();\n   *   });\n   * }\n   * ```\n   */\n  destroy() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n    this.observedElements.clear();\n  }\n}\n\n/**\n * Singleton VirtualRenderer instance\n * ====================================\n *\n * Global singleton instance shared across all grid components.\n *\n * ## Singleton Pattern\n *\n * **Why singleton**:\n * - Single IntersectionObserver for all items (efficient)\n * - Shared callback registry (O(1) lookups)\n * - Consistent configuration across app\n * - Easier to use (no prop drilling)\n * - Standard service pattern\n *\n * **Instantiation**:\n * ```typescript\n * export const virtualRenderer = new VirtualRendererService();\n * ```\n * - Created at module load time\n * - Immediately available to all components\n * - Initializes IntersectionObserver\n * - Ready for observe() calls\n *\n * ## Usage Pattern\n *\n * **In grid-builder-app.tsx** (optional, for visibility):\n * ```typescript\n * componentDidLoad() {\n *   // Expose globally for debugging (optional)\n *   (window as any).virtualRenderer = virtualRenderer;\n * }\n * ```\n *\n * **In grid-item-wrapper.tsx**:\n * ```typescript\n * import { virtualRenderer } from '../../services/virtual-renderer';\n *\n * componentDidLoad() {\n *   virtualRenderer.observe(this.itemRef, this.item.id, (isVisible) => {\n *     this.isVisible = isVisible;\n * });\n * }\n *\n * disconnectedCallback() {\n *   virtualRenderer.unobserve(this.itemRef, this.item.id);\n * }\n * ```\n *\n * ## Global State\n *\n * **Observer shared across**:\n * - All grid-item-wrapper components\n * - All canvas sections\n * - Entire application\n *\n * **Benefits**:\n * - Single observer instance (low overhead)\n * - Batch intersection processing\n * - Consistent behavior\n * - Simple API\n *\n * ## Alternative Patterns\n *\n * **Could use React Context** (not needed):\n * ```typescript\n * const VirtualRendererContext = createContext(virtualRenderer);\n * // More boilerplate, no real benefit\n * ```\n *\n * **Could use dependency injection** (overkill):\n * ```typescript\n * @Inject() virtualRenderer: VirtualRendererService\n * // Complex setup, no benefit for this use case\n * ```\n *\n * **Singleton is simplest**:\n * - Direct import\n * - No context setup\n * - No DI container\n * - Works across frameworks\n *\n * @example\n * ```typescript\n * // Import and use directly:\n * import { virtualRenderer } from './virtual-renderer';\n *\n * virtualRenderer.observe(element, id, callback);\n * ```\n */\nexport const virtualRenderer = new VirtualRendererService();\n","/**\n * Debug Utility\n * ==============\n *\n * Environment-aware logging utility for the grid-builder library. Provides conditional\n * logging that only outputs in development mode, keeping production console clean.\n *\n * ## Problem\n *\n * Development logging is helpful for debugging but pollutes production console:\n * - Performance tracking logs on every drag/resize\n * - Build timestamp logs on initialization\n * - State change debug messages\n * - Verbose interaction tracking\n *\n * ## Solution\n *\n * Centralized debug utility that checks environment before logging:\n * - Development: Full logging for debugging\n * - Production: Silent (no console pollution)\n * - Test: Configurable via `ENABLE_TEST_LOGS` flag\n *\n * ## Usage\n *\n * ```typescript\n * import { debug } from '../utils/debug';\n *\n * // Replace console.log with debug.log\n * debug.log('Component mounted', { itemId, canvasId });\n *\n * // Still use console.warn/error for actual issues\n * console.warn('Invalid configuration:', config);\n * ```\n *\n * ## Environment Detection\n *\n * **How it works**:\n * - Checks `process.env.NODE_ENV` at runtime\n * - StencilJS sets NODE_ENV during build\n * - Development builds: NODE_ENV = 'development'\n * - Production builds: NODE_ENV = 'production'\n * - Test builds: NODE_ENV = 'test'\n *\n * **Build-time optimization**:\n * - Production: debug.log() calls are no-ops (dead code elimination)\n * - Tree-shaking removes unused debug code\n * - Zero runtime overhead in production\n *\n * @module debug\n */\n\n/**\n * Check if debug logging is enabled\n *\n * **Enabled when**:\n * - NODE_ENV === 'development'\n * - NODE_ENV === 'test' AND ENABLE_TEST_LOGS === true\n *\n * **Disabled when**:\n * - NODE_ENV === 'production'\n * - NODE_ENV === 'test' AND ENABLE_TEST_LOGS !== true\n *\n * @returns true if debug logging should be enabled\n */\nfunction isDebugEnabled(): boolean {\n  // Check if we're in development mode\n  if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'development') {\n    return true;\n  }\n\n  // Allow test logs if explicitly enabled\n  if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {\n    return process.env.ENABLE_TEST_LOGS === 'true';\n  }\n\n  // Disable in production\n  return false;\n}\n\n/**\n * Debug logger instance\n *\n * Provides console.log-compatible methods that only log in development mode.\n * All methods are no-ops in production, allowing tree-shaking to remove them.\n */\nexport const debug = {\n  /**\n   * Log informational message\n   *\n   * **Use for**: General debugging, state changes, lifecycle events\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.log output\n   *\n   * @param args - Arguments to pass to console.log\n   *\n   * @example\n   * ```typescript\n   * debug.log('Item added:', item);\n   * debug.log('Grid size:', gridSize, 'for canvas:', canvasId);\n   * ```\n   */\n  log(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.log(...args);\n    }\n  },\n\n  /**\n   * Log warning message\n   *\n   * **Use for**: Recoverable issues, deprecation warnings, suspicious state\n   *\n   * **Note**: Consider using console.warn directly for warnings that should\n   * always be visible (even in production)\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.warn output\n   *\n   * @param args - Arguments to pass to console.warn\n   *\n   * @example\n   * ```typescript\n   * debug.warn('Deprecated API usage:', methodName);\n   * ```\n   */\n  warn(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.warn(...args);\n    }\n  },\n\n  /**\n   * Log error message\n   *\n   * **Use for**: Non-critical errors, caught exceptions, debugging errors\n   *\n   * **Note**: Use console.error directly for critical errors that should\n   * always be visible (even in production)\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.error output\n   *\n   * @param args - Arguments to pass to console.error\n   *\n   * @example\n   * ```typescript\n   * debug.error('Failed to initialize drag handler:', error);\n   * ```\n   */\n  error(...args: any[]): void {\n    if (isDebugEnabled()) {\n      console.error(...args);\n    }\n  },\n\n  /**\n   * Log grouped messages\n   *\n   * **Use for**: Complex debug output, nested data structures\n   *\n   * **Production**: No-op (dead code eliminated)\n   * **Development**: console.group/groupEnd output\n   *\n   * @param label - Group label\n   * @param fn - Function to execute within group\n   *\n   * @example\n   * ```typescript\n   * debug.group('Drag operation', () => {\n   *   debug.log('Start position:', startPos);\n   *   debug.log('End position:', endPos);\n   *   debug.log('Delta:', delta);\n   * });\n   * ```\n   */\n  group(label: string, fn: () => void): void {\n    if (isDebugEnabled()) {\n      console.group(label);\n      fn();\n      console.groupEnd();\n    }\n  },\n\n  /**\n   * Check if debug mode is enabled\n   *\n   * **Use for**: Expensive debug operations that should be skipped in production\n   *\n   * @returns true if debug logging is enabled\n   *\n   * @example\n   * ```typescript\n   * if (debug.isEnabled()) {\n   *   // Expensive operation only in development\n   *   const stats = calculateDetailedStats();\n   *   debug.log('Stats:', stats);\n   * }\n   * ```\n   */\n  isEnabled(): boolean {\n    return isDebugEnabled();\n  },\n};\n\n/**\n * Create a namespaced debug logger\n *\n * **Use for**: Module-specific logging with consistent prefixes\n *\n * @param namespace - Namespace for log messages (e.g., 'drag-handler', 'grid-calculations')\n * @returns Debug logger with namespace prefix\n *\n * @example\n * ```typescript\n * // In drag-handler.ts\n * const debug = createDebugLogger('drag-handler');\n * debug.log('Drag started'); // → [drag-handler] Drag started\n * ```\n */\nexport function createDebugLogger(namespace: string) {\n  return {\n    log(...args: any[]): void {\n      debug.log(`[${namespace}]`, ...args);\n    },\n    warn(...args: any[]): void {\n      debug.warn(`[${namespace}]`, ...args);\n    },\n    error(...args: any[]): void {\n      debug.error(`[${namespace}]`, ...args);\n    },\n    group(label: string, fn: () => void): void {\n      debug.group(`[${namespace}] ${label}`, fn);\n    },\n    isEnabled(): boolean {\n      return debug.isEnabled();\n    },\n  };\n}\n","/**\n * Undo/Redo Commands\n * ===================\n *\n * Concrete Command implementations for grid operations. Each command class\n * encapsulates a specific user action with the ability to undo and redo.\n *\n * ## Problem\n *\n * The Command pattern requires concrete implementations for each undoable operation.\n * Each command must:\n * - Capture enough state to reverse the operation (undo)\n * - Capture enough state to reapply the operation (redo)\n * - Be self-contained (no external dependencies)\n * - Handle edge cases (canvas switching, index preservation)\n *\n * ## Solution\n *\n * Four concrete command classes covering all grid operations:\n *\n * 1. **AddItemCommand**: Adding new items to canvas\n * 2. **DeleteItemCommand**: Removing items with index preservation\n * 3. **MoveItemCommand**: Dragging items (same or different canvas)\n * 4. **ResizeCommand**: (Not yet implemented - resize operations not tracked)\n *\n * ## Key Design Patterns\n *\n * ### Deep Cloning Strategy\n *\n * **Why deep clone**: Prevent mutations from affecting command snapshots\n *\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **When to clone**:\n * - ✅ Constructor: Capture initial state\n * - ✅ redo(): Create fresh copy for state mutation\n * - ❌ undo(): Usually work with existing state references\n *\n * **Trade-offs**:\n * - ✅ Simple and reliable\n * - ✅ No reference bugs\n * - ❌ Higher memory usage (~1-5 KB per command)\n * - ❌ Slower than structural sharing\n *\n * ### Index Preservation Pattern\n *\n * **Why preserve index**: Undo delete should restore item at original position\n *\n * ```typescript\n * class DeleteItemCommand {\n *   private itemIndex: number;  // Capture index before deletion\n *\n *   undo() {\n *     canvas.items.splice(this.itemIndex, 0, item);  // Restore at index\n *   }\n * }\n * ```\n *\n * **Important for**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * ### Selection State Management\n *\n * **Pattern**: Clear selection when deleting selected item\n *\n * ```typescript\n * if (gridState.selectedItemId === itemId) {\n *   gridState.selectedItemId = null;\n *   gridState.selectedCanvasId = null;\n * }\n * ```\n *\n * **Why needed**:\n * - Prevents dangling references to deleted items\n * - Avoids errors when accessing selectedItemId\n * - Matches user expectations (deleted item can't be selected)\n *\n * ### Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between canvases\n *\n * **Solution**: Track source and target canvas IDs\n *\n * ```typescript\n * class MoveItemCommand {\n *   sourceCanvasId: string;\n *   targetCanvasId: string;\n *\n *   undo() {\n *     // Move from target back to source\n *     removeFrom(targetCanvasId);\n *     addTo(sourceCanvasId, sourceIndex);  // Restore position\n *   }\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Typical flow**:\n * ```\n * 1. User performs action (drag, delete, etc.)\n * 2. Operation completes (state already updated)\n * 3. Create command with before/after snapshots\n * 4. pushCommand(command) → adds to history\n * 5. User presses Ctrl+Z\n * 6. command.undo() → reverses operation\n * 7. User presses Ctrl+Y\n * 8. command.redo() → reapplies operation\n * ```\n *\n * **Important**: Commands are created AFTER the operation completes,\n * not before. The constructor captures the final state.\n *\n * ## Extracting These Patterns\n *\n * To create new command types:\n *\n * ```typescript\n * export class MyCommand implements Command {\n *   // Capture state needed for undo/redo\n *   private beforeState: any;\n *   private afterState: any;\n *\n *   constructor(params) {\n *     // Deep clone to prevent mutations\n *     this.beforeState = JSON.parse(JSON.stringify(before));\n *     this.afterState = JSON.parse(JSON.stringify(after));\n *   }\n *\n *   undo(): void {\n *     // Restore before state\n *     restoreState(this.beforeState);\n *     gridState.canvases = { ...gridState.canvases };  // Trigger reactivity\n *   }\n *\n *   redo(): void {\n *     // Apply after state\n *     restoreState(this.afterState);\n *     gridState.canvases = { ...gridState.canvases };\n *   }\n * }\n * ```\n *\n * **Guidelines**:\n * - Always deep clone state in constructor\n * - Always trigger reactivity (`gridState.canvases = { ...gridState.canvases }`)\n * - Handle null cases (canvas/item not found)\n * - Clear selection if needed\n * - Preserve array indices for positional restore\n *\n * @module undo-redo-commands\n */\n\nimport {\n  addItemToCanvas,\n  GridItem,\n  gridState,\n  updateItem as updateItemInState,\n  deleteItemsBatch,\n  updateItemsBatch,\n} from './state-manager';\nimport { Command } from './undo-redo';\nimport { eventManager } from './event-manager';\nimport { createDebugLogger } from '../utils/debug';\n\nconst debug = createDebugLogger('undo-redo-commands');\n\n/**\n * Helper function to remove an item from a canvas and clear selection\n *\n * **Responsibilities**:\n * - Remove item from canvas items array\n * - Trigger state reactivity (spread pattern)\n * - Clear selection if deleted item was selected\n *\n * **Used by**:\n * - AddItemCommand.undo() - Remove just-added item\n * - DeleteItemCommand.redo() - Remove item again\n * - MoveItemCommand (implicitly via filter)\n *\n * **Why helper function**:\n * - DRY principle (used in multiple commands)\n * - Encapsulates selection clearing logic\n * - Consistent behavior across commands\n *\n * **Selection clearing**:\n * Prevents dangling references and UI errors when selected item deleted.\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item to remove\n *\n * @example\n * ```typescript\n * // Used internally by commands\n * undo() {\n *   removeItemFromCanvas(this.canvasId, this.item.id);\n * }\n * ```\n *\n * @private\n */\nfunction removeItemFromCanvas(canvasId: string, itemId: string): void {\n  const canvas = gridState.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((i) => i.id !== itemId);\n  gridState.canvases = { ...gridState.canvases };\n\n  // Clear selection if this item was selected\n  if (gridState.selectedItemId === itemId) {\n    gridState.selectedItemId = null;\n    gridState.selectedCanvasId = null;\n  }\n}\n\n/**\n * AddItemCommand\n * ==============\n *\n * Captures the addition of a new grid item to a canvas, enabling undo/redo\n * for create operations.\n *\n * ## Use Cases\n *\n * - User drops component from palette onto canvas\n * - Programmatic item creation (stress tests, templates)\n * - Duplicating existing items\n *\n * ## Command Lifecycle\n *\n * **Creation**: After item already added to canvas\n * ```typescript\n * // 1. Add item to canvas (operation completes)\n * addItemToCanvas('canvas1', newItem);\n *\n * // 2. Create command for undo (captures final state)\n * const command = new AddItemCommand('canvas1', newItem);\n * pushCommand(command);\n * ```\n *\n * **Undo**: Remove the item from canvas\n * ```typescript\n * command.undo(); // Item disappears from canvas\n * ```\n *\n * **Redo**: Re-add the item to canvas\n * ```typescript\n * command.redo(); // Item reappears in canvas\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures item state with deep clone\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Prevents mutations from affecting command's snapshot\n * - Item might be modified after command creation\n * - Ensures redo restores exact original state\n *\n * **Redo cloning**: Creates fresh copy for state mutation\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.push(itemCopy);\n * ```\n *\n * **Why redo also clones**:\n * - Multiple redo calls shouldn't share references\n * - Prevents undo/redo from affecting each other\n * - Safe state isolation\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: redo() returns early if canvas not found\n * - **Item modified**: Command stores original state, not current\n * - **Selection**: undo() automatically clears selection via helper\n *\n * @example\n * ```typescript\n * // After palette drop\n * const newItem: GridItem = {\n *   id: generateItemId(),\n *   canvasId: 'canvas1',\n *   type: 'header',\n *   name: 'Header',\n *   layouts: { desktop: { x: 5, y: 5, width: 20, height: 8 }, ... },\n *   zIndex: gridState.canvases['canvas1'].zIndexCounter++\n * };\n *\n * addItemToCanvas('canvas1', newItem);\n * pushCommand(new AddItemCommand('canvas1', newItem));\n * ```\n */\nexport class AddItemCommand implements Command {\n  /** Deep clone of item at creation time */\n  private item: GridItem;\n\n  /** Canvas ID where item was added */\n  private canvasId: string;\n\n  /**\n   * Capture item addition operation\n   *\n   * **Important**: Call AFTER item added to canvas (not before)\n   *\n   * **Deep clones item**: Prevents future mutations from affecting snapshot\n   *\n   * @param canvasId - Canvas where item was added\n   * @param item - Item that was added (will be deep cloned)\n   */\n  constructor(canvasId: string, item: GridItem) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state at time of creation\n    this.item = JSON.parse(JSON.stringify(item));\n  }\n\n  /**\n   * Undo: Remove the item from canvas\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  undo(): void {\n    // Remove the item from the canvas\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n\n  /**\n   * Redo: Re-add the item to canvas\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Appends to end**: Doesn't preserve original index (acceptable for add)\n   *\n   * **Side effects**:\n   * - Item added to end of canvas.items array\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found (e.g., canvas was deleted)\n   */\n  redo(): void {\n    // Re-add the item to the canvas\n    const canvas = gridState.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Use the cloned item state\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    canvas.items.push(itemCopy);\n    gridState.canvases = { ...gridState.canvases };\n  }\n}\n\n/**\n * DeleteItemCommand\n * ==================\n *\n * Captures the deletion of a grid item from a canvas, enabling undo/redo\n * for delete operations with index preservation.\n *\n * ## Use Cases\n *\n * - User deletes item with Delete key\n * - Delete button clicked\n * - Programmatic item removal\n * - Clearing canvas sections\n *\n * ## Index Preservation Pattern\n *\n * **Critical feature**: Restores deleted item at its ORIGINAL array position\n *\n * **Why important**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * **Implementation**:\n * ```typescript\n * constructor(canvasId, item, itemIndex) {\n *   this.itemIndex = itemIndex;  // Capture before deletion!\n * }\n *\n * undo() {\n *   canvas.items.splice(this.itemIndex, 0, itemCopy);  // Restore at index\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE deleting item (to capture index)\n * ```typescript\n * // 1. Get item and its index BEFORE deletion\n * const item = getItem('canvas1', 'item-5');\n * const index = gridState.canvases['canvas1'].items.indexOf(item);\n *\n * // 2. Create command (captures item and index)\n * const command = new DeleteItemCommand('canvas1', item, index);\n *\n * // 3. Perform deletion\n * removeItemFromCanvas('canvas1', 'item-5');\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Restore item at original position\n * ```typescript\n * command.undo(); // Item reappears at exact original position\n * ```\n *\n * **Redo**: Delete item again\n * ```typescript\n * command.redo(); // Item disappears (and selection cleared if selected)\n * ```\n *\n * ## Deep Cloning Strategy\n *\n * **Constructor**: Captures complete item state before deletion\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **Why needed**:\n * - Item will be deleted from state immediately after\n * - Reference would become invalid after deletion\n * - Must preserve complete state for restoration\n *\n * **Undo cloning**: Creates fresh copy for state insertion\n * ```typescript\n * const itemCopy = JSON.parse(JSON.stringify(this.item));\n * canvas.items.splice(this.itemIndex, 0, itemCopy);\n * ```\n *\n * ## Selection State Handling\n *\n * **Redo behavior**: Delegates to removeItemFromCanvas helper\n *\n * **Helper automatically**:\n * - Clears selectedItemId if this item was selected\n * - Clears selectedCanvasId\n * - Prevents dangling references\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: undo() returns early if canvas not found\n * - **Invalid index**: Falls back to push() if index out of bounds\n * - **Item modified before delete**: Command stores pre-deletion state\n * - **Multiple deletes**: Each command independently tracks its item\n *\n * @example\n * ```typescript\n * // Handle Delete key press\n * handleDeleteKey() {\n *   if (!gridState.selectedItemId || !gridState.selectedCanvasId) {\n *     return;\n *   }\n *\n *   const item = getItem(gridState.selectedCanvasId, gridState.selectedItemId);\n *   const canvas = gridState.canvases[gridState.selectedCanvasId];\n *   const index = canvas.items.indexOf(item);\n *\n *   // Create command before deleting\n *   const command = new DeleteItemCommand(\n *     gridState.selectedCanvasId,\n *     item,\n *     index\n *   );\n *\n *   // Perform deletion\n *   removeItemFromCanvas(gridState.selectedCanvasId, gridState.selectedItemId);\n *\n *   // Enable undo\n *   pushCommand(command);\n * }\n * ```\n */\nexport class DeleteItemCommand implements Command {\n  /** Deep clone of item before deletion */\n  private item: GridItem;\n\n  /** Canvas ID where item was deleted from */\n  private canvasId: string;\n\n  /** Original array index for position restoration */\n  private itemIndex: number;\n\n  /**\n   * Capture item deletion operation\n   *\n   * **Important**: Call BEFORE deleting item (to capture index)\n   *\n   * **Deep clones item**: Preserves state before deletion\n   *\n   * **Captures index**: Critical for restoring at original position\n   *\n   * @param canvasId - Canvas containing the item\n   * @param item - Item being deleted (will be deep cloned)\n   * @param itemIndex - Original array index (call indexOf before deletion!)\n   */\n  constructor(canvasId: string, item: GridItem, itemIndex: number) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state before deletion\n    this.item = JSON.parse(JSON.stringify(item));\n    this.itemIndex = itemIndex;\n  }\n\n  /**\n   * Undo: Restore item at original position\n   *\n   * **Index preservation**: Uses splice to insert at exact original position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive coding)\n   *\n   * **Fresh clone**: Creates new copy to prevent reference sharing\n   *\n   * **Side effects**:\n   * - Item restored to canvas.items array at original index\n   * - Other items shift to make room\n   * - Z-index order maintained (items render in array order)\n   * - Triggers component re-render\n   *\n   * **Safety**: No-op if canvas not found\n   */\n  undo(): void {\n    // Re-add the item to its original position\n    const canvas = gridState.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    // Insert at original index if possible, otherwise push to end\n    if (this.itemIndex >= 0 && this.itemIndex <= canvas.items.length) {\n      canvas.items.splice(this.itemIndex, 0, itemCopy);\n    } else {\n      canvas.items.push(itemCopy);\n    }\n    gridState.canvases = { ...gridState.canvases };\n  }\n\n  /**\n   * Redo: Delete item again\n   *\n   * **Delegates to helper**: Uses removeItemFromCanvas for consistency\n   *\n   * **Automatic selection clearing**: Helper clears selection if this item selected\n   *\n   * **Side effects**:\n   * - Item removed from canvas.items array\n   * - Selection cleared if this item was selected\n   * - Triggers component re-render\n   *\n   * **Delegates to**: removeItemFromCanvas helper for DRY\n   */\n  redo(): void {\n    // Remove the item again\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n}\n\n/**\n * MoveItemCommand\n * ===============\n *\n * Captures the movement of a grid item within the same canvas or across canvases,\n * enabling undo/redo for drag operations with position and index preservation.\n *\n * ## Use Cases\n *\n * - User drags item to new position in same canvas\n * - User drags item across canvas boundaries (cross-canvas move)\n * - Programmatic item repositioning\n * - Layout reorganization\n *\n * ## Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between different canvases\n *\n * **Solution**: Track both source and target canvas IDs\n *\n * **Same-canvas move**:\n * ```typescript\n * sourceCanvasId === targetCanvasId\n * // Only position changes, no canvas transfer\n * ```\n *\n * **Cross-canvas move**:\n * ```typescript\n * sourceCanvasId !== targetCanvasId\n * // Item removed from source, added to target\n * // Position updated to target coordinates\n * ```\n *\n * ## Position Tracking\n *\n * **Dual position capture**:\n * - `sourcePosition`: { x, y } before drag\n * - `targetPosition`: { x, y } after drag\n *\n * **Why both needed**:\n * - Undo must restore original position\n * - Redo must restore final position\n * - Positions are in grid coordinates (not pixels)\n *\n * ## Index Preservation Pattern\n *\n * **Critical for undo**: Restore item at original array position in source canvas\n *\n * **Why important**:\n * - Maintains visual z-order consistency\n * - Restores exact pre-drag state\n * - Items render in array order\n *\n * **Implementation**:\n * ```typescript\n * // Capture source index before move\n * const sourceIndex = sourceCanvas.items.indexOf(item);\n *\n * // Restore at index on undo\n * sourceCanvas.items.splice(sourceIndex, 0, item);\n * ```\n *\n * ## Command Lifecycle\n *\n * **Creation**: BEFORE drag operation (capture source state)\n * ```typescript\n * // 1. Capture state before drag starts\n * const sourceIndex = canvas.items.indexOf(item);\n * const sourcePos = { x: item.layouts.desktop.x, y: item.layouts.desktop.y };\n *\n * // 2. Drag completes (position updated in DOM)\n * // ...\n *\n * // 3. Create command with before/after state\n * const command = new MoveItemCommand(\n *   item.id,\n *   sourceCanvasId,\n *   targetCanvasId,  // May be same as source\n *   sourcePos,\n *   targetPos,       // New position after drag\n *   sourceIndex\n * );\n *\n * // 4. Push command for undo\n * pushCommand(command);\n * ```\n *\n * **Undo**: Move back to source at original position\n * ```typescript\n * command.undo();\n * // Item returns to source canvas at original index\n * // Position restored to sourcePosition\n * ```\n *\n * **Redo**: Move to target at new position\n * ```typescript\n * command.redo();\n * // Item moves to target canvas (appended to end)\n * // Position updated to targetPosition\n * ```\n *\n * ## State Mutation Pattern\n *\n * **Unlike Add/Delete**: Does NOT deep clone item\n *\n * **Why reference-based**:\n * - Same item object moves between canvases\n * - Only position properties mutated\n * - Efficient (no serialization overhead)\n * - Item identity preserved (same ID, zIndex, etc.)\n *\n * **What gets cloned**:\n * ```typescript\n * // Only position objects cloned (shallow)\n * this.sourcePosition = { ...sourcePosition };\n * this.targetPosition = { ...targetPosition };\n * ```\n *\n * ## Position Coordinates\n *\n * **Uses desktop layout**: `item.layouts.desktop.x/y`\n *\n * **Why desktop**:\n * - Drag handler operates on desktop coordinates\n * - Mobile layout auto-generated or separately customized\n * - Single source of truth for command\n *\n * **Grid units**: Positions stored in grid units (not pixels)\n *\n * ## Canvas Mutation Flow\n *\n * **Undo sequence** (target → source):\n * 1. Find item in target canvas\n * 2. Remove from target.items array\n * 3. Update item.canvasId to source\n * 4. Update item position to sourcePosition\n * 5. Insert at sourceIndex in source.items\n * 6. Trigger reactivity\n *\n * **Redo sequence** (source → target):\n * 1. Find item in source canvas\n * 2. Remove from source.items array\n * 3. Update item.canvasId to target\n * 4. Update item position to targetPosition\n * 5. Append to target.items (no index preservation for redo)\n * 6. Trigger reactivity\n *\n * ## Edge Cases\n *\n * - **Canvas deleted**: Both undo/redo return early if canvas not found\n * - **Item not found**: Returns early (defensive coding)\n * - **Same position move**: Creates valid command (user expectation)\n * - **Invalid source index**: Fallback to append (defensive)\n *\n * @example\n * ```typescript\n * // After drag end event\n * handleDragEnd(event) {\n *   const item = getItem(sourceCanvasId, itemId);\n *   const sourceIndex = gridState.canvases[sourceCanvasId].items.indexOf(item);\n *\n *   const command = new MoveItemCommand(\n *     itemId,\n *     sourceCanvasId,\n *     targetCanvasId,  // Detected from drop target\n *     { x: oldX, y: oldY },  // Captured on drag start\n *     { x: newX, y: newY },  // Calculated from drop position\n *     sourceIndex\n *   );\n *\n *   pushCommand(command);\n * }\n * ```\n */\nexport class MoveItemCommand implements Command {\n  /** Item ID (reference to item, not deep clone) */\n  private itemId: string;\n\n  /** Canvas ID where item started */\n  private sourceCanvasId: string;\n\n  /** Canvas ID where item ended (may equal source for same-canvas move) */\n  private targetCanvasId: string;\n\n  /** Position before drag (grid coordinates) */\n  private sourcePosition: { x: number; y: number };\n\n  /** Position after drag (grid coordinates) */\n  private targetPosition: { x: number; y: number };\n\n  /** Size before operation (grid units) - optional for resize tracking */\n  private sourceSize?: { width: number; height: number };\n\n  /** Size after operation (grid units) - optional for resize tracking */\n  private targetSize?: { width: number; height: number };\n\n  /** Original array index in source canvas (for undo restoration) */\n  private sourceIndex: number;\n\n  /**\n   * Capture item move operation\n   *\n   * **Important**: Item should already be at target position\n   *\n   * **Shallow position clone**: Prevents mutation of passed objects\n   *\n   * **No item clone**: Uses reference-based approach (item ID tracking)\n   *\n   * **Resize support**: Optional size parameters track width/height changes\n   *\n   * @param itemId - ID of moved item\n   * @param sourceCanvasId - Canvas where item started\n   * @param targetCanvasId - Canvas where item ended\n   * @param sourcePosition - Position before drag (will be shallow cloned)\n   * @param targetPosition - Position after drag (will be shallow cloned)\n   * @param sourceIndex - Original array index in source canvas\n   * @param sourceSize - Optional: Size before operation (for resize tracking)\n   * @param targetSize - Optional: Size after operation (for resize tracking)\n   */\n  constructor(\n    itemId: string,\n    sourceCanvasId: string,\n    targetCanvasId: string,\n    sourcePosition: { x: number; y: number },\n    targetPosition: { x: number; y: number },\n    sourceIndex: number,\n    sourceSize?: { width: number; height: number },\n    targetSize?: { width: number; height: number }\n  ) {\n    this.itemId = itemId;\n    this.sourceCanvasId = sourceCanvasId;\n    this.targetCanvasId = targetCanvasId;\n    this.sourcePosition = { ...sourcePosition };\n    this.targetPosition = { ...targetPosition };\n    this.sourceSize = sourceSize ? { ...sourceSize } : undefined;\n    this.targetSize = targetSize ? { ...targetSize } : undefined;\n    this.sourceIndex = sourceIndex;\n  }\n\n  /**\n   * Undo: Move item back to source canvas at original position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from target canvas\n   * - Updates canvasId back to source\n   * - Restores source position\n   * - Inserts at original index in source\n   *\n   * **Index preservation**: Uses splice to restore exact array position\n   *\n   * **Fallback**: Appends to end if index invalid (defensive)\n   *\n   * **Side effects**:\n   * - Item removed from target canvas\n   * - Item added to source canvas at original index\n   * - Item position updated to sourcePosition\n   * - Item canvasId updated to sourceCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  undo(): void {\n    debug.log('🔙 MoveItemCommand.undo()', {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in target canvas first\n    let targetCanvas = gridState.canvases[this.targetCanvasId];\n    let item = targetCanvas?.items.find((i) => i.id === this.itemId);\n\n    // If target canvas doesn't exist or item not found there, search all canvases\n    // This handles the case where the target canvas was deleted\n    if (!item) {\n      for (const canvasId in gridState.canvases) {\n        const canvas = gridState.canvases[canvasId];\n        item = canvas.items.find((i) => i.id === this.itemId);\n        if (item) {\n          targetCanvas = canvas;\n          break;\n        }\n      }\n    }\n\n    if (!item || !targetCanvas) {\n      console.warn('  ❌ Item or canvas not found, aborting undo');\n      return;\n    }\n\n    debug.log('  📍 Found item, current position:', {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Remove from current canvas (wherever it is)\n    targetCanvas.items = targetCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's position and canvasId back to source\n    item.canvasId = this.sourceCanvasId;\n    item.layouts.desktop.x = this.sourcePosition.x;\n    item.layouts.desktop.y = this.sourcePosition.y;\n\n    debug.log('  ✅ Updated item position to:', {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Restore size if it was tracked (for resize operations)\n    if (this.sourceSize) {\n      item.layouts.desktop.width = this.sourceSize.width;\n      item.layouts.desktop.height = this.sourceSize.height;\n    }\n\n    // Add back to source canvas at original index\n    const sourceCanvas = gridState.canvases[this.sourceCanvasId];\n    if (!sourceCanvas) {\n      console.warn('  ❌ Source canvas not found, aborting undo');\n      return;\n    }\n\n    if (this.sourceIndex >= 0 && this.sourceIndex <= sourceCanvas.items.length) {\n      sourceCanvas.items.splice(this.sourceIndex, 0, item);\n    } else {\n      sourceCanvas.items.push(item);\n    }\n\n    // Trigger state update\n    gridState.canvases = { ...gridState.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log('  🎨 Clearing inline transform style');\n      element.style.transform = '';\n    }\n\n    debug.log('  ✅ Undo complete');\n  }\n\n  /**\n   * Redo: Move item to target canvas at final position\n   *\n   * **Cross-canvas handling**:\n   * - Removes from source canvas\n   * - Updates canvasId to target\n   * - Restores target position\n   * - Appends to target canvas (no index preservation for redo)\n   *\n   * **No index preservation for redo**: Appends to end of target array\n   * (undo needs original index, redo doesn't)\n   *\n   * **Side effects**:\n   * - Item removed from source canvas\n   * - Item added to end of target canvas\n   * - Item position updated to targetPosition\n   * - Item canvasId updated to targetCanvasId\n   * - Triggers component re-render\n   *\n   * **Safety**: Returns early if canvas or item not found\n   */\n  redo(): void {\n    debug.log('🔜 MoveItemCommand.redo()', {\n      itemId: this.itemId,\n      sourceCanvasId: this.sourceCanvasId,\n      targetCanvasId: this.targetCanvasId,\n      sourcePosition: this.sourcePosition,\n      targetPosition: this.targetPosition,\n    });\n\n    // Find the item in source canvas\n    const sourceCanvas = gridState.canvases[this.sourceCanvasId];\n    const item = sourceCanvas?.items.find((i) => i.id === this.itemId);\n    if (!item) {\n      console.warn('  ❌ Item not found, aborting redo');\n      return;\n    }\n\n    debug.log('  📍 Found item, current position:', {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Remove from source canvas\n    sourceCanvas.items = sourceCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's position and canvasId to target\n    item.canvasId = this.targetCanvasId;\n    item.layouts.desktop.x = this.targetPosition.x;\n    item.layouts.desktop.y = this.targetPosition.y;\n\n    debug.log('  ✅ Updated item position to:', {\n      x: item.layouts.desktop.x,\n      y: item.layouts.desktop.y,\n    });\n\n    // Restore size if it was tracked (for resize operations)\n    if (this.targetSize) {\n      item.layouts.desktop.width = this.targetSize.width;\n      item.layouts.desktop.height = this.targetSize.height;\n    }\n\n    // Add to target canvas\n    const targetCanvas = gridState.canvases[this.targetCanvasId];\n    if (!targetCanvas) {\n      console.warn('  ❌ Target canvas not found, aborting redo');\n      return;\n    }\n\n    targetCanvas.items.push(item);\n\n    // Trigger state update\n    gridState.canvases = { ...gridState.canvases };\n\n    // Clear any inline transform style that might be persisting from drag handler\n    // This ensures the component re-renders with the correct position from state\n    const element = document.getElementById(this.itemId);\n    if (element) {\n      debug.log('  🎨 Clearing inline transform style');\n      element.style.transform = '';\n    }\n\n    debug.log('  ✅ Redo complete');\n  }\n}\n\n/**\n * UpdateItemCommand - Update item properties\n *\n * Records old item state and applies updates\n */\nexport class UpdateItemCommand implements Command {\n  constructor(\n    private canvasId: string,\n    private itemId: string,\n    private oldItem: GridItem,\n    private updates: Partial<GridItem>\n  ) {}\n\n  undo(): void {\n    updateItemInState(this.canvasId, this.itemId, this.oldItem);\n  }\n\n  redo(): void {\n    updateItemInState(this.canvasId, this.itemId, this.updates);\n  }\n}\n\n/**\n * RemoveItemCommand - Remove item from canvas\n *\n * Stores removed item for restoration\n */\nexport class RemoveItemCommand implements Command {\n  constructor(\n    private canvasId: string,\n    private item: GridItem\n  ) {}\n\n  undo(): void {\n    addItemToCanvas(this.canvasId, this.item);\n  }\n\n  redo(): void {\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n}\n\n/**\n * SetViewportCommand - Change current viewport\n *\n * Stores old and new viewport states\n */\nexport class SetViewportCommand implements Command {\n  constructor(\n    private oldViewport: 'desktop' | 'mobile',\n    private newViewport: 'desktop' | 'mobile'\n  ) {}\n\n  undo(): void {\n    gridState.currentViewport = this.oldViewport;\n  }\n\n  redo(): void {\n    gridState.currentViewport = this.newViewport;\n  }\n}\n\n/**\n * ToggleGridCommand - Toggle grid visibility\n *\n * Stores old and new visibility states\n */\nexport class ToggleGridCommand implements Command {\n  constructor(\n    private oldValue: boolean,\n    private newValue: boolean\n  ) {}\n\n  undo(): void {\n    gridState.showGrid = this.oldValue;\n  }\n\n  redo(): void {\n    gridState.showGrid = this.newValue;\n  }\n}\n\n\n/**\n * BatchAddCommand - Add multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n * Reduces undo stack size and provides atomic undo/redo for batch operations.\n *\n * **Use cases**:\n * - Stress test (add 100+ items at once)\n * - Template application (add multiple pre-configured items)\n * - Undo batch delete operation\n * - Import from file (restore multiple items)\n *\n * **Undo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Re-adds all items with original IDs and properties\n * - Maintains z-index and positioning\n * - Single state update, single re-render\n */\nexport class BatchAddCommand implements Command {\n  private itemsData: GridItem[];\n\n  constructor(itemIds: string[]) {\n    // Store full item data for redo (deep clone to prevent mutations)\n    this.itemsData = itemIds.map((id) => {\n      const item = Object.values(gridState.canvases)\n        .flatMap((canvas) => canvas.items)\n        .find((i) => i.id === id);\n      return item ? JSON.parse(JSON.stringify(item)) : null;\n    }).filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n    deleteItemsBatch(itemIds);\n  }\n\n  redo(): void {\n    // Re-add all items (addItemsBatch will generate new IDs, so we need custom logic)\n    const updatedCanvases = { ...gridState.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    gridState.canvases = updatedCanvases;\n  }\n}\n\n/**\n * BatchDeleteCommand - Delete multiple items in a single batch operation\n *\n * **Performance benefit**: 1 undo/redo command for N items instead of N commands.\n *\n * **Use cases**:\n * - Clear canvas (delete all items)\n * - Delete selection group\n * - Undo batch add operation\n * - Bulk cleanup operations\n *\n * **Undo behavior**:\n * - Re-adds all items with original properties and positions\n * - Maintains z-index and canvas placement\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Deletes all items in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchDeleteCommand implements Command {\n  private itemsData: GridItem[];\n\n  constructor(itemIds: string[]) {\n    // Store full item data for undo (deep clone to prevent mutations)\n    this.itemsData = itemIds.map((id) => {\n      const item = Object.values(gridState.canvases)\n        .flatMap((canvas) => canvas.items)\n        .find((i) => i.id === id);\n      return item ? JSON.parse(JSON.stringify(item)) : null;\n    }).filter(Boolean) as GridItem[];\n  }\n\n  undo(): void {\n    // Re-add all items (same logic as BatchAddCommand.redo)\n    const updatedCanvases = { ...gridState.canvases };\n\n    for (const itemData of this.itemsData) {\n      const canvas = updatedCanvases[itemData.canvasId];\n      if (canvas) {\n        // Check if item already exists (prevent duplicates)\n        const exists = canvas.items.some((i) => i.id === itemData.id);\n        if (!exists) {\n          canvas.items.push(itemData);\n        }\n      }\n    }\n\n    gridState.canvases = updatedCanvases;\n  }\n\n  redo(): void {\n    // Delete all items in one batch\n    const itemIds = this.itemsData.map((item) => item.id);\n    deleteItemsBatch(itemIds);\n  }\n}\n\n/**\n * BatchUpdateConfigCommand - Update multiple item configs in a single batch\n *\n * **Performance benefit**: 1 undo/redo command for N config updates instead of N commands.\n *\n * **Use cases**:\n * - Theme changes (update colors for all headers)\n * - Bulk property changes (set all text sizes to 16px)\n * - Template application (apply preset configs)\n * - Undo/redo bulk config changes\n *\n * **Undo behavior**:\n * - Restores all old configs in a single batch operation\n * - Single state update, single re-render\n *\n * **Redo behavior**:\n * - Applies all new configs in a single batch operation\n * - Single state update, single re-render\n */\nexport class BatchUpdateConfigCommand implements Command {\n  private updates: Array<{\n    itemId: string;\n    canvasId: string;\n    oldItem: GridItem;\n    newItem: GridItem;\n  }>;\n\n  constructor(\n    updates: Array<{\n      itemId: string;\n      canvasId: string;\n      updates: Partial<GridItem>;\n    }>\n  ) {\n    // Store old and new state for each item (deep clone to prevent mutations)\n    this.updates = updates.map(({ itemId, canvasId, updates: itemUpdates }) => {\n      const canvas = gridState.canvases[canvasId];\n      const item = canvas?.items.find((i) => i.id === itemId);\n\n      if (!item) {\n        return null;\n      }\n\n      return {\n        itemId,\n        canvasId,\n        oldItem: JSON.parse(JSON.stringify(item)),\n        newItem: JSON.parse(JSON.stringify({ ...item, ...itemUpdates })),\n      };\n    }).filter(Boolean) as Array<{\n      itemId: string;\n      canvasId: string;\n      oldItem: GridItem;\n      newItem: GridItem;\n    }>;\n  }\n\n  undo(): void {\n    // Restore old configs\n    const batchUpdates = this.updates.map(({ itemId, canvasId, oldItem }) => ({\n      itemId,\n      canvasId,\n      updates: oldItem,\n    }));\n    updateItemsBatch(batchUpdates);\n  }\n\n  redo(): void {\n    // Apply new configs\n    const batchUpdates = this.updates.map(({ itemId, canvasId, newItem }) => ({\n      itemId,\n      canvasId,\n      updates: newItem,\n    }));\n    updateItemsBatch(batchUpdates);\n  }\n}\n\n/**\n * AddCanvasCommand\n * =================\n *\n * Undoable command for adding a canvas to the grid.\n *\n * **Pattern**: Host app owns canvas metadata, library manages item placement\n *\n * **Library responsibility** (what this command does):\n * - Create canvas in gridState.canvases with empty items array\n * - Initialize zIndexCounter for item stacking\n * - Track operation in undo/redo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or other metadata\n * - Host app maintains its own canvas metadata separately\n * - Host app listens to canvasAdded event to sync its state\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app maintains canvas metadata\n * const canvasMetadata = {\n *   'section-1': { title: 'Hero Section', backgroundColor: '#f0f4f8' }\n * };\n *\n * // Create canvas in library (just placement state)\n * const cmd = new AddCanvasCommand('section-1');\n * pushCommand(cmd); // Add to undo/redo stack\n * cmd.redo(); // Creates canvas with items: [], zIndexCounter: 1\n *\n * // Host app listens to event and syncs its own state\n * api.on('canvasAdded', (event) => {\n *   // Host app can now add its own metadata\n * });\n * ```\n *\n * **Why this separation**:\n * - Library focuses on layout (items, positions, z-index)\n * - Host app owns presentation (styling, titles, metadata)\n * - Different apps can use library with different data models\n *\n * @module undo-redo-commands\n */\nexport class AddCanvasCommand implements Command {\n  description = 'Add Canvas';\n  private canvasId: string;\n\n  constructor(canvasId: string) {\n    this.canvasId = canvasId;\n  }\n\n  undo(): void {\n    debug.log('🔙 AddCanvasCommand.undo() - removing canvas:', this.canvasId);\n\n    // Remove canvas from library state\n    delete gridState.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    gridState.canvases = { ...gridState.canvases };\n\n    // Emit event so host app can sync its metadata\n    debug.log('  📢 Emitting canvasRemoved event for:', this.canvasId);\n    eventManager.emit('canvasRemoved', { canvasId: this.canvasId });\n  }\n\n  redo(): void {\n    // Add canvas to library state (minimal - just item placement management)\n    gridState.canvases[this.canvasId] = {\n      zIndexCounter: 1,\n      items: [],\n    };\n\n    // Trigger state change for reactivity\n    gridState.canvases = { ...gridState.canvases };\n\n    // Emit event so host app can sync its metadata\n    eventManager.emit('canvasAdded', { canvasId: this.canvasId });\n  }\n}\n\n/**\n * RemoveCanvasCommand\n * ====================\n *\n * Undoable command for removing a canvas from the grid.\n *\n * **Critical**: Snapshots canvas items and zIndexCounter before removal\n *\n * **Library responsibility** (what this command does):\n * - Snapshot canvas items array and zIndexCounter\n * - Remove canvas from gridState.canvases\n * - Restore canvas with all items on undo\n *\n * **Host app responsibility** (what this command does NOT do):\n * - Store canvas title, backgroundColor, or metadata\n * - Host app must listen to canvasRemoved event\n * - Host app must manage its own metadata undo/redo separately\n *\n * **Integration pattern**:\n * ```typescript\n * // Host app listens to events and manages its own metadata\n * api.on('canvasRemoved', (event) => {\n *   // Host app removes its own metadata\n *   delete canvasMetadata[event.canvasId];\n * });\n *\n * api.on('canvasAdded', (event) => {\n *   // On undo of remove, host app restores metadata\n *   if (wasUndoOperation) {\n *     canvasMetadata[event.canvasId] = savedMetadata;\n *   }\n * });\n *\n * // Remove canvas\n * const cmd = new RemoveCanvasCommand('section-1');\n * pushCommand(cmd);\n * cmd.redo(); // Removes canvas from library\n * ```\n *\n * **Edge case handling**:\n * - Canvas doesn't exist: command becomes no-op\n * - Canvas has items: all items removed with canvas\n * - Undo restores items with original layouts and zIndex\n *\n * @module undo-redo-commands\n */\nexport class RemoveCanvasCommand implements Command {\n  description = 'Remove Canvas';\n  private canvasId: string;\n  private canvasSnapshot: {\n    zIndexCounter: number;\n    items: GridItem[];\n  } | null = null;\n\n  constructor(canvasId: string) {\n    this.canvasId = canvasId;\n\n    // Snapshot canvas state (deep clone to prevent mutations)\n    const canvas = gridState.canvases[canvasId];\n    if (canvas) {\n      this.canvasSnapshot = JSON.parse(JSON.stringify(canvas));\n    }\n  }\n\n  undo(): void {\n    // Restore canvas from snapshot (just layout state, no metadata)\n    if (this.canvasSnapshot) {\n      gridState.canvases[this.canvasId] = JSON.parse(JSON.stringify(this.canvasSnapshot));\n\n      // Trigger state change for reactivity\n      gridState.canvases = { ...gridState.canvases };\n\n      // Emit event so host app can sync its metadata\n      eventManager.emit('canvasAdded', { canvasId: this.canvasId });\n    }\n  }\n\n  redo(): void {\n    // Remove canvas from library state\n    delete gridState.canvases[this.canvasId];\n\n    // Trigger state change for reactivity\n    gridState.canvases = { ...gridState.canvases };\n\n    // Emit event so host app can sync its metadata\n    eventManager.emit('canvasRemoved', { canvasId: this.canvasId });\n  }\n}\n","/**\n * Undo/Redo Service\n * ==================\n *\n * Command pattern implementation for undo/redo functionality in the grid builder.\n * Provides stack-based history management with keyboard shortcuts and UI state tracking.\n *\n * ## Problem\n *\n * Interactive applications need undo/redo capabilities for:\n * - Recovering from mistakes (accidental delete)\n * - Experimenting with layouts (try different arrangements)\n * - Learning the interface (undo to see what changed)\n * - Building confidence (knowing you can undo)\n *\n * **Without undo/redo**:\n * - Users hesitant to experiment\n * - Mistakes are permanent\n * - No way to review history\n * - Poor user experience\n *\n * ## Solution\n *\n * Implement **Command Pattern** with stack-based history:\n *\n * 1. **Command Interface**: Each undoable action implements undo() and redo()\n * 2. **History Stack**: Array of command objects\n * 3. **Position Pointer**: Tracks current position in history\n * 4. **Bounded History**: Limited to 50 commands to prevent memory bloat\n * 5. **Branching**: New actions after undo discard \"future\" history\n *\n * ## Architecture: Command Pattern\n *\n * **Classic Gang of Four pattern** for undo/redo:\n *\n * **Key Components**:\n * - **Command Interface**: Defines undo() and redo() methods\n * - **Concrete Commands**: AddItemCommand, DeleteItemCommand, MoveItemCommand, ResizeCommand\n * - **Invoker**: undo-redo.ts (this file) manages command execution\n * - **Receiver**: state-manager.ts (receives state mutations)\n *\n * **Flow**:\n * ```\n * User Action → Create Command → pushCommand() → Execute & Store\n * Undo (Ctrl+Z) → Get command at position → command.undo() → Update position\n * Redo (Ctrl+Y) → Advance position → command.redo() → Execute\n * ```\n *\n * **Why Command Pattern**:\n * - ✅ Encapsulates actions as objects\n * - ✅ Enables undo/redo without coupling to specific operations\n * - ✅ Supports macro commands (batch operations)\n * - ✅ Easy to extend with new command types\n * - ✅ History can be serialized/persisted\n *\n * ## History Management\n *\n * **Stack-based with position pointer**:\n * ```\n * commandHistory = [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                                  ↑\n *                            historyPosition = 2\n * ```\n *\n * **Operations**:\n * - **Push new command**: Discard commands after position, append new command\n * - **Undo**: Execute command.undo() at position, decrement position\n * - **Redo**: Increment position, execute command.redo() at new position\n *\n * **Branching behavior** (discarding future on new action):\n * ```\n * Initial:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                         ↑ position = 2\n *\n * Undo 2x:  [cmd1, cmd2, cmd3, cmd4, cmd5]\n *                  ↑ position = 0\n *\n * New cmd:  [cmd1, cmd6]  ← cmd2-cmd5 discarded!\n *                  ↑ position = 1\n * ```\n *\n * **Why branching (not tree)**:\n * - Simpler mental model for users\n * - No UI complexity for branch navigation\n * - Standard undo/redo UX pattern\n *\n * ## Memory Management\n *\n * **Bounded history** (MAX_HISTORY = 50):\n * - Prevents unbounded memory growth\n * - Removes oldest command when limit reached\n * - 50 commands ≈ typical user session\n *\n * **Memory per command**:\n * - Command object: ~200-500 bytes\n * - State snapshots: ~1-5 KB (JSON serialized GridItem)\n * - Total for 50 commands: ~50-250 KB (acceptable)\n *\n * **Sliding window approach**:\n * ```\n * When history full:\n * [cmd1, cmd2, ..., cmd50]  ← At capacity\n * Push cmd51:\n * [cmd2, cmd3, ..., cmd51]  ← cmd1 removed\n * ```\n *\n * ## State Snapshot Strategy\n *\n * Each command stores **before/after snapshots**:\n * ```typescript\n * class MoveItemCommand implements Command {\n *   beforeState = JSON.parse(JSON.stringify(item));  // Deep clone\n *   afterState = JSON.parse(JSON.stringify(updatedItem));\n *\n *   undo() { restoreState(beforeState); }\n *   redo() { restoreState(afterState); }\n * }\n * ```\n *\n * **Deep cloning required because**:\n * - Prevents mutations from affecting snapshots\n * - Ensures independent state copies\n * - Simple and reliable (no reference tracking needed)\n *\n * **Trade-off**:\n * - ✅ Simple implementation\n * - ✅ No reference bugs\n * - ❌ Higher memory usage than delta-based\n * - ❌ Slower than structural sharing (acceptable for this use case)\n *\n * ## Keyboard Shortcuts\n *\n * Implemented in grid-builder-app.tsx:\n * - **Ctrl+Z** (Cmd+Z on Mac): Undo last command\n * - **Ctrl+Y** (Cmd+Y on Mac): Redo next command\n * - **Ctrl+Shift+Z**: Alternative redo (common in design tools)\n *\n * ## UI Integration\n *\n * **Reactive state for buttons**:\n * ```typescript\n * undoRedoState = {\n *   canUndo: boolean,  // Enable/disable undo button\n *   canRedo: boolean   // Enable/disable redo button\n * }\n * ```\n *\n * **Updates on**:\n * - New command pushed\n * - Undo executed\n * - Redo executed\n * - History cleared\n *\n * **Button rendering**:\n * ```tsx\n * <button disabled={!undoRedoState.canUndo} onClick={undo}>\n *   Undo\n * </button>\n * ```\n *\n * ## Extracting This Pattern\n *\n * To adapt Command pattern for your project:\n *\n * **Minimal implementation**:\n * ```typescript\n * interface Command {\n *   undo(): void;\n *   redo(): void;\n * }\n *\n * class UndoRedoManager {\n *   private history: Command[] = [];\n *   private position = -1;\n *\n *   push(command: Command) {\n *     this.history.splice(this.position + 1);  // Discard future\n *     this.history.push(command);\n *     this.position++;\n *   }\n *\n *   undo() {\n *     if (this.position >= 0) {\n *       this.history[this.position].undo();\n *       this.position--;\n *     }\n *   }\n *\n *   redo() {\n *     if (this.position < this.history.length - 1) {\n *       this.position++;\n *       this.history[this.position].redo();\n *     }\n *   }\n * }\n * ```\n *\n * **Example commands**:\n * ```typescript\n * class AddItemCommand implements Command {\n *   constructor(\n *     private canvasId: string,\n *     private item: GridItem\n *   ) {}\n *\n *   undo() { removeItemFromCanvas(this.canvasId, this.item.id); }\n *   redo() { addItemToCanvas(this.canvasId, this.item); }\n * }\n * ```\n *\n * **For different frameworks**:\n * - React: Use useReducer or Zustand middleware\n * - Vue: Use Pinia plugin or custom composable\n * - Angular: Use NgRx effects or service\n *\n * @module undo-redo\n */\n\nimport { createStore } from '@stencil/store';\nimport { createDebugLogger } from '../utils/debug';\n\nconst debug = createDebugLogger('undo-redo');\n\n/**\n * Command Interface\n * =================\n *\n * Core abstraction for undoable operations. All commands must implement\n * both undo() and redo() methods to reverse and reapply their effects.\n *\n * **Design principle**: Commands are **self-contained** - they store all\n * data needed to both undo and redo without external dependencies.\n *\n * **Typical implementation**:\n * ```typescript\n * class MyCommand implements Command {\n *   private beforeState: any;\n *   private afterState: any;\n *\n *   constructor(initialState) {\n *     this.beforeState = JSON.parse(JSON.stringify(initialState));\n *     // ... perform operation ...\n *     this.afterState = JSON.parse(JSON.stringify(finalState));\n *   }\n *\n *   undo() { restoreState(this.beforeState); }\n *   redo() { restoreState(this.afterState); }\n * }\n * ```\n *\n * **Why separate undo/redo methods**:\n * - ❌ Not: Single execute(reverse: boolean) method\n * - ✅ Yes: Separate undo() and redo() methods\n * - Reason: Clearer intent, easier to implement, matches user mental model\n *\n * **Concrete implementations**:\n * - AddItemCommand: Add/remove grid item\n * - DeleteItemCommand: Remove/restore grid item with index preservation\n * - MoveItemCommand: Update item position (cross-canvas support)\n * - ResizeCommand: Update item dimensions\n *\n * @example\n * ```typescript\n * class DeleteItemCommand implements Command {\n *   constructor(\n *     private canvasId: string,\n *     private item: GridItem,\n *     private itemIndex: number\n *   ) {}\n *\n *   undo() {\n *     // Restore item at original index\n *     const canvas = gridState.canvases[this.canvasId];\n *     canvas.items.splice(this.itemIndex, 0, this.item);\n *     gridState.canvases = { ...gridState.canvases };\n *   }\n *\n *   redo() {\n *     // Remove item again\n *     removeItemFromCanvas(this.canvasId, this.item.id);\n *   }\n * }\n * ```\n */\nexport interface Command {\n  /**\n   * Reverse the effect of this command\n   *\n   * **Idempotent**: Calling undo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  undo(): void;\n\n  /**\n   * Reapply the effect of this command\n   *\n   * **Idempotent**: Calling redo() multiple times has same effect as once\n   * **Side effects**: May update global state, trigger re-renders\n   * **Error handling**: Should not throw (use try/catch internally)\n   */\n  redo(): void;\n}\n\n/**\n * Undo/Redo State\n * ================\n *\n * Reactive state for UI button enable/disable logic.\n * Components subscribe to this state to update undo/redo button states.\n *\n * **Why reactive**:\n * - Automatic button state updates (no manual DOM manipulation)\n * - Components re-render when canUndo/canRedo changes\n * - Declarative UI logic\n *\n * **Usage in components**:\n * ```tsx\n * import { undoRedoState } from './undo-redo';\n *\n * render() {\n *   return (\n *     <div>\n *       <button\n *         disabled={!undoRedoState.canUndo}\n *         onClick={() => undo()}>\n *         Undo\n *       </button>\n *       <button\n *         disabled={!undoRedoState.canRedo}\n *         onClick={() => redo()}>\n *         Redo\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n */\nexport interface UndoRedoState {\n  /** Whether undo operation is available (historyPosition >= 0) */\n  canUndo: boolean;\n\n  /** Whether redo operation is available (historyPosition < commandHistory.length - 1) */\n  canRedo: boolean;\n}\n\n/**\n * Reactive state store for undo/redo button states\n *\n * **StencilJS integration**: Components automatically subscribe when accessing properties\n * **Updates**: Modified by updateButtonStates() after each operation\n */\nconst { state: undoRedoState } = createStore<UndoRedoState>({\n  canUndo: false,\n  canRedo: false,\n});\n\nexport { undoRedoState };\n\n/**\n * Undo/Redo Service API\n * =====================\n *\n * Provides a clear, namespaced API for undo/redo operations.\n * Use this instead of individual function imports for better clarity.\n *\n * @example\n * ```typescript\n * import { undoRedo } from './services/undo-redo';\n *\n * // Add command to history\n * undoRedo.push(new AddItemCommand(canvasId, item));\n *\n * // Undo/redo\n * undoRedo.undo();\n * undoRedo.redo();\n *\n * // Check availability\n * if (undoRedo.canUndo()) {\n *   undoRedo.undo();\n * }\n * ```\n */\nexport const undoRedo = {\n  /** Add command to undo/redo history */\n  push: pushCommand,\n\n  /** Undo last command */\n  undo,\n\n  /** Redo previously undone command */\n  redo,\n\n  /** Check if undo is available */\n  canUndo,\n\n  /** Check if redo is available */\n  canRedo,\n\n  /** Clear entire history */\n  clearHistory,\n};\n\n/**\n * Internal Command History State\n * ===============================\n *\n * Private state managing command stack and position.\n * Not exported - accessed only through public functions.\n */\n\n/**\n * Command history stack\n *\n * **Structure**: Array of Command objects in chronological order\n * **Growth**: Appends new commands to end\n * **Bounded**: Limited to MAX_HISTORY commands (50)\n * **Branching**: Discards commands after current position on new push\n *\n * @example\n * ```\n * [AddItemCommand, DeleteItemCommand, MoveItemCommand]\n *  ↑                ↑                  ↑\n *  0                1                  2 (historyPosition)\n * ```\n */\nconst commandHistory: Command[] = [];\n\n/**\n * Current position in command history\n *\n * **Range**: -1 (empty history) to commandHistory.length - 1\n * **Meaning**:\n * - -1: No commands or all undone\n * - 0: First command is current state\n * - N: Command at index N is current state\n *\n * **Operations**:\n * - Push command: position++\n * - Undo: position--\n * - Redo: position++\n *\n * **Invariant**: position < commandHistory.length\n */\nlet historyPosition: number = -1;\n\n/**\n * Maximum number of commands in history\n *\n * **Why 50**: Balance between:\n * - ✅ Enough for typical user session\n * - ✅ Reasonable memory usage (~50-250 KB)\n * - ❌ Not unlimited (prevents memory bloat)\n *\n * **Behavior when exceeded**: Oldest command removed (sliding window)\n */\nconst MAX_HISTORY = 50;\n\n/**\n * Update reactive state for undo/redo button enablement\n *\n * **Called after**:\n * - pushCommand() - New command added\n * - undo() - Position moved backward\n * - redo() - Position moved forward\n * - clearHistory() - History reset\n *\n * **Updates**:\n * - `canUndo`: true if historyPosition >= 0 (commands available to undo)\n * - `canRedo`: true if historyPosition < commandHistory.length - 1 (commands available to redo)\n *\n * **Triggers**:\n * - Component re-renders (via StencilJS Store reactivity)\n * - Button enable/disable state changes\n *\n * **Why not inline**:\n * - DRY principle (called from 4 places)\n * - Single responsibility (updating button states)\n * - Easier to extend (e.g., add logging, analytics)\n *\n * @private\n */\nfunction updateButtonStates(): void {\n  undoRedoState.canUndo = historyPosition >= 0;\n  undoRedoState.canRedo = historyPosition < commandHistory.length - 1;\n}\n\n/**\n * Push a new command to the history stack\n *\n * **Use cases**:\n * - After drag operation completes\n * - After resize operation completes\n * - After adding new item\n * - After deleting item\n *\n * **Branching behavior** (discards future):\n * ```\n * Before: [cmd1, cmd2, cmd3, cmd4]\n *                  ↑ position = 1 (undid twice)\n *\n * Push cmd5: [cmd1, cmd2, cmd5]\n *                        ↑ position = 2\n *\n * Note: cmd3 and cmd4 discarded!\n * ```\n *\n * **Why discard future**:\n * - Matches user mental model (new action erases \"undone\" history)\n * - Simpler implementation than tree-based history\n * - Standard undo/redo UX pattern\n *\n * **Memory management**:\n * - If history exceeds MAX_HISTORY (50), oldest command removed\n * - Position adjusted to maintain integrity\n *\n * **Operation sequence**:\n * 1. Discard commands after current position (splice)\n * 2. Append new command to history\n * 3. If over limit, remove oldest (shift)\n * 4. Update position pointer\n * 5. Update button states (triggers UI)\n *\n * **Typical usage**:\n * ```typescript\n * // After drag end\n * const command = new MoveItemCommand(item, oldPos, newPos);\n * pushCommand(command);\n * ```\n *\n * **Important**: Command should be fully constructed (with snapshots taken)\n * before being pushed. This function does NOT execute the command - it's\n * assumed the operation already happened.\n *\n * @param command - Fully constructed command with before/after snapshots\n *\n * @example\n * ```typescript\n * // Delete item example\n * handleDelete(itemId: string, canvasId: string) {\n *   const item = getItem(canvasId, itemId);\n *   const index = gridState.canvases[canvasId].items.indexOf(item);\n *\n *   // Perform the delete\n *   removeItemFromCanvas(canvasId, itemId);\n *\n *   // Push command for undo (AFTER operation)\n *   const command = new DeleteItemCommand(canvasId, item, index);\n *   pushCommand(command);\n * }\n * ```\n */\nexport function pushCommand(command: Command): void {\n  debug.log('➕ PUSH: Adding command to history:', (command as any).description || command);\n\n  // Remove any commands after current position\n  commandHistory.splice(historyPosition + 1);\n\n  // Add new command\n  commandHistory.push(command);\n\n  // Limit history size\n  if (commandHistory.length > MAX_HISTORY) {\n    commandHistory.shift();\n  } else {\n    historyPosition++;\n  }\n\n  debug.log('  History position now:', historyPosition, ', Total commands:', commandHistory.length);\n\n  // Update button states\n  updateButtonStates();\n}\n\n/**\n * Undo the last command in history\n *\n * **Triggered by**:\n * - Ctrl+Z / Cmd+Z keyboard shortcut\n * - Undo button click\n * - Programmatic undo (rare)\n *\n * **Operation sequence**:\n * 1. Check if undo available (historyPosition >= 0)\n * 2. Get command at current position\n * 3. Execute command.undo() (reverses operation)\n * 4. Decrement position pointer\n * 5. Update button states (triggers UI)\n *\n * **Side effects**:\n * - Mutates global state (via command.undo())\n * - Triggers component re-renders\n * - Updates undo/redo button states\n * - May deselect items (depending on command)\n *\n * **Position before/after**:\n * ```\n * Before: [cmd1, cmd2, cmd3]\n *                      ↑ position = 2\n *\n * After:  [cmd1, cmd2, cmd3]\n *                ↑ position = 1\n * ```\n *\n * **Safety**: No-op if historyPosition < 0 (nothing to undo)\n *\n * **Multiple undo**: Can be called repeatedly to undo multiple commands\n *\n * @example\n * ```typescript\n * // Keyboard shortcut handler\n * window.addEventListener('keydown', (e) => {\n *   if ((e.ctrlKey || e.metaKey) && e.key === 'z') {\n *     undo();\n *     e.preventDefault();\n *   }\n * });\n * ```\n */\nexport function undo(): void {\n  if (historyPosition < 0) {\n    return;\n  }\n\n  const command = commandHistory[historyPosition];\n  debug.log('🔙 UNDO: Executing command at position', historyPosition, ':', command);\n  debug.log('  Command description:', (command as any).description);\n  command.undo();\n  historyPosition--;\n  debug.log('  New position after undo:', historyPosition);\n\n  updateButtonStates();\n}\n\n/**\n * Redo the next command in history\n *\n * **Triggered by**:\n * - Ctrl+Y / Cmd+Y keyboard shortcut\n * - Ctrl+Shift+Z / Cmd+Shift+Z (alternative)\n * - Redo button click\n * - Programmatic redo (rare)\n *\n * **Operation sequence**:\n * 1. Check if redo available (historyPosition < commandHistory.length - 1)\n * 2. Increment position pointer\n * 3. Get command at new position\n * 4. Execute command.redo() (reapplies operation)\n * 5. Update button states (triggers UI)\n *\n * **Side effects**:\n * - Mutates global state (via command.redo())\n * - Triggers component re-renders\n * - Updates undo/redo button states\n * - May select items (depending on command)\n *\n * **Position before/after**:\n * ```\n * Before: [cmd1, cmd2, cmd3]\n *                ↑ position = 1\n *\n * After:  [cmd1, cmd2, cmd3]\n *                      ↑ position = 2\n * ```\n *\n * **Safety**: No-op if no commands to redo (position at end)\n *\n * **Multiple redo**: Can be called repeatedly to redo multiple commands\n *\n * **Redo after new action**: Redo becomes unavailable after new command\n * pushed (future history discarded)\n *\n * @example\n * ```typescript\n * // Keyboard shortcut handler\n * window.addEventListener('keydown', (e) => {\n *   if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\n *     redo();\n *     e.preventDefault();\n *   }\n * });\n * ```\n */\nexport function redo(): void {\n  if (historyPosition >= commandHistory.length - 1) {\n    return;\n  }\n\n  historyPosition++;\n  const command = commandHistory[historyPosition];\n  command.redo();\n\n  updateButtonStates();\n}\n\n/**\n * Check if undo operation is available\n *\n * **Use cases**:\n * - Enabling/disabling undo button\n * - Showing undo keyboard hint\n * - Programmatic checks before undo\n *\n * **Returns true when**: historyPosition >= 0 (commands in history)\n * **Returns false when**: historyPosition = -1 (no history or all undone)\n *\n * **Note**: Prefer using `undoRedoState.canUndo` in UI components\n * for automatic reactivity. This function is for imperative checks.\n *\n * @returns true if undo() can be called, false otherwise\n *\n * @example\n * ```typescript\n * // Imperative check\n * if (canUndo()) {\n *   debug.log('Undo available');\n *   undo();\n * }\n *\n * // Prefer reactive state in UI\n * <button disabled={!undoRedoState.canUndo}>Undo</button>\n * ```\n */\nexport function canUndo(): boolean {\n  return historyPosition >= 0;\n}\n\n/**\n * Check if redo operation is available\n *\n * **Use cases**:\n * - Enabling/disabling redo button\n * - Showing redo keyboard hint\n * - Programmatic checks before redo\n *\n * **Returns true when**: historyPosition < commandHistory.length - 1\n * **Returns false when**: At end of history or history empty\n *\n * **Becomes false after**: New command pushed (future discarded)\n *\n * **Note**: Prefer using `undoRedoState.canRedo` in UI components\n * for automatic reactivity. This function is for imperative checks.\n *\n * @returns true if redo() can be called, false otherwise\n *\n * @example\n * ```typescript\n * // Imperative check\n * if (canRedo()) {\n *   debug.log('Redo available');\n *   redo();\n * }\n *\n * // Prefer reactive state in UI\n * <button disabled={!undoRedoState.canRedo}>Redo</button>\n * ```\n */\nexport function canRedo(): boolean {\n  return historyPosition < commandHistory.length - 1;\n}\n\n/**\n * Clear all command history\n *\n * **Use cases**:\n * - Application reset\n * - Loading new project\n * - Test cleanup\n * - Memory management (rare)\n *\n * **Effects**:\n * - Empties command history array\n * - Resets position to -1\n * - Disables both undo and redo buttons\n * - Does NOT affect current state (only history)\n *\n * **Memory**: Allows garbage collection of command objects and snapshots\n *\n * **Cannot be undone**: This operation itself is not undoable\n *\n * **Safety**: Safe to call even if history already empty\n *\n * @example\n * ```typescript\n * // Reset application\n * function resetApp() {\n *   clearHistory();\n *   reset(); // Reset state\n *   debug.log('Application reset');\n * }\n *\n * // Test cleanup\n * afterEach(() => {\n *   clearHistory();\n * });\n * ```\n */\nexport function clearHistory(): void {\n  commandHistory.length = 0;\n  historyPosition = -1;\n  updateButtonStates();\n}\n","/**\n * Boundary Constraints Utility\n * =============================\n *\n * Utilities for constraining component placement and sizing within canvas boundaries.\n * Ensures components stay fully within canvas and handles size fitting when needed.\n *\n * ## Problem\n *\n * Components can be placed or dragged such that they extend beyond canvas boundaries:\n * - Dropped from palette outside canvas bounds\n * - Dragged beyond edges\n * - Default size larger than canvas\n *\n * ## Solution\n *\n * Provides constraint functions that:\n * 1. Validate component can fit within canvas (respecting minSize)\n * 2. Adjust size to fit canvas if needed (respecting minSize/maxSize)\n * 3. Constrain position to keep component fully within bounds\n *\n * @module boundary-constraints\n */\n\nimport { ComponentDefinition } from '../types/component-definition';\n\n/**\n * Canvas dimensions in grid units\n *\n * **Standard canvas size**:\n * - Width: 50 units (100% width, 2% per unit)\n * - Height: Unlimited (grows with content)\n */\nexport const CANVAS_WIDTH_UNITS = 50;\n\n/**\n * Component size after constraint validation\n */\nexport interface ConstrainedSize {\n  /** Width in grid units (may be adjusted from default) */\n  width: number;\n  /** Height in grid units (may be adjusted from default) */\n  height: number;\n  /** Whether size was adjusted to fit */\n  wasAdjusted: boolean;\n}\n\n/**\n * Component position and size after boundary constraints\n */\nexport interface ConstrainedPlacement {\n  /** X position in grid units */\n  x: number;\n  /** Y position in grid units */\n  y: number;\n  /** Width in grid units */\n  width: number;\n  /** Height in grid units */\n  height: number;\n  /** Whether position was adjusted */\n  positionAdjusted: boolean;\n  /** Whether size was adjusted */\n  sizeAdjusted: boolean;\n}\n\n/**\n * Validate if component can fit within canvas\n *\n * Checks if component's minimum size is smaller than or equal to canvas size.\n * If component's minSize > canvas size, placement should be rejected.\n *\n * @param definition - Component definition with min/max size constraints\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns true if component can fit, false if too large\n *\n * @example\n * ```typescript\n * const hugeComponent = {\n *   type: 'huge-widget',\n *   minSize: { width: 60, height: 10 } // 60 > 50 canvas width\n * };\n *\n * if (!canComponentFitCanvas(hugeComponent)) {\n *   console.warn('Component too large for canvas');\n *   return; // Don't allow placement\n * }\n * ```\n */\nexport function canComponentFitCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS\n): boolean {\n  // Get minimum size (or use default minimums if not specified)\n  const minWidth = definition.minSize?.width || 0;\n\n  // Check if minimum size fits within canvas\n  // Height is unlimited, so only check width\n  return minWidth <= canvasWidth;\n}\n\n/**\n * Constrain component size to fit within canvas\n *\n * Adjusts component size if default size exceeds canvas bounds,\n * while respecting min/max size constraints.\n *\n * **Size adjustment rules**:\n * 1. If defaultSize fits, use it\n * 2. If defaultSize > canvas, shrink to canvas size\n * 3. Never shrink below minSize\n * 4. Never grow beyond maxSize\n *\n * **Width constraint**: Canvas width (50 units)\n * **Height constraint**: None (canvas height grows with content)\n *\n * @param definition - Component definition\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained size and adjustment flag\n *\n * @example\n * ```typescript\n * const wideComponent = {\n *   type: 'banner',\n *   defaultSize: { width: 60, height: 10 }, // Too wide\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const size = constrainSizeToCanvas(wideComponent);\n * // { width: 50, height: 10, wasAdjusted: true }\n * ```\n */\nexport function constrainSizeToCanvas(\n  definition: ComponentDefinition,\n  canvasWidth: number = CANVAS_WIDTH_UNITS\n): ConstrainedSize {\n  const defaultWidth = definition.defaultSize.width;\n  const defaultHeight = definition.defaultSize.height;\n\n  const minWidth = definition.minSize?.width || 0;\n  const maxWidth = definition.maxSize?.width || Infinity;\n\n  let width = defaultWidth;\n  let height = defaultHeight;\n  let wasAdjusted = false;\n\n  // Constrain width to canvas\n  if (width > canvasWidth) {\n    width = canvasWidth;\n    wasAdjusted = true;\n  }\n\n  // Respect minSize\n  if (width < minWidth) {\n    width = minWidth;\n  }\n\n  // Respect maxSize\n  if (width > maxWidth) {\n    width = maxWidth;\n  }\n\n  // Height is not constrained by canvas (canvas grows vertically)\n  // but still respect min/max if specified\n  const minHeight = definition.minSize?.height || 0;\n  const maxHeight = definition.maxSize?.height || Infinity;\n\n  if (height < minHeight) {\n    height = minHeight;\n  }\n  if (height > maxHeight) {\n    height = maxHeight;\n  }\n\n  return { width, height, wasAdjusted };\n}\n\n/**\n * Constrain component position to keep it fully within canvas bounds\n *\n * Adjusts position so component stays completely inside canvas.\n * Snaps to edges if component would extend beyond boundaries.\n *\n * **Boundary rules**:\n * - Left edge: x >= 0\n * - Right edge: x + width <= canvasWidth\n * - Top edge: y >= 0\n * - Bottom edge: No constraint (canvas height grows)\n *\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param width - Component width in grid units\n * @param height - Component height in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement\n *\n * @example\n * ```typescript\n * // Component would extend beyond right edge\n * const placement = constrainPositionToCanvas(45, 10, 20, 10);\n * // { x: 30, y: 10, width: 20, height: 10, positionAdjusted: true, sizeAdjusted: false }\n * // Adjusted from 45 to 30 so (30 + 20 = 50) stays within canvas\n * ```\n */\nexport function constrainPositionToCanvas(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS\n): ConstrainedPlacement {\n  let newX = x;\n  let newY = y;\n  let positionAdjusted = false;\n\n  // Constrain left edge\n  if (newX < 0) {\n    newX = 0;\n    positionAdjusted = true;\n  }\n\n  // Constrain right edge\n  if (newX + width > canvasWidth) {\n    newX = canvasWidth - width;\n    positionAdjusted = true;\n  }\n\n  // Constrain top edge\n  if (newY < 0) {\n    newY = 0;\n    positionAdjusted = true;\n  }\n\n  // No bottom edge constraint - canvas grows vertically\n\n  // Ensure position doesn't go negative after adjustment\n  newX = Math.max(0, newX);\n  newY = Math.max(0, newY);\n\n  return {\n    x: newX,\n    y: newY,\n    width,\n    height,\n    positionAdjusted,\n    sizeAdjusted: false,\n  };\n}\n\n/**\n * Apply full boundary constraints to component placement\n *\n * Complete constraint pipeline:\n * 1. Check if component can fit (validate minSize <= canvas)\n * 2. Adjust size to fit canvas (if needed)\n * 3. Constrain position to keep within bounds\n *\n * **Returns null if component cannot fit** (minSize > canvas)\n *\n * @param definition - Component definition\n * @param x - Desired x position in grid units\n * @param y - Desired y position in grid units\n * @param canvasWidth - Canvas width in grid units (default: 50)\n * @returns Constrained placement, or null if component too large\n *\n * @example\n * ```typescript\n * const definition = {\n *   type: 'widget',\n *   defaultSize: { width: 60, height: 10 },\n *   minSize: { width: 20, height: 5 }\n * };\n *\n * const placement = applyBoundaryConstraints(definition, 45, 10);\n * // {\n * //   x: 0,              // Adjusted from 45 to fit\n * //   y: 10,             // No Y adjustment needed\n * //   width: 50,         // Shrunk from 60 to fit canvas\n * //   height: 10,        // No height adjustment\n * //   positionAdjusted: true,\n * //   sizeAdjusted: true\n * // }\n * ```\n */\nexport function applyBoundaryConstraints(\n  definition: ComponentDefinition,\n  x: number,\n  y: number,\n  canvasWidth: number = CANVAS_WIDTH_UNITS\n): ConstrainedPlacement | null {\n  // 1. Validate component can fit\n  if (!canComponentFitCanvas(definition, canvasWidth)) {\n    console.warn(\n      `Component \"${definition.name}\" minSize (${definition.minSize?.width}) ` +\n      `exceeds canvas width (${canvasWidth}). Placement rejected.`\n    );\n    return null;\n  }\n\n  // 2. Adjust size to fit canvas\n  const constrainedSize = constrainSizeToCanvas(definition, canvasWidth);\n\n  // 3. Constrain position to keep within bounds\n  const constrainedPlacement = constrainPositionToCanvas(\n    x,\n    y,\n    constrainedSize.width,\n    constrainedSize.height,\n    canvasWidth\n  );\n\n  // Combine size and position adjustments\n  return {\n    ...constrainedPlacement,\n    sizeAdjusted: constrainedSize.wasAdjusted,\n  };\n}\n"],"names":["debug","gridState"],"mappings":"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"}