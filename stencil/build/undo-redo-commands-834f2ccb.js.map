{"file":"undo-redo-commands-834f2ccb.js","mappings":"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","names":["gridState"],"sources":["src/services/undo-redo-commands.ts"],"sourcesContent":["/**\n * Undo/Redo Commands\n * ===================\n *\n * Concrete Command implementations for grid operations. Each command class\n * encapsulates a specific user action with the ability to undo and redo.\n *\n * ## Problem\n *\n * The Command pattern requires concrete implementations for each undoable operation.\n * Each command must:\n * - Capture enough state to reverse the operation (undo)\n * - Capture enough state to reapply the operation (redo)\n * - Be self-contained (no external dependencies)\n * - Handle edge cases (canvas switching, index preservation)\n *\n * ## Solution\n *\n * Four concrete command classes covering all grid operations:\n *\n * 1. **AddItemCommand**: Adding new items to canvas\n * 2. **DeleteItemCommand**: Removing items with index preservation\n * 3. **MoveItemCommand**: Dragging items (same or different canvas)\n * 4. **ResizeCommand**: (Not yet implemented - resize operations not tracked)\n *\n * ## Key Design Patterns\n *\n * ### Deep Cloning Strategy\n *\n * **Why deep clone**: Prevent mutations from affecting command snapshots\n *\n * ```typescript\n * this.item = JSON.parse(JSON.stringify(item));\n * ```\n *\n * **When to clone**:\n * - ✅ Constructor: Capture initial state\n * - ✅ redo(): Create fresh copy for state mutation\n * - ❌ undo(): Usually work with existing state references\n *\n * **Trade-offs**:\n * - ✅ Simple and reliable\n * - ✅ No reference bugs\n * - ❌ Higher memory usage (~1-5 KB per command)\n * - ❌ Slower than structural sharing\n *\n * ### Index Preservation Pattern\n *\n * **Why preserve index**: Undo delete should restore item at original position\n *\n * ```typescript\n * class DeleteItemCommand {\n *   private itemIndex: number;  // Capture index before deletion\n *\n *   undo() {\n *     canvas.items.splice(this.itemIndex, 0, item);  // Restore at index\n *   }\n * }\n * ```\n *\n * **Important for**:\n * - Visual consistency (item appears in same spot)\n * - Z-index order (items render in array order)\n * - User expectations (undo puts things back exactly)\n *\n * ### Selection State Management\n *\n * **Pattern**: Clear selection when deleting selected item\n *\n * ```typescript\n * if (gridState.selectedItemId === itemId) {\n *   gridState.selectedItemId = null;\n *   gridState.selectedCanvasId = null;\n * }\n * ```\n *\n * **Why needed**:\n * - Prevents dangling references to deleted items\n * - Avoids errors when accessing selectedItemId\n * - Matches user expectations (deleted item can't be selected)\n *\n * ### Cross-Canvas Move Support\n *\n * **Challenge**: Items can be dragged between canvases\n *\n * **Solution**: Track source and target canvas IDs\n *\n * ```typescript\n * class MoveItemCommand {\n *   sourceCanvasId: string;\n *   targetCanvasId: string;\n *\n *   undo() {\n *     // Move from target back to source\n *     removeFrom(targetCanvasId);\n *     addTo(sourceCanvasId, sourceIndex);  // Restore position\n *   }\n * }\n * ```\n *\n * ## Command Lifecycle\n *\n * **Typical flow**:\n * ```\n * 1. User performs action (drag, delete, etc.)\n * 2. Operation completes (state already updated)\n * 3. Create command with before/after snapshots\n * 4. pushCommand(command) → adds to history\n * 5. User presses Ctrl+Z\n * 6. command.undo() → reverses operation\n * 7. User presses Ctrl+Y\n * 8. command.redo() → reapplies operation\n * ```\n *\n * **Important**: Commands are created AFTER the operation completes,\n * not before. The constructor captures the final state.\n *\n * ## Extracting These Patterns\n *\n * To create new command types:\n *\n * ```typescript\n * export class MyCommand implements Command {\n *   // Capture state needed for undo/redo\n *   private beforeState: any;\n *   private afterState: any;\n *\n *   constructor(params) {\n *     // Deep clone to prevent mutations\n *     this.beforeState = JSON.parse(JSON.stringify(before));\n *     this.afterState = JSON.parse(JSON.stringify(after));\n *   }\n *\n *   undo(): void {\n *     // Restore before state\n *     restoreState(this.beforeState);\n *     gridState.canvases = { ...gridState.canvases };  // Trigger reactivity\n *   }\n *\n *   redo(): void {\n *     // Apply after state\n *     restoreState(this.afterState);\n *     gridState.canvases = { ...gridState.canvases };\n *   }\n * }\n * ```\n *\n * **Guidelines**:\n * - Always deep clone state in constructor\n * - Always trigger reactivity (`gridState.canvases = { ...gridState.canvases }`)\n * - Handle null cases (canvas/item not found)\n * - Clear selection if needed\n * - Preserve array indices for positional restore\n *\n * @module undo-redo-commands\n */\n\nimport { GridItem, gridState } from './state-manager';\nimport { Command } from './undo-redo';\n\n/**\n * Helper function to remove an item from a canvas and clear selection\n *\n * **Responsibilities**:\n * - Remove item from canvas items array\n * - Trigger state reactivity (spread pattern)\n * - Clear selection if deleted item was selected\n *\n * **Used by**:\n * - AddItemCommand.undo() - Remove just-added item\n * - DeleteItemCommand.redo() - Remove item again\n * - MoveItemCommand (implicitly via filter)\n *\n * **Why helper function**:\n * - DRY principle (used in multiple commands)\n * - Encapsulates selection clearing logic\n * - Consistent behavior across commands\n *\n * **Selection clearing**:\n * Prevents dangling references and UI errors when selected item deleted.\n *\n * @param canvasId - Canvas containing the item\n * @param itemId - Item to remove\n *\n * @example\n * ```typescript\n * // Used internally by commands\n * undo() {\n *   removeItemFromCanvas(this.canvasId, this.item.id);\n * }\n * ```\n *\n * @private\n */\nfunction removeItemFromCanvas(canvasId: string, itemId: string): void {\n  const canvas = gridState.canvases[canvasId];\n  if (!canvas) {\n    return;\n  }\n\n  canvas.items = canvas.items.filter((i) => i.id !== itemId);\n  gridState.canvases = { ...gridState.canvases };\n\n  // Clear selection if this item was selected\n  if (gridState.selectedItemId === itemId) {\n    gridState.selectedItemId = null;\n    gridState.selectedCanvasId = null;\n  }\n}\n\n/**\n * AddItemCommand\n * Captures the addition of a new item to a canvas\n */\nexport class AddItemCommand implements Command {\n  private item: GridItem;\n  private canvasId: string;\n\n  constructor(canvasId: string, item: GridItem) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state at time of creation\n    this.item = JSON.parse(JSON.stringify(item));\n  }\n\n  undo(): void {\n    // Remove the item from the canvas\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n\n  redo(): void {\n    // Re-add the item to the canvas\n    const canvas = gridState.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    // Use the cloned item state\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    canvas.items.push(itemCopy);\n    gridState.canvases = { ...gridState.canvases };\n  }\n}\n\n/**\n * DeleteItemCommand\n * Captures the deletion of an item from a canvas\n */\nexport class DeleteItemCommand implements Command {\n  private item: GridItem;\n  private canvasId: string;\n  private itemIndex: number;\n\n  constructor(canvasId: string, item: GridItem, itemIndex: number) {\n    this.canvasId = canvasId;\n    // Deep clone the item to capture its state before deletion\n    this.item = JSON.parse(JSON.stringify(item));\n    this.itemIndex = itemIndex;\n  }\n\n  undo(): void {\n    // Re-add the item to its original position\n    const canvas = gridState.canvases[this.canvasId];\n    if (!canvas) {\n      return;\n    }\n\n    const itemCopy = JSON.parse(JSON.stringify(this.item));\n    // Insert at original index if possible, otherwise push to end\n    if (this.itemIndex >= 0 && this.itemIndex <= canvas.items.length) {\n      canvas.items.splice(this.itemIndex, 0, itemCopy);\n    } else {\n      canvas.items.push(itemCopy);\n    }\n    gridState.canvases = { ...gridState.canvases };\n  }\n\n  redo(): void {\n    // Remove the item again\n    removeItemFromCanvas(this.canvasId, this.item.id);\n  }\n}\n\n/**\n * MoveItemCommand\n * Captures the movement of an item within or between canvases\n */\nexport class MoveItemCommand implements Command {\n  private itemId: string;\n  private sourceCanvasId: string;\n  private targetCanvasId: string;\n  private sourcePosition: { x: number; y: number };\n  private targetPosition: { x: number; y: number };\n  private sourceIndex: number;\n\n  constructor(\n    itemId: string,\n    sourceCanvasId: string,\n    targetCanvasId: string,\n    sourcePosition: { x: number; y: number },\n    targetPosition: { x: number; y: number },\n    sourceIndex: number\n  ) {\n    this.itemId = itemId;\n    this.sourceCanvasId = sourceCanvasId;\n    this.targetCanvasId = targetCanvasId;\n    this.sourcePosition = { ...sourcePosition };\n    this.targetPosition = { ...targetPosition };\n    this.sourceIndex = sourceIndex;\n  }\n\n  undo(): void {\n    // Find the item in target canvas\n    const targetCanvas = gridState.canvases[this.targetCanvasId];\n    const item = targetCanvas?.items.find((i) => i.id === this.itemId);\n    if (!item) {\n      return;\n    }\n\n    // Remove from target canvas\n    targetCanvas.items = targetCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's position and canvasId back to source\n    item.canvasId = this.sourceCanvasId;\n    item.layouts.desktop.x = this.sourcePosition.x;\n    item.layouts.desktop.y = this.sourcePosition.y;\n\n    // Add back to source canvas at original index\n    const sourceCanvas = gridState.canvases[this.sourceCanvasId];\n    if (!sourceCanvas) {\n      return;\n    }\n\n    if (this.sourceIndex >= 0 && this.sourceIndex <= sourceCanvas.items.length) {\n      sourceCanvas.items.splice(this.sourceIndex, 0, item);\n    } else {\n      sourceCanvas.items.push(item);\n    }\n\n    gridState.canvases = { ...gridState.canvases };\n  }\n\n  redo(): void {\n    // Find the item in source canvas\n    const sourceCanvas = gridState.canvases[this.sourceCanvasId];\n    const item = sourceCanvas?.items.find((i) => i.id === this.itemId);\n    if (!item) {\n      return;\n    }\n\n    // Remove from source canvas\n    sourceCanvas.items = sourceCanvas.items.filter((i) => i.id !== this.itemId);\n\n    // Update item's position and canvasId to target\n    item.canvasId = this.targetCanvasId;\n    item.layouts.desktop.x = this.targetPosition.x;\n    item.layouts.desktop.y = this.targetPosition.y;\n\n    // Add to target canvas\n    const targetCanvas = gridState.canvases[this.targetCanvasId];\n    if (!targetCanvas) {\n      return;\n    }\n\n    targetCanvas.items.push(item);\n\n    gridState.canvases = { ...gridState.canvases };\n  }\n}\n"],"version":3}